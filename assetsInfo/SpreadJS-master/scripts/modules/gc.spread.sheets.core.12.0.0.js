/*!
 * 
 * Spread.Sheets Library 12.0.0
 * 
 * Copyright(c) GrapeCity, Inc.  All rights reserved.
 * 
 * Licensed under the SpreadJS Commercial License.
 * us.sales@grapecity.com
 * http://www.grapecity.com/en/licensing/grapecity/
 * 
 * 
 */
var GC = GC || {}; GC["Spread"] = GC["Spread"] || {}; GC["Spread"]["Sheets"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/assets/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var exports = __webpack_require__(1);
	    var calcEngine = __webpack_require__(2);
	    __webpack_require__(3);
	    __webpack_require__(4);
	    var ls = __webpack_require__(7);
	    var pt = ls._pt;
	    var seed = -1;
	    if (pt === 1) {
	        __webpack_require__(8);
	        __webpack_require__(9);
	        __webpack_require__(10);
	        seed = Math.floor(Math.random() * 5);// 0-5
	        exports['G'.concat('C', '$')]['s'.concat('d')] = seed;
	
	    } else {
	        __webpack_require__(10);
	        __webpack_require__(8);
	        __webpack_require__(9);
	    }
	
	   
	   
	    if (seed === 0) {
	        __webpack_require__(7);
	    }
	    __webpack_require__(11);
	    if (seed === 1) {
	        __webpack_require__(7);
	    }
	    __webpack_require__(12);
	    if (seed === 2) {
	        __webpack_require__(7);
	    }
	    __webpack_require__(15);
	    if (seed === 3) {
	        __webpack_require__(7);
	    }
	    __webpack_require__(16);
	    if (seed === 4) {
	        __webpack_require__(7);
	    }
	    __webpack_require__(17);
	
	    if (calcEngine) {
	        __webpack_require__(18);
	        __webpack_require__(19);
	        __webpack_require__(20);
	        __webpack_require__(21);
	    }
	    __webpack_require__(30);
	    __webpack_require__(24);
	    __webpack_require__(31);
	    __webpack_require__(32);
	    __webpack_require__(33);
	    __webpack_require__(34);
	    __webpack_require__(35);
	    __webpack_require__(36);
	    __webpack_require__(37);
	    __webpack_require__(38);
	    __webpack_require__(25);
	
	    __webpack_require__(22);
	    if (calcEngine) {
	        __webpack_require__(39);
	    }
	    __webpack_require__(40);
	    __webpack_require__(28);
	    __webpack_require__(27);
	    __webpack_require__(29);
	    __webpack_require__(26);
	
	
	    __webpack_require__(13);
	    __webpack_require__(41);
	    __webpack_require__(42);
	    if (pt === 1 || pt === 2) {
	        ls._replace();
	    }
	    exports.SR = {};
	    exports.SR['en'] = __webpack_require__(43);
	
	
	    module.exports = exports;
	
	}());

/***/ }),
/* 1 */
/***/ (function(module, exports) {

	(function() {
	    'use strict';
	
	    module.exports = {};
	
	}());

/***/ }),
/* 2 */
/***/ (function(module, exports) {

	module.exports = GC.Spread.CalcEngine;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var $$ = __webpack_require__(4).GC$;
	    var Common = __webpack_require__(5);
	    var CalcEngine = __webpack_require__(2);
	    var Formatter = __webpack_require__(6);
	
	    var exports = __webpack_require__(1);
	    var $$_each = $$.each, $$_extend = $$.extend;
	    var _NumberHelper = Common._NumberHelper;
	    var cloneArray = Common._ArrayHelper._clone;
	    var GeneralFormatter = Formatter && Formatter.GeneralFormatter;
	    var isNullOrUndefined = Common._Types._isNullOrUndefined;
	    exports.FallbackFontFamily = '"Helvetica Neue", Arial, sans-serif';
	
	    var WINDOW = window, DOCUMENT = document;
	    var const_boolean = 'boolean', const_date = 'date', const_undefined = 'undefined', const_function = 'function',
	        keyword_undefined = void 0,
	        keyword_null = null, Math_floor = Math.floor, Math_ceil = Math.ceil, Math_min = Math.min,
	        Math_max = Math.max, Math_round = Math.round, convertToInt = parseInt, convertToFloat = parseFloat,
	        isNotANumber = isNaN, subscriptAndSuperscriptScale = 0.58,
	        CSS_PX = 'px', SPECE_STR = ' ', DOT_STR = '.', const_string = 'string', const_number = 'number';
	    var CONST_TOUCH = 'touch', MSPOINTER_TYPE_TOUCH = 'MSPOINTER_TYPE_TOUCH';
	    var _jsonDateRegExp = new RegExp('^/Date\\((-?\\d+)([-+]{1}\\d+)?\\)/\\s*$');
	    var _jsonOADateRegExp = new RegExp('^/OADate\\(([-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)\\)/\\s*$');
	
	    function isDefined(t) {
	        return typeof t !== const_undefined;
	    }
	
	    function createElement(tag) {
	        return DOCUMENT.createElement(tag);
	    }
	
	    function documentInsertBefore(element) {
	        DOCUMENT.body && DOCUMENT.body.insertBefore(element, keyword_null);
	    }
	
	    function defineProperty(obj, pn, callback) {
	        Object.defineProperty(obj, pn, {
	            get: function () {
	                return this._ps[pn];
	            },
	            set: function (value) {
	                var old = this._ps[pn];
	                if (old !== value) {
	                    this._ps[pn] = value;
	                    if (callback) {
	                        callback(pn, value, old);
	                    }
	                }
	            },
	            enumerable: true
	        });
	    }
	
	   
	
	    exports.productInfo = {
	        productVersion: ('12.0.0') 
	    };
	
	   
	    exports.CursorResource = {
	        ResizeCol: 'col-Resize',
	        ResizeRow: 'row-resize',
	        ResizeHiddenCol: 'w-resize',
	        ResizeHiddenRow: 'n-resize'
	    };
	   
	
	   
	    
	    exports.getTypeFromString = function (typeString) {
	        var found = false;
	        var t = WINDOW;
	        if (typeof typeString === const_string) {
	            var arr = typeString.split(DOT_STR);
	            for (var i = 0, length = arr.length; i < length; i++) {
	                if (!t) {
	                    break;
	                }
	                t = t[arr[i]];
	            }
	            if (t && i === length && length > 0) {
	                found = true;
	            }
	        }
	        return found ? t : keyword_undefined;
	    };
	
	   
	    
	    exports.findControl = function (host) {
	        if (typeof host === const_string) {
	            host = DOCUMENT.getElementById(host);
	        }
	        return $$(host).data('workbook');
	    };
	   
	
	   
	    function cancelDefault(e) {
	        if (e.preventDefault) {
	            e.preventDefault();
	            e.stopPropagation();
	        } else {
	            e.cancelBubble = false;
	            e.returnValue = false;
	        }
	        return false;
	    }
	
	   
	    var util = {};
	    
	    util._indexToLetters = function (index) {
	        var sb = '';
	        for (; index > 0; index = parseInt((index - 1) / 26), 10) {
	            var n = (index - 1) % 26;
	            sb = String.fromCharCode(65  + n) + sb;
	        }
	        return sb;
	    };
	   
	   
	   
	   
	    util._cancelDefault = cancelDefault;
	    util._getHAlignByValueType = function (hAlign, value, formatter) {
	        if (hAlign === 3 ) {
	            var type = $$.getType(value);
	            if (formatter && formatter === '@') {
	                hAlign = 0 ;
	            } else if (type === const_boolean) {
	                hAlign = 1 ;
	            } else if (type === const_number || type === const_date) {
	                hAlign = 2 ;
	            } else {
	                hAlign = 0 ;
	            }
	        }
	        return hAlign;
	    };
	   
	    util._toString = function (value) {
	        var type = $$.getType(value);
	        if (value === keyword_null || value === keyword_undefined) {
	            value = '';
	        } else if (type === const_boolean) {
	            value = value.toString().toUpperCase();
	        } else if (type === const_date) {
	            var onlyDate = value.getHours() === 0 && value.getMinutes() === 0 && value.getSeconds() === 0 && value.getMilliseconds() === 0;
	            value = Common._DateTimeHelper._localeFormat(value, onlyDate ? 'M/d/yyyy' : 'M/d/yyyy h:mm:ss');
	        } else if (value.richText) {
	            value = util._convertRichTextValue(value);
	        } else {
	            value = value.toString();
	        }
	        return value;
	    };
	    util._applyBackgroundImageLayout = function (element, contentWidth, contentHeight, imgWidth, imgHeight, layout, backgroundInfo) {
	        var content = $$(element), width = contentWidth, height = contentHeight,
	            cssBackgroundPosition = 'background-position',
	            cssBackgroundSize = 'background-size', CSS_AUTO = 'auto', ZERO_PERCENT = '0%', FIFTY_PERCENT = '50%',
	            A_HUNDRED_PERCENT = '100%';
	        switch (layout) {
	            case 0 
	            :
	            if (backgroundInfo) {
	                content.css(cssBackgroundPosition, backgroundInfo.position).css(cssBackgroundSize, backgroundInfo.size);
	            } else {
	                content.css(cssBackgroundPosition, ZERO_PERCENT + SPECE_STR + ZERO_PERCENT).css(cssBackgroundSize, A_HUNDRED_PERCENT + SPECE_STR + A_HUNDRED_PERCENT);
	            }
	                break;
	            case 1 
	            :
	                var posX = FIFTY_PERCENT, posY = FIFTY_PERCENT;
	                if (imgWidth > width) {
	                    posX = ZERO_PERCENT;
	                }
	                if (imgHeight > height) {
	                    posY = ZERO_PERCENT;
	                }
	                content.css(cssBackgroundPosition, posX + SPECE_STR + posY).css(cssBackgroundSize, CSS_AUTO + SPECE_STR + CSS_AUTO);
	                break;
	            case 2 
	            :
	                var posX1 = 0, posY1 = 0, sizeW = width, sizeH = height;
	                if (height > 0 && imgHeight > 0 && width / height > imgWidth / imgHeight) {
	                    sizeW = imgWidth / imgHeight * height;
	                    posX1 = posX1 + width / 2 - sizeW / 2;
	                } else if (width > 0 && imgWidth > 0 && height / width > imgHeight / imgWidth) {
	                    sizeH = imgHeight / imgWidth * width;
	                    posY1 = posY1 + height / 2 - sizeH / 2;
	                }
	                content.css(cssBackgroundPosition, posX1 + CSS_PX + SPECE_STR + posY1 + CSS_PX).css(cssBackgroundSize, sizeW + CSS_PX + SPECE_STR + sizeH + CSS_PX);
	                break;
	            case 3 
	            :
	                content.css(cssBackgroundPosition, ZERO_PERCENT + SPECE_STR + ZERO_PERCENT).css(cssBackgroundSize, CSS_AUTO + SPECE_STR + CSS_AUTO);
	                break;
	            default:
	                break;
	        }
	    };
	    util._device = util.device = function () {
	        var ua = navigator.userAgent;
	        var result = ua.match(/iPad/i), firstMatch, isIpad, isIphone, isAndroid;
	        if (result) {
	            firstMatch = result[0];
	            if (firstMatch) {
	                isIpad = firstMatch.toLowerCase() === 'ipad';
	            }
	        }
	        result = ua.match(/iPhone/i);
	        if (result) {
	            firstMatch = result[0];
	            if (firstMatch) {
	                isIphone = firstMatch.toLowerCase() === 'iphone';
	            }
	        }
	        result = ua.match(/android/i);
	        if (result) {
	            firstMatch = result[0];
	            if (firstMatch) {
	                isAndroid = firstMatch.toLowerCase() === 'android';
	            }
	        }
	        return {
	            ipad: isIpad,
	            iphone: isIphone,
	            android: isAndroid
	        };
	    };
	    util._isMacOS = function () {
	        var platform = navigator.platform;
	        return platform && platform.indexOf('Mac') > -1;
	    };
	    util._isStringNumber = function (obj) {
	        if (obj === keyword_undefined || obj === keyword_null) {
	            return false;
	        }
	        var objStr = obj.toString();
	        objStr = _NumberHelper._replaceCultureSymbolToNormal(objStr);
	        return !isNotANumber(Number(objStr.trim() === '' ? NaN : objStr)) || /^[1-9]\d{0,2}(?:(,\d{3})*|\d*)(?:\.\d*)?$/.test(objStr);
	    };
	    util._parseText2Value = function (style, text, autoFormat, formaterRef, editingFormatter) {
	        var cellFormatter = keyword_null;
	        if (style) {
	            if (style.formatter) {
	                cellFormatter = editingFormatter ? editingFormatter : style.formatter;
	                if (typeof cellFormatter === const_string && GeneralFormatter) {
	                    cellFormatter = new GeneralFormatter(cellFormatter);
	                }
	            } else {
	                cellFormatter = style._autoFormatter;
	            }
	        }
	        if (cellFormatter && !cellFormatter.isAuto) {
	            var customerValue = keyword_null;
	            try {
	               
	               
	               
	               
	               
	               
	                customerValue = cellFormatter.parse(text);
	                if (typeof customerValue === const_number) {
	                    return customerValue;
	                }
	            } catch (ex) {
	               
	            }
	            return customerValue === keyword_undefined || customerValue === keyword_null ? text : customerValue;
	        } else if (autoFormat) {
	            var aValRef = {}, aValRef_value;
	            var autoDisplayFormatter = keyword_null;
	            if (GeneralFormatter) {
	                try {
	                    autoDisplayFormatter = new GeneralFormatter().getPreferredDisplayFormatter(text, aValRef);
	                } catch (ex) {
	                   
	                }
	            }
	            aValRef_value = aValRef.value;
	            if (typeof aValRef_value === const_number) {
	                text = aValRef_value;
	            } else if (util._isStringNumber(text)) {
	                aValRef_value = aValRef.value = text;
	            }
	            if (formaterRef) {
	                formaterRef.value = autoDisplayFormatter;
	            }
	            return aValRef_value !== keyword_undefined && aValRef_value !== keyword_null ? aValRef_value : text;
	        }
	        return text;
	    };
	    util._getPreferredZIndex = function (context) {
	        var body = DOCUMENT.body;
	        var element = context;
	        while (element && element.parentElement && element.parentElement !== body) {
	            element = element.parentElement;
	        }
	        var zindex = 1000, index;
	        if (element && element.parentElement === body) {
	            index = convertToInt($$(element).css('z-index'));
	            if (!isNotANumber(index)) {
	                zindex += index;
	            }
	        }
	        return zindex;
	    };
	    util._getLinearGradientColors = function (backgroundImg) {
	        if (!backgroundImg) {
	            return [];
	        }
	        var colorsStart = backgroundImg.indexOf('('), colorsEnd = backgroundImg.lastIndexOf(')');
	        var colorsStr = backgroundImg.substring(colorsStart + 1, colorsEnd);
	        if (!colorsStr) {
	            return [];
	        }
	        var colorStrArray = [], searchStartIndex = 0, subStr = '', rgbStartIndex = 0, rgbEndIndex = 0;
	        while (rgbEndIndex < colorsStr.length) {
	            rgbStartIndex = colorsStr.indexOf('rgb', searchStartIndex);
	            rgbEndIndex = colorsStr.indexOf('rgb', searchStartIndex + 1);
	            if (rgbEndIndex === -1) {
	                rgbEndIndex = colorsStr.length;
	            }
	            subStr = colorsStr.substring(rgbStartIndex, rgbEndIndex);
	            colorStrArray.push(subStr);
	            searchStartIndex = rgbEndIndex;
	        }
	        var colors = [];
	        for (var i = 0, len = colorStrArray.length; i < len; i++) {
	            var temp = colorStrArray[i];
	            var rightBracketIndex = temp.indexOf(')');
	            var color = temp.substring(0, rightBracketIndex + 1);
	            var point = convertToFloat(temp.substring(rightBracketIndex + 1, temp.length));
	            if (isNotANumber(point)) {
	                if (i === len - 1) {
	                    point = 100;
	                } else if (i <= 1) {
	                    point = 0;
	                }
	            }
	           
	           
	            if (!color && i === 0) {
	                continue;
	            }
	            point = point / 100.0;
	            colors.push({
	                color: color,
	                point: point
	            });
	        }
	        return colors;
	    };
	    util._getColumnAutoFitValue = function (col, sheet, sheetArea, autofitType) {
	        var render = sheet._render;
	        var width = 0;
	        var areas = [sheetArea];
	        var zoomFactor = sheet.zoom();
	        if (autofitType === 1 ) {
	            if (sheetArea === 3 ) {
	                areas.push(1 );
	            } else if (sheetArea === 2 ) {
	                areas.push(0 );
	            }
	        }
	        for (var i = 0; i < areas.length; i++) {
	            var row = 0;
	            var area = areas[i];
	            var rowCount = sheet.getRowCount(area);
	            while (row >= 0 && row < rowCount) {
	                var span = sheet._modelManager.findSpan(row, col, area);
	                if (span && (span.col < col || span.colCount > 1 || span.row < row)) {
	                    row = span.row + span.rowCount;
	                    continue;
	                }
	                if (sheet.getRowHeight(row, area) > 0) {
	                    var style = sheet.getActualStyle(row, col, area);
	                    var valueWidth = 0;
	                    var cellType = style.cellType || sheet._getDefaultCellType(area);
	                    if (cellType) {
	                        var font = style.font || render._getDefaultFont();
	                        style.font = render._getZoomFont(font);
	                        var rowFilter = sheet.rowFilter && sheet.rowFilter();
	                        var isFilterHeader = !!(rowFilter && rowFilter._isFilterHeader(row, col, area));
	                        if (!isFilterHeader && area === 3 ) {
	                            var table = sheet.tables ? sheet.tables.find(row, col) : keyword_null;
	                            if (table && table.showHeader() && table.headerIndex() === row && table.rowFilter() && table.filterButtonVisible(col - table.range().col)) {
	                                isFilterHeader = true;
	                            }
	                        }
	                        var fmt = style.formatter ? style.formatter : style._autoFormatter, context = {
	                            sheet: sheet,
	                            row: row,
	                            col: col,
	                            sheetArea: area,
	                            quotePrefix: style.quotePrefix
	                        };
	                        var formattedData = {};
	                        var value = sheet.getValue(row, col, area, 1 );
	                       
	                        var text = '';
	                        if (value && value.richText) {
	                            text = sheet.getText(row, col, area);
	                        } else {
	                            text = cellType.format(value, fmt, formattedData, context);
	                        }
	                        valueWidth = cellType._getAutoFitContainerWidth(value, text, style, zoomFactor, context);
	                        if (isFilterHeader) {
	                            var filterButtonZoom = Math_min(zoomFactor, 1);
	                            var buttonwidth = convertToInt((sheet.defaults.rowHeight * filterButtonZoom).toString(), 10);
	                            valueWidth += buttonwidth;
	                        }
	                    }
	                    if (valueWidth > width) {
	                        width = valueWidth;
	                    }
	                }
	
	                if (area === 3 ) {
	                    row = util._nextAutoFitRow(row, col, sheet, area);
	                } else {
	                    row++;
	                }
	            }
	        }
	        if (width === 0) {
	            width = sheet.defaults.colWidth;
	        } else {
	           
	            width += Math_ceil(3 / zoomFactor);
	        }
	        return Math_ceil(width);
	    };
	    util._nextAutoFitRow = function (row, col, sheet, sheetArea) {
	        var nextNonNullRow = -1;
	        var rowCount = sheet.getRowCount(sheetArea);
	        for (var i = row + 1; i < rowCount; i++) {
	            var text = sheet.getText(i, col, sheetArea);
	            if (text) {
	                nextNonNullRow = i;
	                break;
	            }
	            var style = sheet.getActualStyle(i, col, sheetArea);
	            if (style && style.cellType) {
	                nextNonNullRow = i;
	                break;
	            }
	        }
	        return nextNonNullRow;
	    };
	    util._getRowAutoFitValue = function (row, sheet, sheetArea, autofitType) {
	        var render = sheet._render;
	        var height = 0;
	        var areas = [sheetArea];
	        var zoomFactor = sheet.zoom();
	        if (autofitType === 1 ) {
	            if (sheetArea === 3 ) {
	                areas.push(2 );
	            } else if (sheetArea === 1 ) {
	                areas.push(0 );
	            }
	        }
	        for (var i = 0; i < areas.length; i++) {
	            sheetArea = areas[i];
	            var col = 0;
	            var colCount = sheet.getColumnCount(sheetArea);
	            while (col >= 0 && col < colCount) {
	                var span = sheet._modelManager.findSpan(row, col, sheetArea);
	                if (span && (span.row < row || span.rowCount > 1 || span.col < col)) {
	                    col = span.col + span.colCount;
	                    continue;
	                }
	                if (sheet.getColumnWidth(col, sheetArea) > 0) {
	                    var style = sheet.getActualStyle(row, col, sheetArea);
	                    var font = style.font || render._getDefaultFont();
	                    style.font = render._getZoomFont(font);
	                    var valueHeight = 0;
	                    var cellType = sheet.getCellType(row, col, sheetArea);
	                    if (cellType) {
	                        var text = sheet.getText(row, col, sheetArea);
	                        var value = sheet.getValue(row, col, sheetArea, 1 );
	                        var context = {
	                            sheet: sheet,
	                            row: row,
	                            col: col,
	                            sheetArea: sheetArea
	                        };
	                        valueHeight = cellType._getAutoFitContainerHeight(value, text, style, zoomFactor, context);
	                    }
	                    if (valueHeight > height) {
	                        height = valueHeight;
	                    }
	                }
	
	                if (sheetArea === 3 ) {
	                    col = util._nextAutoFitColumn(row, col, sheet, sheetArea);
	                } else {
	                    col++;
	                }
	            }
	        }
	        if (height === 0) {
	            height = sheet.defaults.rowHeight;
	        } else {
	           
	            height += Math_ceil(3 / zoomFactor);
	        }
	        return Math_ceil(height);
	    };
	    util._nextAutoFitColumn = function (row, col, sheet, sheetArea) {
	        var nextNonNullCol = -1;
	        var colCount = sheet.getColumnCount(sheetArea);
	        for (var j = col + 1; j < colCount; j++) {
	            var text = sheet.getText(row, j, sheetArea);
	            if (text) {
	                nextNonNullCol = j;
	                break;
	            }
	            var style = sheet.getActualStyle(row, j, sheetArea);
	            if (style && style.cellType) {
	                nextNonNullCol = j;
	                break;
	            }
	        }
	        return nextNonNullCol;
	    };
	    util._formatValue2Text = function (cellStyle, value, sheet, editingFormatterRef) {
	
	        if (sheet) {
	            var r = sheet._activeRowIndex, c = sheet._activeColIndex;
	            var formatter = cellStyle.formatter ? cellStyle.formatter : cellStyle._autoFormatter;
	            var formatterRef = editingFormatterRef || {};
	            if (GeneralFormatter && value !== keyword_null && value !== keyword_undefined) {
	                var isNumber;
	                if (formatter && formatter.isAuto) {
	                    isNumber = typeof value === const_number;
	                    var isNumberString = util._isStringNumber(value);
	                    if (!isNumber && isNumberString) {
	                        value = _NumberHelper._replaceCultureSymbolToNormal(value);
	                    }
	                    value = formatter.getPreferredEditingFormatter ? formatter.getPreferredEditingFormatter(value).format(value) : value;
	                } else {
	                    if (typeof formatter === const_string) {
	                        formatter = new GeneralFormatter(formatter);
	                    }
	                    if (formatter) {
	                        try {
	                            if (value instanceof Date) {
	                                var dateTime = CalcEngine && CalcEngine.Convert._toDateTime(value);
	                                if (dateTime) {
	                                    value = dateTime;
	                                }
	                                var df = Common.CultureManager._getCultureInfo().DateTimeFormat;
	                                if (value.getHours() === 0 && value.getMinutes() === 0 && value.getSeconds() === 0 && value.getMilliseconds() === 0) {
	                                    formatter = new GeneralFormatter(df.shortDatePattern);
	                                } else {
	                                   
	                                    formatter = new GeneralFormatter(df.shortDatePattern + SPECE_STR + df.longTimePattern);
	                                }
	                                sheet._editingTimeValue = true;
	                                value = formatter.format(value);
	                                formatterRef.formatter = formatter;
	                            } else if (typeof value === const_number) {
	                                value = _NumberHelper._replaceNormalToCultureSymbol(value.toString());
	                            }
	                        } catch (ex) {
	                            value = sheet.getText(r, c);
	                        }
	                    } else {
	                        value = sheet.getText(r, c);
	                    }
	                }
	            }
	        }
	        if (value !== keyword_null && value !== keyword_undefined) {
	            value = util._toString(value);
	        }
	        return value;
	    };
	   
	    util._browser = util.browser = (function () {
	        function uaMatch(ua) {
	            ua = ua.toLowerCase();
	            var match = /(chrome)[ \/]([\w.]+)/.exec(ua) || /(webkit)[ \/]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];
	            return {
	                browser: match[1] || '',
	                version: match[2] || '0'
	            };
	        }
	
	        var userAgent = navigator.userAgent;
	        var matched = uaMatch(userAgent);
	        var browser = {};
	        if (matched.browser) {
	            browser[matched.browser] = true;
	            browser.version = matched.version;
	        }
	       
	        if (browser.chrome) {
	            browser.webkit = true;
	        } else if (browser.webkit) {
	            browser.safari = true;
	        }
	       
	        var isPhantomJS = userAgent.indexOf('PhantomJS') >= 0;
	        if (isPhantomJS) {
	            browser.safari = false;
	            browser.chrome = true;
	        }
	       
	        var uaForIE = userAgent.toLowerCase();
	        var isIE11 = uaForIE.indexOf('compatible') < 0 && /(trident)(?:.*? rv ([\w.]+)|)/.exec(uaForIE) !== keyword_null;
	        if (isIE11) {
	            browser.mozilla = keyword_undefined;
	            browser.msie = true;
	        }
	       
	        var result = /Edge\/\d+/.exec(userAgent);
	        if (result !== keyword_null && result.length > 0) {
	            browser.webkit = keyword_undefined;
	            browser.chrome = keyword_undefined;
	            browser.msie = true;
	            browser.edge = true;
	            browser.version = result[0].substr(result[0].indexOf('/') + 1);
	        }
	
	        function metrotest() {
	            var errorName = keyword_null;
	            var supported = false;
	            try {
	                new ActiveXObject('') ;
	            } catch (e) {
	               
	                errorName = e.name;
	            }
	            try {
	                supported = !!new ActiveXObject('htmlfile') ;
	            } catch (e) {
	                supported = false;
	            }
	            if (errorName !== 'ReferenceError' && supported === false) {
	                supported = false;
	            } else {
	                supported = true;
	            }
	            return !supported;
	        }
	
	        if (browser.msie && metrotest()) {
	            browser.metroMode = true;
	        }
	        return browser;
	    })();
	    util._isIEOrEdgeInTouchDevice = function (onlyWithMs) {
	        var isIEOrEdge = util._browser.msie || util._browser.edge;
	        var withMs = isIEOrEdge && WINDOW.MSPointerEvent && (navigator.msMaxTouchPoints || 0) > 1;
	        if (onlyWithMs) {
	            return withMs;
	        }
	        var withOutMs = isIEOrEdge && WINDOW.PointerEvent && (navigator.maxTouchPoints || 0) > 1;
	        return withMs || withOutMs;
	    };
	
	   
	    util._convertRichTextValue = function (value) {
	        if (value && value.richText && value.richText.length > 0) {
	           
	           
	            if (!value.text) {
	                value = util._tryAddCacheToRichText(value);
	            }
	            return value.text;
	        }
	        return value;
	    };
	
	    util._tryAddCacheToRichText = function (value) {
	        if (!value) {
	            return value;
	        }
	        var richText = value.richText;
	        if (richText && richText.length > 0) {
	            var plainTextArr = [];
	            for (var i = 0; i < richText.length; i++) {
	                plainTextArr.push(richText[i].text ? richText[i].text : '');
	            }
	            value.text = plainTextArr.join('');
	        }
	        return value;
	    };
	
	    util._createElement = createElement;
	
	    util._isDefined = isDefined;
	
	    function isCJKText(text) {
	        var isCJKTextFlag = false;
	        if (text) {
	            for (var i = 0; i < text.length; i++) {
	                var charCode = text.charCodeAt(i);
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	                if ((charCode >= 0x2E80 && charCode < 0x2F00) ||
	                    (charCode >= 0x3000 && charCode < 0xA000) ||
	                    (charCode >= 0xA960 && charCode < 0xA980) ||
	                    (charCode >= 0xF900 && charCode < 0xFB00)) {
	                    isCJKTextFlag = true;
	                    break;
	                }
	            }
	        }
	        return isCJKTextFlag;
	    }
	
	    util._isCJKText = isCJKText;
	
	    util._defProperty = function (propertyName, initValue, callback, valueCheck) {
	        var pname = propertyName;
	        var defValue = initValue;
	        var t = function (value, shouldCallback) {
	            var self = this;
	           
	           
	           
	            if (!self.hasOwnProperty('_ps')) {
	                self._ps = {};
	            }
	            var ps = self._ps;
	            if (arguments.length === 0) {
	                if (ps[pname] !== keyword_undefined) {
	                    return ps[pname];
	                }
	                return defValue;
	            }
	            if (shouldCallback === false || (!valueCheck || valueCheck.call(self, value))) {
	                var old = ps[pname] !== keyword_undefined ? ps[pname] : defValue;
	                if (old !== value) {
	                    ps[pname] = value;
	                    if (shouldCallback !== false && callback) {
	                        callback.call(self, value, old);
	                    }
	                }
	            }
	            return self;
	        };
	        t.isDefault = function (value) {
	            return value === defValue;
	        };
	        return t;
	    };
	
	    util._createOptions = function (pns, callback) {
	        var ops = {};
	        ops._ps = {};
	        Common._Types._each(pns, function (pn) {
	            defineProperty(ops, pn, callback);
	        });
	        return ops;
	    };
	
	   
	    util._getDistance = function (sheet, index, index2, isRow, max) {
	        var start = Math_min(index, index2);
	        var end = Math_max(index, index2);
	        var total = 0;
	        for (var i = start; i < end; i++) {
	            if (isRow) {
	                total += sheet._getZoomRowHeight(i, 3 );
	            } else {
	                total += sheet._getZoomColumnWidth(i, 3 );
	            }
	            if (max && total > max) {
	                break;
	            }
	        }
	        return total;
	    };
	
	    util._getRelativeOffset = function (target, element) {
	        var left = 0, top = 0;
	        if (target !== element) {
	            var targetOffset = $$(target).offset(), canvasOffset = $$(element).offset();
	            left = targetOffset.left - canvasOffset.left;
	            top = targetOffset.top - canvasOffset.top;
	        }
	        return {
	            _top: top,
	            _left: left
	        };
	    };
	
	    util._isValidSheetName = function (sheetName, sheets, currentSheet) {
	        if (!sheetName || typeof sheetName !== 'string') {
	            return false;
	        }
	        var currentChar, i;
	        for (i = 0; i < sheetName.length; i++) {
	            currentChar = sheetName.charAt(i);
	            if (currentChar === '*' || currentChar === ':' || currentChar === '[' || currentChar === ']' ||
	                currentChar === '?' || currentChar === '\\' || currentChar === '/') {
	                return false;
	            }
	        }
	        if (!sheets) {
	            return true;
	        }
	        var length = sheets.length;
	        for (i = 0; i < length; i++) {
	            var sheet = sheets[i];
	            if (currentSheet !== sheet && sheetName.toUpperCase() === sheet.name().toUpperCase()) {
	                return false;
	            }
	        }
	        return true;
	    };
	
	   
	   
	   
	    util._replaceSpaceChar = function (text, findChar, replaceChar) {
	        if (!text) {
	            return text;
	        }
	        var i = 0, length = text.length;
	        var retValueArray = [];
	        while (i < length) {
	            if (text[i] === findChar) {
	                retValueArray[i] = replaceChar;
	            } else {
	                retValueArray[i] = text[i];
	            }
	            i++;
	        }
	        return retValueArray.join('');
	    };
	
	    util._getEditingSpan = function () {
	        var self = util;
	        if (!self._editingSpan) {
	            var span = createElement('span'), spanStyle = span.style, NEGATIVE_TEN_THOUSANDS_PX = '-10000px';
	            spanStyle.visibility = 'hidden';
	            spanStyle.top = NEGATIVE_TEN_THOUSANDS_PX;
	            spanStyle.left = NEGATIVE_TEN_THOUSANDS_PX;
	            spanStyle.position = 'absolute';
	            span.setAttribute('gcUIElement', 'gcStringWidthSpan');
	            DOCUMENT.body.insertBefore(span, keyword_null);
	            self._editingSpan = span;
	        }
	        return self._editingSpan;
	    };
	
	    util._getFontHeight = function (font, ignoreCache) {
	        var self = util;
	        var cache = self._fontHeightCache;
	        if (!ignoreCache) {
	            if (cache) {
	                var h = cache[font];
	                if (h) {
	                    return h;
	                }
	            } else {
	                cache = self._fontHeightCache = {};
	            }
	        }
	       
	        var htmlSpan = self._getEditingSpan();
	        htmlSpan.style.font = util._adjustFontWithFallback(font);
	        htmlSpan.innerHTML = 'H';
	        var fontHeight = htmlSpan.offsetHeight;
	        if (!ignoreCache) {
	            cache[font] = fontHeight;
	        }
	        return fontHeight;
	    };
	    util._getTextHeight = function (text, font) {
	        var htmlSpan = util._getEditingSpan();
	        htmlSpan.style.font = util._adjustFontWithFallback(font);
	        htmlSpan.innerHTML = text || 'H';
	        return htmlSpan.offsetHeight;
	    };
	    util._getFallbackFont = function (font) {
	        var self = util;
	        if (font.indexOf(exports.FallbackFontFamily) >= 0) {
	            return font;
	        }
	        var htmlSpan = self._getEditingSpan(), style = htmlSpan.style;
	        style.font = font;
	        style.fontFamily = [].concat(style.fontFamily.split(','), exports.FallbackFontFamily.split(',')).join(',');
	        return style.font;
	    };
	    util.__isMac = util._isMacOS();
	    util._adjustFontWithFallback = function (font) {
	        var self = util;
	        if (!font || !self.__isMac) {
	            return font;
	        }
	        var cache = self._adjustFontCache;
	        if (!cache) {
	            cache = self._adjustFontCache = {};
	        }
	        var result = cache[font];
	        if (!result) {
	            result = cache[font] = self._getFallbackFont(font);
	        }
	
	        return result;
	    };
	    util._setContextFont = function (ctx, font) {
	        if (!font) {
	            return;
	        }
	        font = util._adjustFontWithFallback(font);
	        if (ctx.font !== font) {
	            ctx.font = font;
	        }
	    };
	    util._measureTextWidth = function (ctx, font, text) {
	        if (!font || isNullOrUndefined(text)) {
	            return 0;
	        }
	        util._setContextFont(ctx, font);
	        return ctx.measureText(text).width;
	    };
	    util._dispose = function () {
	        var self = util;
	        var span = self._editingSpan;
	        if (span) {
	            $$(span).remove();
	            self._editingSpan = keyword_undefined;
	        }
	        self._fontHeightCache = keyword_undefined;
	        if (util._helpDiv) {
	            util._helpDiv = keyword_undefined;
	        }
	        self._adjustFontCache = keyword_undefined;
	    };
	    util._getEditableDivValue = function (editableDiv) {
	        var helpDiv = util._helpDiv;
	        if (!helpDiv) {
	            helpDiv = util._helpDiv = createElement('div');
	        }
	        var htmlContent = editableDiv.innerHTML;
	        helpDiv.innerHTML = htmlContent;
	        return helpDiv.innerText;
	    };
	    
	    util._isValidCustomName = function (name) {
	        
	
	        
	        return name && /^[A-Za-z_\\\u0080-\uFFFF][A-Za-z0-9_\.\\\?\u0080-\uFFFF]*$/.test(name) &&
	            (!(["C", "c", "R", "r"].indexOf(name) !== -1 ||
	                /^[A-Za-z]{1,3}(\$)?\d+$/.test(name) ||
	                /^[Rr]\d*[Cc]\d*$/.test(name) ||
	                name.length >= 255
	            ));
	    };
	
	    
	    util._adjustConditionFormulaWhenFromJSON = function (condition) {
	        if (condition) {
	            condition._setFlagForInitExpression(true); 
	            condition.initExpression();
	           
	            condition._removeFlagForInitExpression();
	        }
	    };
	
	    util._getBaseRowBaseCol = function (ranges) {
	        var baseRow = 0, baseCol = 0;
	        var length = ranges.length;
	        if (length > 0) {
	            baseRow = ranges[0].row;
	            baseCol = ranges[0].col;
	        }
	        for (var i = 1; i < length; i++) {
	            var range = ranges[i];
	            if (baseRow > range.row) {
	                baseRow = range.row;
	            }
	            if (baseCol > range.col) {
	                baseCol = range.col;
	            }
	        }
	        baseRow = baseRow < 0 ? 0 : baseRow;
	        baseCol = baseCol < 0 ? 0 : baseCol;
	        return {
	            r: baseRow,
	            c: baseCol
	        };
	    };
	
	    util._tryConvertOADateToDate = function (t) {
	       
	        if (typeof (t) === const_string && t.charAt(0) === '/') {
	            var x;
	           
	            if (_jsonOADateRegExp.test(t)) {
	                x = t.match(_jsonOADateRegExp);
	                t = Common._DateTimeHelper._fromOADate(convertToFloat(x[1]));
	            } else if (_jsonDateRegExp.test(t)) {
	                x = t.match(_jsonDateRegExp);
	                t = new Date(convertToFloat(x[1]));
	            }
	        }
	        return t;
	    };
	
	    util._tryConvertDateToOADate = function (value) {
	       
	       
	       
	        if (!isNullOrUndefined(value) && Common._DateTimeHelper._isDate(value)) {
	            value = Common._DateTimeHelper._toOADateString(value);
	        }
	        return value;
	    };
	
	    var measureTextWidth = util._measureTextWidth;
	
	    exports._util = exports.util = util;
	   
	
	   
	    var _FocusHelper = exports._FocusHelper = {};
	    _FocusHelper._isActiveElement = function (sheet) {
	        return _FocusHelper._getActiveElement() === sheet && sheet._eventHandler && sheet._eventHandler._focusElem;
	    };
	    _FocusHelper._getActiveElement = function () {
	        return WINDOW._gcGlobal.activeElement;
	    };
	
	    _FocusHelper._hideSelectionImp = function (sheet) {
	        function paintHeaderSelection(headerRectFunc) {
	            for (var r = 0; r <= 2; r++) {
	                var rect = headerRectFunc.call(layout, r);
	
	                if (rect && rect.width !== 0 && rect.height !== 0) {
	                    sheet._dirty = true;
	                    render._paintBody(ctx, rect);
	                }
	            }
	        }
	
	        if (sheet && !_FocusHelper._isActiveElement(sheet) && sheet.parent && sheet.parent.options.hideSelection) {
	            var layout = sheet._getSheetLayout(), render = sheet._render, ctx = render._getCtx(),
	                selections = sheet.getSelections(), i;
	            for (i = 0; i < selections.length; i++) {
	                var sel = selections[i], rect = sheet._getRangeWholeRect(sel);
	                if (rect.width >= 0 && rect.height >= 0) {
	                   
	                    rect.x -= 9;
	                    rect.y -= 9;
	                    rect.width += 18;
	                    rect.height += 30;
	
	                   
	                    render._copyDoubleBufferRect(rect);
	                }
	            }
	
	           
	            rect = layout._headerCornerRect();
	            sheet._dirty = true;
	            render._paintBody(ctx, rect);
	
	           
	            paintHeaderSelection(layout._rowHeaderRect);
	
	           
	            paintHeaderSelection(layout._colHeaderRect);
	        }
	    };
	
	    _FocusHelper._setActiveElement = function (sheet, ignoreRepaintSelection) {
	        var oldActiveElement = _FocusHelper._getActiveElement();
	        WINDOW._gcGlobal.activeElement = sheet;
	       
	       
	        if (sheet !== oldActiveElement && !ignoreRepaintSelection) {
	            if (oldActiveElement) {
	                oldActiveElement.endEdit();
	                _FocusHelper._hideSelectionImp(oldActiveElement);
	                oldActiveElement._disposeValidationUI && oldActiveElement._disposeValidationUI();
	            }
	            if (sheet) {
	                sheet._render._repaintSelection();
	            }
	        }
	    };
	   
	
	   
	   
	   
	
	    function _Global() {
	        this._eventSuspended = 0;
	        this._init();
	        this._clickOutsideSheetCallBack = [];
	    }
	
	    function createSpanElement(className, id) {
	        var t = createElement('span');
	        t.className = className;
	        if (id) {
	            t.id = id;
	        }
	        t.style.display = 'none';
	        documentInsertBefore(t);
	        return t;
	    }
	
	    function bindEventListener(elem, type, listener, useCapture) {
	        elem.addEventListener(type, listener, useCapture);
	    }
	
	    function getCurrentStyleOrComputedStyle(t) {
	        var ts = t.currentStyle;
	        var defaultView = DOCUMENT.defaultView;
	        if (defaultView && defaultView.getComputedStyle) {
	            ts = defaultView.getComputedStyle(t, '');
	        }
	        return ts;
	    }
	
	    function global_keyDown(event) {
	        var gcGlobal = WINDOW._gcGlobal;
	        if (gcGlobal._eventSuspended > 0) {
	            return;
	        }
	        var activeElement = _FocusHelper._getActiveElement(),
	            validationSelect = activeElement && activeElement._validationSelect;
	        if (validationSelect) {
	            var $select = $$(validationSelect);
	            if ($select.isVisible()) {
	                return;
	            }
	        }
	        if (activeElement && activeElement._eventHandler && activeElement._eventHandler._doKeyDown) {
	            activeElement._eventHandler._doKeyDown(event);
	            if (!activeElement.isEditing()) {
	                var keyCode = event.keyCode, ctrlKey = event.ctrlKey, altKey = event.altKey, shiftKey = event.shiftKey;
	                if ((keyCode === 90  || keyCode === 89 ) && ctrlKey && !altKey) {
	                   
	                    cancelDefault(event);
	                } else if (keyCode === 86  && ctrlKey && !altKey && !shiftKey) { 
	                   
	                   
	                   
	                   
	                   
	                   
	
	                   
	                    if (event.stopPropagation) {
	                        event.stopPropagation();
	                    }
	                }
	            }
	        }
	    }
	
	    function global_keyUp(event) {
	        var gcGlobal = WINDOW._gcGlobal;
	        if (gcGlobal._eventSuspended > 0) {
	            return;
	        }
	        var activeElement = _FocusHelper._getActiveElement();
	        if (activeElement && activeElement._eventHandler && activeElement._eventHandler._doKeyUp) {
	            activeElement._eventHandler._doKeyUp(event);
	        }
	    }
	
	    function global_compositionStart(event) {
	        var gcGlobal = WINDOW._gcGlobal;
	        if (gcGlobal._eventSuspended > 0) {
	            return;
	        }
	        var activeElement = _FocusHelper._getActiveElement();
	        if (activeElement && activeElement._eventHandler && activeElement._eventHandler._doCompositionStart) {
	            activeElement._eventHandler._doCompositionStart(event);
	        }
	    }
	
	    function global_docSelectStart(event) {
	       
	       
	       
	       
	        if (DOCUMENT.all === keyword_undefined && _FocusHelper._getActiveElement()) {
	            cancelDefault(event);
	        }
	        return false;
	    }
	
	    var globalPrototype = _Global.prototype = {
	        _createDummyObjects: function () {
	            globalPrototype._getDummyHeader();
	            globalPrototype._getDummyContent();
	            globalPrototype._getDummyHover();
	            globalPrototype._getDummyHighlight();
	        },
	        _getDummyHeader: function () {
	            var className = 'gc-theme-version ui-widget-header ui-state-default wijmoThemeHelper btn-default',
	                selector = 'span.' + className.split(SPECE_STR).join(DOT_STR);
	            if (!globalPrototype._dummyHeader) {
	                globalPrototype._dummyHeader = createSpanElement(className);
	            } else if ($$(DOCUMENT).find(selector).length <= 0) {
	                documentInsertBefore(globalPrototype._dummyHeader);
	            }
	            return globalPrototype._dummyHeader;
	        },
	        _getDummyContent: function () {
	            var className = 'gc-theme-version ui-widget-content wijmoThemeHelper btn-default',
	                selector = 'span.' + className.split(SPECE_STR).join(DOT_STR);
	            if (!globalPrototype._dummyContent) {
	                globalPrototype._dummyContent = createSpanElement(className);
	            } else if ($$(DOCUMENT).find(selector).length <= 0) {
	                documentInsertBefore(globalPrototype._dummyContent);
	            }
	            return globalPrototype._dummyContent;
	        },
	        _getDummyHover: function () {
	            var className = 'gc-theme-version ui-state-hover wijmoThemeHelper btn-primary',
	                selector = 'span.' + className.split(SPECE_STR).join(DOT_STR);
	            if (!globalPrototype._dummyHover) {
	                globalPrototype._dummyHover = createSpanElement(className);
	            } else if ($$(DOCUMENT).find(selector).length <= 0) {
	                documentInsertBefore(globalPrototype._dummyHover);
	            }
	            return globalPrototype._dummyHover;
	        },
	        _getDummyHighlight: function () {
	            var className = 'gc-theme-version ui-state-highlight wijmoThemeHelper btn-warning',
	                selector = 'span.' + className.split(SPECE_STR).join(DOT_STR);
	            if (!globalPrototype._dummyHighlight) {
	                globalPrototype._dummyHighlight = createSpanElement(className);
	            } else if ($$(DOCUMENT).find(selector).length <= 0) {
	                documentInsertBefore(globalPrototype._dummyHighlight);
	            }
	            return globalPrototype._dummyHighlight;
	        },
	        _getDummyElement: function () {
	            var className = 'gc-theme-version', id = 'gcDummyElement';
	            if (!globalPrototype._dummyElement) {
	                globalPrototype._dummyElement = createSpanElement(className, id);
	            } else if ($$(DOCUMENT).find('#' + id).length <= 0) {
	                documentInsertBefore(globalPrototype._dummyElement);
	            }
	            return globalPrototype._dummyElement;
	        },
	       
	       
	       
	       
	       
	       
	       
	       
	       
	        _init: function () {
	            var self = this;
	            self._eventSuspended = 0;
	            bindEventListener(WINDOW, 'keydown', global_keyDown, true);
	            bindEventListener(WINDOW, 'keyup', global_keyUp, true);
	            bindEventListener(WINDOW, 'compositionstart', global_compositionStart, true);
	            bindEventListener(WINDOW, 'selectstart', global_docSelectStart, true);
	            var device = util._device();
	            var isIPhoneOrIPad = device.ipad || device.iphone;
	
	            function processDocumentMouseDown(e) {
	                var activeElement = _FocusHelper._getActiveElement();
	                if (activeElement) {
	                    var hitElement = globalPrototype._getUIElement(e.target);
	
	                    self._clickOutsideSheetCallBack.forEach(function (callBack) {
	                        callBack && callBack(activeElement, hitElement);
	                    });
	
	                   
	                   
	                    if (!hitElement || ($$(hitElement).attr("gcUIElement") === 'gcSpread' && activeElement._getHost() !== hitElement)) {
	                       
	
	                        var ignoreFormulaTextBox = activeElement._formulaTextBox && activeElement._formulaTextBox._isSelectMode;
	                       
	                        if (activeElement._endEditImp(keyword_undefined, keyword_undefined, ignoreFormulaTextBox, true)) {
	                            if (isIPhoneOrIPad) {
	                                var eventHanlder = activeElement._eventHandler;
	                                if (eventHanlder && eventHanlder._setFocusToReadonlyFocusElem) {
	                                    eventHanlder._setFocusToReadonlyFocusElem();
	                                }
	                            }
	                            _FocusHelper._setActiveElement(keyword_null);
	                        } else if (e.cancelable) {
	                            return false;
	                        }
	                    }
	                }
	            }
	
	            function processTouch(e) {
	                var pointerType = e.pointerType;
	               
	                if (pointerType === e[MSPOINTER_TYPE_TOUCH] || pointerType === CONST_TOUCH) {
	                    processDocumentMouseDown(e);
	                }
	            }
	
	           
	            if (util._isIEOrEdgeInTouchDevice()) {     
	                $$(DOCUMENT).bind('MSPointerDown', processTouch);
	                $$(DOCUMENT).bind('pointerdown', processTouch);
	            } else {
	                $$(DOCUMENT).bind('touchstart', processDocumentMouseDown);
	            }
	           
	            bindEventListener(DOCUMENT, 'mousedown', function (e) {
	                var returnValue = processDocumentMouseDown(e);
	                if (returnValue === false) {
	                    cancelDefault(e);
	                }
	            }, true);
	
	            $$(DOCUMENT).bind('DOMContentLoaded', function () {
	                globalPrototype._createDummyObjects();
	            });
	        },
	        _getUIElement: function (e) {
	            var w = e;
	            while (w && w.tagName !== 'BODY') {
	                if (typeof w.getAttribute !== const_function) {
	                    break;
	                }
	                var t = w.getAttribute('gcUIElement');
	                if (!t) {
	                    t = w.gcUIElement;
	                }
	                if (t) {
	                    return w;
	                }
	                w = w.parentNode;
	            }
	            return keyword_null;
	        },
	        _getExternalThemeStyle: function (visualState, defaultClass) {
	            var t = globalPrototype._getDummyHeader();
	            if (visualState === 1  || visualState === 2 ) {
	                t = globalPrototype._getDummyHighlight();
	            } else if (visualState === 4 ) {
	                t = globalPrototype._getDummyHover();
	            }
	            var className = t.className;
	            $$(t).removeClass(className).addClass(defaultClass);
	            var ts = getCurrentStyleOrComputedStyle(t);
	            var defaultCss = {
	                backgroundColor: ts.backgroundColor,
	                backgroundImage: ts.backgroundImage
	            };
	            $$(t).addClass(className);
	            ts = getCurrentStyleOrComputedStyle(t);
	            var resultCss = {
	                backgroundColor: ts.backgroundColor,
	                backgroundImage: ts.backgroundImage,
	                color: ts.color,
	                zIndex: ts.zIndex
	            };
	            resultCss.borderLeftColor = ts.borderLeftColor;
	            resultCss.borderRightColor = ts.borderRightColor;
	            resultCss.borderBottomColor = ts.borderBottomColor;
	            resultCss.borderBottomWidth = ts.borderBottomWidth;
	            resultCss.borderTopColor = ts.borderTopColor;
	            resultCss.borderRightWidth = ts.borderRightWidth;
	            if (resultCss.backgroundImage === defaultCss.backgroundImage && resultCss.backgroundColor !== defaultCss.backgroundColor) {
	                resultCss.backgroundImage = keyword_undefined;
	            }
	            $$(t).removeClass(defaultClass);
	            return resultCss;
	        },
	        _getStyleByCssClass: function (cssClass) {
	            var t = globalPrototype._getDummyElement();
	            $$(t).removeClass(t.className).addClass('gc-theme-version ' + cssClass);
	            var ts = getCurrentStyleOrComputedStyle(t);
	            return $$_extend({}, ts);
	        },
	        _getThemeContentStyle: function (cssClass) {
	            var t = globalPrototype._getDummyContent();
	            $$(t).removeClass(t.className).addClass('gc-theme-version ui-widget-content wijmoThemeHelper btn-default ' + cssClass);
	            var ts = getCurrentStyleOrComputedStyle(t);
	            return $$_extend({}, ts);
	        },
	        _suspendEvent: function () {
	            var gcGlobal = WINDOW._gcGlobal;
	            gcGlobal._eventSuspended++;
	        },
	        _resumeEvent: function () {
	            var gcGlobal = WINDOW._gcGlobal;
	            gcGlobal._eventSuspended--;
	            if (gcGlobal._eventSuspended < 0) {
	                gcGlobal._eventSuspended = 0;
	            }
	        }
	    };
	    if (!WINDOW._gcGlobal) {
	        WINDOW._gcGlobal = new _Global();
	    }
	   
	
	   
	   
	    
	    exports.VisualState = {
	        
	        normal: 0,
	        
	        highlight: 1,
	        
	        selected: 2,
	        
	        active: 3,
	        
	        hover: 4
	    };
	   
	
	   
	   
	    
	    exports.SortState = {
	        
	        none: 0,
	        
	        ascending: 1,
	        
	        descending: 2
	    };
	   
	
	   
	    var _ThemeStyleHelper = exports._ThemeStyleHelper = {styleCache: {}};
	    _ThemeStyleHelper._getString = function (visualState) {
	        var dict = {
	            0: 'normal',
	            1: 'highlight',
	            2: 'selected',
	            3: 'active',
	            4: 'hover'
	        };
	        return dict[visualState] || '';
	    };
	    _ThemeStyleHelper._getVisualStateThemeStyle = function (visualState, cssClass) {
	        var cacheName = _ThemeStyleHelper._getString(visualState) + cssClass, styleCache = _ThemeStyleHelper.styleCache;
	        if (!styleCache[cacheName]) {
	            styleCache[cacheName] = globalPrototype._getExternalThemeStyle(visualState, cssClass);
	        }
	        return styleCache[cacheName];
	    };
	    _ThemeStyleHelper._getCssClassThemeStyle = function (cssClass) {
	        var cacheName = cssClass, styleCache = _ThemeStyleHelper.styleCache;
	        if (!styleCache[cacheName]) {
	            styleCache[cacheName] = globalPrototype._getStyleByCssClass(cssClass);
	        }
	        return styleCache[cacheName];
	    };
	    _ThemeStyleHelper._getContentThemeStyle = function (cssClass) {
	        var cacheName = 'content' + cssClass, styleCache = _ThemeStyleHelper.styleCache;
	        if (!styleCache[cacheName]) {
	            styleCache[cacheName] = globalPrototype._getThemeContentStyle(cssClass);
	        }
	        return styleCache[cacheName];
	    };
	    _ThemeStyleHelper._getColorStringFromThemeColor = function (sheet, color) {
	        var theme = sheet._currentTheme;
	        if (theme && theme.getColor) {
	            color = theme.getColor(color);
	        }
	        return color;
	    };
	    _ThemeStyleHelper._clearCache = function () {
	        _ThemeStyleHelper.styleCache = {};
	    };
	   
	
	   
	   
	    
	    function Point(x, y) {
	        this.x = x;
	        this.y = y;
	    }
	
	   
	    
	    Point.prototype.clone = function () {
	        return new Point(this.x, this.y);
	    };
	    exports.Point = Point;
	   
	
	   
	   
	    
	    function Rect(x, y, w, h) {
	        var self = this;
	       
	        
	        self.x = x;
	       
	        
	        self.y = y;
	       
	        
	        self.width = w;
	       
	        
	        self.height = h;
	    }
	
	    Rect.prototype = {
	       
	        
	        intersect: function (x, y, width, height) {
	            var self = this;
	            return x < self.x + self.width && self.x < x + width && y < self.y + self.height && self.y < y + height;
	        },
	       
	        
	        intersectRect: function (rect) {
	            return this.intersect(rect.x, rect.y, rect.width, rect.height);
	        },
	       
	        
	        contains: function (x, y) {
	            var self = this;
	            return self.x < x && x < self.x + self.width && self.y < y && y < self.y + self.height;
	        },
	        containsRect: function (rect) {
	            return this.contains(rect.x, rect.y) && this.contains(rect.x + rect.width, rect.y + rect.height);
	        },
	       
	        
	        getIntersectRect: function (rect) {
	            return this.getIntersect(rect.x, rect.y, rect.width, rect.height);
	        },
	        getIntersect: function (x, y, width, height) {
	            var self = this, x1_s = self.x, y1_s = self.y, x1_e = self.x + self.width, y1_e = self.y + self.height,
	                x2_s = x, y2_s = y, x2_e = x + width, y2_e = y + height,
	                intersectX_s = Math_max(x1_s, x2_s), intersectY_s = Math_max(y1_s, y2_s),
	                intersectX_e = Math_min(x1_e, x2_e), intersectY_e = Math_min(y1_e, y2_e),
	                newX = intersectX_s, newY = intersectY_s, newWidth = intersectX_e - intersectX_s,
	                newHeight = intersectY_e - intersectY_s;
	            if (newWidth > 0 && newHeight > 0) {
	                return new Rect(newX, newY, newWidth, newHeight);
	            }
	            return keyword_null;
	        },
	        round: function () {
	            var self = this;
	            self.x = Math_floor(self.x);
	            self.y = Math_floor(self.y);
	            self.width = Math_ceil(self.width);
	            self.height = Math_ceil(self.height);
	        },
	        clone: function () {
	            var self = this;
	            return new Rect(self.x, self.y, self.width, self.height);
	        }
	    };
	    exports.Rect = Rect;
	   
	
	   
	   
	    
	    function Range(r, c, rc, cc) {
	        var self = this;
	       
	        
	        self.row = r;
	       
	        
	        self.rowCount = rc;
	       
	        
	        self.col = c;
	       
	        
	        self.colCount = cc;
	    }
	
	    Range.prototype = {
	       
	        
	        intersect: function (row, col, rowCount, colCount) {
	            var self = this;
	            return (row === -1 || self.row === -1 || self.row < row + rowCount && row < self.row + self.rowCount) &&
	                (col === -1 || self.col === -1 || self.col < col + colCount && col < self.col + self.colCount);
	        },
	       
	        
	        getIntersect: function (range, maxRowCount, maxColumnCount) {
	            var self = this;
	            if (!range || !self.intersect(range.row, range.col, range.rowCount, range.colCount)) {
	                return keyword_null;
	            }
	            var num1 = self.col === -1 ? maxColumnCount - 1 : self.col + self.colCount - 1;
	            var num2 = range.col === -1 ? maxColumnCount - 1 : range.col + range.colCount - 1;
	            var num3 = self.row === -1 ? maxRowCount - 1 : self.row + self.rowCount - 1;
	            var num4 = range.row === -1 ? maxRowCount - 1 : range.row + range.rowCount - 1;
	            var column = Math_max(self.col, range.col);
	            var num6 = Math_min(num1, num2);
	            var row = Math_max(self.row, range.row);
	            var num8 = Math_min(num3, num4);
	            var rowCount = row === -1 ? -1 : num8 - row + 1;
	            var columnCount = column === -1 ? -1 : num6 - column + 1;
	            return new Range(row, column, rowCount, columnCount);
	        },
	       
	        
	        contains: function (row, col, rowCount, colCount) {
	            var self = this, argumentsLength = arguments.length, contains = false;
	            if (argumentsLength === 2 || argumentsLength === 4) {
	                if (argumentsLength === 2) {
	                    rowCount = 1;
	                    colCount = 1;
	                }
	                contains = (self.row === -1 || self.row <= row && row + rowCount <= self.row + self.rowCount) &&
	                    (self.col === -1 || self.col <= col && col + colCount <= self.col + self.colCount);
	            }
	            return contains;
	        },
	       
	        
	        containsRange: function (range) {
	            return this.contains(range.row, range.col, range.rowCount, range.colCount);
	        },
	       
	        
	        offset: function (x, y) {
	            var self = this;
	            var column = self.col;
	            var row = self.row;
	            if (column !== -1) {
	                column += x;
	            }
	            if (row !== -1) {
	                row += y;
	            }
	            return new Range(row, column, self.rowCount, self.colCount);
	        },
	       
	        
	        union: function (range) {
	            var self = this;
	            var ltr = Math_min(self.row, range.row);
	            var ltc = Math_min(self.col, range.col);
	            var rbr = Math_max(self.row + self.rowCount - 1, range.row + range.rowCount - 1);
	            var rbc = Math_max(self.col + self.colCount - 1, range.col + range.colCount - 1);
	            if (ltr >= 0 && ltc >= 0) {
	                return new Range(ltr, ltc, rbr - ltr + 1, rbc - ltc + 1);
	            } else if (ltr >= 0) {
	                return new Range(ltr, -1, rbr - ltr + 1, -1);
	            } else if (ltc >= 0) {
	                return new Range(-1, ltc, -1, rbc - ltc + 1);
	            }
	            return new Range(-1, -1, -1, -1);
	        },
	       
	        
	        equals: function (range) {
	            var self = this;
	            return range instanceof Range && self.row === range.row && self.col === range.col && self.rowCount === range.rowCount && self.colCount === range.colCount;
	        }
	    };
	    exports.Range = Range;
	
	    exports._createRange = function (r, c, rc, cc) {
	        return new Range(r, c, rc, cc);
	    };
	   
	
	   
	    function _ThemeContext() {
	    }
	
	    _ThemeContext._getColor = function (owner, name) {
	        if (owner && name) {
	            var currentTheme = owner._currentTheme;
	            if (currentTheme) {
	                return currentTheme.getColor(name);
	            }
	        }
	        return name;
	    };
	    _ThemeContext._getFont = function (owner, name) {
	        if (owner && name) {
	            var currentTheme = owner._currentTheme;
	            if (currentTheme) {
	                return currentTheme.getFont(name);
	            }
	            return name;
	        }
	        return keyword_null;
	    };
	    exports._ThemeContext = _ThemeContext;
	   
	
	   
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	    var Events = {};
	    var EVENTS_NAMES = ['ValidationError', 'CellClick', 'CellDoubleClick', 'EnterCell',
	        'LeaveCell', 'ValueChanged', 'TopRowChanged', 'LeftColumnChanged',
	        'InvalidOperation', 'RangeFiltering', 'RangeFiltered', 'TableFiltering',
	        'TableFiltered', 'RangeSorting', 'RangeSorted', 'ClipboardChanging',
	        'ClipboardChanged', 'ClipboardPasting', 'ClipboardPasted', 'ColumnWidthChanging',
	        'ColumnWidthChanged', 'RowHeightChanging', 'RowHeightChanged', 'DragDropBlock',
	        'DragDropBlockCompleted', 'DragFillBlock', 'DragFillBlockCompleted', 'EditStarting',
	        'EditStarted', 'EditChange', 'EditEnding', 'EditEnd', 'EditEnded', 'RangeGroupStateChanging',
	        'RangeGroupStateChanged', 'SelectionChanging', 'SelectionChanged', 'SheetTabClick',
	        'SheetTabDoubleClick', 'SheetNameChanging', 'SheetNameChanged',
	        'UserZooming', 'UserFormulaEntered', 'CellChanged', 'ColumnChanged',
	        'RowChanged', 'ActiveSheetChanging', 'ActiveSheetChanged',
	        'SparklineChanged',
	        'RangeChanged', 'ButtonClicked', 'EditorStatusChanged',
	        'FloatingObjectChanged', 'FloatingObjectSelectionChanged', 'PictureChanged', 'FloatingObjectRemoving', 'FloatingObjectRemoved', 'PictureSelectionChanged',
	        'FloatingObjectLoaded', 'TouchToolStripOpening', 'CommentChanged', 'CommentRemoving', 'CommentRemoved', 'SlicerChanged',
	        'ShapeChanged', 'ShapeSelectionChanged', 'ShapeRemoved', 'ShapeRemoving',
	        'ResetBinding', 'InitBinding',
	        'BeforeDragDrop',
	        'FormulatextboxActiveSheetChanging', 'FormulatextboxActiveSheetChanged',
	        'FormulatextboxEditStarted', 'FormulatextboxEnterCell', 'FormulatextboxEditEnded', 'FormulatextboxRangeChanged',
	        'SheetMoving', 'SheetMoved', 'DragMerging', 'DragMerged', 'ChartClicked', 'FloatingElementSelected'];
	    $$_each(EVENTS_NAMES, function (i, p) {
	        Events[p] = p;
	    });
	    exports.Events = Events;
	   
	
	   
	    function _CachePool(sheet) {
	        this._sheet = sheet;
	    }
	
	    _CachePool.prototype = {
	        _getCellOverflowBuilder: function (rowViewportIndex, colViewportIndex, createBuilder) {
	            var caches = this._cellOverflowBuilderCache, index = rowViewportIndex << 4 + colViewportIndex;
	            if (!caches) {
	                return createBuilder();
	            }
	            var cache = caches[index];
	            if (!cache) {
	                cache = createBuilder();
	                caches[index] = cache;
	            }
	            return cache;
	        },
	        _getConditionalFormat: function (row, col) {
	            var caches = this._conditionalFormatCache;
	            if (caches) {
	                var rowCaches = caches[row];
	                if (rowCaches) {
	                    return rowCaches[col];
	                }
	            }
	            return keyword_null;
	        },
	        _setConditionalFormat: function (row, col, dataBar, iconSet) {
	            var caches = this._conditionalFormatCache;
	            if (caches) {
	                if (!caches[row]) {
	                    caches[row] = {};
	                }
	                var rowCaches = caches[row];
	                rowCaches[col] = {d: dataBar, i: iconSet};
	            }
	        },
	        _getValue: function (row, col, sheetArea, valueType) {
	            var self = this, sheet = self._sheet, cache = self._valueCache;
	            if (sheetArea === keyword_undefined) {
	                sheetArea = 3 ;
	            }
	            if (!cache) {
	                return sheet.getValue(row, col, sheetArea, valueType);
	            }
	            var sCache = cache[sheetArea], rowCache, cellCache;
	            if (!sCache) {
	                sCache = {};
	                cache[sheetArea] = sCache;
	            }
	            rowCache = sCache[row];
	            if (!rowCache) {
	                rowCache = {};
	                sCache[row] = rowCache;
	            }
	            cellCache = rowCache[col];
	            if (cellCache === keyword_undefined) {
	                cellCache = sheet.getValue(row, col, sheetArea, valueType);
	                rowCache[col] = cellCache;
	            }
	            return cellCache;
	        },
	        _getActualStyle: function (row, col, sheetArea) {
	            var self = this, sheet = self._sheet, cache = self._styleCache;
	            if (sheetArea === keyword_undefined) {
	                sheetArea = 3 ;
	            }
	            if (!cache) {
	                return sheet.getActualStyle(row, col, sheetArea, false, false);
	            }
	            var sCache = cache[sheetArea], rowCache, cellCache;
	            if (!sCache) {
	                sCache = {};
	                cache[sheetArea] = sCache;
	            }
	            rowCache = sCache[row];
	            if (!rowCache) {
	                rowCache = {};
	                sCache[row] = rowCache;
	            }
	            cellCache = rowCache[col];
	            if (!cellCache) {
	                cellCache = sheet.getActualStyle(row, col, sheetArea, false, true);
	                rowCache[col] = cellCache;
	            }
	            return cellCache.clone(true);
	        },
	        _getRichText: function (row, col) {
	           
	            var self = this, sheet = self._sheet;
	            return sheet.getRichText(row, col);
	        },
	        _getZoomRowHeight: function (row) {
	            var self = this, sheet = self._sheet, cache = self._rowHeightCache;
	            if (!cache) {
	                return sheet._getZoomRowHeight(row);
	            }
	            var c = cache[row];
	            if (c === keyword_undefined) {
	                c = cache[row] = sheet._getZoomRowHeight(row);
	            }
	            return c;
	        },
	        _getZoomColWidth: function (col) {
	            var self = this, sheet = self._sheet, cache = self._colWidthCache;
	            if (!cache) {
	                return sheet._getZoomColumnWidth(col);
	            }
	            var c = cache[col];
	            if (c === keyword_undefined) {
	                c = cache[col] = sheet._getZoomColumnWidth(col);
	            }
	            return c;
	        },
	        _getRowGroups: function (createFunction) {
	            var self = this;
	            if (!self._valueCache) {
	                return createFunction();
	            }
	            if (!self._rowGroups) {
	                self._rowGroups = createFunction();
	            }
	            return self._rowGroups;
	        },
	        _getColGroups: function (createFunction) {
	            var self = this;
	            if (!self._valueCache) {
	                return createFunction();
	            }
	            if (!self._colGroups) {
	                self._colGroups = createFunction();
	            }
	            return self._colGroups;
	        },
	        _startCacheBeforPan: function () {
	            var self = this;
	            self._isCaching = true;
	            self._cellOverflowBuilderCache = {};
	            self._conditionalFormatCache = {};
	            self._valueCache = {};
	            self._styleCache = {};
	            self._rowHeightCache = {};
	            self._colWidthCache = {};
	        },
	        _endCache: function () {
	            this._isCaching = false;
	        },
	        _clearCacheEndPan: function () {
	            var self = this;
	            self._isCaching = false;
	            self._cellOverflowBuilderCache = keyword_null;
	            self._conditionalFormatCache = keyword_null;
	            self._valueCache = keyword_null;
	            self._styleCache = keyword_null;
	            self._colWidthCache = keyword_null;
	            self._rowHeightCache = keyword_null;
	            self._rowGroups = keyword_null;
	            self._colGroups = keyword_null;
	        }
	    };
	    exports._CachePool = _CachePool;
	   
	
	   
	    var _CacheMgr = exports._CacheMgr = {_cached: false, _formatterCache: {}, _formattedTextCache: {}};
	    _CacheMgr._startCache = function (sheet, startRow, startColumn, endRow, endColumn) {
	        _CacheMgr._cached = true;
	        var tables = sheet.tables;
	        if (tables && tables._has(startRow, startColumn, endRow - startRow + 1, endColumn - startColumn + 1)) {
	            var vIndex = -1;
	            var vIndexCache = _CacheMgr._visibleRowIndexCache = [];
	            for (var r = 0; r <= endRow; r++) {
	                if (sheet.getRowVisible(r)) {
	                    vIndex++;
	                    vIndexCache[r] = vIndex;
	                } else {
	                    vIndexCache[r] = -1;
	                }
	            }
	        }
	    };
	    _CacheMgr._clearCache = function () {
	        _CacheMgr._visibleRowIndexCache = keyword_null;
	        _CacheMgr._cached = false;
	    };
	    _CacheMgr._getFormatter = function (format) {
	        var formatterCache = _CacheMgr._formatterCache;
	        if (!formatterCache[format]) {
	            formatterCache[format] = GeneralFormatter ? new GeneralFormatter(format) : keyword_null;
	        }
	        return formatterCache[format];
	    };
	    _CacheMgr._getFormattedText = function (value, format, formattedData) {
	        var mgrCache = _CacheMgr._formattedTextCache;
	       
	        var valueKey = value + '_' + (typeof value);
	        if (GeneralFormatter) {
	            if (!mgrCache[format]) {
	                mgrCache[format] = {};
	            }
	            var formatCache = mgrCache[format];
	            var formattedResultCache = formatCache[valueKey];
	            if (formattedResultCache) {
	                if (formattedData) {
	                    formattedData.conditionalForeColor = formattedData.value = formattedResultCache.color;
	                    formattedData.content = cloneArray(formattedResultCache.content);
	                }
	                return formattedResultCache.text;
	            }
	            var formatterCache = _CacheMgr._formatterCache;
	            if (!formatterCache[format]) {
	                formatterCache[format] = new GeneralFormatter(format);
	            }
	            var formatter = formatterCache[format];
	            var tempFormattedResult = {};
	            var result = formatter.format(value, tempFormattedResult);
	            var formatResult = formatCache[valueKey] = {};
	            formatResult.text = result;
	            formatResult.color = tempFormattedResult.conditionalForeColor;
	            formatResult.content = tempFormattedResult.content;
	            if (formattedData) {
	                formattedData.conditionalForeColor = formattedData.value = tempFormattedResult.conditionalForeColor;
	                formattedData.content = cloneArray(tempFormattedResult.content);
	            }
	            return result;
	        }
	        return value.toString();
	    };
	    _CacheMgr._getFormattedTextByStyle = function (sheet, style, value, formattedData) {
	       
	       
	        if (value && value.typeName === 'SparklineExValue') {
	            return '';
	        }
	
	        var ct = style.cellType || sheet._getDefaultCellType();
	        var format = style.formatter || style._autoFormatter;
	        return ct.format(value, format, formattedData, keyword_null);
	    };
	    _CacheMgr._clearFormatCache = function () {
	        _CacheMgr._formatterCache = {};
	        _CacheMgr._formattedTextCache = {};
	    };
	
	   
	
	    function createMatrix(ctx) {
	        var matrix = ctx._matrix || {
	            scaleX: 1, scaleY: 1, translateX: 0, translateY: 0, skewX: 0, skewY: 0,
	            orgTranslateX: 0, orgTranslateY: 0
	        };
	        ctx._matrix = matrix;
	        return matrix;
	    }
	
	    var CanvasHelper = exports._CanvasHelper = {
	        _scaleTo: function (ctx, scaleX, scaleY) {
	            var matrix = createMatrix(ctx);
	            matrix.scaleX = scaleX;
	            matrix.scaleY = scaleY;
	            matrix.translateX = matrix.orgTranslateX * scaleX;
	            matrix.translateY = matrix.orgTranslateY * scaleY;
	            ctx.setTransform(matrix.scaleX, matrix.skewX, matrix.skewY, matrix.scaleY, matrix.translateX, matrix.translateY);
	        },
	        _translate: function (ctx, translateX, translateY) {
	            var matrix = createMatrix(ctx);
	            matrix.orgTranslateX += translateX;
	            matrix.orgTranslateY += translateY;
	            matrix.translateX = matrix.orgTranslateX * matrix.scaleX;
	            matrix.translateY = matrix.orgTranslateY * matrix.scaleY;
	            ctx.setTransform(matrix.scaleX, matrix.skewX, matrix.skewY, matrix.scaleY, matrix.translateX, matrix.translateY);
	        }
	    };
	
	   
	    var _DPIHelper = exports._DPIHelper = {dpr: 1, _spreadCanvasCaches: []};
	
	    function DPIHelper_getDevicePixel() {
	        var screen = WINDOW.screen, deviceXDPI = screen.deviceXDPI;
	        var ratio = WINDOW.devicePixelRatio || (deviceXDPI ? deviceXDPI / screen.logicalXDPI : 1);
	       
	
	       
	       
	       
	       
	       
	        var x = ratio * 20;
	        var rx = Math_round(x);
	        return rx - x > 0.82 ? rx / 20 : Math_round(ratio * 100) / 100;
	    }
	    _DPIHelper._getDevicePixel = DPIHelper_getDevicePixel;
	
	    function DPIHelper_setScaleX(canvas, scaleX) {
	        if (canvas) {
	            canvas._gcDPIScaleX = scaleX;
	        }
	    }
	
	    function DPIHelper_setScaleY(canvas, scaleY) {
	        if (canvas) {
	            canvas._gcDPIScaleY = scaleY;
	        }
	    }
	
	    function DPIHelper_setLogicWidth(canvas, width) {
	        canvas._gcLogicWidth = width;
	    }
	
	    function DPIHelper_setLogicHeight(canvas, height) {
	        canvas._gcLogicHeight = height;
	    }
	
	    _DPIHelper._adjustDevicePixel = function (canvas, workbook, sheet) {
	        var self = _DPIHelper;
	        DPIHelper_setScaleX(canvas, 1);
	        DPIHelper_setScaleY(canvas, 1);
	        var ratio = DPIHelper_getDevicePixel();
	        if (ratio === 1 && self.dpr === 1) {
	            return;
	        }
	        self.dpr = ratio;
	       
	        var ownerWorkbook = workbook ? workbook : sheet && sheet.parent;
	        if (ownerWorkbook) {
	            var cache = self._spreadCanvasCaches, spreadCache;
	            for (var i = 0; i < cache.length; i++) {
	                if (ownerWorkbook === cache[i].workbook) {
	                    spreadCache = cache[i];
	                    break;
	                }
	            }
	            if (!spreadCache) {
	                spreadCache = {workbook: ownerWorkbook, sheets: [], canvases: []};
	                cache.push(spreadCache);
	            }
	            if (workbook) {
	                spreadCache.canvases.push(canvas);
	            } else {
	                var cacheSheet, sheets = spreadCache.sheets;
	                for (var j = 0; j < sheets.length; j++) {
	                    if (sheets[j].sheet === sheet) {
	                        cacheSheet = sheets[j];
	                        break;
	                    }
	                }
	                if (!cacheSheet) {
	                    cacheSheet = {sheet: sheet, canvases: []};
	                    sheets.push(cacheSheet);
	                }
	                cacheSheet.canvases.push(canvas);
	            }
	        }
	    };
	    _DPIHelper._getScaleX = function (canvas) {
	        return canvas && canvas._gcDPIScaleX || 1;
	    };
	    _DPIHelper._getScaleY = function (canvas) {
	        return canvas && canvas._gcDPIScaleY || 1;
	    };
	    _DPIHelper._getLogicWidth = function (canvas) {
	        return canvas._gcLogicWidth;
	    };
	    _DPIHelper._getLogicHeight = function (canvas) {
	        return canvas._gcLogicHeight;
	    };
	    _DPIHelper._setSize = function (canvas, width, height) {
	        var self = _DPIHelper, ratio = self.dpr;
	        var oldScaleX = self._getScaleX(canvas), oldScaleY = self._getScaleY(canvas);
	        DPIHelper_setLogicWidth(canvas, width);
	        DPIHelper_setLogicHeight(canvas, height);
	        if (ratio === 1 && oldScaleX === 1 && oldScaleY === 1) {
	            canvas.width = width;
	            canvas.height = height;
	        } else {
	            var ctx = canvas.getContext('2d');
	            CanvasHelper._scaleTo(ctx, 1, 1);
	            if (util._browser.mozilla) {
	                canvas.width = Math_ceil(width * ratio);
	                canvas.height = Math_ceil(height * ratio);
	            } else {
	                canvas.width = Math_round(width * ratio);
	                canvas.height = Math_round(height * ratio);
	            }
	            canvas.style.width = width + CSS_PX;
	            canvas.style.height = height + CSS_PX;
	            var newScaleX = canvas.width / width, newScaleY = canvas.height / height;
	            if (newScaleX !== oldScaleX || newScaleY !== oldScaleY) {
	                DPIHelper_setScaleX(canvas, newScaleX);
	                DPIHelper_setScaleY(canvas, newScaleY);
	            }
	            CanvasHelper._scaleTo(ctx, newScaleX, newScaleY);
	        }
	    };
	    _DPIHelper._disposeCanvasForSheet = function (sheet, canvas) {
	        var caches = _DPIHelper._spreadCanvasCaches;
	        var workbook = sheet.parent;
	        var sheets;
	        var canvases;
	        for (var i = 0; i < caches.length; i++) {
	            if (!workbook || caches[i].workbook === workbook) {
	                sheets = caches[i].sheets;
	                for (var j = 0; j < sheets.length; j++) {
	                    if (sheets[j].sheet === sheet) {
	                        canvases = sheets[j].canvases;
	                        for (var k = 0; k < canvases.length; k++) {
	                            if (canvases[k] === canvas) {
	                                canvases.splice(k, 1);
	                                break;
	                            }
	                        }
	                        break;
	                    }
	                }
	            }
	        }
	    };
	    _DPIHelper._disposeCanvasForSpread = function (workbook, canvas) {
	        var caches = _DPIHelper._spreadCanvasCaches;
	        var canvases;
	        for (var i = 0; i < caches.length; i++) {
	            if (caches[i].workbook === workbook) {
	                canvases = caches[i].canvases;
	                for (var k = 0; k < canvases.length; k++) {
	                    if (canvases[k] === canvas) {
	                        canvases.splice(k, 1);
	                        break;
	                    }
	                }
	            }
	        }
	    };
	    _DPIHelper._disposeSheet = function (sheet) {
	        var caches = _DPIHelper._spreadCanvasCaches;
	        var workbook = sheet.parent;
	        var sheets;
	        for (var i = 0; i < caches.length; i++) {
	            if (!workbook || caches[i].workbook === workbook) {
	                sheets = caches[i].sheets;
	                for (var j = 0; j < sheets.length; j++) {
	                    if (sheets[j].sheet === sheet) {
	                        sheets.splice(j, 1);
	                    }
	                }
	                return;
	            }
	        }
	    };
	    _DPIHelper._disposeSpread = function (workbook) {
	        var caches = _DPIHelper._spreadCanvasCaches;
	        for (var i = 0; i < caches.length; i++) {
	            if (caches[i].workbook === workbook) {
	                caches.splice(i, 1);
	                return;
	            }
	        }
	    };
	    _DPIHelper._updateDPI = function () {
	        var self = _DPIHelper;
	        var dpr = DPIHelper_getDevicePixel();
	        if (self.dpr !== dpr) {
	            var caches = self._spreadCanvasCaches, sheets, spreadCache, canvases, canvas;
	            self.dpr = dpr;
	            for (var i = 0; i < caches.length; i++) {
	                spreadCache = caches[i];
	                canvases = spreadCache.canvases;
	                sheets = spreadCache.sheets;
	                for (var sIndex = 0; sIndex < sheets.length; sIndex++) {
	                    canvases = canvases.concat(sheets[sIndex].canvases);
	                }
	
	                for (var j = 0; j < canvases.length; j++) {
	                    canvas = canvases[j];
	                    self._setSize(canvas, self._getLogicWidth(canvas), self._getLogicHeight(canvas));
	                }
	            }
	        }
	    };
	   
	
	   
	    var _WordWrapHelper = exports._WordWrapHelper = {};
	
	   
	    _WordWrapHelper._getWrapInfo = function (text, size, font, isVerticalText) {
	        var wrapLines = [];
	        if (text.length === 0) {
	            return wrapLines;
	        }
	        var ctx = _WordWrapHelper_getCtx();
	        if (!ctx) {
	            return wrapLines;
	        }
	        util._setContextFont(ctx, font);
	        var lineHeight = util._getFontHeight(font);
	        if (size <= 0) {
	            var charMinSize = -1;
	            var flag = true;
	            for (var index = 0; index < text.length; index++) {
	                var tempChar = text.charAt(index);
	                if (tempChar !== SPECE_STR && !flag) {
	                    charMinSize = Math_min(charMinSize, isVerticalText ? lineHeight : measureTextWidth(ctx, ctx.font, tempChar));
	                } else if (tempChar !== SPECE_STR && flag) {
	                    charMinSize = isVerticalText ? lineHeight : measureTextWidth(ctx, ctx.font, tempChar);
	                    flag = false;
	                }
	            }
	            size = charMinSize;
	            if (size <= 0) {
	               
	               
	                return [text];
	            }
	        }
	        var lines = text.split(/\r\n|\r|\n/);
	        for (var i = 0; i < lines.length; i++) {
	            var wrapLine = _WordWrapHelper_getWrapInfoByWord(lines[i], size, isVerticalText, lineHeight);
	            if (wrapLine) {
	                if (wrapLine.length === 0) {
	                    wrapLines.push('');
	                } else {
	                    for (var j = 0; j < wrapLine.length; j++) {
	                        wrapLines.push(wrapLine[j]);
	                    }
	                }
	            }
	        }
	        return wrapLines;
	    };
	
	    _WordWrapHelper._getVerticalInfo = function (ctx, text, font, wordWrap, wordWrapHeight) {
	        var verticalLines = [];
	        if (text.length === 0) {
	            return verticalLines;
	        }
	        if (!wordWrap) {
	            var lines = text.split(/\r\n|\r|\n/);
	            for (var i = 0; i < lines.length; i++) {
	                var verticalLine = [];
	                for (var j = 0; j < lines[i].length; j++) {
	                    verticalLine.push(lines[i][j]);
	                }
	                verticalLines.push(verticalLine);
	            }
	        } else {
	            verticalLines = _WordWrapHelper._getWrapInfo(text, wordWrapHeight, font, true);
	        }
	        return verticalLines;
	    };
	    _WordWrapHelper.getRichTextWrapInfo = function (text, size, font, allChars) {
	        var wrapLines = [];
	        if (text.length === 0) {
	            return wrapLines;
	        }
	        var ctx = _WordWrapHelper_getCtx();
	        if (!ctx) {
	            return wrapLines;
	        }
	        if (size <= 0) {
	            var charMinSize = -1;
	            var flag = true;
	            for (var index = 0; index < allChars.length; index++) {
	                var tempChar = allChars[index].charInfo;
	                if (tempChar !== SPECE_STR && !flag) {
	                    util._setContextFont(ctx, allChars[index].fontInfo);
	                    charMinSize = Math_min(charMinSize, measureTextWidth(ctx, ctx.font, tempChar));
	                } else if (tempChar !== SPECE_STR && flag) {
	                    util._setContextFont(ctx, allChars[index].fontInfo);
	                    charMinSize = measureTextWidth(ctx, ctx.font, tempChar);
	                    flag = false;
	                }
	            }
	            size = charMinSize;
	            if (size <= 0) {
	               
	               
	                return [text];
	            }
	        }
	        var lines = text.split(/\r\n|\r|\n/);
	        for (var i = 0; i < lines.length; i++) {
	            var wrapLine = _WordWrapHelper_getRichTextWrapInfoByWord(lines[i], size, allChars.slice(0, lines[i].length));
	            if (wrapLine) {
	                if (wrapLine.length === 0) {
	                    wrapLines.push('');
	                } else {
	                    for (var j = 0; j < wrapLine.length; j++) {
	                        wrapLines.push(wrapLine[j]);
	                    }
	                }
	            }
	        }
	        return wrapLines;
	    };
	    _WordWrapHelper._getWordWrapInfo = function (text, size, font, richText, isVerticalText) {
	        var wrapLines = [];
	        if (text.length === 0) {
	            return wrapLines;
	        }
	        var ctx = _WordWrapHelper_getCtx();
	        if (!ctx) {
	            return wrapLines;
	        }
	        var i;
	        if (size <= 0) {
	            size = resetSize(ctx, richText, font, isVerticalText);
	            if (size <= 0) {
	               
	               
	                var data = [];
	                for (i = 0; i < richText.length; i++) {
	                    if (!isNullOrUndefined(richText[i].text)) {
	                        data.push({
	                            textLength: _WordWrapHelper._getTextLengthInLine(richText[i], font, 1, isVerticalText, false),
	                            text: richText[i].text,
	                            textInfos: [richText[i]]
	                        });
	                    }
	                }
	                return data;
	            }
	        }
	        var lines = _WordWrapHelper._splitTextByLineBreakAndWords(text);
	        lines = _WordWrapHelper._composeTextInfos(lines, _WordWrapHelper._trimLineBreaksInRichText(richText));
	        for (i = 0; i < lines.length; i++) {
	            var wrapLine = _WordWrapHelper_getRichTextWrapInfoByWord(lines[i], size, font, isVerticalText);
	            if (wrapLine) {
	                if (wrapLine.length === 0) {
	                    wrapLines.push('');
	                } else {
	                    for (var j = 0; j < wrapLine.length; j++) {
	                        wrapLines.push(wrapLine[j]);
	                    }
	                }
	            }
	        }
	        return wrapLines;
	    };
	    _WordWrapHelper._splitTextByLineBreakAndWords = function (text) {
	        var lines = [];
	        var linesByLineBreak = text.split(/\r\n|\r|\n/);
	        for (var i = 0; i < linesByLineBreak.length; i++) {
	            lines.push(_WordWrapHelper_getTextWords(linesByLineBreak[i]));
	        }
	        return lines;
	    };
	    _WordWrapHelper._composeTextInfos = function (textSplitByLineBreakAndWords, richText) {
	        var lines = [];
	        var richTextItemIndex = 0;
	        var richTextItemStoredLength = 0;
	        for (var i = 0; i < textSplitByLineBreakAndWords.length; i++) {
	            var line = [];
	            for (var j = 0; j < textSplitByLineBreakAndWords[i].length; j++) {
	                var word = textSplitByLineBreakAndWords[i][j];
	                if (word.length <= richText[richTextItemIndex].text.length - richTextItemStoredLength) {
	                    line.push({
	                        style: richText[richTextItemIndex].style,
	                        text: word
	                    });
	                    richTextItemStoredLength += word.length;
	                } else {
	                    line.push({
	                        style: richText[richTextItemIndex].style,
	                        text: richText[richTextItemIndex].text.substring(richTextItemStoredLength)
	                    });
	                    var wordLastLength = word.length - (richText[richTextItemIndex].text.length - richTextItemStoredLength);
	                   
	                    richTextItemIndex++;
	                    for (; richTextItemIndex < richText.length; richTextItemIndex++) {
	                        if (wordLastLength < richText[richTextItemIndex].text.length) {
	                            line.push({
	                                style: richText[richTextItemIndex].style,
	                                text: word.substring(word.length - wordLastLength)
	                            });
	                            richTextItemStoredLength = wordLastLength;
	                            break;
	                        } else if (wordLastLength === richText[richTextItemIndex].text.length) {
	                            line.push({
	                                style: richText[richTextItemIndex].style,
	                                text: word.substring(word.length - wordLastLength)
	                            });
	                            richTextItemIndex++;
	                            richTextItemStoredLength = 0;
	                            break;
	                        } else {
	                            line.push({
	                                style: richText[richTextItemIndex].style,
	                                text: richText[richTextItemIndex].text
	                            });
	                            wordLastLength -= richText[richTextItemIndex].text.length;
	                        }
	                    }
	                }
	            }
	            lines.push(line);
	        }
	        return lines;
	    };
	
	    _WordWrapHelper._measureText = function (text, font, withoutEndSpaces) {
	        var ctx = _WordWrapHelper_getCtx();
	        if (!ctx) {
	            return 0;
	        }
	        if (font) {
	            util._setContextFont(ctx, font);
	        }
	        var tempText = withoutEndSpaces ? _WordWrapHelper_removeEndSpace(text) : text;
	        return measureTextWidth(ctx, ctx.font, tempText);
	    };
	
	    _WordWrapHelper._trimLineBreaksInRichText = function (richText) {
	        var richTextWithoutLineBreak = [];
	        for (var i = 0; i < richText.length; i++) {
	            richTextWithoutLineBreak.push({
	                style: richText[i].style,
	                text: richText[i].text ? richText[i].text.replace(/\r\n|\r|\n/, '') : richText[i].text
	            });
	        }
	        return richTextWithoutLineBreak;
	    };
	
	    _WordWrapHelper._getTextLengthInLine = function (line, defaultFont, zoomFactor, isVerticalText, withoutEndSpaces) {
	        var ctx = _WordWrapHelper_getCtx();
	        if (!ctx) {
	            return 0;
	        }
	        var textLength = 0;
	        for (var i = 0; i < line.length; i++) {
	            var font;
	            if (line[i].style && line[i].style.font) {
	                font = line[i].style.font;
	            } else {
	                font = defaultFont;
	            }
	            util._setContextFont(ctx, font);
	            var text = '';
	            if (i === line.length - 1 && withoutEndSpaces) {
	                text = _WordWrapHelper_removeEndSpace(line[i].text);
	            } else {
	                text = line[i].text;
	            }
	            var tempLength = 0;
	            if (isVerticalText) {
	                tempLength = util._getFontHeight(font) * text.length / zoomFactor;
	            } else if (!isNullOrUndefined(line[i].text)) {
	                tempLength = measureTextWidth(ctx, ctx.font, line[i].text) / zoomFactor;
	            }
	            if (line[i].style && line[i].style.vertAlign) {
	               
	                tempLength = tempLength * subscriptAndSuperscriptScale;
	            }
	            textLength += tempLength;
	        }
	        return textLength;
	    };
	
	    _WordWrapHelper._removeEndSpace = function (text) {
	        return _WordWrapHelper_removeEndSpace(text);
	    };
	
	    _WordWrapHelper._getCtx = function () {
	        return _WordWrapHelper_getCtx();
	    };
	
	    function _WordWrapHelper_getCtx() {
	        if (!_WordWrapHelper._ctx) {
	            _WordWrapHelper._ctx = createElement('canvas').getContext('2d');
	        }
	        return _WordWrapHelper._ctx;
	    }
	
	    function _WordWrapHelper_getTextWords(text) {
	        var lines = [];
	        var startIndex = 0;
	        var space = SPECE_STR;
	        for (var i = 0; i < text.length; i++) {
	            if (lines[startIndex] === keyword_undefined) {
	                lines[startIndex] = '';
	            }
	            var currentChar = text.charAt(i);
	            var nextChar = '';
	            if (i + 1 < text.length) {
	                nextChar = text.charAt(i + 1);
	            }
	            if (currentChar === space && nextChar !== space) {
	                lines[startIndex] += currentChar;
	                startIndex++;
	            } else {
	                lines[startIndex] += currentChar;
	            }
	        }
	        return lines;
	    }
	
	    function _WordWrapHelper_removeEndSpace(text) {
	        var index = text.length - 1;
	        while (text.charAt(index) === ' ') {
	            index--;
	        }
	        if (index !== text.length - 1) {
	            text = text.substring(0, index + 1);
	        }
	        return text;
	    }
	
	    function objDeepCopy(source) {
	        var sourceCopy = source instanceof Array ? [] : {};
	        for (var item in source) {
	            if (source.hasOwnProperty(item)) {
	                sourceCopy[item] = (typeof source[item] === 'object' && source[item] !== keyword_null) ? objDeepCopy(source[item]) : source[item];
	            }
	        }
	        return sourceCopy;
	    }
	
	    function _WordWrapHelper_getWrapInfoByCharacter(text, size, isVerticalText, lineHeight) {
	        var lines = [];
	        var ctx = _WordWrapHelper_getCtx();
	        if (!ctx) {
	            return lines;
	        }
	        var orgtLength, totalSize;
	        if (isVerticalText) {
	            totalSize = text.length * lineHeight;
	            orgtLength = Math_ceil(size / lineHeight);
	        } else {
	            totalSize = measureTextWidth(ctx, ctx.font, text);
	            var charSize = totalSize / text.length;
	            orgtLength = Math_ceil(size / charSize);
	        }
	        while (totalSize > size && text) {
	            var isLong = false;
	            var targetLength = orgtLength;
	            while (true) {
	                if (text.length < targetLength) {
	                    lines.push(text);
	                    text = "";
	                    break;
	                }
	                var subText = text.substring(0, targetLength);
	                var subSize = isVerticalText ? targetLength * lineHeight : measureTextWidth(ctx, ctx.font, subText);
	
	                if (subSize === size || isLong && subSize < size) {
	                    lines.push(subText);
	                    text = text.substring(targetLength);
	                    totalSize = totalSize - subSize;
	                    break;
	                } else if (subSize > size) {
	                    if (subText.length === 1) {
	                        var remainText = text.substring(subText.length);
	                        if (remainText.trim()) {
	                            lines.push(subText);
	                            text = text.substring(targetLength);
	                            totalSize = totalSize - subSize;
	                        } else {
	                            lines.push(text);
	                            text = "";
	                        }
	                        break;
	                    }
	                    targetLength -= 1;
	                    isLong = true;
	                } else {
	                    var step = isVerticalText ? (size - subSize) / lineHeight : (size - subSize) / charSize;
	                    step = step >= 1 ? step : 1;
	                    targetLength += step;
	                }
	            }
	        }
	        if (text) {
	            lines.push(text);
	        }
	        return lines;
	    }
	
	    function _WordWrapHelper_getRichTextWrapInfoByCharacter(word, availSizeInFirstLine, size, isVerticalText, lineHeight) {
	        var ctx = _WordWrapHelper_getCtx();
	        if (!ctx) {
	            return word;
	        }
	        var parts = [];
	        var charIndex = 0;
	        var tempSize = 0;
	        var availSize = availSizeInFirstLine;
	        for (var i = 0; i < word.text.length; i++) {
	            tempSize += isVerticalText ? lineHeight : measureTextWidth(ctx, ctx.font, word.text.charAt(i));
	            if (tempSize > availSize) {
	                if (i - charIndex === 0) {
	                   
	                    parts.push({
	                        style: word.style,
	                        text: word.text.substring(i, i + 1)
	                    });
	                    charIndex = i + 1;
	                } else {
	                    parts.push({
	                        style: word.style,
	                        text: word.text.substring(charIndex, i)
	                    });
	                    charIndex = i--;
	                }
	                tempSize = 0;
	                availSize = size;
	            }
	        }
	        parts.push({
	            style: word.style,
	            text: word.text.substring(charIndex)
	        });
	        return parts;
	    }
	
	    function _WordWrapHelper_getWrapInfoByWord(text, size, isVerticalText, lineHeight) {
	        var lines = [];
	        var words = _WordWrapHelper_getTextWords(text);
	        var ctx = _WordWrapHelper_getCtx();
	        if (!ctx) {
	            return lines;
	        }
	        var totalSize = measureTextWidth(ctx, ctx.font, text);
	        var charSize = isVerticalText ? lineHeight : totalSize / text.length;
	        var averageLength = convertToInt(size / charSize + '', 10);
	        var lineIndex = 0, stackCharCount = 0, tempCount = 0, index = 0;
	        var stack = [];
	        var isLong = false;
	        while (index < words.length) {
	            if (isLong === false) {
	                var word = words[index];
	                stack.push(word);
	                stackCharCount += word.length;
	                if (stackCharCount < averageLength && (index < words.length - 1)) {
	                    index++;
	                    continue;
	                } else {
	                    tempCount = stackCharCount;
	                    stackCharCount = 0;
	                }
	            }
	            var subSize = isVerticalText ? stack.join('').length * lineHeight :
	                _WordWrapHelper._measureText(stack.join(''), keyword_undefined, true);
	            if (subSize > size) {
	                var tempWord = stack.pop();
	                if (stack.length === 0) {
	                    var parts = _WordWrapHelper_getWrapInfoByCharacter(tempWord, size, isVerticalText, lineHeight);
	                    for (var i = 0; i < parts.length - 1; i++) {
	                        lines[lineIndex++] = parts[i];
	                    }
	                    if (parts.length >= 2) {
	                        words[index] = parts[parts.length - 1];
	                    } else {
	                        index++;      
	                    }
	                    isLong = false;
	                } else {
	                    isLong = true;
	                    index--;
	                }
	            } else if (subSize < size && isLong === true || subSize === size) {
	                isLong = false;
	                lines[lineIndex++] = _WordWrapHelper_removeEndSpace(stack.join(''));
	                stack = [];
	                index++;
	            } else if (subSize < size) {
	                index++;
	                stackCharCount = tempCount;
	            }
	        }
	        if (stack.length !== 0) {
	            lines[lineIndex] = _WordWrapHelper_removeEndSpace(stack.join(''));
	        }
	        return lines;
	    }
	
	    function _WordWrapHelper_getRichTextWrapInfoByWord(words, size, lineDefaultFont, isVerticalText) {
	        var lines = [];
	        var ctx = _WordWrapHelper_getCtx();
	        if (!ctx) {
	            return lines;
	        }
	        if (words.length === 0) {
	           
	            lines.push({
	                textLength: 0,
	                text: '',
	                textInfos: [{
	                    style: {
	                        font: lineDefaultFont
	                    },
	                    text: ''
	                }]
	            });
	            return lines;
	        }
	        var tempSize = 0, stack = [];
	        for (var i = 0; i < words.length; i++) {
	            var word = words[i];
	            var font;
	            if (word.style && word.style.font) {
	                font = word.style.font;
	            } else {
	                font = lineDefaultFont;
	            }
	            var wordSize = 0, lineHeight = 0;
	            if (isVerticalText) {
	                lineHeight = util._getFontHeight(font);
	                wordSize = lineHeight * word.text.length;
	            } else if(!isNullOrUndefined(word.text)) {
	                wordSize = measureTextWidth(ctx, font, word.text);
	            }
	            if (wordSize > size) {
	                if (stack.length > 0) {
	                    lines.push({
	                        textLength: tempSize,
	                        text: _WordWrapHelper_removeEndSpace(mergeArrayText(stack)),
	                        textInfos: objDeepCopy(stack)
	                    });
	                    stack = [];
	                    tempSize = 0;
	                }
	                var parts = _WordWrapHelper_getRichTextWrapInfoByCharacter(word, size - tempSize, size, isVerticalText, lineHeight);
	                stack.push(parts[0]);
	                if (!isNullOrUndefined(parts[0].text)) {
	                    lines.push({
	                        textLength: isVerticalText ? tempSize + lineHeight * parts[0].text.length : tempSize + measureTextWidth(ctx, font, parts[0].text),
	                        text: _WordWrapHelper_removeEndSpace(mergeArrayText(stack)),
	                        textInfos: objDeepCopy(stack)
	                    });
	                }
	                stack = [];
	                tempSize = 0;
	                for (var k = 1; k < parts.length - 1; k++) {
	                    if (!isNullOrUndefined(parts[k].text)) {
	                        lines.push({
	                            textLength: isVerticalText ? lineHeight * parts[k].text.length : measureTextWidth(ctx, font, parts[k].text),
	                            text: _WordWrapHelper_removeEndSpace(mergeArrayText([parts[k]])),
	                            textInfos: objDeepCopy([parts[k]])
	                        });
	                    }
	                }
	                if (parts.length > 1) {
	                    var lastPart = parts[parts.length - 1];
	                    stack.push(lastPart);
	                    if (!isNullOrUndefined(lastPart.text)) {
	                        tempSize += isVerticalText ? lineHeight * lastPart.text.length : measureTextWidth(ctx, font, lastPart.text);
	                    }
	                }
	            } else if (tempSize + wordSize > size) {
	                lines.push({
	                    textLength: tempSize,
	                    text: _WordWrapHelper_removeEndSpace(mergeArrayText(stack)),
	                    textInfos: objDeepCopy(stack)
	                });
	                stack = [];
	                stack.push(word);
	                tempSize = wordSize;
	            } else {
	                stack.push(word);
	                tempSize += wordSize;
	            }
	        }
	        if (stack.length > 0) {
	            lines.push({
	                textLength: tempSize,
	                text: _WordWrapHelper_removeEndSpace(mergeArrayText(stack)),
	                textInfos: objDeepCopy(stack)
	            });
	        }
	        return lines;
	    }
	
	    function mergeArrayText(stack) {
	        var text = '';
	        for (var i = 0; i < stack.length; i++) {
	            text += stack[i].text;
	        }
	        return text;
	    }
	
	    function resetSize(ctx, richText, font, isVerticalText) {
	        var charMinSize = -1;
	        var flag = true;
	        for (var i = 0; i < richText.length; i++) {
	            if (isNullOrUndefined(richText[i].text)) {
	                continue;
	            }
	            for (var j = 0; j < richText[i].text.length; j++) {
	                var tempChar = richText[i].text.charAt(j);
	                var actualFont = richText[i].style ? richText[i].style.font : font;
	                util._setContextFont(ctx, actualFont);
	                var lineHeight = util._getFontHeight(actualFont);
	                if (tempChar !== SPECE_STR && !flag) {
	                    charMinSize = Math_min(charMinSize, isVerticalText ? lineHeight : measureTextWidth(ctx, font, tempChar));
	                } else if (tempChar !== SPECE_STR && flag) {
	                    charMinSize = isVerticalText ? lineHeight : measureTextWidth(ctx, font, tempChar);
	                    flag = false;
	                }
	            }
	        }
	        return charMinSize;
	    }
	
	   
	   
	   
	   
	   
	   
	
	   
	    exports._defineFeature = function (obj) {
	        obj._registerFeature = function (name, feature) {
	            if (!obj._features) {
	                obj._features = [];
	            }
	            var features = obj._features;
	            feature.name = name;
	            feature.priority = feature.priority || 5000 ;
	            for (var i = 0; ; i++) {
	                if (i >= features.length || feature.priority > features[i].priority) {
	                    features.splice(i, 0, feature);
	                    break;
	                }
	            }
	        };
	        obj._callFeatureHandler = function (target, fn, eventArg, endLoopFn) {
	            var sf = obj._features;
	            if (sf) {
	                for (var i = 0; i < sf.length; i++) {
	                    var f = sf[i][fn];
	                    f && f.call(target, eventArg);
	
	                    if (endLoopFn && endLoopFn()) {
	                        break;
	                    }
	                }
	            }
	        };
	    };
	
	   
	    function SparseArray() {
	        this._store = {};
	    }
	
	    SparseArray.prototype.get = function (row, col) {
	        var rowNode = this._store[row];
	        return rowNode ? rowNode[col] : keyword_undefined;
	    };
	    SparseArray.prototype.set = function (row, col, value) {
	        var rowNode = this._store[row];
	        if (!rowNode) {
	            rowNode = this._store[row] = {};
	        }
	        rowNode[col] = value;
	    };
	    exports._SparseArray = SparseArray;
	   
	
	    module.exports = exports;
	
	}());

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var Common = __webpack_require__(5);
	    var Types = Common._Types;
	    var hasOwnProperty = Common._hasOwnProperty;
	
	    var keyword_undefined = void 0, keyword_null = null, convertToFloat = parseFloat, DOCUMENT = document;
	    var NO_NAMESPACE = '_nonamespace', EVENTS = 'events', str_get = 'get', str_set = 'set', str_width = 'width',
	        str_height = 'height', str_left = 'left', str_right = 'right', str_top = 'top', str_bottom = 'bottom',
	        css_hidden = 'hidden', css_block = 'block', css_none = 'none', css_position = 'position',
	        css_visibility = 'visibility', css_display = 'display';
	
	    var propFix = {
	        tabindex: 'tabIndex',
	        readonly: 'readOnly',
	        'for': 'htmlFor',
	        'class': 'className',
	        maxlength: 'maxLength',
	        cellspacing: 'cellSpacing',
	        cellpadding: 'cellPadding',
	        rowspan: 'rowSpan',
	        colspan: 'colSpan',
	        usemap: 'useMap',
	        frameborder: 'frameBorder',
	        contenteditable: 'contentEditable'
	    };
	    var propHooks = {
	        tabIndex: {
	            get: function (elem) {
	               
	               
	                var attributeNode = elem.getAttributeNode('tabindex');
	                var rfocusable = /^(?:input|select|textarea|button|object)$/i, rclickable = /^(?:a|area)$/i;
	                var nodeName = elem.nodeName;
	                if (attributeNode && attributeNode.specified) {
	                    return parseInt(attributeNode.value, 10);
	                }
	                return rfocusable.test(nodeName) || rclickable.test(nodeName) && elem.href ? 0 : keyword_undefined;
	            }
	        }
	    };
	    var valHooks = {
	        option: {
	            get: function (elem) {
	               
	               
	                var val = elem.attributes.value;
	                return !val || val.specified ? elem.value : elem.text;
	            }
	        },
	        select: {
	            get: function (elem) {
	                var value, option, options = elem.options, index = elem.selectedIndex,
	                    one = elem.type === 'select-one' || index < 0,
	                    values = one ? keyword_null : [], max = one ? index + 1 : options.length, i = one ? index : 0;
	                if (index < 0) {
	                    i = max;
	                }
	                for (; i < max; i++) {
	                    option = options[i];
	                   
	                    if ((option.selected || i === index) && !option.disabled && (!option.parentNode.disabled || !getNodeName(option.parentNode, 'optgroup'))) {
	                       
	                        value = $(option).val();
	                       
	                        if (one) {
	                            return value;
	                        }
	                       
	                        values.push(value);
	                    }
	                }
	                return values;
	            },
	            set: function (elem, value) {
	                var values = $.makeArray(value);
	                var elements = $(elem).find('option').getAll();
	                elements.forEach(function (e) {
	                    e.selected = $.inArray($(e).val(), values) >= 0;
	                });
	                if (!values.length) {
	                    elem.selectedIndex = -1;
	                }
	                return values;
	            }
	        }
	    };
	    var globalCache = {};
	    var expando = 'GC$' + ('' + Math.random()).replace(/\D/g, '');
	    var guid = 1;
	    var cssHooks = {};
	    [str_height, str_width].forEach(function (name) {
	        cssHooks[name] = {
	            get: function (elem) {
	                var computedStyle = getComputedStyle(elem);
	                var style = elem.style;
	                var originalPosition = style[css_position], originalVisibility = style[css_visibility],
	                    originalDisplay = style[css_display];
	                var elemIsInvisible = elem.offsetWidth === 0 && /^(none|table(?!-c[ea]).+)/.test(computedStyle[css_display]);
	               
	                if (elemIsInvisible) {
	                    style[css_position] = 'absolute';
	                    style[css_visibility] = css_hidden;
	                    style[css_display] = css_block;
	                }
	               
	                var ret = computedStyle && computedStyle[name];
	               
	                if (elemIsInvisible) {
	                    style[css_position] = originalPosition;
	                    style[css_visibility] = originalVisibility;
	                    style[css_display] = originalDisplay;
	                }
	
	                if (ret === '') {
	                    var parentElement = elem.parentElement, bodyElement = DOCUMENT.body;
	                    while (parentElement && parentElement !== bodyElement) {
	                        parentElement = parentElement.parentElement;
	                    }
	                    if (parentElement !== bodyElement) {
	                        ret = style[name];
	                    }
	                }
	                return ret;
	            }
	        };
	    });
	
	   
	    function init(selectors, context) {
	        Array.call(this);
	        var list;
	        if (typeof selectors === 'string') {
	            list = (context || DOCUMENT).querySelectorAll(selectors);
	        } else if (selectors) {
	            if (Types._isArray(selectors) || selectors instanceof HTMLCollection) {
	                list = selectors;
	            } else {
	                list = [selectors];
	            }
	        }
	        for (var i = 0; list && i < list.length; i++) {
	            this.push(list[i]);
	        }
	    }
	
	    function $(selectors, context) {
	       
	        if (selectors instanceof init) {
	            return selectors;
	        }
	        return new init(selectors, context);
	    }
	
	   
	    var prototypeEx = {
	       
	        get: function (index) {
	            return this[index];
	        },
	       
	        getAll: function () {
	            return this;
	        },
	       
	        bind: function (eventType, data, listener) {
	            var self = this;
	            if (isUndefined(listener)) {
	                listener = data;
	                data = keyword_undefined;
	            }
	            self.forEach(function (elem) {
	                var elemData = internalData(elem, EVENTS, keyword_undefined, true);
	                if (!elemData) {
	                    elemData = {};
	                    internalData(elem, EVENTS, elemData, true);
	                }
	                var array = eventType.split('.'), actualName = array[0], namespace = array[1] || NO_NAMESPACE;
	                var nsObj = elemData[namespace];
	                if (!nsObj) {
	                    nsObj = elemData[namespace] = {};
	                }
	                var actualListener = function (e) {
	                    if (!isUndefined(data)) {
	                        e.data = data;
	                    }
	                    var returnValue = listener.apply(elem, arguments);
	                    e.result = returnValue;
	                    if (returnValue === false) {
	                        if (e.preventDefault) {
	                            e.preventDefault();
	                            e.stopPropagation();
	                        } else {
	                            e.cancelBubble = false;
	                            e.returnValue = false;
	                        }
	                    }
	                };
	                actualListener.original = listener;
	                var listenerArray = nsObj[actualName];
	                if (!listenerArray) {
	                    listenerArray = nsObj[actualName] = [];
	                }
	                listenerArray.push(actualListener);
	                elem.addEventListener(actualName, actualListener);
	            });
	            return self;
	        },
	       
	        unbind: function (eventType, listener) {
	            var self = this;
	            self.forEach(function (elem) {
	                var array = eventType.split('.'), actualName = array[0], namespace = array[1] || NO_NAMESPACE;
	                var elemData = internalData(elem, EVENTS, keyword_undefined, true);
	                var nsObj = elemData && elemData[namespace], listenerArray, i, length;
	                if (listener) {
	                    if (nsObj && actualName) {
	                        listenerArray = nsObj[actualName];
	                        if (listenerArray) {
	                            for (i = 0, length = listenerArray.length; i < length; i++) {
	                                if (listenerArray[i].original === listener) {
	                                    removeEventListener(elem, actualName, listenerArray[i]);
	                                    listenerArray.splice(i, 1);
	                                    break;
	                                }
	                            }
	                        }
	                    }
	                } else if (nsObj) {
	                    if (actualName) {
	                        listenerArray = nsObj[actualName];
	                        if (listenerArray) {
	                            for (i = 0, length = listenerArray.length; i < length; i++) {
	                                removeEventListener(elem, actualName, listenerArray[i]);
	                            }
	                        }
	                        nsObj[actualName] = keyword_undefined;
	                    } else {
	                        for (var ns in nsObj) {
	                            if (hasOwnProperty(nsObj, ns)) {
	                                listenerArray = nsObj[ns];
	                                if (listenerArray) {
	                                    for (i = 0, length = listenerArray.length; i < length; i++) {
	                                        removeEventListener(elem, ns, listenerArray[i]);
	                                    }
	                                }
	                            }
	                        }
	                        elemData[namespace] = keyword_undefined;
	                    }
	                }
	            });
	            return self;
	        },
	       
	        trigger: function (eventType, args) {
	            var self = this;
	            for (var index = 0, count = self.length; index < count; index++) {
	                var elem = self[index];
	                var elemData = internalData(elem, EVENTS, keyword_undefined, true);
	                if (elemData) {
	                    var array = eventType.split('.'), actualName = array[0];
	                    for (var ns in elemData) {
	                        if (hasOwnProperty(elemData, ns)) {
	                            var nsObj = elemData[ns];
	                            var listenerArray = nsObj && nsObj[actualName];
	                            if (listenerArray) {
	                                for (var i = 0, length = listenerArray.length; i < length; i++) {
	                                    listenerArray[i].apply(elem, [{'type': actualName}, args]);
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            return self;
	        },
	       
	        css: function (cssName, cssValue) {
	            var self = this;
	            var elements = self, argumentsLength = arguments.length;
	
	            function applyStyle(name, value) {
	                elements.forEach(function (elem) {
	                    elem.style[name] = fixCssValue(name, value);
	                });
	            }
	
	            if (argumentsLength === 1) {
	                if (isObject(cssName)) {
	                    elements.forEach(function (value) {
	                        for (var p in cssName) {
	                            if (hasOwnProperty(cssName, p)) {
	                                value.style[p] = fixCssValue(p, cssName[p]);
	                            }
	                        }
	                    });
	                } else {
	                    var firstElem = self[0];
	                    var hooks = cssHooks[cssName];
	                    if (hooks && str_get in hooks) {
	                        return hooks.get(firstElem);
	                    }
	                    var style = getComputedStyle(firstElem);
	                    return style && style[cssName];
	                }
	            } else if (argumentsLength === 2) {
	                if (Array.isArray(cssName) && Array.isArray(cssValue) && cssName.length === cssValue.length) {
	                    cssName.forEach(function (value, index) {  
	                        applyStyle(value, cssValue[index]);
	                    });
	                } else {                                         
	                    applyStyle(cssName, cssValue);
	                }
	            }
	            return self;
	        },
	       
	        width: defineWidthHeight(true),
	       
	        height: defineWidthHeight(),
	       
	        innerWidth: defineInnerWidthInnerHeight(true),
	       
	        innerHeight: defineInnerWidthInnerHeight(),
	       
	        outerWidth: defineOuterWidthOuterHeight(true),
	       
	        outerHeight: defineOuterWidthOuterHeight(),
	       
	        append: function (child) {
	            var children = [child];
	            if (child instanceof $) {
	                children = child.getAll();
	            }
	            var self = this, parentElement = self[0];
	            children.forEach(function (el) {
	                if (el) {
	                    parentElement.appendChild(el);
	                }
	            });
	            return self;
	        },
	       
	        appendTo: function (parent) {
	            var parentElement = parent;
	            if (parent instanceof $) {
	                parentElement = parent[0];
	            }
	            var self = this;
	            self.forEach(function (value) {
	                parentElement.appendChild(value);
	            });
	            return self;
	        },
	       
	        prepend: function (element) {
	            var self = this, parentElement = self[0];
	            parentElement.insertBefore(element, parentElement.firstChild);
	            return self;
	        },
	       
	        insertBefore: function (element) {
	            var self = this, parentElement = element.parentElement;
	            self.forEach(function (value) {
	                parentElement.insertBefore(value, element);
	            });
	            return self;
	        },
	       
	        addClass: function (className) {
	            var classes, elem, cur, clazz, j, i = 0, elements = this, len = elements.length, core_rnotwhite = /\S+/g,
	                rclass = /[\t\r\n]/g;
	            classes = (className || '').match(core_rnotwhite) || [];
	            for (; i < len; i++) {
	                elem = elements[i];
	                cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : ' ');
	                if (cur) {
	                    j = 0;
	                    while ((clazz = classes[j++])) {
	                        if (cur.indexOf(' ' + clazz + ' ') < 0) {
	                            cur += clazz + ' ';
	                        }
	                    }
	                    elem.className = $.trim(cur);
	                }
	            }
	            return this;
	        },
	       
	        removeClass: function (className) {
	            var classes, elem, cur, clazz, j, i = 0, elements = this, len = elements.length, core_rnotwhite = /\S+/g,
	                rclass = /[\t\r\n]/g;
	            classes = (className || '').match(core_rnotwhite) || [];
	            for (; i < len; i++) {
	                elem = elements[i];
	               
	                cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : '');
	                if (cur) {
	                    j = 0;
	                    while ((clazz = classes[j++])) {
	                        while (cur.indexOf(' ' + clazz + ' ') >= 0) {
	                            cur = cur.replace(' ' + clazz + ' ', ' ');
	                        }
	                    }
	                    elem.className = className ? $.trim(cur) : '';
	                }
	            }
	            return this;
	        },
	       
	        hasClass: function (className) {
	            var i = 0, elements = this, l = elements.length, rclass = /[\t\r\n]/g;
	            className = ' ' + className + ' ';
	            for (; i < l; i++) {
	                var el = elements[i];
	                if (el.nodeType === 1 && (' ' + el.className + ' ').replace(rclass, ' ').indexOf(className) >= 0) {
	                    return true;
	                }
	            }
	            return false;
	        },
	       
	        toggle: function () {
	            var self = this;
	            var firstElement = self[0];
	            if (firstElement.style[css_display] === css_none) {
	                self.show();
	            } else {
	                self.hide();
	            }
	            return self;
	        },
	       
	        show: defineShowHide(true),
	       
	        hide: defineShowHide(),
	       
	        attr: function (attrName, attrValue) {
	            var self = this, elements = self, argumentsLength = arguments.length;
	            if (argumentsLength === 1) {
	                if (isObject(attrName)) {
	                    elements.forEach(function (value) {
	                        for (var p in attrName) {
	                            if (hasOwnProperty(attrName, p)) {
	                                value.setAttribute(p, attrName[p]);
	                            }
	                        }
	                    });
	                } else {
	                    return self[0].getAttribute(attrName);
	                }
	            } else if (argumentsLength === 2) {
	                elements.forEach(function (value) {
	                    value.setAttribute(attrName, attrValue);
	                });
	            }
	            return self;
	        },
	       
	        removeAttr: function (name) {
	            this.forEach(function (value) {
	                value.removeAttribute(name);
	            });
	            return this;
	        },
	       
	        prop: function (propName, propValue) {
	            var self = this, elements = self, argumentsLength = arguments.length;
	            if (argumentsLength === 1) {
	                if (isObject(propName)) {
	                    elements.forEach(function (value) {
	                        for (var p in propName) {
	                            if (hasOwnProperty(propName, p)) {
	                                internalProp(value, p, propName[p]);
	                            }
	                        }
	                    });
	                } else {
	                    return internalProp(self[0], propName);
	                }
	            } else if (argumentsLength === 2) {
	                elements.forEach(function (value) {
	                    internalProp(value, propName, propValue);
	                });
	            }
	            return self;
	        },
	       
	        removeProp: function (propName) {
	            propName = propFix[propName] || propName;
	            var self = this, elements = self;
	            elements.forEach(function (value) {
	                try {
	                    value[propName] = keyword_undefined;
	                    delete value[propName];
	                } catch (e) {
	                   
	                }
	            });
	            return self;
	        },
	       
	        text: function (text) {
	            var self = this, elements = self;
	            if (arguments.length === 0) {
	                return self[0].textContent;
	            }
	
	            elements.forEach(function (value) {
	                value.textContent = text;
	            });
	            return self;
	        },
	       
	        val: function (value) {
	            var self = this, hooks;
	            if (!arguments.length) {
	                var firstElem = self[0], ret;
	                if (firstElem) {
	                    hooks = valHooks[firstElem.type] || valHooks[firstElem.nodeName.toLowerCase()];
	                    if (hooks && str_get in hooks) {
	                        ret = hooks.get(firstElem, 'value');
	                        if (!isUndefined(ret)) {
	                            return ret;
	                        }
	                    }
	                    ret = firstElem.value;
	                    if (isString(ret)) {
	                        return ret.replace(/\r/g, '');
	                    }
	                    return ret === keyword_null || ret === keyword_undefined ? '' : ret;
	                }
	                return;
	            }
	            var isFunction = $.isFunction(value);
	            self.forEach(function (elem, i) {
	                var val;
	                if (elem.nodeType !== 1) {
	                    return;
	                }
	                if (isFunction) {
	                    val = value.call(elem, i, $(elem).val());
	                } else {
	                    val = value;
	                }
	               
	                if (val === keyword_null || val === keyword_undefined) {
	                    val = '';
	                } else if (typeof val === 'number') {
	                    val += '';
	                } else if ($.isArray(val)) {
	                    val = $.map(val, function (item) {
	                        return item === keyword_null || item === keyword_undefined ? '' : item + '';
	                    });
	                }
	                hooks = valHooks[elem.type] || valHooks[elem.nodeName.toLowerCase()];
	               
	                if (!hooks || !(str_set in hooks) || isUndefined(hooks.set(elem, val, 'value'))) {
	                    elem.value = val;
	                }
	            });
	            return self;
	        },
	       
	        position: function () {
	            var elem = this[0];
	            if (!elem) {
	                return;
	            }
	            var offset, parentOffset = {top: 0, left: 0};
	           
	            if ($(elem).css(css_position) === 'fixed') {
	               
	                offset = elem.getBoundingClientRect();
	            } else {
	               
	                var offsetParent = this.offsetParent();
	               
	                offset = this.offset();
	                var firstOffsetParent = offsetParent[0];
	                if (!getNodeName(firstOffsetParent, 'html')) {
	                    parentOffset = offsetParent.offset();
	                    parentOffset.left -= firstOffsetParent.scrollLeft;
	                    parentOffset.top -= firstOffsetParent.scrollTop;
	                }
	               
	                parentOffset.top += convertToFloat($(firstOffsetParent).css('borderTopWidth'));
	                parentOffset.left += convertToFloat($(firstOffsetParent).css('borderLeftWidth'));
	            }
	           
	           
	           
	            return {
	                top: offset.top - parentOffset.top - convertToFloat($(elem).css('marginTop')),
	                left: offset.left - parentOffset.left - convertToFloat($(elem).css('marginLeft'))
	            };
	        },
	       
	        offsetParent: function () {
	            var array = $.map(this, function (element) {
	                var documentElement = DOCUMENT.documentElement;
	                var offsetParent = element.offsetParent || documentElement;
	                while (offsetParent && (!getNodeName(offsetParent, 'html') && $(offsetParent).css(css_position) === 'static')) {
	                    offsetParent = offsetParent.offsetParent;
	                }
	                return offsetParent || documentElement;
	            });
	            return $(array);
	        },
	       
	        offset: function () {
	            var docElem, win, box = {top: 0, left: 0}, elem = this[0], ownerDocument = elem && elem.ownerDocument;
	            if (!ownerDocument) {
	                return;
	            }
	            docElem = ownerDocument.documentElement;
	           
	           
	           
	           
	           
	           
	            if (!isUndefined(elem.getBoundingClientRect)) {
	                box = elem.getBoundingClientRect();
	            }
	            win = getWindow(ownerDocument);
	            return {
	                top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
	                left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
	            };
	        },
	       
	        scrollLeft: defineScrollLeftScrollTop(true),
	       
	        scrollTop: defineScrollLeftScrollTop(),
	       
	        html: function (html) {
	            var self = this, elements = self;
	            if (arguments.length === 0) {
	                return self[0].innerHTML;
	            }
	
	            elements.forEach(function (value) {
	                value.innerHTML = html;
	            });
	            return self;
	        },
	       
	        remove: function () {
	            var elements = this;
	            elements.forEach(function (value) {
	                var parent = value.parentElement;
	                if (parent) {
	                    parent.removeChild(value);
	                    cleanData([value]);
	                }
	            });
	        },
	       
	        empty: function () {
	            this.forEach(function (value) {
	                $(value.children).remove();
	            });
	            return this;
	        },
	       
	        find: function (selectors) {
	            var allList = [];
	            if (isString(selectors)) {
	                this.forEach(function (value) {
	                    var list = value.querySelectorAll(selectors);
	                    $.merge(allList, list);
	                });
	            }
	            return $(allList);
	        },
	       
	        parent: function () {
	            var list = [];
	            this.forEach(function (value) {
	                var parentElement = value.parentElement;
	                if (parentElement) {
	                    list.push(parentElement);
	                }
	            });
	            return $(list);
	        },
	       
	        index: function (elem) {
	           
	            var first = this[0];
	            if (!elem) {
	                return first && first.parentElement ? $.inArray(first, first.parentElement.children) : -1;
	            }
	           
	            if (isString(elem)) {
	                return $.inArray(first, $(elem).getAll());
	            }
	           
	            return $.inArray(elem, this);
	        },
	       
	        focus: function () {
	            var self = this, firstElement = self[0];
	            if (firstElement !== DOCUMENT.activeElement && firstElement.focus) {
	                firstElement.focus();
	            }
	            return self;
	        },
	       
	        isVisible: function () {
	            var visibleElementCount = 0;
	            this.forEach(function (elem) {
	                var style = getComputedStyle(elem);
	                if (style[css_visibility] !== css_hidden && style[css_display] !== css_none) {
	                    visibleElementCount++;
	                }
	            });
	            return visibleElementCount > 0;
	        },
	       
	        data: function (name, data) {
	            var returnValue = this;
	            var isGet = isUndefined(data);
	            if (isGet) {
	                returnValue = void 0;
	            }
	            $.each(this, function (index, elem) {
	                var result = internalData(elem, name, data);
	                if (isGet) {
	                    returnValue = result;
	                    return false;
	                }
	            });
	            return returnValue;
	        },
	       
	        removeData: function (name) {
	            $.each(this, function (index, elem) {
	                internalRemoveData(elem, name);
	            });
	            return this;
	        }
	    };
	    var init_prototype = init.prototype = [];
	    Types._extend(init_prototype, prototypeEx);
	    $.prototype = init_prototype;
	   
	    $.each = Types._each;
	    $.isEmptyObject = Types._isEmptyObject;
	    $.isFunction = Types._isFunction;
	    $.isArray = Types._isArray;
	    $.isNumeric = Types._isNumeric;
	    $.getType = Types._getType;
	    $.inArray = Types._inArray;
	    $.merge = Types._merge;
	    $.map = Types._map;
	    $.extend = Types._extend;
	    $.inherit = Types._inherit;
	    $.isPlainObject = Types._isPlainObject;
	    $.isArraylike = Types._isArraylike;
	    $.isWindow = Types._isWindow;
	    $.makeArray = Types._makeArray;
	    $.trim = function (text) {
	        if (text.trim) {
	            return text.trim();
	        }
	
	        var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
	        return text === keyword_null || text === keyword_undefined ? '' : (text + '').replace(rtrim, '');
	    };
	    $._createElement = function (tag, cssName, cssValue, cssClass, parentElement) {
	        var element = $(DOCUMENT.createElement(tag));
	        if (cssName && cssValue) {
	            element.css(cssName, cssValue);
	        }
	        if (cssClass) {
	            element.addClass(cssClass);
	        }
	        if (parentElement) {
	            if (parentElement instanceof $) {
	                parentElement.append(element);
	            } else {
	                $(parentElement).append(element);
	            }
	        }
	        return element;
	    };
	
	    function getWindow(elem) {
	        if ($.isWindow(elem)) {
	            return elem;
	        }
	        return elem.nodeType === 9 ? elem.defaultView || elem.parentWindow : false;
	    }
	
	    function getNodeName(elem, name) {
	        var nodeName = elem.nodeName;
	        return nodeName && nodeName.toLowerCase() === name.toLowerCase();
	    }
	
	    function fixCssValue(cssName, cssValue) {
	        if ('top left right bottom width height border-radius border-width border-left-width border-right-width border-top-width border-bottom-width line-height padding padding-left padding-right padding-top padding-bottom margin margin-left margin-right margin-top margin-bottom'.split(' ').indexOf(cssName) >= 0 && isFinite(cssValue)) {
	            if ('width height'.split(' ').indexOf(cssName) >= 0 && cssValue < 0) {
	                cssValue = 0;
	            }
	            return cssValue + 'px';
	        }
	        return cssValue;
	    }
	
	    function internalProp(elem, name, value) {
	        var ret, hooks, notxml, nType = elem.nodeType;
	       
	        if (!elem || nType === 3 || nType === 8 || nType === 2) {
	            return;
	        }
	        notxml = nType !== 1;
	        if (notxml) {
	           
	            name = propFix[name] || name;
	            hooks = propHooks[name];
	        }
	        if (!isUndefined(value)) {
	            if (hooks && str_set in hooks) {
	                ret = hooks.set(elem, value, name);
	                if (!isUndefined(ret)) {
	                    return ret;
	                }
	            }
	            elem[name] = value;
	            return value;
	        }
	
	        if (hooks && str_get in hooks && (ret = hooks.get(elem, name)) !== keyword_null) {
	            return ret;
	        }
	        return elem[name];
	    }
	
	    function acceptData(elem) {
	       
	        var nodeType = elem.nodeType;
	        if (nodeType && nodeType !== 1 && nodeType !== 9) {
	            return false;
	        }
	        var noDataDict = {
	            'embed': true,
	           
	            'object': 'clsid:D27CDB6E-AE6D-11cf-96B8-444553540000',
	            'applet': true
	        };
	        var nodeName = elem.nodeName;
	        var noData = nodeName && noDataDict[nodeName.toLowerCase()];
	       
	        return !noData || noData !== true && elem.getAttribute('classid') === noData;
	    }
	
	    function camelCase(str) {
	        return str.replace(/^-ms-/, 'ms-').replace(/-([\da-z])/gi, function (all, letter) {
	            return letter.toUpperCase();
	        });
	    }
	
	    function internalData(elem, name, data, pvt) {
	        if (!acceptData(elem)) {
	            return;
	        }
	        var thisCache, ret, internalKey = expando, getByName = isString(name),
	           
	           
	            isNode = elem.nodeType,
	           
	           
	            cache = isNode ? globalCache : elem,
	           
	           
	            id = isNode ? elem[internalKey] : elem[internalKey] && internalKey;
	       
	       
	        if ((!id || !cache[id] || !pvt && !cache[id].data) && getByName && isUndefined(data)) {
	            return;
	        }
	        if (!id) {
	           
	           
	            if (isNode) {
	                elem[internalKey] = id = guid++;
	            } else {
	                id = internalKey;
	            }
	        }
	        if (!cache[id]) {
	            cache[id] = {};
	           
	           
	            if (!isNode) {
	                cache[id].toJSON = function () {
	                   
	                };
	            }
	        }
	       
	       
	        if (isObject(name) || typeof name === 'function') {
	            if (pvt) {
	                cache[id] = $.extend(cache[id], name);
	            } else {
	                cache[id].data = $.extend(cache[id].data, name);
	            }
	        }
	        thisCache = cache[id];
	       
	       
	       
	        if (!pvt) {
	            if (!thisCache.data) {
	                thisCache.data = {};
	            }
	            thisCache = thisCache.data;
	        }
	        if (!isUndefined(data)) {
	            thisCache[camelCase(name)] = data;
	        }
	       
	       
	        if (getByName) {
	           
	            ret = thisCache[name];
	           
	            if (ret === keyword_null || ret === keyword_undefined) {
	               
	                ret = thisCache[camelCase(name)];
	            }
	        } else {
	            ret = thisCache;
	        }
	        return ret;
	    }
	
	    function isEmptyDataObject(obj) {
	        var name;
	        for (name in obj) {
	           
	            if (name === 'data' && $.isEmptyObject(obj[name])) {
	                continue;
	            }
	            if (name !== 'toJSON') {
	                return false;
	            }
	        }
	        return true;
	    }
	    function internalRemoveData(elem, name, pvt) {
	        if (!acceptData(elem)) {
	            return;
	        }
	        var i, l, thisCache, isNode = elem.nodeType,
	           
	            cache = isNode ? globalCache : elem, id = isNode ? elem[expando] : expando;
	       
	       
	        if (!cache[id]) {
	            return;
	        }
	        if (name) {
	            thisCache = pvt ? cache[id] : cache[id].data;
	            if (thisCache) {
	               
	                if (!$.isArray(name)) {
	                   
	                    if (name in thisCache) {
	                        name = [name];
	                    } else {
	                       
	                        name = camelCase(name);
	                        if (name in thisCache) {
	                            name = [name];
	                        } else {
	                            name = name.split(' ');
	                        }
	                    }
	                } else {
	                   
	                   
	                   
	                   
	                   
	                   
	                    name = name.concat($.map(name, camelCase));
	                }
	                for (i = 0, l = name.length; i < l; i++) {
	                    delete thisCache[name[i]];
	                }
	               
	               
	                if (!(pvt ? isEmptyDataObject : $.isEmptyObject)(thisCache)) {
	                    return;
	                }
	            }
	        }
	       
	        if (!pvt) {
	            delete cache[id].data;
	           
	           
	            if (!isEmptyDataObject(cache[id])) {
	                return;
	            }
	        }
	       
	        if (isNode) {
	            cleanData([elem], true);
	        } else if (cache !== cache.window) {
	            delete cache[id];
	        } else {
	            cache[id] = keyword_null;
	        }
	    }
	
	    function cleanData(elems,  canAcceptData) {
	        var elem, id, data, i = 0, internalKey = expando, cache = globalCache;
	        for (; (elem = elems[i]) !== keyword_null && elem !== undefined; i++) {
	            if (canAcceptData || acceptData(elem)) {
	                id = elem[internalKey];
	                data = id && cache[id];
	                if (data) {
	                    var events = data.events;
	                    if (events) {
	                        for (var ns in events) {
	                            if (hasOwnProperty(events, ns)) {
	                                var nsObj = events[ns];
	                                if (nsObj) {
	                                    for (var eventName in nsObj) {
	                                        if (hasOwnProperty(nsObj, eventName)) {
	                                            var listenerArray = nsObj[eventName];
	                                            if (listenerArray) {
	                                                for (var index = 0, length = listenerArray.length; index < length; index++) {
	                                                    removeEventListener(elem, ns, listenerArray[index]);
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                   
	                    if (cache[id]) {
	                        delete cache[id];
	                        delete elem[internalKey];
	                    }
	                }
	            }
	        }
	    }
	
	    function isString(v) {
	        return typeof v === 'string';
	    }
	
	    function isObject(v) {
	        return typeof v === 'object';
	    }
	
	    function isUndefined(v) {
	        return typeof v === typeof keyword_undefined;
	    }
	
	    function defineWidthHeight(needWidth) {
	        var isWidth = needWidth;
	        return function (value) {
	            var self = this, isBorderBox = self.css('box-sizing') === 'border-box', size;
	            var prop = isWidth ? str_width : str_height;
	            var leftOrTop = isWidth ? str_left : str_top, rightOrBottom = isWidth ? str_right : str_bottom;
	            if (arguments.length === 0) {
	                size = Math.round(convertToFloat(self.css(prop))) || 0;
	                if (isBorderBox) {
	                    size -= convertToFloat(self.css('padding-' + leftOrTop)) +
	                        convertToFloat(self.css('padding-' + rightOrBottom)) +
	                        convertToFloat(self.css('border-' + leftOrTop + '-' + str_width)) +
	                        convertToFloat(self.css('border-' + rightOrBottom + '-' + str_width));
	                }
	                return size;
	            }
	
	            self.css(prop, value);
	            return self;
	        };
	    }
	
	    function defineInnerWidthInnerHeight(isInnerWidth) {
	        var isWidth = isInnerWidth;
	        return function () {
	            var self = this;
	            var leftOrTop = isWidth ? str_left : str_top, rightOrBottom = isWidth ? str_right : str_bottom;
	            return isWidth ? self.width() : self.height() + convertToFloat(self.css('padding-' + leftOrTop)) + convertToFloat(self.css('padding-' + rightOrBottom));
	        };
	    }
	
	    function defineOuterWidthOuterHeight(isOuterWidth) {
	        var isWidth = isOuterWidth;
	        return function (includeMargin) {
	            var leftOrTop = isWidth ? str_left : str_top, rightOrBottom = isWidth ? str_right : str_bottom;
	            var self = this, size = isWidth ? self.innerWidth() : self.innerHeight();
	            size += convertToFloat(self.css('border-' + leftOrTop + '-' + str_width)) + convertToFloat(self.css('border-' + rightOrBottom + '-' + str_width));
	            if (includeMargin) {
	                size += convertToFloat(self.css('margin-' + leftOrTop)) + convertToFloat(self.css('margin-' + rightOrBottom));
	            }
	            return size;
	        };
	    }
	
	    function defineShowHide(needShow) {
	        var isShow = needShow;
	        return function (callback) {
	            this.forEach(function (elem) {
	                elem.style[css_display] = isShow ? css_block : css_none;
	                if (callback) {
	                    callback.apply(elem);
	                }
	            });
	            return this;
	        };
	    }
	
	    function defineScrollLeftScrollTop(needScrollLeft) {
	        var isScrollLeft = needScrollLeft;
	        return function (value) {
	            var SCROLL_LEFT = 'scrollLeft', SCROLL_TOP = 'scrollTop';
	            var PROP = isScrollLeft ? SCROLL_LEFT : SCROLL_TOP;
	            var PAGE_OFFSET = isScrollLeft ? 'pageXOffset' : 'pageYOffset';
	            var self = this, elem = self[0];
	            var win = getWindow(elem);
	            if (isUndefined(value)) {
	                if (win) {
	                    return (PAGE_OFFSET in win) ? win[PAGE_OFFSET] : DOCUMENT.documentElement[PROP];
	                }
	                return elem[PROP];
	            }
	            if (win) {
	                win.scrollTo(isScrollLeft ? value : $(win)[SCROLL_LEFT](), isScrollLeft ? $(win)[SCROLL_TOP]() : value);
	            } else {
	                elem[PROP] = value;
	            }
	            return self;
	        };
	    }
	
	    function removeEventListener(elem, type, listener) {
	        elem.removeEventListener(type, listener);
	    }
	
	   
	    var exports = __webpack_require__(1);
	    exports.GC$ = $;
	    module.exports = exports;
	
	}());

/***/ }),
/* 5 */
/***/ (function(module, exports) {

	module.exports = GC.Spread.Common;

/***/ }),
/* 6 */
/***/ (function(module, exports) {

	module.exports = GC.Spread.Formatter;

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	(function() {
	    'use strict';
	
	    
	    
	    module.exports = {
	        _pri: function () {
	        },
	        _pt: 0
	    };
	
	}());

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var exports = __webpack_require__(1);
	    var $ = __webpack_require__(4).GC$;
	    var util_common = __webpack_require__(3);
	    var createElement = util_common._util._createElement;
	    var util_common_util = util_common._util;
	    var browser = util_common_util._browser;
	    var cancelDefault = util_common_util._cancelDefault;
	    var gcGlobal = window._gcGlobal;
	    var DOCUMENT = document;
	
	    var BaseDialog = (function () {
	       
	        function BaseDialog(host, zindex, isModal) {
	            var self = this;
	            self._host = host;
	            self._isModal = isModal;
	            self._gcPopupClass = 'gc-popup';
	            self._overlayClass = 'gc-overlay';
	            self._overlay = null;
	            zindex = zindex || 0;
	            self._defaultOverlayCSS = {
	                position: 'fixed',
	                width: '100%',
	                height: '100%',
	                margin: 0,
	                padding: 0,
	                top: 0,
	                left: 0,
	                border: 'none',
	                zIndex: zindex,
	                backgroundColor: 'rgba(0,0,0,0)'
	            };
	            self._defaultContainerCSS = {
	                position: 'absolute',
	                padding: 0,
	                margin: 0,
	                height: 'auto',
	                zIndex: zindex + 1,
	                outline: 'none'
	            };
	            self._init();
	        }
	
	        BaseDialog.prototype = {
	            constructor: BaseDialog,
	            _init: function () {
	                var self = this;
	                if (!self._hasTargetContainer(self._name)) {
	                    self._name = self._generateName();
	                    self._container = $(createElement('div')).addClass(self._gcPopupClass + ' ui-widget').attr({
	                        'id': self._name,
	                        'tabIndex': -1
	                    }).css(self._defaultContainerCSS);
	                } else {
	                    self._container = $('#' + self._name);
	                }
	            },
	            _generateName: function () {
	                var num = 0;
	                var prefix = 'gc-dialog';
	                while (this._hasTargetContainer(prefix + num.toString())) {
	                    num++;
	                }
	                return prefix + num.toString();
	            },
	            _getContainer: function () {
	                if (this._container) {
	                    return this._container;
	                }
	            },
	            _getHost: function () {
	                if (this._host) {
	                    return this._host;
	                }
	                return DOCUMENT.body;
	            },
	            _show: function (callback) {
	                var self = this, container = self._container;
	                if (!self._hasOverlay()) {
	                    self._createOverlay();
	                }
	                gcGlobal._suspendEvent();
	                if (!self._hasTargetContainer(self._name)) {
	                    $(self._getHost()).append(container);
	                    self._resetDialogPosition();
	                    container.css('display', 'none');
	                }
	                container.show(callback);
	            },
	            close: function () {
	                var self = this;
	                if (self._hasTargetContainer(self._name)) {
	                    self._container.remove();
	                }
	                if (!$('.' + self._gcPopupClass).isVisible()) {
	                    self._closeOverlay();
	                }
	                gcGlobal._resumeEvent();
	            },
	            _closeOverlay: function () {
	                $('.' + this._overlayClass).remove();
	                this._overlay = null;
	            },
	           
	            _resetDialogPosition: function () {
	                var container = this._container, host = this._getHost();
	                if (container.length === 0) {
	                    return;
	                }
	                var hostOffset = $(host).offset();
	                var left = parseInt(container.css('left')) + hostOffset.left;
	                var top = parseInt(container.css('top')) + hostOffset.top;
	                var dialogWidth = container.width();
	                var dialogHeight = container.height();
	                if (isNaN(left) || isNaN(top) || isNaN(dialogWidth) || isNaN(dialogHeight)) {
	                    return;
	                }
	                var bottomCross = 0, rightCross = 0;
	                var docElement = DOCUMENT.documentElement;
	                var clientWidth = docElement.clientWidth;
	                var clientHeight = docElement.clientHeight;
	                var pos = container[0].getBoundingClientRect();
	                if (pos.left + dialogWidth > clientWidth) {
	                    rightCross = pos.left + dialogWidth - clientWidth;
	                }
	                if (pos.top + dialogHeight > clientHeight) {
	                    bottomCross = pos.top + dialogHeight - clientHeight;
	                }
	                if (left < 0 || top < 0 || bottomCross > 0 || rightCross > 0) {
	                    left -= rightCross;
	                    top -= bottomCross;
	                    if (left < 0) {
	                        left = 0;
	                    }
	                    if (top < 0) {
	                        top = 0;
	                    }
	                    container.css({left: (left - hostOffset.left) + 'px', top: (top - hostOffset.top) + 'px'});
	                }
	            },
	            _hasTargetContainer: function (target) {
	                return $('#' + target).length > 0;
	
	            },
	            _createOverlay: function () {
	                var self = this;
	                var overlay = $(createElement('div')).addClass(self._overlayClass), container = self._container;
	                this._overlay = overlay;
	                overlay.css(self._defaultOverlayCSS);
	                $(self._host).append(overlay);
	                var isFirefox = browser && browser.mozilla;
	               
	                if (isFirefox) {
	                    var openTime = new Date().valueOf();
	                }
	                overlay.bind('mousedown', function (e) {
	                    if(!self._isModal) {
	                       
	                       
	                        if (isFirefox) {
	                            var closeTime = new Date().valueOf();
	                            if (closeTime - openTime < 100) {
	                                return;
	                            }
	                        }
	                        self.close();
	                       
	                        if (isFirefox && self._delayCloseTimeout) {
	                            clearTimeout(self._delayCloseTimeout);
	                        }
	                    }
	                    cancelDefault(e);
	                });
	                overlay.bind("contextmenu", function (e) {
	                    if(self._isModal) {
	                        cancelDefault(e);
	                    }
	                });
	                container.bind("contextmenu", function (e) {
	                    cancelDefault(e);
	                });
	                'touchstart MSPointerDown pointerdown'.split(' ').forEach(function (value) {
	                    overlay.bind(value, function (e) {
	                        if(!self._isModal) {
	                           
	                           
	                            if (isFirefox) {
	                                self._delayCloseTimeout = setTimeout(function () {
	                                    self.close();
	                                }, 100);
	                            } else {
	                                self.close();
	                            }
	                        }
	                        cancelDefault(e);
	                    });
	                });
	            },
	            _hasOverlay: function () {
	                return $('.' + this._overlayClass).length > 0;
	
	            }
	        };
	        return BaseDialog;
	    })();
	
	    exports._BaseDialog = BaseDialog;
	    module.exports = exports;
	
	}());

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	    var $$ = __webpack_require__(4).GC$;
	    var GCSHEET = '.gcSheet';
	
	    function _ImageLoader(loadedCallBack) {
	        var self = this;
	        self._imageCount = 0;
	        self._loadedCount = 0;
	        self._onLoadedComplete = loadedCallBack;
	        self._imgs = {};
	    }
	
	    _ImageLoader.prototype = {
	        _addImage: function (imgUrl) {
	            var self = this;
	
	            function onImageLoaded() {
	                self._imageLoaded(imgUrl);
	            }
	
	            var imgs = self._imgs;
	            var imgObj = imgs[imgUrl];
	            if (!imgObj) {
	                var $img = $$(document.createElement('img'));
	                $img.bind('load' + GCSHEET, onImageLoaded);
	                $img.bind('error' + GCSHEET, onImageLoaded);
	                $img.bind('abort' + GCSHEET, onImageLoaded);
	
	                self._imageCount++;
	                imgs[imgUrl] = {_state: false, _img: $img[0]};
	
	                $img[0].src = imgUrl;
	            }
	        },
	        _getState: function (imgUrl) {
	            var img = this._imgs[imgUrl];
	            return img ? img._state : false;
	        },
	        _getImage: function (imgUrl) {
	            var img = this._imgs[imgUrl];
	            return img ? img._img : null;
	        },
	        _imageLoaded: function (imgUrl) {
	            var self = this;
	            self._loadedCount++;
	            self._imgs[imgUrl]._state = true;
	
	            if (self._isAllImagesLoaded() && self._onLoadedComplete) {
	                self._onLoadedComplete();
	            }
	        },
	        _isAllImagesLoaded: function () {
	            return this._loadedCount >= this._imageCount;
	        },
	        _dispose: function () {
	            var imgs = this._imgs;
	            if (imgs) {
	                for (var imgKey in imgs) {
	                    if (imgs[imgKey]) {
	                        var $img = $$(imgs[imgKey]._img);
	                        $img.unbind(GCSHEET);
	                    }
	                }
	            }
	            this._onLoadedComplete = null;
	        }
	    };
	    var exports = __webpack_require__(1);
	    exports._ImageLoader = _ImageLoader;
	    module.exports = exports;
	
	
	}());

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var Common = __webpack_require__(5);
	    var isNullOrUndefined = Common._Types._isNullOrUndefined;
	    var _ColorHelper = Common._ColorHelper;
	    var parseToColor = _ColorHelper._fromString;
	    var parseIntFn = parseInt;
	    var commonUtil = __webpack_require__(3);
	    var defProperty = commonUtil._util._defProperty;
	
	    function defColorSchemeProperty(index) {
	        var colorIndex = index;
	        return function (value) {
	            if (arguments.length === 0) {
	                return this._colorList[colorIndex];
	            }
	            this._colorList[index] = parseToColor(value);
	
	            return this;
	        };
	    }
	
	    var BACKCOLOR1 = 0, BACKCOLOR2 = 1, TEXTCOLOR1 = 2, TEXTCOLOR2 = 3, ACCENT1 = 4, ACCENT2 = 5, ACCENT3 = 6,
	        ACCENT4 = 7, ACCENT5 = 8, ACCENT6 = 9, HYPERLINK = 10, FHYPERLINK = 11;
	    var ColorScheme = (function () {
	       
	        
	        function ColorScheme(name, background1, background2, text1, text2, accent1, accent2, accent3, accent4, accent5, accent6, link, followedLink) {
	            this._name = name;
	            this._colorList = [];
	            for (var i = 1; i < 13; i++) {
	                this._colorList.push(parseToColor(arguments[i]));
	            }
	        }
	
	
	        ColorScheme.prototype = {
	            constructor: ColorScheme,
	           
	            
	            name: function (value) {
	                if (arguments.length === 0) {
	                    return this._name;
	                }
	                this._name = value;
	                return this;
	            },
	           
	            
	            background1: defColorSchemeProperty(BACKCOLOR1),
	           
	            
	            background2: defColorSchemeProperty(BACKCOLOR2),
	           
	            
	            textColor1: defColorSchemeProperty(TEXTCOLOR1),
	           
	            
	            textColor2: defColorSchemeProperty(TEXTCOLOR2),
	           
	            
	            accent1: defColorSchemeProperty(ACCENT1),
	           
	            
	            accent2: defColorSchemeProperty(ACCENT2),
	           
	            
	            accent3: defColorSchemeProperty(ACCENT3),
	           
	            
	            accent4: defColorSchemeProperty(ACCENT4),
	           
	            
	            accent5: defColorSchemeProperty(ACCENT5),
	           
	            
	            accent6: defColorSchemeProperty(ACCENT6),
	           
	            
	            hyperlink: defColorSchemeProperty(HYPERLINK),
	           
	            
	            followedHyperlink: defColorSchemeProperty(FHYPERLINK),
	           
	            
	            getColor: function (name) {
	                if (name) {
	                   
	                   
	                    var t = name.split(' '), cn;
	                    if (t) {
	                        var index = -1, len = t.length;
	                        if (len > 1) {
	                            if (!t[0]) {
	                                return name;
	                            }
	                            cn = t[0].toLowerCase();
	                            if (cn === 'background') {
	                                index = parseIntFn(t[1], 10) - 1;
	                            } else if (cn === 'text') {
	                                index = parseIntFn(t[1], 10) + 1;
	                            } else if (cn === 'accent') {
	                                index = parseIntFn(t[1], 10) + 3;
	                            }
	                        } else if (len === 1) {
	                            cn = t[0].toLowerCase();
	                            if (cn === 'hyperlink') {
	                                index = HYPERLINK;
	                            } else if (cn === 'followedhyperlink') {
	                                index = FHYPERLINK;
	                            }
	                        }
	                        if (index >= 0 && index <= 11) {
	                            if (len > 2) {
	                                var tint = parseIntFn(t[2], 10) / 100.0;
	                                return _ColorHelper._toString(_ColorHelper._applyTint(this._colorList[index], tint));
	                            }
	                            return _ColorHelper._toString(this._colorList[index]);
	                        }
	                    }
	                }
	                return name;
	            },
	            toJSON: function () {
	                var self = this, colorList = self._colorList;
	                return {
	                    name: self._name,
	                    background1: colorList[BACKCOLOR1],
	                    background2: colorList[BACKCOLOR2],
	                    text1: colorList[TEXTCOLOR1],
	                    text2: colorList[TEXTCOLOR2],
	                    accent1: colorList[ACCENT1],
	                    accent2: colorList[ACCENT2],
	                    accent3: colorList[ACCENT3],
	                    accent4: colorList[ACCENT4],
	                    accent5: colorList[ACCENT5],
	                    accent6: colorList[ACCENT6],
	                    hyperlink: colorList[HYPERLINK],
	                    followedHyperlink: colorList[FHYPERLINK]
	                };
	            },
	            fromJSON: function (jsonData, noSchema) {
	                if (!jsonData) {
	                    return;
	                }
	               
	               
	               
	               
	               
	               
	                var self = this;
	                var COLOR_LIST = '_colorList', NAME = '_name';
	
	                function readColor(colorName, color) {
	                    if (!isNullOrUndefined(color)) {
	                        self._colorList[colorName] = {a: color.a, r: color.r, g: color.g, b: color.b};
	                    }
	                }
	
	                if (noSchema) {
	                    var name = jsonData.name ? jsonData.name : jsonData[NAME];
	                    if (!isNullOrUndefined(name)) {
	                        self._name = name;
	                    }
	                    var colorList = jsonData.colorList ? jsonData.colorList : jsonData[COLOR_LIST];
	                    var background1 = colorList[BACKCOLOR1], background2 = colorList[BACKCOLOR2],
	                        text1 = colorList[TEXTCOLOR1], text2 = colorList[TEXTCOLOR2], accent1 = colorList[ACCENT1],
	                        accent2 = colorList[ACCENT2], accent3 = colorList[ACCENT3], accent4 = colorList[ACCENT4],
	                        accent5 = colorList[ACCENT5], accent6 = colorList[ACCENT6], hyperlink = colorList[HYPERLINK],
	                        followedHyperlink = colorList[FHYPERLINK];
	                } else {
	                    if (!isNullOrUndefined(jsonData.name)) {
	                        self._name = jsonData.name;
	                    }
	                    background1 = jsonData.background1;
	                    background2 = jsonData.background2;
	                    text1 = jsonData.text1;
	                    text2 = jsonData.text2;
	                    accent1 = jsonData.accent1;
	                    accent2 = jsonData.accent2;
	                    accent3 = jsonData.accent3;
	                    accent4 = jsonData.accent4;
	                    accent5 = jsonData.accent5;
	                    accent6 = jsonData.accent6;
	                    hyperlink = jsonData.hyperlink;
	                    followedHyperlink = jsonData.followedHyperlink;
	                }
	                readColor(BACKCOLOR1, background1);
	                readColor(BACKCOLOR2, background2);
	                readColor(TEXTCOLOR1, text1);
	                readColor(TEXTCOLOR2, text2);
	                readColor(ACCENT1, accent1);
	                readColor(ACCENT2, accent2);
	                readColor(ACCENT3, accent3);
	                readColor(ACCENT4, accent4);
	                readColor(ACCENT5, accent5);
	                readColor(ACCENT6, accent6);
	                readColor(HYPERLINK, hyperlink);
	                readColor(FHYPERLINK, followedHyperlink);
	            },
	            _compare: function (themeColor) {
	                if (this.name() !== themeColor.name()) {
	                    return false;
	                }
	                var comProps = ["textColor1", "textColor2", "background1", "background2", "accent1", "accent2", "accent3", "accent4", "accent5", "accent6", "hyperlink", "followedHyperlink"];
	                for (var i = 0, length = comProps.length; i < length; i++) {
	                    var prop = comProps[i];
	                    if (!_ColorHelper._equal(this[prop](), themeColor[prop]())) {
	                        return false;
	                    }
	                }
	                return true;
	
	            }
	        };
	        return ColorScheme;
	    })();
	
	    var Theme = (function () {
	       
	        
	        function Theme(name, colorScheme, headerFont, bodyFont) {
	            var self = this;
	            self.name(name);
	            self.colors(colorScheme ? colorScheme : new ColorScheme(name));
	            self.headerFont(headerFont);
	            self.bodyFont(bodyFont);
	        }
	
	        Theme.prototype = {
	           
	            
	            name: defProperty('name'),
	           
	            
	            colors: defProperty('colors'),
	           
	            
	            headerFont: defProperty('headerFont'),
	           
	            
	            bodyFont: defProperty('bodyFont'),
	            getColor: function (colorString) {
	                return this.colors().getColor(colorString);
	            },
	            getFont: function (fontString) {
	                if (fontString === 'Body') {
	                    return this.bodyFont();
	                } else if (fontString === 'Headings') {
	                    return this.headerFont();
	                }
	                return fontString;
	            },
	            toJSON: function () {
	                var self = this, name = self.name();
	               
	                if (Theme._isBuiltInTheme(self)) {
	                    return name;
	                }
	                return {
	                    name: name,
	                    themeColor: self.colors() ? self.colors().toJSON() : undefined,
	                    headingFont: self.headerFont(),
	                    bodyFont: self.bodyFont()
	                };
	            }
	        };
	
	        Theme._isBuiltInTheme = function (theme) {
	            var name = theme.name();
	            if (Themes[name]) { 
	                var builtInTheme = Themes[name];
	                return theme.bodyFont() === builtInTheme.bodyFont() &&
	                    theme.headerFont() === builtInTheme.headerFont() &&
	                    theme.colors()._compare(builtInTheme.colors());
	            }
	            return false;
	        };
	        return Theme;
	    })();
	
	   
	    
	    var ThemeColors = (function () {
	        function ThemeColors() {
	        }
	
	        var color000000 = '#000000';
	        var colorFFFFFF = '#FFFFFF';
	       
	        
	        ThemeColors.Default = new ColorScheme('Default', colorFFFFFF, '#EEECE1', color000000, '#1F497D', '#4F81BD', '#C0504D', '#9BBB59', '#8064A2', '#4BACC6', '#F79646', '#0000FF', '#800080');
	       
	        
	        ThemeColors.Office2007 = new ColorScheme('Office2007', colorFFFFFF, '#EEECE1', color000000, '#1F497D', '#4F81BD', '#C0504D', '#9BBB59', '#8064A2', '#4BACC6', '#F79646', '#0000FF', '#800080');
	       
	        
	        ThemeColors.Office = new ColorScheme('Office', colorFFFFFF, '#E7E6E6', color000000, '#44546A', '#5B9BD5', '#ED7D31', '#A5A5A5', '#FFC000', '#4472C4', '#70AD47', '#0563C1', '#954F72');
	       
	        
	        ThemeColors.Apex = new ColorScheme('Apex', colorFFFFFF, '#C9C2D1', color000000, '#69676D', '#CEB966', '#9CB084', '#6BB1C9', '#6585CF', '#7E6BC9', '#A379BB', '#410082', '#932968');
	       
	        
	        ThemeColors.Aspect = new ColorScheme('Aspect', colorFFFFFF, '#E3DED1', color000000, '#323232', '#F07F09', '#9F2936', '#1B587C', '#4E8542', '#604878', '#C19859', '#6B9F25', '#B26B02');
	       
	        
	        ThemeColors.Concourse = new ColorScheme('Concourse', colorFFFFFF, '#DEF5FA', color000000, '#464646', '#2DA2BF', '#DA1F28', '#EB641B', '#39639D', '#474B78', '#7D3C4A', '#FF8119', '#44B9E8');
	       
	        
	        ThemeColors.Civic = new ColorScheme('Civic', colorFFFFFF, '#C5D1D7', color000000, '#646B86', '#D16349', '#CCB400', '#8CADAE', '#8C7B70', '#8FB08C', '#D19049', '#00A3D6', '#694F07');
	       
	        
	        ThemeColors.Oriel = new ColorScheme('Oriel', colorFFFFFF, '#FFF39D', color000000, '#575F6D', '#FE8637', '#7598D9', '#B32C16', '#F5CD2D', '#AEBAD5', '#777C84', '#D2611C', '#3B435B');
	       
	        
	        ThemeColors.Origin = new ColorScheme('Origin', colorFFFFFF, '#DDE9EC', color000000, '#464653', '#727CA3', '#9FB8CD', '#D2DA7A', '#FADA7A', '#B88472', '#8E736A', '#B292CA', '#6B5680');
	       
	        
	        ThemeColors.Paper = new ColorScheme('Paper', colorFFFFFF, '#FEFAC9', color000000, '#444D26', '#A5B592', '#F3A447', '#E7BC29', '#D092A7', '#9C85C0', '#809EC2', '#8E58B6', '#7F6F6F');
	       
	        
	        ThemeColors.Solstice = new ColorScheme('Solstice', colorFFFFFF, '#E7DEC9', color000000, '#4F271C', '#3891A7', '#FEB80A', '#C32D2E', '#84AA33', '#964305', '#475A8D', '#8DC765', '#AA8A14');
	       
	        
	        ThemeColors.Technic = new ColorScheme('Technic', colorFFFFFF, '#D4D2D0', color000000, '#3B3B3B', '#6EA0B0', '#CCAF0A', '#8D89A4', '#748560', '#9E9273', '#7E848D', '#00C8C3', '#A116E0');
	       
	        
	        ThemeColors.Trek = new ColorScheme('Trek', colorFFFFFF, '#FBEEC9', color000000, '#4E3B30', '#F0A22E', '#A5644E', '#B58B80', '#C3986D', '#A19574', '#C17529', '#AD1F1F', '#FFC42F');
	       
	        
	        ThemeColors.Urban = new ColorScheme('Urban', colorFFFFFF, '#DEDEDE', color000000, '#424456', '#53548A', '#438086', '#A04DA3', '#C4652D', '#8B5D3D', '#5C92B5', '#67AFBD', '#C2A874');
	       
	        
	        ThemeColors.Verve = new ColorScheme('Verve', colorFFFFFF, '#D2D2D2', color000000, '#666666', '#FF388C', '#E40059', '#9C007F', '#68007F', '#005BD3', '#00349E', '#17BBFD', '#FF79C2');
	       
	        
	        ThemeColors.Equity = new ColorScheme('Equity', colorFFFFFF, '#E9E5DC', color000000, '#696464', '#D34817', '#9B2D1F', '#A28E6A', '#956251', '#918485', '#855D5D', '#CC9900', '#96A9A9');
	       
	        
	        ThemeColors.Flow = new ColorScheme('Flow', colorFFFFFF, '#DBF5F9', color000000, '#04617B', '#0F6FC6', '#009DD9', '#0BD0D9', '#10CF9B', '#7CCA62', '#A5C249', '#E2D700', '#85DFD0');
	       
	        
	        ThemeColors.Foundry = new ColorScheme('Foundry', colorFFFFFF, '#EAEBDE', color000000, '#676A55', '#72A376', '#B0CCB0', '#A8CDD7', '#C0BEAF', '#CEC597', '#E8B7B7', '#DB5353', '#903638');
	       
	        
	        ThemeColors.Median = new ColorScheme('Median', colorFFFFFF, '#EBDDC3', color000000, '#775F55', '#94B6D2', '#DD8047', '#A5AB81', '#D8B25C', '#7BA79D', '#968C8C', '#F7B615', '#704404');
	       
	        
	        ThemeColors.Metro = new ColorScheme('Metro', colorFFFFFF, '#D6ECFF', color000000, '#4E5B6F', '#7FD13B', '#EA157A', '#FEB80A', '#00ADDC', '#738AC8', '#1AB39F', '#EB8803', '#5F7791');
	       
	        
	        ThemeColors.Module = new ColorScheme('Module', colorFFFFFF, '#D4D4D6', color000000, '#5A6378', '#F0AD00', '#60B5CC', '#E66C7D', '#6BB76D', '#E88651', '#C64847', '#168BBA', '#680000');
	       
	        
	        ThemeColors.Opulent = new ColorScheme('Opulent', colorFFFFFF, '#F4E7ED', color000000, '#B13F9A', '#B83D68', '#AC66BB', '#DE6C36', '#F9B639', '#CF6DA4', '#FA8D3D', '#FFDE66', '#D490C5');
	        return ThemeColors;
	    })();
	
	   
	    
	    var Themes = {
	       
	        
	        Default: new Theme('Default', ThemeColors.Default, 'Cambria', 'Calibri'),
	       
	        
	        Office: new Theme('Office', ThemeColors.Office, 'Calibri Light', 'Calibri'),
	       
	        
	        Office2007: new Theme('Office2007', ThemeColors.Office2007, 'Cambria', 'Calibri'),
	       
	        
	        Apex: new Theme('Apex', ThemeColors.Apex, 'Lucida Sans', 'Book Antiqua'),
	       
	        
	        Aspect: new Theme('Aspect', ThemeColors.Aspect, 'Verdana', 'Verdana'),
	       
	        
	        Concourse: new Theme('Concourse', ThemeColors.Concourse, 'Lucida Sans Unicode', 'Lucida Sans Unicode'),
	       
	        
	        Civic: new Theme('Civic', ThemeColors.Civic, 'Georgia', 'Georgia'),
	       
	        
	        Oriel: new Theme('Oriel', ThemeColors.Oriel, 'Century Schoolbook', 'Century Schoolbook'),
	       
	        
	        Origin: new Theme('Origin', ThemeColors.Origin, 'Bookman Old Style', 'Gill Sans MT'),
	       
	        
	        Paper: new Theme('Paper', ThemeColors.Paper, 'Constantia', 'Constantia'),
	       
	        
	        Solstice: new Theme('Solstice', ThemeColors.Solstice, 'Gill Sans MT', 'Gill Sans MT'),
	       
	        
	        Technic: new Theme('Technic', ThemeColors.Technic, 'Franklin Gothic Book', 'Arial'),
	       
	        
	        Trek: new Theme('Trek', ThemeColors.Trek, 'Franklin Gothic Medium', 'Franklin Gothic Book'),
	       
	        
	        Urban: new Theme('Urban', ThemeColors.Urban, 'Trebuchet MS', 'Georgia'),
	       
	        
	        Verve: new Theme('Verve', ThemeColors.Verve, 'Century Gothic', 'Century Gothic'),
	       
	        
	        Equity: new Theme('Equity', ThemeColors.Equity, 'Franklin Gothic Book', 'Perpetua'),
	       
	        
	        Flow: new Theme('Flow', ThemeColors.Flow, 'Calibri', 'Constantia'),
	       
	        
	        Foundry: new Theme('Foundry', ThemeColors.Foundry, 'Rockwell', 'Rockwell'),
	       
	        
	        Median: new Theme('Median', ThemeColors.Median, 'Tw Cen MT', 'Tw Cen MT'),
	       
	        
	        Metro: new Theme('Metro', ThemeColors.Metro, 'Consolas', 'Corbel'),
	       
	        
	        Module: new Theme('Module', ThemeColors.Module, 'Corbel', 'Corbel'),
	       
	        
	        Opulent: new Theme('Opulent', ThemeColors.Opulent, 'Trebuchet MS', 'Trebuchet MS')
	    };
	
	
	    commonUtil.ColorScheme = ColorScheme;
	    commonUtil.ThemeColors = ThemeColors;
	    commonUtil.Theme = Theme;
	    commonUtil.Themes = Themes;
	    module.exports = commonUtil;
	
	}());

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var exports = __webpack_require__(1);
	    var $ = __webpack_require__(4).GC$;
	    var util_common_util = __webpack_require__(3)._util;
	    
	    var DOCUMENT = document, Math_max = Math.max, keyword_undefined = void 0;
	    
	    var DefaultFontSize = exports._DefaultFontSize = '11pt';
	    
	    function StyleHelper() {
	    
	    }
	    StyleHelper._composeFont = function (font, fontFamily) {
	        return !fontFamily ? font : StyleHelper._normalizeFont(font, fontFamily);
	    };
	    StyleHelper._splitFont = function (font) {
	        if (!font) {
	            return {};
	        }
	    
	        var span = StyleHelper._getMeasureSpan();
	        span.style.font = font;
	        var cssStyle = span.style;
	    
	        return {
	            fontFamily: cssStyle.fontFamily,
	            fontSize: cssStyle.fontSize,
	            fontStyle: cssStyle.fontStyle,
	            fontWeight: cssStyle.fontWeight
	        };
	    };
	    StyleHelper._buildFontString = function (cssStyle) {
	        if (util_common_util._browser.safari) {
	            return cssStyle.font;
	        }
	        var f = '';
	        var normal = 'normal';
	        var defaultFontWeight = '400';
	        var fontStyle = cssStyle.fontStyle, fontVariant = cssStyle.fontVariant, fontWeight = cssStyle.fontWeight, lineHeight = cssStyle.lineHeight;
	        if (fontStyle !== normal) {
	            f = fontStyle;
	        }
	        if (fontVariant !== normal) {
	            f += (f ? ' ' : '') + fontVariant;
	        }
	        if (fontWeight !== normal && fontWeight !== defaultFontWeight) {
	            f += (f ? ' ' : '') + fontWeight;
	        }
	        f += (f ? ' ' : '') + cssStyle.fontSize;
	        if (lineHeight !== normal) {
	            f += '/' + lineHeight;
	        }
	        f += ' ' + cssStyle.fontFamily;
	        return f;
	    };
	    StyleHelper._normalizeFont = function (font, fontFamily) {
	        if (!font && !fontFamily) {
	            return font;
	        }
	        var span;
	        var key;
	        var stringCache;
	        if (font) {
	            key = fontFamily ? font + '+' + fontFamily : font;
	            stringCache = StyleHelper._fontStringCache[key];
	            if (stringCache) {
	                return stringCache;
	            }
	            span = StyleHelper._getMeasureSpan();
	            $(span).css('font', font);
	        } else {
	            key = fontFamily;
	            stringCache = StyleHelper._fontStringCache[key];
	            if (stringCache) {
	                return stringCache;
	            }
	            span = StyleHelper._getMeasureSpan();
	            $(span).css('fontSize', DefaultFontSize);
	        }
	        if (fontFamily) {
	            $(span).css('fontFamily', fontFamily);
	        }
	        var fs = span.currentStyle;
	        var defaultView = DOCUMENT.defaultView;
	        if (defaultView && defaultView.getComputedStyle) {
	            fs = defaultView.getComputedStyle(span, '');
	        }
	        stringCache = StyleHelper._buildFontString(fs);
	        StyleHelper._fontStringCache[key] = stringCache;
	        StyleHelper._fontStringCache[stringCache] = stringCache;
	        return stringCache;
	    };
	    StyleHelper._scaleFont = function (font, factor, minFont, ignoreCache) {
	        var cache = StyleHelper._scaleFontInfoCache[factor], fontInfo;
	        if (!ignoreCache) {
	            if (cache) {
	                fontInfo = cache[font];
	                if (fontInfo) {
	                    return fontInfo;
	                }
	            } else {
	                cache = StyleHelper._scaleFontInfoCache[factor] = {};
	            }
	        }
	        var span = StyleHelper._getMeasureSpan();
	        span.style.font = font;
	       
	        var style = span.currentStyle, docView = DOCUMENT.defaultView;
	        if (docView && docView.getComputedStyle) {
	            style = docView.getComputedStyle(span, '');
	        }
	        var fontSize = style.fontSize;
	        var unit = 'px';
	        if (fontSize.indexOf(unit) !== -1) {
	            var size = Math_max(1, parseFloat(fontSize.replace(unit, '')) * factor);
	            if (minFont && size === 1) {
	                minFont.value = true;
	            }
	            fontSize = size + unit;
	        }
	        var lineHeight = style.lineHeight;
	        if (lineHeight.indexOf(unit) !== -1) {
	            var height = Math_max(1, parseFloat(lineHeight.replace(unit, '')) * factor);
	            lineHeight = height + unit;
	        }
	        if (factor === 1) {
	            fontInfo = {font: font, fontSize: size};
	        } else {
	            span.style.fontSize = fontSize;
	            span.style.lineHeight = lineHeight;
	            fontInfo = {font: span.style.font, fontSize: size};
	        }
	        if (!ignoreCache) {
	            cache[font] = fontInfo;
	        }
	        return fontInfo;
	    };
	    StyleHelper._getMeasureSpan = function () {
	        if (!StyleHelper._measureSpan) {
	            var NEGTIVE_10000_PX = '-10000px';
	            var span = util_common_util._createElement('span'), spanStyle = span.style;
	            spanStyle.visibility = 'hidden';
	            spanStyle.top = NEGTIVE_10000_PX;
	            spanStyle.left = NEGTIVE_10000_PX;
	            spanStyle.lineHeight = 'normal';
	            spanStyle.position = 'absolute';
	            spanStyle.fontWeight = "normal";
	            spanStyle.fontStretch = "normal";
	            spanStyle.fontVariant = "normal";
	            spanStyle.fontStyle = "normal";
	            DOCUMENT.body.insertBefore(span, null);
	            StyleHelper._measureSpan = span;
	            StyleHelper._measureSpanOriginalStyleText = spanStyle.cssText;
	        } else {
	            StyleHelper._measureSpan.style.cssText = StyleHelper._measureSpanOriginalStyleText;
	        }
	        return StyleHelper._measureSpan;
	    };
	    StyleHelper._dispose = function () {
	        var span = StyleHelper._measureSpan;
	        if (span) {
	            $(span).remove();
	            StyleHelper._measureSpan = keyword_undefined;
	            StyleHelper._measureSpanOriginalStyleText = keyword_undefined;
	        }
	    };
	    var stringFontCatch = {};
	    StyleHelper._setStringFont = function (font, fontWeight) {
	        var key = font + ',' + fontWeight;
	        var cache = stringFontCatch;
	        var result = cache[key];
	        if (!result) {
	            var span = StyleHelper._getMeasureSpan();
	            span.style.font = font;
	            if (fontWeight) {
	                span.style.fontWeight = fontWeight;
	            }
	            result = cache[key] = span.style.font;
	        }
	        return result;
	    };
	    StyleHelper._fontStringCache = {};
	    StyleHelper._scaleFontInfoCache = {};
	    StyleHelper._composeTextDecoration = function (value) {
	        if (value <= 0) {
	            return 'none';
	        }
	    
	        var result = '';
	        if ((value | 1 ) === value) {
	            result += 'underline ';
	        }
	        if ((value | 2 ) === value) {
	            result += 'line-through ';
	        }
	        if ((value | 4 ) === value) {
	            result += 'overline ';
	        }
	    
	        return result.trim();
	    };
	    exports._StyleHelper = StyleHelper;
	    
	    module.exports = exports;
	
	}());

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var exports = __webpack_require__(1);
	    var $ = __webpack_require__(4).GC$;
	    var util_common = __webpack_require__(3);
	    var StyleHelper = __webpack_require__(11)._StyleHelper;
	
	    var $_each = $.each;
	    var util_common_util = util_common._util;
	    var isDefined = util_common_util._isDefined;
	
	    var keyword_undefined = void 0, keyword_null = null,
	        AUTO_FORMATTER = 'autoFormatter', FORMATTER = 'formatter', CELLTYPE = 'cellType',
	        HALIGN = 'hAlign', VALIGN = 'vAlign', IME_MODE = 'imeMode', LABEL_OPTIONS = 'labelOptions',
	        SUPPORT_BORDER_DICT = {
	            "borderLeft": true,
	            "borderRight": true,
	            "borderTop": true,
	            "borderBottom": true,
	            "diagonalDown": true,
	            "diagonalUp": true
	        };
	
	   
	   
	    
	    exports.HorizontalAlign = {
	        
	        left: 0,
	        
	        center: 1,
	        
	        right: 2,
	        
	        general: 3
	    };
	
	   
	    
	    exports.VerticalAlign = {
	        
	        top: 0,
	        
	        center: 1,
	        
	        bottom: 2
	    };
	
	   
	    
	    exports.ImageLayout = {
	        
	        stretch: 0,
	        
	        center: 1,
	        
	        zoom: 2,
	        
	        none: 3
	    };
	
	   
	    
	    exports.LineStyle = {
	        
	        empty: 0,
	        
	        thin: 1,
	        
	        medium: 2,
	        
	        dashed: 3,
	        
	        dotted: 4,
	        
	        thick: 5,
	        
	        double: 6,
	        
	        hair: 7,
	        
	        mediumDashed: 8,
	        
	        dashDot: 9,
	        
	        mediumDashDot: 10,
	        
	        dashDotDot: 11,
	        
	        mediumDashDotDot: 12,
	        
	        slantedDashDot: 13
	    };
	
	   
	    
	    exports.TextDecorationType = {
	        
	        underline: 1,
	        
	        lineThrough: 2,
	        
	        overline: 4,
	        
	        doubleUnderline: 8,
	        
	        none: 0
	    };
	
	   
	    
	    exports.VertAlign = {
	        
	        normal: 0,
	        
	        superscript: 1,
	        
	        subscript: 2
	    };
	
	    exports.LineBorderComposeLevel = {
	       
	        conditionalFormat: 1,
	        cell: 10,
	        table: 20,
	        row: 30,
	        column: 40,
	        sheet: 50
	    };
	
	   
	    
	    exports.LabelAlignment = {
	        
	        topLeft: 0,
	        
	        topCenter: 1,
	        
	        topRight: 2,
	        
	        bottomLeft: 3,
	        
	        bottomCenter: 4,
	        
	        bottomRight: 5
	    };
	
	   
	    
	    exports.LabelVisibility = {
	        
	        visible: 0,
	        
	        hidden: 1,
	        
	        auto: 2
	    };
	   
	
	   
	   
	    
	    function LineBorder(color, style, level) {
	       
	        
	        this.color = color || 'black';
	       
	        
	        this.style = style || 0 ;
	        this.level = level;
	    }
	
	    LineBorder.prototype = {
	        constructor: LineBorder,
	        _clone: function () {
	            return new LineBorder(this.color, this.style, this.level);
	        },
	        toJSON: function () {
	            var jsData = {};
	            var self = this, color = self.color, style = self.style;
	            if (color !== 'black') {
	                jsData.color = color;
	            }
	            if (style !== 0 ) {
	                jsData.style = style;
	            }
	            return jsData;
	        },
	        fromJSON: function (jsData) {
	            if (jsData) {
	                var self = this, color = jsData.color, style = jsData.style;
	                if (isDefined(color)) {
	                    self.color = color;
	                }
	                if (isDefined(style)) {
	                    self.style = style;
	                }
	            }
	        }
	    };
	    LineBorder._width = function (border) {
	        var style = border && border.style;
	        var dict = {
	            9 : 1,
	            1 : 1,
	            3 : 1,
	            4 : 1,
	            7 : 1,
	            11 : 1,
	            2 : 2,
	            10 : 2,
	            12 : 2,
	            8 : 2,
	            13 : 2,
	            5 : 3,
	            6 : 3
	        };
	        return dict[style] || 0;
	    };
	    exports.LineBorder = LineBorder;
	   
	
	   
	   
	    var stylePropertyDict = ['backColor', 'foreColor', HALIGN, VALIGN, 'font', 'themeFont', FORMATTER, 'borderLeft',
	        'borderTop', 'borderRight', 'borderBottom', 'locked', 'textIndent', 'wordWrap', 'shrinkToFit', 'backgroundImage',
	        CELLTYPE, 'backgroundImageLayout', 'tabStop', 'textDecoration', IME_MODE, 'name', 'parentName', 'watermark',
	        'cellPadding', LABEL_OPTIONS, 'quotePrefix', 'diagonalDown', 'diagonalUp', 'isVerticalText'];
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	    
	   
	    
	
	   
	    
	
	   
	    
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	    function Style() {
	        var self = this;
	        self._id = Style._styleId++;
	        var args = arguments, i;
	        if (args.length === 0) {
	            return;
	        }
	       
	        for (i = 0; i < stylePropertyDict.length; i++) {
	            self[stylePropertyDict[i]] = args[i];
	        }
	    }
	
	    function _cloneCellType(style, cellType, deepClone, noSchema) {
	        var resultCellType = cellType;
	        if (deepClone && cellType) {
	            var cellTypeInstance = cellType._cloneCellType && cellType._cloneCellType();
	            if (cellTypeInstance) {
	                style.cellType = resultCellType;
	                return;
	            }
	            if (cellType.toJSON) {
	                cellType = cellType.toJSON();
	            }
	            var dict = __webpack_require__(13).CellTypes._typeDict,
	                typeName = cellType.typeName;
	
	           
	           
	            var celltypeClass = dict[cellType.type] || dict[typeName] || util_common.getTypeFromString(typeName);
	            if (celltypeClass) {
	                resultCellType = new celltypeClass();
	                resultCellType.fromJSON(cellType, noSchema);
	            } else {
	                resultCellType = keyword_undefined;
	            }
	        }
	        style.cellType = resultCellType;
	    }
	
	    function _cloneFormatter(style, formatter, deepClone) {
	        var resultFormatter = formatter;
	        if (deepClone && formatter && typeof formatter === 'object') {
	            if (formatter.toJSON) {
	                formatter = formatter.toJSON();
	            }
	            var Formatter_module = __webpack_require__(6);
	            var GeneralFormatter = Formatter_module && Formatter_module.GeneralFormatter;
	            if (GeneralFormatter) {
	               
	                var typeName = formatter.typeName;
	                if (!typeName) {
	                    resultFormatter = new GeneralFormatter(formatter.formatCached, formatter.customerCultureName);
	                } else {
	                    var customFormatterClass = util_common.getTypeFromString(typeName);
	                    if (customFormatterClass) {
	                        resultFormatter = new customFormatterClass();
	                        resultFormatter.fromJSON(formatter);
	                    }
	                }
	            }
	        }
	        style.formatter = resultFormatter;
	    }
	
	    function _cloneAutoFormatter(style, autoFormatter, deepClone) {
	        var resultAutoFormatter = autoFormatter;
	        if (deepClone && autoFormatter) {
	            if (autoFormatter.toJSON) {
	                autoFormatter = autoFormatter.toJSON();
	            }
	            var Formatter_module = __webpack_require__(6);
	            var GeneralFormatter = Formatter_module && Formatter_module.GeneralFormatter;
	            if (GeneralFormatter) {
	                resultAutoFormatter = new GeneralFormatter(autoFormatter.formatCached, autoFormatter.customerCultureName);
	                resultAutoFormatter.isAuto = true;
	            }
	        }
	        style._autoFormatter = resultAutoFormatter;
	    }
	
	    function normalizeColor(theme, color, callback) {
	        if (color) {
	            color = theme.getColor(color);
	            if (color) {
	                callback(color);
	            }
	        }
	    }
	
	    function _isDefaultValue(propertyName, value, sheetArea) {
	        if (propertyName === HALIGN) {
	            if (sheetArea === 2 ) {
	                return value === 1 ;
	            }
	            if (sheetArea === 1 ) {
	                return value === 1 ;
	            }
	            return value === 3 ;
	        }
	        if (propertyName === VALIGN) {
	            if (sheetArea === 2 ) {
	                return value === 1 ;
	            }
	            if (sheetArea === 1 ) {
	                return value === 1 ;
	            }
	            return value === 0 ;
	        }
	        if (propertyName === IME_MODE) {
	            return value === 1 ;
	        }
	        if (propertyName === AUTO_FORMATTER) {
	            return value === keyword_undefined;
	        }
	    }
	
	    Style.prototype = {
	        constructor: Style,
	        _compose: function (style, force, composeLevel) {
	           
	            var self = this, borderLeft, borderTop, borderRight, borderBottom, diagonalDown, diagonalUp,
	                labelOptions = style.labelOptions;
	            if (force) {
	                self._autoFormatter = style._autoFormatter;
	                self.backgroundImage = style.backgroundImage;
	                self.backgroundImageLayout = style.backgroundImageLayout;
	                self.backColor = style.backColor;
	                self.foreColor = style.foreColor;
	                self.hAlign = style.hAlign;
	                self.vAlign = style.vAlign;
	                self.font = style.font;
	                self.themeFont = style.themeFont;
	                self.formatter = style.formatter;
	                borderLeft = style.borderLeft;
	                self.borderLeft = ((borderLeft && borderLeft._clone()) || borderLeft);
	                if (self.borderLeft && composeLevel) {
	                    self.borderLeft.level = composeLevel;
	                }
	
	                borderTop = style.borderTop;
	                self.borderTop = ((borderTop && borderTop._clone()) || borderTop);
	                if (self.borderTop && composeLevel) {
	                    self.borderTop.level = composeLevel;
	                }
	
	                borderRight = style.borderRight;
	                self.borderRight = ((borderRight && borderRight._clone()) || borderRight);
	                if (self.borderRight && composeLevel) {
	                    self.borderRight.level = composeLevel;
	                }
	
	                borderBottom = style.borderBottom;
	                self.borderBottom = ((borderBottom && borderBottom._clone()) || borderBottom);
	                if (self.borderBottom && composeLevel) {
	                    self.borderBottom.level = composeLevel;
	                }
	
	                diagonalDown = style.diagonalDown;
	                self.diagonalDown = ((diagonalDown && diagonalDown._clone()) || diagonalDown);
	                if (self.diagonalDown && composeLevel) {
	                    self.diagonalDown.level = composeLevel;
	                }
	
	                diagonalUp = style.diagonalUp;
	                self.diagonalUp = ((diagonalUp && diagonalUp._clone()) || diagonalUp);
	                if (self.diagonalUp && composeLevel) {
	                    self.diagonalUp.level = composeLevel;
	                }
	
	                self.locked = style.locked;
	                self.textIndent = style.textIndent;
	                self.wordWrap = style.wordWrap;
	                self.shrinkToFit = style.shrinkToFit;
	                self.cellType = style.cellType;
	                self.name = style.name;
	                self.parentName = style.parentName;
	                self.tabStop = style.tabStop;
	                self.textDecoration = style.textDecoration;
	                self.imeMode = style.imeMode;
	                self.watermark = style.watermark;
	                self.cellPadding = style.cellPadding;
	                self.isVerticalText = style.isVerticalText;
	                if (labelOptions) {
	                    self.labelOptions = {
	                        alignment: labelOptions.alignment,
	                        font: labelOptions.font,
	                        foreColor: labelOptions.foreColor,
	                        visibility: labelOptions.visibility,
	                        margin: labelOptions.margin
	                    };
	                }
	                self.quotePrefix = style.quotePrefix;
	            } else {
	                if (self.backgroundImage === keyword_undefined) {
	                    self.backgroundImage = style.backgroundImage;
	                }
	                if (self.backgroundImageLayout === keyword_undefined) {
	                    self.backgroundImageLayout = style.backgroundImageLayout;
	                }
	                if (self.backColor === keyword_undefined) {
	                    self.backColor = style.backColor;
	                }
	                if (self.foreColor === keyword_undefined) {
	                    self.foreColor = style.foreColor;
	                }
	                if (self.hAlign === keyword_undefined) {
	                    self.hAlign = style.hAlign;
	                }
	                if (self.vAlign === keyword_undefined) {
	                    self.vAlign = style.vAlign;
	                }
	                if (self.themeFont === keyword_undefined && self.font === keyword_undefined) {
	                    self.themeFont = style.themeFont;
	                    self.font = style.font;
	                } else if (self.themeFont !== keyword_undefined && self.font === keyword_undefined) {
	                    self.font = style.font;
	                }
	                if (self.formatter === keyword_undefined) {
	                    self.formatter = style.formatter;
	                }
	                if (self._autoFormatter === keyword_undefined) {
	                    self._autoFormatter = style._autoFormatter;
	                }
	                if (self.borderLeft === keyword_undefined) {
	                    borderLeft = style.borderLeft;
	                    self.borderLeft = ((borderLeft && borderLeft._clone()) || borderLeft);
	                    if (self.borderLeft && composeLevel) {
	                        self.borderLeft.level = composeLevel;
	                    }
	                }
	                if (self.borderTop === keyword_undefined) {
	                    borderTop = style.borderTop;
	                    self.borderTop = ((borderTop && borderTop._clone()) || borderTop);
	                    if (self.borderTop && composeLevel) {
	                        self.borderTop.level = composeLevel;
	                    }
	                }
	                if (self.borderRight === keyword_undefined) {
	                    borderRight = style.borderRight;
	                    self.borderRight = ((borderRight && borderRight._clone()) || borderRight);
	                    if (self.borderRight && composeLevel) {
	                        self.borderRight.level = composeLevel;
	                    }
	                }
	                if (self.borderBottom === keyword_undefined) {
	                    borderBottom = style.borderBottom;
	                    self.borderBottom = ((borderBottom && borderBottom._clone()) || borderBottom);
	                    if (self.borderBottom && composeLevel) {
	                        self.borderBottom.level = composeLevel;
	                    }
	                }
	                if (self.diagonalDown === keyword_undefined) {
	                    diagonalDown = style.diagonalDown;
	                    self.diagonalDown = ((diagonalDown && diagonalDown._clone()) || diagonalDown);
	                    if (self.diagonalDown && composeLevel) {
	                        self.diagonalDown.level = composeLevel;
	                    }
	                }
	                if (self.diagonalUp === keyword_undefined) {
	                    diagonalUp = style.diagonalUp;
	                    self.diagonalUp = ((diagonalUp && diagonalUp._clone()) || diagonalUp);
	                    if (self.diagonalUp && composeLevel) {
	                        self.diagonalUp.level = composeLevel;
	                    }
	                }
	                if (self.locked === keyword_undefined) {
	                    self.locked = style.locked;
	                }
	                if (self.textIndent === keyword_undefined) {
	                    self.textIndent = style.textIndent;
	                }
	                if (self.wordWrap === keyword_undefined) {
	                    self.wordWrap = style.wordWrap;
	                }
	                if (self.shrinkToFit === keyword_undefined) {
	                    self.shrinkToFit = style.shrinkToFit;
	                }
	                if (self.cellType === keyword_undefined) {
	                    self.cellType = style.cellType;
	                }
	                if (self.tabStop === keyword_undefined) {
	                    self.tabStop = style.tabStop;
	                }
	                if (self.textDecoration === keyword_undefined) {
	                    self.textDecoration = style.textDecoration;
	                }
	                if (self.imeMode === keyword_undefined) {
	                    self.imeMode = style.imeMode;
	                }
	                if (self.name === keyword_undefined) {
	                    self.name = style.name;
	                }
	                if (self.parentName === keyword_undefined) {
	                    self.parentName = style.parentName;
	                }
	                if (self.watermark === keyword_undefined) {
	                    self.watermark = style.watermark;
	                }
	                if (self.cellPadding === keyword_undefined) {
	                    self.cellPadding = style.cellPadding;
	                }
	                if (!self.labelOptions && labelOptions) {
	                    self.labelOptions = {};
	                }
	                var selfLabelOptions = self.labelOptions;
	                if (selfLabelOptions && labelOptions) {
	                    if (selfLabelOptions.alignment === keyword_undefined) {
	                        selfLabelOptions.alignment = labelOptions.alignment;
	                    }
	                    if (selfLabelOptions.font === keyword_undefined) {
	                        selfLabelOptions.font = labelOptions.font;
	                    }
	                    if (selfLabelOptions.foreColor === keyword_undefined) {
	                        selfLabelOptions.foreColor = labelOptions.foreColor;
	                    }
	                    if (selfLabelOptions.visibility === keyword_undefined) {
	                        selfLabelOptions.visibility = labelOptions.visibility;
	                    }
	                    if (selfLabelOptions.margin === keyword_undefined) {
	                        selfLabelOptions.margin = labelOptions.margin;
	                    }
	                }
	                if (self.quotePrefix === keyword_undefined) {
	                    self.quotePrefix = style.quotePrefix;
	                }
	                if (self.isVerticalText === keyword_undefined) {
	                    self.isVerticalText = style.isVerticalText;
	                }
	            }
	        },
	        _clear: function (propertyName) {
	            var self = this;
	            if (arguments.length === 0) {
	                $_each(stylePropertyDict, function (i, p) {
	                    self[p] = keyword_undefined;
	                });
	            } else {
	               
	               
	               
	               
	                self[propertyName] = keyword_undefined;
	            }
	        },
	       
	        
	        clone: function (noDeepClone) {
	            var self = this;
	            var borderLeft = self.borderLeft, borderTop = self.borderTop, borderRight = self.borderRight,
	                borderBottom = self.borderBottom, diagonalDown = self.diagonalDown, diagonalUp = self.diagonalUp;
	            var style = new Style();
	            style.backColor = self.backColor;
	            style.foreColor = self.foreColor;
	            style.hAlign = self.hAlign;
	            style.vAlign = self.vAlign;
	            style.font = self.font;
	            style.themeFont = self.themeFont;
	            style.formatter = keyword_undefined ;
	            style.borderLeft = ((borderLeft && !noDeepClone && borderLeft._clone()) || borderLeft);
	            style.borderTop = ((borderTop && !noDeepClone && borderTop._clone()) || borderTop);
	            style.borderRight = ((borderRight && !noDeepClone && borderRight._clone()) || borderRight);
	            style.borderBottom = ((borderBottom && !noDeepClone && borderBottom._clone()) || borderBottom);
	            style.locked = self.locked;
	            style.textIndent = self.textIndent;
	            style.wordWrap = self.wordWrap;
	            style.shrinkToFit = self.shrinkToFit;
	            style.backgroundImage = self.backgroundImage;
	            style.cellType = keyword_undefined ;
	            style.backgroundImageLayout = self.backgroundImageLayout;
	            style.tabStop = self.tabStop;
	            style.textDecoration = self.textDecoration;
	            style.imeMode = self.imeMode;
	            style.name = self.name;
	            style.parentName = self.parentName;
	            style.watermark = self.watermark;
	            style.cellPadding = self.cellPadding;
	            style.labelOptions = self.labelOptions;
	            style.quotePrefix = self.quotePrefix;
	            style.diagonalDown = ((diagonalDown && !noDeepClone && diagonalDown._clone()) || diagonalDown);
	            style.diagonalUp = ((diagonalUp && !noDeepClone && diagonalUp._clone()) || diagonalUp);
	            style.isVerticalText = self.isVerticalText;
	           
	            _cloneFormatter(style, self.formatter, !noDeepClone);
	           
	            _cloneAutoFormatter(style, self._autoFormatter, !noDeepClone);
	           
	           
	           
	           
	           
	           
	           
	            _cloneCellType(style, self.cellType, !noDeepClone, true);
	            return style;
	        },
	        _normalize: function (theme) {
	            var self = this;
	            if (theme && theme.getColor) {
	                normalizeColor(theme, self.foreColor, function (color) {
	                    self.foreColor = color;
	                });
	                normalizeColor(theme, self.backColor, function (color) {
	                    self.backColor = color;
	                });
	
	                var borderLines = [self.borderLeft, self.borderTop, self.borderRight, self.borderBottom, self.diagonalDown, self.diagonalUp];
	                for (var i = 0, count = borderLines.length; i < count; i++) {
	                    var borderLine = borderLines[i];
	                    if (borderLine && borderLine.color) {
	                        normalizeColor(theme, borderLine.color, function (color) { 
	                            borderLine.color = color;
	                        });
	                    }
	                }
	            }
	            var themeFont = self.themeFont, font = self.font;
	            if (theme && theme.getFont) {
	                if (themeFont) {
	                    self.font = StyleHelper._composeFont(font, theme.getFont(themeFont));
	                } else if (!font) {
	                    self.font = StyleHelper._composeFont(font, theme.bodyFont());
	                }
	            }
	            return self;
	        },
	        _setActualAutoFormatter: function (value) {
	           
	           
	            var self = this;
	            var formatter = self._autoFormatter;
	            if (!formatter || value === keyword_null) {
	                return;
	            }
	            var newFormatObj = formatter.getPreferredEditingFormatter(value);
	            newFormatObj.isAuto = true;
	           
	           
	            self._autoFormatter = newFormatObj;
	           
	        },
	        toJSON: function (sheetArea, checkDefaultValue) {
	            var self = this;
	            var jsonData = {};
	
	            var value = self._autoFormatter, i, item;
	            if (isDefined(value) && (!checkDefaultValue || !_isDefaultValue(AUTO_FORMATTER, value, sheetArea))) {
	                if (value.toJSON) {
	                    value = value.toJSON();
	                }
	                if (!$.isEmptyObject(value)) {
	                    jsonData[AUTO_FORMATTER] = value;
	                }
	            }
	
	            for (i = 0; i < stylePropertyDict.length; i++) {
	                item = stylePropertyDict[i];
	                value = self[item];
	                if (item === LABEL_OPTIONS && !$.isEmptyObject(value)) {
	                    jsonData[LABEL_OPTIONS] = value;
	                } else if (isDefined(value) && (!checkDefaultValue || !_isDefaultValue(item, value, sheetArea))) {
	                    jsonData[item] = value && value.toJSON ? value.toJSON() : value;
	                }
	            }
	
	            return $.isEmptyObject(jsonData) ? keyword_undefined : jsonData;
	        },
	        fromJSON: function (jsonData, noSchema) {
	            if (!jsonData) {
	                return;
	            }
	            var self = this, p, value;
	            for (p in jsonData) {           
	                value = jsonData[p];
	                if (!isDefined(value)) {
	                    continue;
	                }
	                var arg = {p: p, v: value, r: false};
	                Style._callFeatureHandler(self, 'fromJson', arg);
	                if (!arg.r) {
	                    if (p === 'formatter') {
	                        _cloneFormatter(self, value, true);
	                    } else if (p === 'autoFormatter') {
	                        _cloneAutoFormatter(self, value, true);
	                    } else if (p === CELLTYPE) {
	                        _cloneCellType(self, value, true, noSchema);
	                    } else if (SUPPORT_BORDER_DICT[p]) {
	                        if (value === keyword_null) {
	                            self[p] = null;
	                        } else {
	                            var border = new LineBorder();
	                            border.fromJSON(value, noSchema);
	                            self[p] = border;
	                        }
	                    } else {
	                        self[p] = value;
	                    }
	                }
	            }
	        }
	    };
	    util_common._defineFeature(Style);
	    Style._styleId = 0;
	    exports.Style = Style;
	   
	
	    module.exports = exports;
	
	}());

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	
	    var Common = __webpack_require__(5);
	    var $ = __webpack_require__(4).GC$;
	    var util_common = __webpack_require__(3);
	    var StyleHelper = __webpack_require__(11)._StyleHelper;
	    var exports = __webpack_require__(1);
	    var CellTypes = exports.CellTypes = {};
	    var CultureManager = Common.CultureManager;
	
	    var _NumberHelper = Common._NumberHelper, _DateTimeHelper = Common._DateTimeHelper,
	        _ColorHelper = Common._ColorHelper;
	    var _CacheMgr = util_common._CacheMgr;
	    var isNullOrUndefined = Common._Types._isNullOrUndefined;
	    var isType = Common._Types._isType;
	    var _WordWrapHelper = util_common._WordWrapHelper;
	    var Rect = util_common.Rect;
	    var _ThemeStyleHelper = util_common._ThemeStyleHelper;
	    var util_common_util = util_common._util;
	    var getFontHeight = util_common_util._getFontHeight;
	    var getHAlignByValueType = util_common_util._getHAlignByValueType;
	    var _isCJKText = util_common_util._isCJKText;
	    var setContextFont = util_common_util._setContextFont;
	    var adjustFontWithFallback = util_common_util._adjustFontWithFallback;
	    var convertRichTextValue = util_common_util._convertRichTextValue;
	    var measureTextWidth = util_common_util._measureTextWidth;
	    var extend = $.extend;
	
	    var cssLeft = 'left', cssRight = 'right', cssCenter = 'center', textBaseline = 'alphabetic';
	    var ICONSET_SIZE = 16;
	    var const_string = 'string', const_number = 'number', keyword_null = null, keyword_undefined = void 0,
	        Math_floor = Math.floor, Math_ceil = Math.ceil, cssNone = 'none', const_general = 'General',
	        Math_max = Math.max, subscriptAndSuperscriptScale = 0.58;
	
	   
	    var CellTypeContext = CellTypes.Context = {};
	
	    CellTypeContext._paintBackgroundImage = function (ctx, x, y, w, h, backgroundImage, backgroundImageLayout, imageLoader) {
	        if (backgroundImage && backgroundImage !== 'none' && imageLoader) {
	            try {
	                if (imageLoader._getState(backgroundImage)) {
	                    var bkImg = imageLoader._getImage(backgroundImage);
	                    var imgWidth = bkImg.width;
	                    var imgHeight = bkImg.height;
	                    var sx = 0, sy = 0, swidth = imgWidth, sheight = imgHeight, useWidth = w, useHeight = h;
	                    var px = x, py = y;
	                    if (backgroundImageLayout === 1 ) {
	                        swidth = w >= imgWidth ? imgWidth : w;
	                        sheight = h >= imgHeight ? imgHeight : h;
	                        px = (w > imgWidth) && (imgWidth > 0) ? Math_ceil(x + w / 2 - imgWidth / 2) : x;
	                        py = (h > imgHeight) && (imgHeight > 0) ? Math_ceil(y + h / 2 - imgHeight / 2) : y;
	                        useWidth = swidth;
	                        useHeight = sheight;
	                    } else if (backgroundImageLayout === 2 ) {
	                        if (h > 0 && imgHeight > 0 && w / h > imgWidth / imgHeight) {
	                            useWidth = imgWidth / imgHeight * h;
	                            px = x + w / 2 - useWidth / 2;
	                        } else if (w > 0 && imgWidth > 0 && h / w > imgHeight / imgWidth) {
	                            useHeight = imgHeight / imgWidth * w;
	                            py = y + h / 2 - useHeight / 2;
	                        }
	                    } else if (backgroundImageLayout === 3 ) {
	                        swidth = w >= imgWidth ? imgWidth : w;
	                        sheight = h >= imgHeight ? imgHeight : h;
	                        useWidth = swidth;
	                        useHeight = sheight;
	                    }
	                    ctx.drawImage(bkImg, sx, sy, swidth, sheight, px, py, useWidth, useHeight);
	                } else {
	                    imageLoader._addImage(backgroundImage);
	                }
	            } catch (ex) {
	               
	            }
	        }
	    };
	
	    function cellTypeContext_hasIconSet(sheet, row, col, sheetArea) {
	        var cfs = sheet.conditionalFormats;
	        if (cfs) {
	            return cfs._hasIconSet(row, col, sheetArea);
	        }
	    }
	
	    CellTypeContext._getAutoFitWidth = function (value, text, cellStyle, zoomFactor, context) {
	        var width = 0;
	        var sheet = context && context.sheet;
	        var textIndent = cellStyle.textIndent, hAlign = cellStyle.hAlign;
	        var isVerticalText = cellStyle.isVerticalText;
	        var i;
	        var defaultFont = cellStyle.font;
	        if (sheet && typeof text === const_string && text) {
	            var lines = [];
	            var richText;
	            if (value && value.richText) {
	                richText = extend(true, [], value.richText);
	               
	               
	               
	                scaleFontByZoomFactor(richText, defaultFont, zoomFactor);
	                if (isVerticalText) {
	                    if (cellStyle.wordWrap) {
	                        var row = context.row, col = context.col, sheetArea = context.sheetArea;
	                        var rowHeight = sheet._getZoomRowHeight(row);
	                        var span = sheet._modelManager.findSpan(row, col, sheetArea);
	                        if (span && span.row >= row && span.col >= col && span.rowCount > 1) {
	                            for (var rowIndex = (row + 1); rowIndex < (row + span.rowCount); rowIndex++) {
	                                rowHeight += sheet._getZoomRowHeight(rowIndex);
	                            }
	                        }
	                       
	                       
	                        var indent = 0;
	                        if (textIndent > 0) {
	                            indent = textIndent * 8;
	                        }
	                        var topOffset = getPositionOffset(cellStyle, 0 ),
	                            bottomOffset = getPositionOffset(cellStyle, 2 );
	                        if (topOffset > 0) {
	                            rowHeight -= topOffset;
	                        }
	                        if (bottomOffset > 0) {
	                            rowHeight -= bottomOffset;
	                        }
	                       
	                       
	                        rowHeight++;
	                        lines = _WordWrapHelper._getWordWrapInfo(text, rowHeight - 3 - indent, defaultFont, richText, isVerticalText);
	                        for (i = 0; i < lines.length; i++) {
	                            width += getMaxHeightInLine(lines[i].textInfos, defaultFont, zoomFactor);
	                        }
	                    } else {
	                        width = getMaxHeightInLine(richText, defaultFont, zoomFactor);
	                    }
	                } else {
	                    if (cellStyle.wordWrap) {
	                        var linesByLineBreak = text.split(/\r\n|\r|\n/);
	                        for (i = 0; i < linesByLineBreak.length; i++) {
	                            var line = [];
	                            line.push(linesByLineBreak[i]);
	                            lines.push(line);
	                        }
	                        lines = _WordWrapHelper._composeTextInfos(lines, _WordWrapHelper._trimLineBreaksInRichText(richText));
	                        for (i = 0; i < lines.length; i++) {
	                            width = Math.max(width, getTextLengthInLine(lines[i], defaultFont, zoomFactor, isVerticalText, true));
	                        }
	                    } else {
	                        width = getTextLengthInLine(richText, defaultFont, zoomFactor);
	                    }
	                    if (hAlign !== 1  && textIndent > 0) {
	                        width += textIndent * 8 / zoomFactor;
	                    }
	                    if (hAlign === 0  && cellTypeContext_hasIconSet(sheet, context.row, context.col, context.sheetArea)) {
	                        width += cellTypeContext_getIconSetSize(sheet);
	                    }
	                }
	            } else {
	                lines = text.split(/\r\n|\r|\n/);
	                var font = cellStyle.font, lineHeight = getFontHeight(font) / zoomFactor;
	                if (isVerticalText) {
	                    if (cellStyle.wordWrap) {
	                        for (i = 0; i < lines.length; i++) {
	                            width += lineHeight;
	                        }
	                    } else {
	                        width = lineHeight;
	                    }
	                } else {
	                    if (cellStyle.wordWrap) {
	                        for (i = 0; i < lines.length; i++) {
	                            width = Math.max(width, _WordWrapHelper._measureText(lines[i], font, true) / zoomFactor);
	                        }
	                    } else {
	                        width = sheet._getStringWidthByCanvas(text, font) / zoomFactor;
	                    }
	                    if (hAlign !== 1  && textIndent > 0) {
	                        width += textIndent * 8 / zoomFactor;
	                    }
	                    if (hAlign === 0  && cellTypeContext_hasIconSet(sheet, context.row, context.col, context.sheetArea)) {
	                        width += ICONSET_SIZE;
	                    }
	                }
	            }
	        }
	        return width;
	    };
	
	    CellTypeContext._getAutoFitHeight = function (value, text, cellStyle, zoomFactor, context) {
	        var height = 0, i;
	        var sheet = context && context.sheet;
	        var defaultFont = cellStyle.font;
	        var isVerticalText = cellStyle.isVerticalText;
	        var textIndent = cellStyle.textIndent;
	        var vAlign = cellStyle.vAlign;
	        var row, col, sheetArea, columnWidth, span, colIdx, indent, rightOffset, leftOffset;
	        if (sheet && typeof text === const_string && text) {
	            var lines = [];
	            var richText;
	            if (value && value.richText) {
	                richText = extend(true, [], value.richText);
	               
	               
	               
	                scaleFontByZoomFactor(richText, defaultFont, zoomFactor);
	                if (isVerticalText) {
	                    if (cellStyle.wordWrap) {
	                        var linesByLineBreak = text.split(/\r\n|\r|\n/);
	                        for (i = 0; i < linesByLineBreak.length; i++) {
	                            var line = [];
	                            line.push(linesByLineBreak[i]);
	                            lines.push(line);
	                        }
	                        lines = _WordWrapHelper._composeTextInfos(lines, _WordWrapHelper._trimLineBreaksInRichText(richText));
	                        for (i = 0; i < lines.length; i++) {
	                            height = Math.max(height, getTextLengthInLine(lines[i], defaultFont, zoomFactor, isVerticalText, true));
	                        }
	                    } else {
	                        height = getTextLengthInLine(richText, defaultFont, zoomFactor, isVerticalText);
	                    }
	                    if (vAlign !== 1  && textIndent > 0) {
	                        height += textIndent * 8 / zoomFactor;
	                    }
	                } else if (cellStyle.wordWrap) {
	                    row = context.row;
	                    col = context.col;
	                    sheetArea = context.sheetArea;
	                    columnWidth = sheet._getZoomColumnWidth(col);
	                    span = sheet._modelManager.findSpan(row, col, sheetArea);
	                    if (span && span.row >= row && span.col >= col && span.colCount > 1) {
	                        for (colIdx = (col + 1); colIdx < (col + span.colCount); colIdx++) {
	                            columnWidth += sheet._getZoomColumnWidth(colIdx);
	                        }
	                    }
	                   
	                   
	                    indent = 0;
	                    if (textIndent > 0) {
	                        indent = textIndent * 8;
	                    }
	                    rightOffset = getPositionOffset(cellStyle, 1 );
	                    leftOffset = getPositionOffset(cellStyle, 3 );
	                    if (leftOffset > 0) {
	                        columnWidth -= leftOffset;
	                    }
	                    if (rightOffset > 0) {
	                        columnWidth -= rightOffset;
	                    }
	                   
	                   
	                    columnWidth++;
	                    lines = _WordWrapHelper._getWordWrapInfo(text, columnWidth - 3 - indent, defaultFont, richText);
	                    for (i = 0; i < lines.length; i++) {
	                        height += getMaxHeightInLine(lines[i].textInfos, defaultFont, zoomFactor);
	                    }
	                } else {
	                    height = getMaxHeightInLine(richText, defaultFont, zoomFactor);
	                }
	            } else {
	                var font = cellStyle.font, lineHeight = getFontHeight(font) / zoomFactor;
	                if (isVerticalText) {
	                    if (cellStyle.wordWrap) {
	                        lines = text.split(/\r\n|\r|\n/);
	                        for (i = 0; i < lines.length; i++) {
	                            var textLength = lines[i].length * lineHeight;
	                            height = Math.max(height, textLength);
	                        }
	                    } else {
	                        height = text.length * lineHeight;
	                    }
	                    if (vAlign !== 1  && textIndent > 0) {
	                        height += textIndent * 8 / zoomFactor;
	                    }
	                } else if (cellStyle.wordWrap) {
	                    row = context.row;
	                    col = context.col;
	                    sheetArea = context.sheetArea;
	                    columnWidth = sheet._getZoomColumnWidth(col);
	                    span = sheet._modelManager.findSpan(row, col, sheetArea);
	                    if (span && span.row >= row && span.col >= col && span.colCount > 1) {
	                        for (colIdx = (col + 1); colIdx < (col + span.colCount); colIdx++) {
	                            columnWidth += sheet._getZoomColumnWidth(colIdx);
	                        }
	                    }
	                   
	                   
	                    indent = 0;
	                    if (textIndent > 0) {
	                        indent = textIndent * 8;
	                    }
	                    rightOffset = getPositionOffset(cellStyle, 1 );
	                    leftOffset = getPositionOffset(cellStyle, 3 );
	                    if (leftOffset > 0) {
	                        columnWidth -= leftOffset;
	                    }
	                    if (rightOffset > 0) {
	                        columnWidth -= rightOffset;
	                    }
	                    lines = _WordWrapHelper._getWrapInfo(text, columnWidth - 3 - indent, font);
	                    height = lines.length * lineHeight;
	                } else {
	                    height = lineHeight;
	                }
	            }
	
	        }
	        return height;
	    };
	
	    function getMaxHeightInLine(line, defaultFont, zoomFactor) {
	        var maxHeightInLine = 0;
	        for (var i = 0; i < line.length; i++) {
	            var font;
	            if (line[i].style && line[i].style.font) {
	                font = line[i].style.font;
	            } else {
	                font = defaultFont;
	            }
	            maxHeightInLine = Math.max(getFontHeight(font) / zoomFactor, maxHeightInLine);
	            if (line[i].style && (line[i].style.vertAlign === 1) || (line[i].style.vertAlign === 2)) {
	                maxHeightInLine = Math.max(getFontHeight(font) / zoomFactor + StyleHelper._scaleFont(font, 1).fontSize * 2 / 3, maxHeightInLine);
	            }
	        }
	        return maxHeightInLine;
	    }
	
	    function getTextLengthInLine(line, defaultFont, zoomFactor, isVerticalText, withoutEndSpaces) {
	        var ctx = _WordWrapHelper._getCtx();
	        if (!ctx) {
	            return 0;
	        }
	        var textLength = 0;
	        for (var i = 0; i < line.length; i++) {
	            var font;
	            if (line[i].style && line[i].style.font) {
	                font = line[i].style.font;
	            } else {
	                font = defaultFont;
	            }
	            if (line[i].style && line[i].style.vertAlign) {
	               
	                font = StyleHelper._scaleFont(font, subscriptAndSuperscriptScale).font;
	            }
	            setContextFont(ctx, font);
	            var text = '';
	            if (i === line.length - 1 && withoutEndSpaces) {
	                text = _WordWrapHelper._removeEndSpace(line[i].text);
	            } else {
	                text = line[i].text;
	            }
	            var tempLength = 0;
	            if (isVerticalText) {
	                tempLength = getFontHeight(font) * text.length / zoomFactor;
	            } else if (!isNullOrUndefined(line[i].text)) {
	                tempLength = measureTextWidth(ctx, font, line[i].text) / zoomFactor;
	            }
	            textLength += tempLength;
	        }
	        return textLength;
	    }
	
	    function cellTypeContext_paintBackground(ctx, x, y, w, h, backColor, backgroundImage, backgroundImageLayout, imageLoader) {
	        if (backColor || backgroundImage) {
	            ctx.save();
	            ctx.beginPath();
	           
	            if (backColor) {
	                if (ctx.fillStyle !== backColor) {
	                    ctx.fillStyle = backColor;
	                }
	                ctx.fillRect(x, y, w, h);
	            }
	           
	            CellTypeContext._paintBackgroundImage(ctx, x, y, w, h, backgroundImage, backgroundImageLayout, imageLoader);
	
	            ctx.restore();
	        }
	    }
	
	    function cellTypeContext_paintSparklineEx(ctx, value, x, y, w, h, sheet) {
	        var Sparkline_module = __webpack_require__(14);
	        var SparklineExValue = Sparkline_module && Sparkline_module.SparklineExValue;
	        if (SparklineExValue && value && value.typeName === 'SparklineExValue') {
	            var sp = sheet && sheet.parent;
	            if (sp) {
	                var sparklineEx = sp.getSparklineEx(value.name);
	                if (sparklineEx) {
	                    sparklineEx.paint(ctx, value.value, x, y, w, h, {zoomFactor: sheet.zoom(), sheet: sheet});
	                    return true;
	                }
	            }
	        }
	        return false;
	    }
	
	    function cellTypeContext_adjustRectForIconSet(hAlign, sheet, row, col, sheetArea, rect) {
	        if (hAlign === 0  && cellTypeContext_hasIconSet(sheet, row, col, sheetArea)) {
	            var iconSize = cellTypeContext_getIconSetSize(sheet);
	            rect.x += iconSize;
	            rect.width -= iconSize;
	        }
	    }
	
	    function cellTypeContext_getIconSetSize(sheet) {
	        return parseInt(ICONSET_SIZE * Math.min(1, sheet.zoom()));
	    }
	
	    CellTypeContext._paintHeaderCellGridline = function (ctx, x, y, w, h, style, headerTypeString, themeStyle, sheetArea, needTopGridline, needLeftGridline) {
	        var strokeStyle;
	        if (sheetArea === 1 ) {
	            ctx.beginPath();
	            strokeStyle = ctx.createLinearGradient(x, y + 1, x, y + h - 2);
	            strokeStyle.addColorStop(0, themeStyle.borderLeftColor);
	            strokeStyle.addColorStop(1, themeStyle.borderRightColor);
	            if (ctx.strokeStyle !== strokeStyle) {
	                ctx.strokeStyle = strokeStyle;
	            }
	           
	            if (!style.borderLeft) {
	                ctx.moveTo(x + 0.5, y);
	                ctx.lineTo(x + 0.5, y + h);
	            }
	           
	            if (!style.borderRight) {
	                ctx.moveTo(x + w - 0.5, y);
	                ctx.lineTo(x + w - 0.5, y + h);
	            }
	           
	            if (needTopGridline && !style.borderTop) {
	                ctx.moveTo(x, y + 0.5);
	                ctx.lineTo(x + w, y + 0.5);
	            }
	            ctx.stroke();
	           
	            if (themeStyle.borderBottomWidth && !style.borderBottom) {
	                ctx.beginPath();
	                if (ctx.strokeStyle !== themeStyle.borderBottomColor) {
	                    ctx.strokeStyle = themeStyle.borderBottomColor;
	                }
	                ctx.moveTo(x + 1, y + h - 0.5);
	                ctx.lineTo(x + w, y + h - 0.5);
	                ctx.stroke();
	            }
	        } else {
	            ctx.beginPath();
	            strokeStyle = ctx.createLinearGradient(x, y, x + w - 2, y);
	            strokeStyle.addColorStop(0, themeStyle.borderTopColor);
	            strokeStyle.addColorStop(1, themeStyle.borderBottomColor);
	            if (ctx.strokeStyle !== strokeStyle) {
	                ctx.strokeStyle = strokeStyle;
	            }
	           
	            if (!style.borderTop) {
	                ctx.moveTo(x, y + 0.5);
	                ctx.lineTo(x + w, y + 0.5);
	            }
	           
	            if (!style.borderBottom) {
	                ctx.moveTo(x, y + h - 0.5);
	                ctx.lineTo(x + w, y + h - 0.5);
	            }
	           
	            if (needLeftGridline && !style.borderLeft) {
	                ctx.moveTo(x + 0.5, y);
	                ctx.lineTo(x + 0.5, y + h);
	            }
	            ctx.stroke();
	           
	            if (themeStyle.borderRightWidth && !style.borderRight) {
	                ctx.beginPath();
	                if (ctx.strokeStyle !== themeStyle.borderRightColor) {
	                    ctx.strokeStyle = themeStyle.borderRightColor;
	                }
	                ctx.moveTo(x + w - 0.5, y + 1);
	                ctx.lineTo(x + w - 0.5, y + h);
	                ctx.stroke();
	            }
	        }
	    };
	    CellTypeContext._setImeMode = function (element, imeMode) {
	        var cssImeModeString;
	        if (imeMode === 2 ) {
	            cssImeModeString = 'active';
	        } else if (imeMode === 4 ) {
	            cssImeModeString = 'inactive';
	        } else if (imeMode === 0 ) {
	            cssImeModeString = 'disabled';
	        } else {
	            cssImeModeString = 'auto';
	        }
	        $(element).css('ime-mode', cssImeModeString);
	    };
	
	    
	    function getPositionOffset(cellStyle, position, isMargin, zoomFactor) {
	        var cellPadding = cellStyle.cellPadding, offsetValue = 0, labelOptions = cellStyle.labelOptions;
	        if (isMargin) {
	            cellPadding = labelOptions ? labelOptions.margin : '0';    
	        }
	        if (cellPadding) {
	            offsetValue = parseInt(getCellOffsetArray(cellPadding)[position]);
	            offsetValue = (typeof offsetValue === const_number) && (offsetValue > 0) ? offsetValue : 0;
	        }
	        return (zoomFactor === keyword_undefined) ? offsetValue : offsetValue * zoomFactor;
	    }
	
	    function getOutlineColumnOffset(context) {
	        var args = {
	            context: context,
	            value: 0
	        };
	        BaseCellType._callFeatureHandler(context.sheet, 'getOutlineColumnOffset', args);
	        return args.value;
	    }
	
	    CellTypeContext._getPositionOffset = getPositionOffset;
	   
	
	   
	    function updateEditorPosition(cellWrapperElement, cellStyle, cellRect, context) {
	        var sheet = context && context.sheet;
	        if (sheet && cellRect) {
	            var offset = context.canvasOffset || sheet._eventHandler._getCanvasPosition();
	            var bounds = sheet._getBounds();
	            $(cellWrapperElement).css('top', offset.top + bounds.y + cellRect.y - 2 )
	                .css('left', offset.left + bounds.x + cellRect.x - 2 )
	                .css('background-color', cellStyle.backColor || 'white')
	                .width(cellRect.width).height(cellRect.height);
	        }
	    }
	
	    function getCellOffsetArray(cellPadding) {
	        var retArray = [0, 0, 0, 0];
	        if (typeof cellPadding === const_string) {
	            var offsetArray = cellPadding.split(' ', 4), length = offsetArray.length,
	                topOffset, rightOffset;
	            if (length === 1) {
	                topOffset = offsetArray[0];
	                retArray = [topOffset, topOffset, topOffset, topOffset];
	            } else if (length === 2) {
	                topOffset = offsetArray[0];
	                rightOffset = offsetArray[1];
	                retArray = [topOffset, rightOffset, topOffset, rightOffset];
	            } else if (length === 3) {
	                rightOffset = offsetArray[1];
	                retArray = [offsetArray[0], rightOffset, offsetArray[2], rightOffset];
	            } else if (length === 4) {
	                retArray = [offsetArray[0], offsetArray[1], offsetArray[2], offsetArray[3]];
	            }
	        }
	        return retArray;
	    }
	
	    function isPaintLabel(cellStyle, cellRect) {
	        var paddingTop = getPositionOffset(cellStyle, 0 ),
	            paddingBottom = getPositionOffset(cellStyle, 2 );
	        var marginTop = getPositionOffset(cellStyle, 0 , true ),
	            marginBottom = getPositionOffset(cellStyle, 2 , true );
	        if (getPositionOffset(cellStyle, 3 , true ) + getPositionOffset(cellStyle, 1 , true ) >= cellRect.width) {
	            return false;
	        }
	
	        var labelAlignment = cellStyle.labelOptions.alignment;
	        if (labelAlignment === keyword_undefined) {   
	            labelAlignment = cellStyle.labelOptions.alignment = 0 ;
	        }
	        if (labelAlignment === 0  || labelAlignment === 1  || labelAlignment === 2 ) {
	            if (paddingTop > 0 && (marginTop + marginBottom < paddingTop)) {
	                return true;
	            }
	        } else if (labelAlignment === 3  || labelAlignment === 4  || labelAlignment === 5 ) { 
	            if (paddingTop < cellRect.height && paddingBottom > 0 && (marginTop + marginBottom < paddingBottom)) {
	                return true;
	            }
	        }
	        return false;
	    }
	
	    function getClipRect(cellRect, cellStyle) {
	        var paddingTop = getPositionOffset(cellStyle, 0 );
	        var marginLeft = getPositionOffset(cellStyle, 3 , true ),
	            marginBottom = getPositionOffset(cellStyle, 2 , true );
	        var newRect = cellRect.clone();
	        var labelAlignment = cellStyle.labelOptions.alignment;
	
	        if ((labelAlignment === 0  || labelAlignment === 1  || labelAlignment === 2 )) {
	            if (paddingTop < cellRect.height) {
	                newRect.height = paddingTop - marginBottom + 1;
	            }
	        } else if (labelAlignment === 3  || labelAlignment === 4  || labelAlignment === 5 ) {
	            newRect.height = cellRect.height - marginBottom;
	        }
	        newRect.x += marginLeft;
	        newRect.width -= marginLeft + getPositionOffset(cellStyle, 1 , true );
	        return newRect;
	    }
	
	    function getTextAlign(labelAlignment) {
	        var align = 'left';
	        if (labelAlignment === 1  || labelAlignment === 4 ) {
	            align = 'center';
	        } else if (labelAlignment === 2  || labelAlignment === 5 ) {
	            align = 'right';
	        }
	        return align;
	    }
	
	    function getLabelPosition(cellRect, cellStyle, fontInfo, lineHeight) {
	        var labelPosition = new util_common.Point(cellRect.x, cellRect.y);
	        var fontSize = fontInfo.fontSize;
	        var paddingTop = getPositionOffset(cellStyle, 0 ),
	            paddingBottom = getPositionOffset(cellStyle, 2 );
	        var marginLeft = getPositionOffset(cellStyle, 3 , true ),
	            marginRight = getPositionOffset(cellStyle, 1 , true );
	        var rectWidth = cellRect.width, rectHeight = cellRect.height;
	
	       
	        var baselineOffset = fontSize > 8 ? Math.floor((fontSize - 8) / 5 + 2) : 1,
	            lineOffset = lineHeight / 2 - fontSize / 2 + baselineOffset - 1;
	        var adjX = fontSize > 8 ? 1 : 2;
	        var adjY = lineHeight - lineOffset + getPositionOffset(cellStyle, 0 , true );
	        var topYOffset = adjY + 1 ;
	        var bottomYOffset = (paddingTop + paddingBottom > rectHeight) ? (paddingTop + adjY) : (rectHeight - paddingBottom + adjY - 1);
	
	        switch (cellStyle.labelOptions.alignment) {
	            case 0: 
	                labelPosition.x += marginLeft + adjX + 1;
	                labelPosition.y += topYOffset;
	                break;
	            case 1: 
	                labelPosition.x += marginLeft + (rectWidth - marginLeft - marginRight) / 2;
	                labelPosition.y += topYOffset;
	                break;
	            case 2: 
	                labelPosition.x += rectWidth - marginRight - 2 ;
	                labelPosition.y += topYOffset;
	                break;
	            case 3: 
	                labelPosition.x += marginLeft + adjX + 1;
	                labelPosition.y += bottomYOffset;
	                break;
	            case 4: 
	                labelPosition.x += marginLeft + (rectWidth - marginLeft - marginRight) / 2;
	                labelPosition.y += bottomYOffset;
	                break;
	            case 5: 
	                labelPosition.x += rectWidth - marginRight - 2;
	                labelPosition.y += bottomYOffset;
	                break;
	        }
	        return labelPosition;
	    }
	
	    function getLabelRect(cellRect, cellStyle) {
	        var marginLeft = getPositionOffset(cellStyle, 3 , true ),
	            marginRight = getPositionOffset(cellStyle, 1 , true ),
	            marginTop = getPositionOffset(cellStyle, 0 , true ),
	            marginBottom = getPositionOffset(cellStyle, 2 , true );
	        var labelRect = cellRect.clone();
	        var labelAlignment = cellStyle.labelOptions.alignment;
	        labelRect.x = marginLeft + 1 ;
	        labelRect.width -= marginLeft + marginRight;
	        if (labelAlignment === 0  || labelAlignment === 1  || labelAlignment === 2 ) {
	            labelRect.y = marginTop;
	            labelRect.height = getPositionOffset(cellStyle, 0 ) - marginTop - marginBottom;
	        } else if (labelAlignment === 3  || labelAlignment === 4  || labelAlignment === 5 ) {
	            labelRect.y = cellRect.height - getPositionOffset(cellStyle, 2 ) + marginTop;
	            labelRect.height = getPositionOffset(cellStyle, 2 ) - marginTop - marginBottom;
	        }
	        if (labelAlignment === 2  || labelAlignment === 5 ) {
	            labelRect.width -= 2 ;
	        }
	        return labelRect;
	    }
	
	    function adjustZoomPadding(cellStyle, zoomFactor) {
	        if (cellStyle.cellPadding) {
	            var paddingArray = getCellOffsetArray(cellStyle.cellPadding), i;
	            for (i = 0; i < 4; i++) {
	                paddingArray[i] = parseInt(paddingArray[i]);
	                if ((typeof paddingArray[i] === 'number') && (paddingArray[i] > 0)) {
	                    paddingArray[i] *= zoomFactor;
	                }
	            }
	            cellStyle.cellPadding = paddingArray.join(' ');
	        }
	    }
	
	    function getTextContentWidth(ctx, textContent, isVerticalText, lineHeight) {
	        if (isVerticalText && textContent && textContent[0] && textContent[0].value) {
	            return textContent[0].value.length * lineHeight;
	        }
	        if (isType(textContent, const_string)) {
	            return measureTextWidth(ctx, ctx.font, textContent);
	        }
	        var width = 0;
	        for (var i = 0; i < textContent.length; i++) {
	            if (textContent[i].type !== 'fillingChar') {
	                width += measureTextWidth(ctx, ctx.font, textContent[i].value);
	            }
	        }
	        return width;
	    }
	
	    function hasInfilling(textContent) {
	        for (var i = 0; i < textContent.length; i++) {
	            if (textContent[i].type === 'fillingChar') {
	                return true;
	            }
	        }
	        return false;
	    }
	
	    function createInfillingText(ctx, infillingWidth, charactor, isVerticalText, lineHeight) {
	        var count;
	        if (isVerticalText) {
	            count = Math.floor(infillingWidth / lineHeight);
	        } else {
	            count = Math.floor(infillingWidth / measureTextWidth(ctx, ctx.font, charactor));
	        }
	        return new Array(count + 1).join(charactor);
	    }
	
	    function getDomRect(cellRect) {
	        var retCellRect = cellRect.clone();
	        retCellRect.width--;
	        
	        retCellRect.height--;
	        return retCellRect;
	    }
	
	    function scaleFontByZoomFactor (richText, defaultFont, zoomFactor) {
	        for (var i = 0; i < richText.length; i++) {
	            var font;
	            richText[i].style = richText[i].style || {};
	            var style = richText[i].style;
	            if (style.font) {
	                font = StyleHelper._scaleFont(style.font, zoomFactor).font;
	            } else {
	                font = defaultFont;
	            }
	            style.font = font;
	        }
	    }
	
	   
	    
	    function BaseCellType() {
	        this.allowOverflow = false;
	       
	        
	        this.typeName = 0  + '';
	    }
	
	    util_common._defineFeature(BaseCellType);
	    BaseCellType.prototype = {
	        constructor: BaseCellType,
	        _paintPadding: function (ctx, cellRect, cellStyle, context, value) {
	            var self = this;
	            if (self._paintLabel) {
	                self._paintLabel(ctx, cellRect, cellStyle, context);
	                cellRect = self._getContentRect(cellRect, cellStyle);
	            }
	            var args = {
	                ctx: ctx,
	                options: {
	                    rect: cellRect,
	                    context: context,
	                    value: value
	                }
	            };
	            BaseCellType._callFeatureHandler(context.sheet, 'paintCellPadding', args);
	            return args.options.rect;
	        },
	        _paintLabel: function (ctx, cellRect, cellStyle, context) {
	            var labelOptions = cellStyle.labelOptions;
	            if (!labelOptions) {
	                return;
	            }
	            var sheet = context.sheet;
	            var watermark = cellStyle.watermark;
	            if (watermark) {
	                var labelVisibility = labelOptions.visibility;
	                var cellText = sheet.getText(context.row, context.col, context.sheetArea);
	                if (labelVisibility === 1  || ((labelVisibility === 2  || labelVisibility === keyword_undefined) && cellText === '')) {
	                    return;
	                }
	                var zoomFactor = sheet.zoom();
	                if (zoomFactor !== 1) {
	                    adjustZoomPadding(cellStyle, zoomFactor);
	                }
	                var labelFont = labelOptions.font, fontInfo;
	                if (labelFont) {
	                    fontInfo = StyleHelper._scaleFont(labelFont, zoomFactor);
	                } else {
	                    fontInfo = StyleHelper._scaleFont(cellStyle.font, 1);
	                }
	                var lineHeight = getFontHeight(fontInfo.font);
	                var clipRect = getClipRect(cellRect, cellStyle), labelPosition;
	                if (isPaintLabel(cellStyle, cellRect)) {
	                    labelPosition = getLabelPosition(cellRect, cellStyle, fontInfo, lineHeight);
	                }
	                if (labelPosition) {
	                    ctx.save();
	                    ctx.textAlign = getTextAlign(labelOptions.alignment);
	                    ctx.textBaseline = 'alphabetic';
	                    setContextFont(ctx, fontInfo.font);
	                    ctx.fillStyle = labelOptions.foreColor || cellStyle.foreColor || 'grey';
	                    ctx.rect(clipRect.x, clipRect.y, clipRect.width, clipRect.height);
	                    ctx.clip();
	                    ctx.beginPath();
	                    ctx.fillText(watermark, labelPosition.x, labelPosition.y);
	                    ctx.restore();
	                }
	            }
	        },
	        _getContentRect: function (cellRect, cellStyle) {
	            var newRect = cellRect.clone();
	            var topOffset = getPositionOffset(cellStyle, 0 ),
	                rightOffset = getPositionOffset(cellStyle, 1 ),
	                bottomOffset = getPositionOffset(cellStyle, 2 ),
	                leftOffset = getPositionOffset(cellStyle, 3 );
	            if (topOffset > 0) {
	                newRect.y += topOffset;
	                newRect.height -= topOffset;
	            }
	            if (bottomOffset > 0) {
	                newRect.height -= bottomOffset;
	            }
	            if (leftOffset > 0) {
	                newRect.x += leftOffset;
	                newRect.width -= leftOffset;
	            }
	            if (rightOffset > 0) {
	                newRect.width -= rightOffset;
	            }
	            if (rightOffset + leftOffset >= cellRect.width) {
	                newRect.width = 0;
	            }
	            if (topOffset + bottomOffset >= cellRect.height) {
	                newRect.height = 0;
	            }
	            return newRect;
	        },
	        _getContentRectImp: function (ctx, cellRect, cellStyle, context) {
	            var self = this;
	            cellRect = self._getContentRect(cellRect, cellStyle);
	            var args = {
	                ctx: ctx,
	                options: {
	                    rect: cellRect,
	                    context: context
	                }
	            };
	            BaseCellType._callFeatureHandler(context.sheet, 'getCellPaddingRect', args);
	
	            return args.options.rect;
	        },
	        _createLabelElement: function (cellWrapperElement, cellRect, cellStyle, context) {
	            var labelOptions = cellStyle.labelOptions;
	            if (!labelOptions) {
	                return;
	            }
	            var sheet = context.sheet;
	            var cellText = sheet.getText(context.row, context.col, context.sheetArea);
	            var watermark = cellStyle.watermark;
	            var labelVisibility = labelOptions.visibility;
	            if (labelVisibility !== 1  && watermark) {
	                var labelFont = labelOptions.font || cellStyle.font || sheet._render._getDefaultFont();
	                var zoomFactor = sheet.zoom();
	                if (zoomFactor !== 1) {
	                    labelFont = sheet._render._getZoomFont(labelFont);
	                    adjustZoomPadding(cellStyle, zoomFactor);
	                }
	                var fontHeight = getFontHeight(labelFont), labelRect;
	                if (isPaintLabel(cellStyle, cellRect)) {
	                    labelRect = getLabelRect(cellRect, cellStyle);
	                }
	                if (labelRect) {
	                    var $span = $(util_common_util._createElement('span'));
	                    $span.text(watermark);
	                    var isMoveSpan = (labelVisibility === 2  || labelVisibility === keyword_undefined) && cellText === '';
	                    var animationOffset = labelRect.height - fontHeight;
	                    var topStartValue = labelRect.y + (isMoveSpan && animationOffset > 0 ? animationOffset : 0);
	                    $span.css({
	                        display: 'block',
	                        position: 'absolute',
	                        left: labelRect.x,
	                        top: topStartValue,
	                        width: labelRect.width,
	                        height: labelRect.height,
	                        font: adjustFontWithFallback(labelFont),
	                        color: labelOptions.foreColor || cellStyle.foreColor || 'grey',
	                        textAlign: getTextAlign(labelOptions.alignment),
	                        overflow: 'hidden',
	                        whiteSpace: 'nowrap'
	                    }).attr('gcUIElement', 'gcEditorLabel');
	                    $(cellWrapperElement).append($span);
	
	                    if (isMoveSpan) {
	                        var timer = setInterval(function () {
	                            topStartValue--;
	                            $span.css('top', topStartValue);
	                            if (topStartValue <= labelRect.y) {
	                                clearInterval(timer);
	                            }
	                        }, 20);
	                    }
	                }
	            }
	        },
	        _createCellTypeElement: function (context) {
	            var self = this, cellWrapperElement = util_common_util._createElement('div');
	            $(cellWrapperElement).css({
	                'position': 'absolute',
	                'margin': 0,
	                'padding': 0,
	                'overflow': 'hidden',
	                'box-sizing': 'content-box',
	                'resize': cssNone,
	                'outline': cssNone,
	                'border': '2px #5292f7 solid',
	                'box-shadow': '1px 2px 5px rgba(0,0,0,0.4)',
	                'background-color': 'white'
	            });
	            var $contentContainer = $(util_common_util._createElement('div'));
	            $contentContainer.css({
	                'position': 'absolute',
	                'outline': cssNone,
	                'border': cssNone
	            });
	            $(cellWrapperElement).append($contentContainer);
	
	            var contentElement = self.createEditorElement(context, cellWrapperElement);
	            
	            if (contentElement) {
	                $contentContainer.append($(contentElement));
	            }
	            return cellWrapperElement;
	        },
	        _activateEditorWrapper: function (cellWrapperElement, cellStyle, cellRect, context) {
	            if (cellWrapperElement && cellWrapperElement.firstChild) {
	                var self = this;
	                var tempCellRect = getDomRect(cellRect);
	                updateEditorPosition(cellWrapperElement, cellStyle, tempCellRect, context);
	                self._createLabelElement && self._createLabelElement(cellWrapperElement, tempCellRect, cellStyle, context);
	                var contentRect = self._getContentRect ? self._getContentRect(tempCellRect, cellStyle) : tempCellRect;
	                self.activateEditor(cellWrapperElement.firstChild.firstChild, cellStyle, contentRect, context);
	            }
	        },
	       
	        
	        updateEditorContainer: function (editorContext, editorBounds, cellStyle) {
	           
	            if (editorContext && editorBounds) {
	                var contentContainer = editorContext.parentNode;
	                if (contentContainer) {
	                    var cellWrapperElement = contentContainer.parentNode;
	                    var $cellWrapperElement = $(cellWrapperElement);
	                    var newWidth = editorBounds.width, newHeight = editorBounds.height;
	                    if (newWidth > 0) {
	                        $cellWrapperElement.width(newWidth);
	                        var spanElement = cellWrapperElement.lastChild;
	                        if (cellStyle && spanElement.getAttribute('gcUIElement') === 'gcEditorLabel') {
	                            $(spanElement).width(newWidth - getPositionOffset(cellStyle, 3 , true ) - getPositionOffset(cellStyle, 1 , true ) - 2 );
	                        }
	                    }
	                    if (newHeight > 0) {
	                        $cellWrapperElement.height(newHeight);
	                    }
	                    if (!isNullOrUndefined(editorBounds.x)) {
	                        $cellWrapperElement.css('left', editorBounds.x + 'px');
	                    }
	                    if (!isNullOrUndefined(editorBounds.y)) {
	                        $cellWrapperElement.css('top', editorBounds.y + 'px');
	                    }
	                }
	            }
	        },
	        _updateEditorWrapper: function (cellWrapperElement, cellStyle, cellRect, context, needZoomPadding) {
	            var self = this, contentContainer = cellWrapperElement.firstChild, sheet = context.sheet;
	            var tempCellRect = getDomRect(cellRect);
	            updateEditorPosition(cellWrapperElement, cellStyle, tempCellRect, context);
	            if (needZoomPadding && sheet) {
	                adjustZoomPadding(cellStyle, sheet.zoom());
	            }
	            $(contentContainer).css({
	                left: getPositionOffset(cellStyle, 3 ),
	                top: getPositionOffset(cellStyle, 0 )
	            });
	            var editor = contentContainer.firstChild;
	            var contentRect = self._getContentRect ? self._getContentRect(tempCellRect, cellStyle) : tempCellRect;
	            var editorBounds = self.updateEditor(editor, cellStyle, contentRect, context);
	            self.updateEditorContainer(editor, editorBounds, cellStyle);
	        },
	        _getHitInfoWrapper: function (x, y, cellStyle, cellRect, context) {
	            var self = this;
	            var contentRect = self._getContentRect ? self._getContentRect(cellRect, cellStyle) : cellRect;
	            return self.getCellAndPaddingHitInfo(x, y, cellStyle, contentRect, context);
	        },
	        _getAutoFitContainerWidth: function (value, text, cellStyle, zoomFactor, context) {
	            return getOutlineColumnOffset(context) + getPositionOffset(cellStyle, 3 , false, zoomFactor) + getPositionOffset(cellStyle, 1 , false, zoomFactor) + this.getAutoFitWidth(value, text, cellStyle, zoomFactor, context);
	        },
	        _getAutoFitContainerHeight: function (value, text, cellStyle, zoomFactor, context) {
	            return getPositionOffset(cellStyle, 0 , false, zoomFactor) + getPositionOffset(cellStyle, 2 , false, zoomFactor) + this.getAutoFitHeight(value, text, cellStyle, zoomFactor, context);
	        },
	        paintValue: function (ctx, value, x, y, w, h, style, options) {
	            var formattedData = {}, text;
	            options.quotePrefix = style.quotePrefix;
	            text = this.format(convertRichTextValue(value), style.formatter || style._autoFormatter, formattedData, options);
	            if (text) {
	                this.paintText(ctx, value, x, y, w, h, style, options, text, formattedData);
	            }
	        },
	        _getIndent: function (textIndent, outlineColumn, col) {
	            var indent = 0;
	            if (textIndent > 0) {
	                indent = textIndent * 8;
	            }
	            if (outlineColumn && outlineColumn._isOutlineColumn(col)) {
	                indent = 0;
	            }
	            return indent;
	        },
	
	        _isRichTextAvailable: function (formatter) {
	            return !formatter
	                || ((isType(formatter, const_string) && formatter === const_general)
	                    || (formatter && formatter.formatString && formatter.formatString() === const_general));
	        },
	
	        paintText: function (ctx, value, x, y, w, h, style, options, text, formattedData, opacity) {
	            var self = this;
	            ctx.save();
	            ctx.beginPath();
	
	           
	            if ((value && value.richText && value.richText.length > 0)
	                || style.isVerticalText) {
	                self._paintRichTextOrVerticalText(ctx, value, x, y, w, h, style, options, text, formattedData, opacity);
	            } else {
	                self._paintHorizontalText(ctx, value, x, y, w, h, style, options, text, formattedData, opacity);
	            }
	            ctx.restore();
	        },
	
	        _paintRichTextOrVerticalText: function (ctx, value, x, y, w, h, style, options, text, formattedData, opacity) {
	            var self = this;
	            var indent = self._getIndent(style.textIndent, options.sheet.outlineColumn, options.col);
	
	            var hAlign = style.hAlign;
	            if (hAlign === 3 ) {
	                hAlign = getHAlignByValueType(hAlign, value, style.formatter);
	            }
	
	            var isVerticalText = style.isVerticalText;
	            var isCJKText = isVerticalText ? _isCJKText(text) : false;
	
	            var defaultFont = style.font;
	            var formatter = style.formatter || style._autoFormatter;
	            var isRichTextAvailable = self._isRichTextAvailable(formatter);
	            var richText = extend(true, [], self._getRichTextValue(value, text, isRichTextAvailable, defaultFont, style.foreColor));
	
	           
	           
	           
	            if (value && value.richText && value.richText.length > 0) {
	                var zoomFactor = options.sheet ? options.sheet.zoom() : 1;
	                self._scaleFontByZoomFactor(richText, defaultFont, zoomFactor);
	            }
	
	            if (!style.wordWrap && style.shrinkToFit) {
	                self._scaleFontByShrinkToFit(richText, w, h, style, defaultFont, 1, isVerticalText);
	            }
	
	            var data = self._processDataByWordWrap(ctx, text, style.font, isVerticalText ? h : w, indent, isVerticalText ? style.vAlign : style.hAlign, style.wordWrap, isVerticalText, richText);
	
	            var linesStyle = self._getLinesStyle(data, style, hAlign, opacity);
	
	            var rect = self._clipRect(ctx, style, x, y, w, h, style.wordWrap, options.cellOverflowLayout, hAlign, indent, isVerticalText, data[0].textLength, linesStyle[0].lineHeight);
	
	            var paintPositions = self._calcPaintPositions(x, y, w, h, hAlign, style.vAlign, indent, isVerticalText, isCJKText, data, linesStyle);
	
	            var count = data.length;
	            if (count === 1 && formattedData && !isRichTextAvailable) {
	                self._paintFormattedData(ctx, options.sheet, text, formattedData, paintPositions[0].x, paintPositions[0].y, w, h, hAlign, style, rect.width, rect.height, indent, isVerticalText, data[0].textLength);
	            } else {
	                for (var i = 0; i < count; i++) {
	                    self._paintEntireLineOfText(ctx, options.sheet, paintPositions[i].x, paintPositions[i].y, linesStyle[i], hAlign, data[i]);
	                }
	            }
	        },
	
	        _paintHorizontalText: function (ctx, value, x, y, w, h, style, options, text, formattedData, opacity) {
	            var self = this, indent = 0, textIndent = style.textIndent, wordWrap = style.wordWrap, hAlign = style.hAlign,
	                vAlign = style.vAlign, shrinkToFit = style.shrinkToFit,
	                textDecoration = style.textDecoration, textAlign = 'left', adjX = 2,
	                adjY = 2, font = style.font,
	                textHeight = 0, lineHeight = options.lineHeight, lines = [], lineCount = 0,
	                fontSize = options.fontInfo.fontSize, sheet = options.sheet;
	
	            var fillStyle = style.foreColor;
	            fillStyle = _ThemeStyleHelper._getColorStringFromThemeColor(sheet, fillStyle);
	            var conditionalForeColor = formattedData.conditionalForeColor;
	            if (conditionalForeColor) {
	                fillStyle = conditionalForeColor;
	            }
	            opacity = !isNullOrUndefined(style.opacity) ? style.opacity : opacity;
	            if (!isNullOrUndefined(opacity)) {
	                var color = _ColorHelper._fromString(fillStyle);
	                color.a = opacity;
	                fillStyle = _ColorHelper._toString(color);
	            }
	            if (ctx.fillStyle !== fillStyle) {
	                ctx.fillStyle = fillStyle;
	            }
	
	            if (textIndent > 0) {
	                indent = textIndent * 8;
	            }
	            if (sheet.outlineColumn && sheet.outlineColumn._isOutlineColumn(options.col)) {
	               
	                indent = 0;
	            }
	            if (hAlign === 3 ) {
	                hAlign = getHAlignByValueType(hAlign, value, style.formatter);
	            }
	
	            setContextFont(ctx, font);
	            if (!wordWrap && shrinkToFit) {
	                var space = 0;
	                var minFont = {value: false};
	                for (var i = 0; i < 3 && minFont.value === false; i++) {
	                    var textLength = ctx.measureText(text).width;
	                    space = Math_max(0, w - 4);
	                    if (space < textLength) {
	                        font = StyleHelper._scaleFont(font, space / textLength, minFont, true).font;
	                        setContextFont(ctx, font);
	                    } else {
	                        break;
	                    }
	                }
	            }
	
	           
	            adjX += indent;
	            if (hAlign === 1 ) {
	                adjX = w / 2;
	                textAlign = cssCenter;
	            } else if (hAlign === 2 ) {
	                adjX = w - 1 - 2;
	                adjX -= indent;
	                textAlign = cssRight;
	            }
	            if (ctx.textAlign !== textAlign) {
	                ctx.textAlign = textAlign;
	            }
	           
	            if (wordWrap) {
	               
	               
	                var wordWrapWidth = w - 3 - indent;
	                wordWrapWidth -= 1;
	                lines = _WordWrapHelper._getWrapInfo(text, wordWrapWidth, font);
	                lineCount = lines.length;
	                if (lineCount > 1 && vAlign !== 0 ) {
	                    textHeight = (lineCount - 1) * lineHeight;
	                }
	            }
	            var baselineOffset = fontSize > 8 ? Math_floor((fontSize - 8) / 5 + 2) : 1,
	                lineOffset = lineHeight / 2 - fontSize / 2 + baselineOffset - 1;
	            adjY += lineHeight - lineOffset;
	            if (vAlign === 1 ) {
	                adjY = (h - textHeight) / 2 + lineHeight / 2 - lineOffset;
	            } else if (vAlign === 2 ) {
	                adjY = h - textHeight - 2 - lineOffset;
	            }
	            if (ctx.textBaseline !== textBaseline) {
	                ctx.textBaseline = textBaseline;
	            }
	           
	            var cellOverflowlayout = options.cellOverflowLayout,
	                layout = (cellOverflowlayout && cellOverflowlayout.layout);
	            var clipRect = {
	                x: layout ? layout.x : x + 1,
	                y: layout ? layout.y : y + 1,
	                width: layout ? layout.width : w - 2,
	                height: layout ? layout.height : h - 2
	            };
	            var hasOverflowed = layout && layout.width > w;
	            var clipX = clipRect.x, clipY = clipRect.y, clipWidth = clipRect.width, clipHeight = clipRect.height;
	            if (wordWrap) {
	                ctx.rect(clipX, clipY, clipWidth, clipHeight);
	                ctx.clip();
	                ctx.beginPath();
	                var vpos = y + adjY;
	                if (lineCount > 1) {
	                    for (i = 0; i < lineCount; i++) {
	                        ctx.fillText(lines[i], x + adjX, vpos);
	                        if (textDecoration) {
	                            textLength = ctx.measureText(lines[i]).width;
	                            self._renderTextDecoration(ctx, textDecoration, x + adjX, vpos, textLength, fontSize, baselineOffset);
	                        }
	                        vpos += lineHeight;
	                    }
	                } else {
	                    self._renderCellTextNormal(ctx, text, formattedData, x + adjX, y + adjY, hAlign, clipWidth, indent, textDecoration, baselineOffset, fontSize, hasOverflowed);
	                }
	            } else {
	               
	                var txtWidth = ctx.measureText(text).width,
	                    needClip = (txtWidth > clipWidth - ((x + 1) - clipX) || lineHeight > clipHeight);
	               
	                var topOffset = getPositionOffset(style, 0 ),
	                    rightOffset = getPositionOffset(style, 1 ),
	                    bottomOffset = getPositionOffset(style, 2 ),
	                    leftOffset = getPositionOffset(style, 3 );
	                if (!needClip) {
	                    if (hAlign === 1 ) {
	                        if (cellOverflowlayout) {
	                            var txtHalfWidth = txtWidth / 2;
	                            if (txtHalfWidth > cellOverflowlayout.backgroundLeftWidth || txtHalfWidth > cellOverflowlayout.backgroundRightWidth) {
	                                needClip = true;
	                            }
	                        }
	                    } else if (txtWidth + indent + topOffset + bottomOffset > clipWidth || textHeight + leftOffset + rightOffset > clipHeight) {
	                        needClip = true;
	                    }
	                }
	               
	                if (needClip) {
	                    ctx.rect(clipX, clipY, clipWidth, clipHeight);
	                    ctx.clip();
	                    ctx.beginPath();
	                }
	                self._renderCellTextNormal(ctx, text, formattedData, x + adjX, y + adjY, hAlign, clipWidth, indent, textDecoration, baselineOffset, fontSize, hasOverflowed);
	            }
	        },
	
	        _scaleFontByZoomFactor: function (richText, defaultFont, zoomFactor) {
	            scaleFontByZoomFactor(richText, defaultFont, zoomFactor);
	        },
	
	        _scaleFontByShrinkToFit: function (richText, width, height, style, defaultFont, zoomFactor, isVerticalText) {
	            var space = 0;
	            var minFont = {value: false};
	            for (var i = 0; i < 3 && minFont.value === false; i++) {
	                var textLength = getTextLengthInLine(richText, defaultFont, zoomFactor, isVerticalText);
	                space = Math_max(0, (isVerticalText ? height : width) - 4);
	                if (isVerticalText ? style.vAlign : style.hAlign !== 1 && style.textIndent) {
	                    space = Math_max(0, space - style.textIndent * 8);
	                }
	                if (space < textLength) {
	                    for (var j = 0; j < richText.length; j++) {
	                        richText[j].style.font = StyleHelper._scaleFont(richText[j].style.font, space / textLength, minFont, true).font;
	                    }
	                } else {
	                    break;
	                }
	            }
	        },
	
	        _getRichTextValue: function (value, text, isRichTextAvailable, defaultFont, foreColor) {
	            var richText = value.richText;
	            if (isNullOrUndefined(richText) || !isRichTextAvailable) {
	                richText = [{
	                    style: {
	                        font: defaultFont,
	                        foreColor: foreColor
	                    },
	                    text: text
	                }];
	            }
	            return richText;
	        },
	        _clipRect: function (ctx, style, x, y, w, h, wordWrap, cellOverflowLayout, hAlign, indent, isVertical, textLength, lineHeight) {
	            var layout = cellOverflowLayout && cellOverflowLayout.layout;
	            var clipRect = {
	                x: layout ? layout.x : x + 1,
	                y: layout ? layout.y : y + 1,
	                width: layout ? layout.width : w - 2,
	                height: layout ? layout.height : h - 2
	            };
	            var clipX = clipRect.x, clipY = clipRect.y, clipWidth = clipRect.width, clipHeight = clipRect.height;
	            if (wordWrap) {
	                ctx.rect(clipX, clipY, clipWidth, clipHeight);
	                ctx.clip();
	                ctx.beginPath();
	            } else {
	                var needClip = this._needClip(style, hAlign, style.vAlign, x, y, clipHeight, clipWidth, clipX, clipY, textLength, lineHeight, indent, isVertical, cellOverflowLayout);
	                if (needClip) {
	                    ctx.rect(clipX, clipY, clipWidth, clipHeight);
	                    ctx.clip();
	                    ctx.beginPath();
	                }
	            }
	            return clipRect;
	        },
	        _needClip: function (style, hAlign, vAlign, x, y, clipHeight, clipWidth, clipX, clipY, textLength, lineHeight, indent, isVertical, cellOverflowlayout) {
	            var needClip;
	           
	            var topOffset = getPositionOffset(style, 0 ),
	                rightOffset = getPositionOffset(style, 1 ),
	                bottomOffset = getPositionOffset(style, 2 ),
	                leftOffset = getPositionOffset(style, 3 );
	            if (isVertical) {
	                needClip = textLength > clipHeight - ((y + 1) - clipY) || lineHeight > clipWidth;
	                if (!needClip && vAlign !== 1  && textLength + indent + topOffset + bottomOffset > clipHeight || lineHeight + leftOffset + rightOffset > clipWidth) {
	                    needClip = true;
	                }
	            } else {
	                needClip = textLength > clipWidth - ((x + 1) - clipX) || lineHeight > clipHeight;
	                if (!needClip) {
	                    if (hAlign === 1 ) {
	                        if (cellOverflowlayout) {
	                            var txtHalfWidth = textLength / 2;
	                            if (txtHalfWidth > cellOverflowlayout.backgroundLeftWidth || txtHalfWidth > cellOverflowlayout.backgroundRightWidth) {
	                                needClip = true;
	                            }
	                        }
	                    } else if (textLength + indent + leftOffset + rightOffset > clipWidth || lineHeight + topOffset + bottomOffset > clipHeight) {
	                        needClip = true;
	                    }
	                }
	            }
	            return needClip;
	        },
	        _processDataByWordWrap: function (ctx, text, font, size, indent, textAlign, wordWrap, isVerticalText, richText) {
	            if (textAlign !== 1 ) {
	                size = size - 3 - indent;
	            } else {
	                size = size - 3;
	            }
	            if (wordWrap) {
	                return _WordWrapHelper._getWordWrapInfo(text, size, font, richText, isVerticalText);
	            }
	            var textLength = 0;
	            for (var i = 0; i < richText.length; i++) {
	                if (isVerticalText) {
	                    textLength += getFontHeight(richText[i].style.font) * richText[i].text.length;
	                } else {
	                    textLength += measureTextWidth(ctx, richText[i].style.font, richText[i].text);
	                }
	            }
	            return [{
	                textLength: textLength,
	                text: text,
	                textInfos: richText
	            }];
	        },
	        _paintFormattedData: function (ctx, sheet, text, formattedData, x, y, w, h, hAlign, style, clipWidth, clipHeight, indent, isVertical, textLength) {
	            var font = style.font;
	            var lineHeight = getFontHeight(font);
	            var fontSize = StyleHelper._scaleFont(font, 1).fontSize;
	            var baselineOffset = fontSize > 8 ? Math_floor((fontSize - 8) / 5 + 2) : 1;
	            this._setContext(ctx, sheet, style);
	           
	            var conditionalForeColor = formattedData.conditionalForeColor;
	            if (conditionalForeColor && ctx.fillStyle !== conditionalForeColor) {
	                ctx.fillStyle = conditionalForeColor;
	            }
	            if (isVertical) {
	                this._renderVerticalFormattedData(ctx, text, formattedData, style, x, y, clipHeight, indent, lineHeight);
	            } else {
	                var hasOverflowed = clipWidth > w;
	                this._renderCellTextNormal(ctx, text, formattedData, x, y, hAlign, clipWidth, indent, style.textDecoration, baselineOffset, fontSize, hasOverflowed, textLength);
	            }
	        },
	        _renderVerticalFormattedData: function (ctx, text, formattedData, style, x, y, clipHeight, indent, lineHeight) {
	            var textContent = formattedData.content;
	            var i;
	            if (textContent && textContent.length > 0) {
	                var textHeight = getTextContentWidth(ctx, textContent, true, lineHeight);
	                var infillingHeight = clipHeight - indent - textHeight - 2;
	                infillingHeight = infillingHeight > 0 ? infillingHeight : 0;
	                var filledHeight;
	                for (i = 0; i < textContent.length; i++) {
	                    if (textContent[i].type === 'fillingChar') {
	                        var fillText = createInfillingText(ctx, infillingHeight, textContent[i].value, true, lineHeight);
	                        this._fillVerticalText(ctx, fillText, x, y, lineHeight);
	                        y += infillingHeight;
	                    } else if (textContent[i].type === 'placeholder') {
	                        y += textContent[i].value ? textContent[i].value.length * lineHeight : 0;
	                    } else if (textContent[i].type === 'numberPlaceholder') {
	                        y += lineHeight;
	                    } else {
	                        this._fillVerticalText(ctx, textContent[i].value, x, y, lineHeight);
	                        filledHeight = textContent[i].value ? textContent[i].value.length * lineHeight : 0;
	                        y += filledHeight;
	                    }
	                }
	            } else if (text) {
	                for (i = 0; i < text.length; i++) {
	                    this._fillVerticalText(ctx, text[i], x, y, lineHeight);
	                }
	            }
	        },
	        _getTextAlign: function (hAlign) {
	            var textAlign = cssLeft;
	            if (hAlign === 1 ) {
	                textAlign = cssCenter;
	            } else if (hAlign === 2 ) {
	                textAlign = cssRight;
	            }
	            return textAlign;
	        },
	        _paintEntireLineOfText: function (ctx, sheet, x, y, lineStyle, textAlign, data) {
	            var actualStyles = [], textInfos = data.textInfos;
	            for (var i = 0; i < textInfos.length; i++) {
	                actualStyles.push(extend(true, {}, lineStyle, textInfos[i].style));
	            }
	            for (i = 0; i < textInfos.length; i++) {
	                var pos = this._paintText(ctx, sheet, x, y, actualStyles[i], textInfos[i].text);
	                x = pos.x;
	                y = pos.y;
	            }
	        },
	        _getLinesStyle: function (data, style, hAlign, opacity) {
	            var linesStyle = [], count = data.length;
	            for (var i = 0; i < count; i++) {
	                var lineStyle = this._getLineStyle(style, hAlign, opacity, data[i].textInfos);
	                linesStyle.push(lineStyle);
	            }
	            return linesStyle;
	        },
	        _getLineStyle: function (style, hAlign, opacity, data) {
	            var self = this;
	            var maxHeightInLine = 0, maxFontSizeInline = 0, maxSubscriptOrSuperscriptFontSizeInline = 0;
	           
	            for (var i = 0; i < data.length; i++) {
	                var font;
	                if (data[i].style && data[i].style.font) {
	                    font = data[i].style.font;
	                } else {
	                    font = style.font;
	                }
	
	                if (data[i].style && data[i].style.vertAlign === 2) {
	                    maxSubscriptOrSuperscriptFontSizeInline = font;
	                }
	                maxHeightInLine = Math.max(getFontHeight(font), maxHeightInLine);
	                maxFontSizeInline = Math.max(StyleHelper._scaleFont(font, 1).fontSize, maxFontSizeInline);
	                if (data[i].style && (data[i].style.vertAlign === 1) || (data[i].style.vertAlign === 2)) {
	                    maxHeightInLine = Math.max(getFontHeight(font) + StyleHelper._scaleFont(font, 1).fontSize * 2 / 3, maxHeightInLine);
	                }
	            }
	            var baselineOffset = maxFontSizeInline > 8 ? Math_floor((maxFontSizeInline - 8) / 5 + 2) : 1;
	            var lineOffset;
	            if (maxSubscriptOrSuperscriptFontSizeInline !== 0) {
	               
	                lineOffset = Math_max(maxHeightInLine / 2 - maxFontSizeInline / 2, StyleHelper._scaleFont(maxSubscriptOrSuperscriptFontSizeInline, 1).fontSize / 3) + baselineOffset - 1;
	            } else {
	                lineOffset = maxHeightInLine / 2 - maxFontSizeInline / 2 + baselineOffset - 1;
	            }
	            return {
	                lineHeight: maxHeightInLine,
	                fontSize: maxFontSizeInline,
	                baselineOffset: baselineOffset,
	                lineOffset: lineOffset,
	                font: style.font,
	                foreColor: style.foreColor,
	                textDecoration: style.textDecoration,
	                isVerticalText: style.isVerticalText,
	                textAlign: self._getTextAlign(hAlign),
	                textBaseline: textBaseline,
	                opacity: opacity
	            };
	        },
	        _calcTextSize: function (data, linesStyle, isVertical) {
	            var width = 0, height = 0, i;
	            for (i = 0; i < data.length; i++) {
	                height += linesStyle[i].lineHeight;
	                width = Math.max(data[i].textLength, width);
	            }
	            return {
	                width: isVertical ? height : width,
	                height: isVertical ? width : height
	            };
	        },
	        _calcPaintPositions: function (x, y, w, h, hAlign, vAlign, indent, isVertical, isCJKText, data, linesStyle) {
	            var textSize = this._calcTextSize(data, linesStyle, isVertical);
	            var textHeight = textSize.height;
	            var textWidth = textSize.width;
	            var positions = [], i;
	            if (isVertical) {
	                for (i = 0; i < data.length; i++) {
	                    positions.push(this._calcVerticalPaintPosition(x, y, w, h, hAlign, vAlign, indent, textWidth,
	                        data[i].textLength, linesStyle[i].lineHeight, linesStyle[i].lineOffset, isCJKText));
	                    if (isCJKText) {
	                        x -= linesStyle[i].lineHeight;
	                    } else {
	                        x += linesStyle[i].lineHeight;
	                    }
	                }
	            } else {
	                for (i = 0; i < data.length; i++) {
	                    positions.push(this._calcHorizontalPaintPosition(x, y, w, h, hAlign, vAlign, indent,
	                        data[i].textLength, textHeight, linesStyle[i].lineHeight, linesStyle[i].lineOffset));
	                    y += linesStyle[i].lineHeight;
	                }
	            }
	            return positions;
	        },
	
	        _calcHorizontalPaintPosition: function (x, y, w, h, hAlign, vAlign, indent, textWidth, textHeight, lineHeight, lineOffset) {
	            var deltaX = 0, deltaY = 0;
	            if (vAlign === 1 ) {
	                deltaY = (h - textHeight) / 2 + lineHeight - lineOffset;
	            } else if (vAlign === 2 ) {
	                deltaY = h - textHeight - 2 + lineHeight - lineOffset;
	            } else { 
	                deltaY = 2 + lineHeight - lineOffset;
	            }
	            if (hAlign === 1 ) {
	                deltaX = (w - textWidth) / 2;
	            } else if (hAlign === 2 ) {
	                deltaX = w - 1 - 2 - textWidth;
	                deltaX -= indent;
	            } else { 
	                deltaX = 2 + indent;
	            }
	            return {
	                x: x + deltaX,
	                y: y + deltaY
	            };
	        },
	
	        _calcVerticalPaintPosition: function (x, y, w, h, hAlign, vAlign, indent, textWidth, textHeight, lineHeight, lineOffset, isCJKText) {
	            var deltaX = 0, deltaY = 0;
	           
	            if (isCJKText) {
	               
	                if (hAlign === 0 ) {
	                    deltaX = 2 + textWidth - lineHeight / 2;
	                } else if (hAlign === 1 ) {
	                    deltaX = (w + textWidth) / 2 - lineHeight / 2;
	                } else if (hAlign === 2 ) {
	                    deltaX = w - 1 - 2 - lineHeight / 2;
	                }
	            } else if (hAlign === 1 ) {
	                deltaX = (w - textWidth) / 2 + lineHeight / 2;
	            } else if (hAlign === 2 ) {
	               
	                deltaX = w - 1 - 2 - textWidth + lineHeight / 2;
	            } else if (hAlign === 0 ) {
	                deltaX = 2 + lineHeight / 2;
	            }
	            if (vAlign === 1 ) {
	                deltaY = (h - textHeight) / 2 + lineHeight - lineOffset;
	            } else if (vAlign === 2 ) {
	                deltaY = h - indent - textHeight - 2 + lineHeight - lineOffset;
	            } else { 
	                deltaY = 2 + indent + lineHeight - lineOffset;
	            }
	            return {
	                x: x + deltaX,
	                y: y + deltaY
	            };
	        },
	
	        _paintText: function (ctx, sheet, x, y, style, text) {
	            ctx.save();
	            this._setContext(ctx, sheet, style);
	            var subscriptOrSuperscriptInfo = style.vertAlign;
	            var lineHeight = util_common_util._getFontHeight(style.font);
	            var pos;
	            if (style.isVerticalText) {
	                pos = this._fillVerticalText(ctx, text, x, y, lineHeight);
	            } else {
	                pos = this._fillHorizontalText(ctx, x, y, style, text, subscriptOrSuperscriptInfo);
	            }
	            ctx.restore();
	            return pos;
	        },
	        _setContext: function (ctx, sheet, style) {
	            var fillStyle = style.foreColor, opacity = style.opacity;
	            fillStyle = _ThemeStyleHelper._getColorStringFromThemeColor(sheet, fillStyle);
	            if (!isNullOrUndefined(opacity)) {
	                var color = _ColorHelper._fromString(fillStyle);
	                color.a = opacity;
	                fillStyle = _ColorHelper._toString(color);
	            }
	            if (ctx.fillStyle !== fillStyle) {
	                ctx.fillStyle = fillStyle;
	            }
	            var font = style.vertAlign ? this._getSubscriptOrSuperscriptFontInfo(style.font) : style.font;
	            if (!isNullOrUndefined(style.textBaseline) && ctx.textBaseline !== style.textBaseline) {
	                ctx.textBaseline = style.textBaseline;
	            } else if (isNullOrUndefined(ctx.textBaseline) && ctx.textBaseline !== textBaseline) {
	                ctx.textBaseline = textBaseline;
	            }
	            if (style.isVerticalText) {
	                if (ctx.textAlign !== cssCenter) {
	                    ctx.textAlign = cssCenter;
	                }
	            } else if (ctx.textAlign !== cssLeft) {
	                ctx.textAlign = cssLeft;
	            }
	            setContextFont(ctx, font);
	        },
	        _getSubscriptOrSuperscriptFontInfo: function (font) {
	            var originalFontInfo = StyleHelper._splitFont(font);
	            var fontSize = parseFloat(originalFontInfo.fontSize) * subscriptAndSuperscriptScale;
	            originalFontInfo.fontSize = fontSize + "px";
	            return this._buildSubscriptOrSuperscriptFontInfoString(originalFontInfo);
	        },
	        _buildSubscriptOrSuperscriptFontInfoString: function (fontInfo) {
	            var f = '';
	            var normal = 'normal';
	            var defaultFontFamily = 'Calibri';
	            var fontStyle = fontInfo.fontStyle, fontSize = fontInfo.fontSize, fontWeight = fontInfo.fontWeight,
	                fontFamily = fontInfo.fontFamily;
	            if (fontStyle !== undefined) {
	                f = fontStyle;
	            } else {
	                f = normal;
	            }
	            if (fontWeight !== undefined) {
	                f += (f ? ' ' : '') + fontWeight;
	            } else {
	                f += (f ? ' ' : '') + normal;
	            }
	            f += (f ? ' ' : '') + fontSize;
	            if (fontFamily !== undefined) {
	                f += (f ? ' ' : '') + fontFamily;
	            } else {
	                f += (f ? ' ' : '') + defaultFontFamily;
	            }
	            return f;
	        },
	        _fillVerticalText: function (ctx, text, x, y, lineHeight) {
	            if (text && text.length > 0) {
	                for (var i = 0; i < text.length; i++) {
	                    ctx.fillText(text[i], x, y);
	                    y += lineHeight;
	                }
	            }
	            return {
	                x: x,
	                y: y
	            };
	        },
	        _fillHorizontalText: function (ctx, x, y, style, text, subscriptOrSuperscriptInfo) {
	            if (isNullOrUndefined(text)) {
	                return {
	                    x: x,
	                    y: y
	                };
	            }
	            var fontSize = StyleHelper._scaleFont(ctx.font, 1).fontSize,
	                offset = fontSize > 8 ? Math_floor((fontSize - 8) / 5 + 2) : 1, subscriptOrSuperscriptOffset = 0;
	           
	            if (subscriptOrSuperscriptInfo) {
	               
	               
	               
	                subscriptOrSuperscriptOffset = subscriptOrSuperscriptInfo === 1 ? fontSize / 3 : -fontSize / 3;
	                ctx.fillText(text, x, y - subscriptOrSuperscriptOffset);
	            } else {
	                ctx.fillText(text, x, y);
	            }
	            var length = measureTextWidth(ctx, ctx.font, text);
	            var textDecoration = style.textDecoration;
	            this._renderTextDecoration(ctx, textDecoration, x, y, length, fontSize, offset - subscriptOrSuperscriptOffset);
	            return {
	                x: x + length,
	                y: y
	            };
	        },
	       
	        
	        paint: function (ctx, value, x, y, w, h, style, context) {
	            if (!ctx) {
	                return;
	            }
	            var styleBackColor = style.backColor;
	            if (context.parentBackColor !== styleBackColor) {
	               
	                cellTypeContext_paintBackground(ctx, x, y, w, h, styleBackColor, style.backgroundImage, style.backgroundImageLayout, context.imageLoader);
	            }
	            var originalCellRect = new Rect(x, y, w, h);
	            var self = this, cellOverflowlayout = context.cellOverflowLayout,
	                layout = (cellOverflowlayout && cellOverflowlayout.layout);
	            var rect = new Rect(layout ? layout.x : x, layout ? layout.y : y, layout ? layout.width : w, layout ? layout.height : h);
	            if (self._paintPadding && !context.cellOverflowLayout) {
	                rect = self._paintPadding(ctx, rect, style, context, convertRichTextValue(value));
	            }
	
	            if (rect.width > 0 && rect.height > 0) {
	                self.paintContent(ctx, value, rect.x, rect.y, rect.width, rect.height, style, context, originalCellRect);
	            }
	        },
	       
	        
	        paintContent: function (ctx, value, x, y, w, h, style, context, originalCellRect) {
	           
	            var sheetArea = context.sheetArea;
	            if (sheetArea === 2  || sheetArea === 1 ) {
	                var visualState = context.visualState || 0 ;
	                var headerTypeString = 'columnHeader';
	                if (sheetArea === 2 ) {
	                    headerTypeString = 'rowHeader';
	                }
	                var themeStyle = this.getThemeStyle(context.visualState, 'gc-' + headerTypeString + '-' + _ThemeStyleHelper._getString(visualState));
	                CellTypeContext._paintHeaderCellGridline(ctx, x, y, w, h, style, headerTypeString, themeStyle, sheetArea);
	            }
	
	           
	            var showBarIconOnly, conditionalFormats = context.conditionalFormats;
	            if (conditionalFormats) {
	                if (originalCellRect) {
	                    showBarIconOnly = conditionalFormats._paint(ctx, convertRichTextValue(value), originalCellRect.x, originalCellRect.y, originalCellRect.width, originalCellRect.height, style, context);
	                } else {
	                    showBarIconOnly = conditionalFormats._paint(ctx, convertRichTextValue(value), x, y, w, h, style, context);
	                }
	            }
	            context.showBarIconOnly = showBarIconOnly;
	           
	            var sparkline = context.sparkline;
	            if (sparkline) {
	                sparkline.paintSparkline(ctx, x, y, w, h);
	            }
	           
	            var showSparklineEx = cellTypeContext_paintSparklineEx(ctx, convertRichTextValue(value), x, y, w, h, context.sheet);
	           
	            if (!context.cellOverflowLayout && !showBarIconOnly && !showSparklineEx) {
	                var rect = new Rect(x, y, w, h);
	                cellTypeContext_adjustRectForIconSet(style.hAlign, context.sheet, context.row, context.col, context.sheetArea, rect);
	                this.paintValue(ctx, value, rect.x, rect.y, rect.width, rect.height, style, context);
	            }
	        },
	       
	        
	        createEditorElement: function (context) { 
	            return keyword_null;
	        },
	       
	        
	        getEditorValue: function (editorContext, context) { 
	            return keyword_null;
	        },
	        _formatEditorValue: function (editorContext, cellStyle, value, context) { 
	            return value;
	        },
	       
	        
	        setEditorValue: function (editorContext, value, context) { 
	        },
	        getEditingElement: function () {
	            return keyword_null;
	        },
	       
	        
	        parse: function (text, formatStr, context) { 
	            var formatStrIsNull = isNullOrUndefined(formatStr), textIsNull = isNullOrUndefined(text);
	            try {
	                var Formatter_module = __webpack_require__(6);
	                var GeneralFormatter = Formatter_module && Formatter_module.GeneralFormatter;
	                if (!formatStrIsNull && !textIsNull && GeneralFormatter) {
	                    var formatter = (typeof (formatStr) === const_string ? new GeneralFormatter(formatStr) : formatStr);
	                    return formatter.parse(text);
	                }
	            } catch (ex) {
	               
	            }
	            return textIsNull ? '' : text.toString();
	        },
	       
	        
	        format: function (value, format, formattedData, context) {
	            if (isNullOrUndefined(value) || value === '') {
	                return '';
	            }
	            if (context && context.quotePrefix) {
	                return value.toString();
	            }
	            if (typeof format === const_string && typeof value !== 'object') {
	                return _CacheMgr._getFormattedText(value, format, formattedData);
	            }
	            if (!format) {
	                if (typeof value === 'boolean' || value instanceof Boolean) {
	                    return value.toString().toUpperCase();
	                } else if (value instanceof Date) {
	                    var DateTimeFormat = CultureManager._getCultureInfo(CultureManager.culture()).DateTimeFormat;
	                    return _DateTimeHelper._localeFormat(value, DateTimeFormat.shortDatePattern + ' H:mm:ss');
	                }
	                if (typeof value === const_number) {
	                    value = _NumberHelper._replaceNormalToCultureSymbol(value.toString());
	                }
	                return value.toString();
	            }
	
	            try {
	                var Formatter_module = __webpack_require__(6);
	                var GeneralFormatter = Formatter_module && Formatter_module.GeneralFormatter;
	                if (GeneralFormatter) {
	                    var formatter = keyword_null;
	                    if (typeof format === const_string) {
	                        formatter = _CacheMgr._getFormatter(format);
	                    } else {
	                        formatter = format;
	                    }
	                    return formatter.format(value, formattedData);
	                }
	
	                return value.toString();
	            } catch (ex) {
	                return value.toString();
	            }
	        },
	       
	        
	        focus: function (editorContext, context) { 
	            if (editorContext && editorContext.focus) {
	                editorContext.focus();
	            }
	        },
	        getThemeStyle: function (visualState, defaultClass) {
	            
	            return _ThemeStyleHelper._getVisualStateThemeStyle(visualState, defaultClass);
	        },
	       
	        
	        activateEditor: function (editorContext, cellStyle, cellRect, context) { 
	        },
	       
	        
	        deactivateEditor: function (editorContext, context) { 
	        },
	       
	        
	        selectAll: function (editorContext, context) { 
	            if (editorContext && editorContext.select) {
	                editorContext.select();
	            }
	        },
	       
	        
	        updateEditor: function (editorContext, cellStyle, cellRect, context) { 
	        },
	        setImeMode: function (editorContext, imeMode, context) {
	            if (this.isImeAware(context)) {
	                this.updateImeMode(editorContext, imeMode, context);
	            } else if (editorContext) {
	                CellTypeContext._setImeMode(editorContext, 0 );
	            }
	        },
	       
	        
	        updateImeMode: function (editorContext, imeMode, context) { 
	            if (editorContext) {
	                CellTypeContext._setImeMode(editorContext, imeMode);
	            }
	        },
	       
	        
	        getHitInfo: function (x, y, cellStyle, cellRect, context) { 
	            return keyword_null;
	        },
	
	        getCellAndPaddingHitInfo: function (x, y, cellStyle, cellRect, context) {
	            if (context && context.sheetArea === 3) {
	                var paddingHitInfo = null;
	                var args = {
	                    x: x,
	                    y: y,
	                    context: context,
	                    cellStyle: cellStyle,
	                    cellRect: cellRect,
	                    paddingHitInfo: paddingHitInfo
	                };
	                BaseCellType._callFeatureHandler(context.sheet, 'getCellPaddingHitInfo', args);
	                if (args.paddingHitInfo) {
	                    return args.paddingHitInfo;
	                }
	                return this.getHitInfo(x, y, cellStyle, cellRect, context);
	            }
	            return this.getHitInfo(x, y, cellStyle, cellRect, context);
	        },
	       
	        
	        processCellAndPaddingMouseDown: function (hitInfo) {
	            BaseCellType._callFeatureHandler(hitInfo.sheet, 'processMouseDownOnCellPadding', hitInfo);
	            return this.processMouseDown(hitInfo);
	        },
	        processMouseDown: function (hitInfo) { 
	            return false;
	        },
	
	       
	        
	        processMouseMove: function (hitInfo) { 
	            return false;
	        },
	       
	        
	        processMouseUp: function (hitInfo) { 
	            return false;
	        },
	       
	        
	        processMouseEnter: function (hitInfo) { 
	        },
	       
	        
	        processMouseLeave: function (hitInfo) { 
	        },
	       
	        
	        isReservedKey: function (e, context) { 
	            return false;
	        },
	       
	        
	        isEditingValueChanged: function (oldValue, newValue, context) { 
	            return oldValue !== newValue;
	        },
	       
	        
	        processKeyDown: function (event, context) { 
	            return false;
	        },
	       
	        
	        processKeyUp: function (event, context) { 
	            return false;
	        },
	       
	        
	        getAutoFitWidth: function (value, text, cellStyle, zoomFactor, context) {
	            return CellTypeContext._getAutoFitWidth(value, text, cellStyle, zoomFactor, context);
	        },
	       
	        
	        getAutoFitHeight: function (value, text, cellStyle, zoomFactor, context) {
	            return CellTypeContext._getAutoFitHeight(value, text, cellStyle, zoomFactor, context);
	        },
	        _renderCellTextNormal: function (ctx, text, formattedData, adjustedX, adjustedY, hAlign, clipWidth, indent, textDecoration, baselineOffset, fontSize, hasOverflowed, textLength) {
	            if (formattedData && formattedData.content && formattedData.content.length > 0 && !hasOverflowed) {
	                this._paintTextObject(ctx, formattedData.content, adjustedX, adjustedY, hAlign, clipWidth, indent, textDecoration, baselineOffset, fontSize, textLength);
	            } else {
	                ctx.fillText(text, adjustedX, adjustedY);
	                if (textDecoration) {
	                    textLength = measureTextWidth(ctx, ctx.font, text);
	                    this._renderTextDecoration(ctx, textDecoration, adjustedX, adjustedY, textLength, fontSize, baselineOffset);
	                }
	            }
	        },
	        _paintTextObject: function (ctx, textContent, x, y, hAlign, clipWidth, indent, textDecoration, baselineOffset, fontSize, textLength) {
	            ctx.save();
	            if (ctx.textAlign !== cssLeft) {
	                ctx.textAlign = cssLeft;
	            }
	            var textContentWidth = getTextContentWidth(ctx, textContent);
	            var infillingWidth = clipWidth - indent - textContentWidth - 2;
	            infillingWidth = infillingWidth > 0 ? infillingWidth : 0;
	            if (!isNullOrUndefined(textLength)) {
	               
	               
	                if (hasInfilling(textContent)) {
	                    if (hAlign === 1 ) {
	                       
	                       
	                        x = x + (textLength ? textLength : textContentWidth) / 2 - clipWidth / 2;
	                        x += indent;
	                    } else if (hAlign === 2 ) {
	                        x = x + (textLength ? textLength : textContentWidth) - clipWidth + 2;//+ 2 is for the left and the right border line;
	                        x += indent;
	                    }
	                } else if (!isNullOrUndefined(textContentWidth)) {
	                    if (hAlign === 1 ) {
	                       
	                       
	                        x = x + textLength / 2 - textContentWidth / 2;
	                    } else if (hAlign === 2 ) {
	                        x = x + textLength - textContentWidth;
	                    }
	                }
	            } else if (hasInfilling(textContent)) {
	               
	                if (hAlign === 1 ) {
	                    x -= clipWidth / 2;
	                    x += indent;
	                } else if (hAlign === 2 ) {
	                    x = x - clipWidth + 2;//+ 2 is for the left and the right border line;
	                    x += indent;
	                }
	            } else if (!isNullOrUndefined(textContentWidth)) {
	               
	                if (hAlign === 1 ) {
	                    x -= textContentWidth / 2;
	                } else if (hAlign === 2 ) {
	                    x -= textContentWidth;
	                }
	            }
	
	            this._paintTextItem(ctx, textContent, x, y, infillingWidth, textDecoration, baselineOffset, fontSize);
	            ctx.restore();
	        },
	        _paintTextItem: function (ctx, text, x, y, infillingWidth, textDecoration, baselineOffset, fontSize) {
	            var filledWidth;
	            for (var i = 0; i < text.length; i++) {
	                if (text[i].type === 'fillingChar') {
	                    ctx.fillText(createInfillingText(ctx, infillingWidth, text[i].value), x, y);
	                    if (textDecoration) {
	                        this._renderTextDecoration(ctx, textDecoration, x, y, infillingWidth, fontSize, baselineOffset);
	                    }
	                    x += infillingWidth;
	                } else if (text[i].type === 'placeholder') {
	                    x += measureTextWidth(ctx, ctx.font, text[i].value);
	                } else if (text[i].type === 'numberPlaceholder') {
	                    x += measureTextWidth(ctx, ctx.font, '0');
	                } else {
	                    ctx.fillText(text[i].value, x, y);
	                    filledWidth = measureTextWidth(ctx, ctx.font, text[i].value);
	                    if (textDecoration) {
	                        this._renderTextDecoration(ctx, textDecoration, x, y, filledWidth, fontSize, baselineOffset);
	                    }
	                    x += filledWidth;
	                }
	            }
	        },
	        _renderTextDecoration: function (ctx, textDecoration, x, y, textLength, fontSize, offset) {
	            if (ctx.strokeStyle !== ctx.fillStyle) {
	                ctx.strokeStyle = ctx.fillStyle;
	            }
	            var textAlign = ctx.textAlign;
	            var vposY = 0, lineWidth = 0, posOffset = 0.5, fontSizeTemp;
	           
	           
	            fontSizeTemp = fontSize <= 12 ? 12 : fontSize;
	            lineWidth = Math_floor((fontSizeTemp - 12) / 21 + 1);
	            if (ctx.lineWidth !== lineWidth) {
	                ctx.lineWidth = lineWidth;
	            }
	            if ((lineWidth & 1) === 0) {
	                posOffset = 0;
	            }
	            if (textAlign === cssCenter) {
	                x = x - textLength / 2;
	            } else if (textAlign === cssRight) {
	                x = x - textLength;
	            }
	            ctx.beginPath();
	            if ((textDecoration & 4 ) === 4 ) {
	                vposY = Math_ceil(y + offset - fontSize - 1) - posOffset;
	                ctx.moveTo(x, vposY);
	                ctx.lineTo(x + textLength, vposY);
	            }
	            if ((textDecoration & 2 ) === 2 ) {
	                vposY = Math_ceil(y + offset - fontSize / 2) - posOffset;
	                ctx.moveTo(x, vposY);
	                ctx.lineTo(x + textLength, vposY);
	            }
	            if ((textDecoration & 1 ) === 1 ) {
	                vposY = Math_ceil(y + offset - 1) - posOffset;
	                ctx.moveTo(x, vposY);
	                ctx.lineTo(x + textLength, vposY);
	            }
	            if ((textDecoration & 8 ) === 8 ) {
	                vposY = Math_ceil(y + offset - 1) - posOffset;
	                ctx.moveTo(x, vposY - lineWidth) ;
	                ctx.lineTo(x + textLength, vposY - lineWidth);
	                ctx.moveTo(x, vposY + lineWidth);
	                ctx.lineTo(x + textLength, vposY + lineWidth);
	            }
	            ctx.stroke();
	        },
	        _setTextDecoration: function (content, textDecorationType) {
	            var textDecoration = '';
	            if ((textDecorationType & 4 ) === 4 ) {
	                textDecoration = 'overline';
	            }
	            if ((textDecorationType & 2 ) === 2 ) {
	                textDecoration += ' line-through';
	            }
	            if ((textDecorationType & 1 ) === 1 ) {
	                textDecoration += ' underline';
	            }
	            content.css('text-decoration', textDecoration);
	        },
	        _cloneCellType: function () {
	            return keyword_null;
	        },
	       
	        
	        isImeAware: function (context) { 
	            return false;
	        },
	        isEditting: function () {
	            return false;
	        },
	       
	        
	        toJSON: function () {
	            var settings = {}, self = this;
	            for (var p in self) {
	                if (self.hasOwnProperty(p)) {
	                    settings[p] = self[p];
	                }
	            }
	            return settings;
	        },
	       
	        
	        fromJSON: function (settings) {
	            if (settings) {
	                for (var p in settings) {
	                    if (!isNullOrUndefined(settings[p])) {
	                        this[p] = settings[p];
	                    }
	                }
	            }
	        }
	    };
	    CellTypes.Base = BaseCellType;
	    CellTypes._typeDict = {0 : BaseCellType};
	   
	
	    module.exports = exports;
	
	}());

/***/ }),
/* 14 */
/***/ (function(module, exports) {

	module.exports = GC.Spread.Sheets.Sparklines;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var exports = __webpack_require__(1),
	        util_common = __webpack_require__(3),
	        Common = __webpack_require__(5),
	        STYLE_MODULE = __webpack_require__(12),
	        _StyleHelper = __webpack_require__(11)._StyleHelper,
	        StringHelper = Common._StringHelper;
	
	    var browser = util_common._util._browser,
	        isNullOrUndefined = Common._Types._isNullOrUndefined,
	        ArrayHelper_contains = Common._ArrayHelper._contains,
	        LineBorder = STYLE_MODULE.LineBorder,
	        Style = STYLE_MODULE.Style;
	
	    var keyword_null = null;
	
	    function allowCopyPasteExcelStyle(workbook) {
	        return workbook && workbook.options.allowCopyPasteExcelStyle;
	    }
	
	
	    function _ClipboardHelper(workbook) {
	        var self = this;
	        self._fromSheet = keyword_null;
	        self._ranges = keyword_null;
	        self._isCutting = false;
	
	        self._owner = workbook;
	        self._createElement();
	    }
	
	    _ClipboardHelper.prototype = {
	        _createElement: function () {
	            var self = this;
	            var container = document.createElement('div');
	            container.style.position = 'fixed';
	            container.style.top = '0px';
	            container.style.left = '0px';
	            container.style.width = '0px';
	            container.style.height = '0px';
	            container.style.overflow = 'hidden';
	
	            var element = document.createElement('div');
	            element.setAttribute('contenteditable', 'true');
	            element.setAttribute('gcUIElement', 'gcSheetClipboard');
	            element.setAttribute('tabindex', -1);
	            element.style.position = 'absolute';
	            element.style.overflow = 'hidden';
	            element.style.background = 'white';
	            element.style.webkitUserSelect = 'text';
	            container.appendChild(element);
	            self._element = element;
	
	            var textAreaElement = document.createElement('textarea');
	            textAreaElement.setAttribute('gcUIElement', 'gcSheetClipboard');
	            textAreaElement.setAttribute('tabindex', -1);
	            textAreaElement.style.position = 'absolute';
	            textAreaElement.style.overflow = 'hidden';
	            textAreaElement.style.background = 'white';
	            textAreaElement.style.webkitUserSelect = 'text';
	            container.appendChild(textAreaElement);
	            self._textAreaElement = textAreaElement;
	
	            var host = self._owner.getHost();
	            if (host) {
	                host.appendChild(container);
	            }
	
	            if (!(browser.msie || browser.edge)) {
	                self._pasteHandler = function (e) {
	                    var sheet = self._owner.getActiveSheet();
	                    var clipboardData = e.clipboardData;
	                    if (clipboardData) {
	                        var clipboardHtml = clipboardData.getData('text/html');
	                        var measureContainer = self._getMeasureContainer();
	                        measureContainer.innerHTML = clipboardHtml;
	                        var clipboardText;
	                        if (clipboardHtml) {
	                            clipboardText = self._getInnerText(measureContainer, true);
	                        } else {
	                            clipboardText = formatClipboardData(clipboardData.getData('text/plain'));
	                        }
	                        measureContainer.innerHTML = '';
	                        sheet._doClipboardPaste(clipboardText, clipboardHtml);
	                    }
	                };
	                element.addEventListener('paste', self._pasteHandler);
	
	                self._textAreaPasteHandler = function (e) {
	                    var sheet = self._owner.getActiveSheet();
	                    var clipboardData = e.clipboardData;
	                    if (clipboardData) {
	                        var clipboardText = formatClipboardData(clipboardData.getData('text/plain'));
	                        if (!clipboardText) {
	                            var clipboardHtml = clipboardData.getData('text/html');
	                            if (clipboardHtml) {
	                                var measureContainer = self._getMeasureContainer();
	                                measureContainer.innerHTML = clipboardHtml;
	                                clipboardText = self._getInnerText(measureContainer, false);
	                                measureContainer.innerHTML = '';
	                            }
	                        }
	                        sheet._doClipboardPaste(clipboardText, '');
	                    }
	                };
	                textAreaElement.addEventListener('paste', self._textAreaPasteHandler);
	            }
	        },
	        _dispose: function () {
	            var self = this;
	            var element = self._element;
	            if (element) {
	                if (!(browser.msie || browser.edge)) {
	                    element.removeEventListener('paste', self._pasteHandler);
	                    self._textAreaElement.removeEventListener('paste', self._textAreaPasteHandler);
	                }
	                var container = element.parent;
	                if (container) {
	                    var containerParent = container.parent;
	                    if (containerParent) {
	                        containerParent.removeChild(container);
	                    }
	                }
	                self._element = keyword_null;
	                self._textAreaElement = keyword_null;
	            }
	
	            var measureContainer = self._measureContainer;
	            if (measureContainer) {
	                var measureContainerParent = measureContainer.parent;
	                if (measureContainerParent) {
	                    measureContainerParent.removeChild(measureContainer);
	                }
	                self._measureContainer = keyword_null;
	            }
	
	            var tempContainer = self._tempContainer;
	            if (tempContainer) {
	                var tempContainerParent = tempContainer.parent;
	                if (tempContainerParent) {
	                    tempContainerParent.removeChild(tempContainer);
	                }
	                self._tempContainer = keyword_null;
	            }
	        },
	        _setClipboardData: function (data) {
	            if (allowCopyPasteExcelStyle(this._owner)) {
	                this._element.innerHTML = data;
	            } else {
	                this._textAreaElement.value = data;
	            }
	        },
	        _focus: function () {
	            if (allowCopyPasteExcelStyle(this._owner)) {
	                this._element.focus();
	            } else {
	                this._textAreaElement.focus();
	            }
	        },
	        _select: function () {
	            if (allowCopyPasteExcelStyle(this._owner)) {
	                document.execCommand('selectAll');
	            } else {
	                this._textAreaElement.select();
	            }
	        },
	        _getClipboardData: function () {
	            var html = '', text = '';
	            if (allowCopyPasteExcelStyle(this._owner)) {
	                var element = this._element;
	                if (element) {
	                    var tables = element.getElementsByTagName('table');
	                    if (tables.length > 0) {
	                        html = tables[0].outerHTML;
	                    }
	                }
	
	                text = this._getInnerText(this._element, true);
	            } else {
	                text = formatClipboardData(this._textAreaElement.value);
	            }
	
	            return {html: html, text: text};
	        },
	        _getRangeHtml: function (sheet, row, rowCount, column, columnCount, includeStyle, ignoredRows, ignoredCols) {
	            var self = this;
	            var actualRange = sheet._getActualRange(util_common._createRange(row, column, rowCount, columnCount)),
	                normalSpReg = new RegExp(String.fromCharCode(32), 'g'),
	                htmlSp = '&nbsp;';
	            var includeColumnHeader = false;
	            var includeRowHeader = false;
	           
	           
	            var copyPasteHeaderOptions = sheet.parent.options.copyPasteHeaderOptions;
	            if (row < 0 && (copyPasteHeaderOptions & 2) === 2 ) {
	                includeColumnHeader = true;
	            }
	            if (column < 0 && (copyPasteHeaderOptions & 1) === 1 ) {
	                includeRowHeader = true;
	            }
	            row = actualRange.row;
	            column = actualRange.col;
	            rowCount = actualRange.rowCount;
	            columnCount = actualRange.colCount;
	
	            var rowHeaderHtml = null, colHeaderHtml = null,
	                viewportHtml = self._getRangeHtmlImp(sheet, row, rowCount, column, columnCount, 3 , ignoredRows, ignoredCols, includeStyle, actualRange, normalSpReg, htmlSp);
	            if (includeRowHeader) {
	                var rowHeaderCount = sheet.getColumnCount(2 );
	                rowHeaderHtml = self._getRangeHtmlImp(sheet, row, rowCount, 0, rowHeaderCount, 2 , ignoredRows, ignoredCols, includeStyle, actualRange, normalSpReg, htmlSp);
	            }
	            if (includeColumnHeader) {
	                var colHeaderRowCount = sheet.getRowCount(1 );
	                colHeaderHtml = self._getRangeHtmlImp(sheet, 0, colHeaderRowCount, column, columnCount, 1 , ignoredRows, ignoredCols, includeStyle, actualRange, normalSpReg, htmlSp);
	            }
	            return self._join(viewportHtml, rowHeaderHtml, colHeaderHtml);
	        },
	        _join: function (viewportHtml, rowHeaderHtml, colHeaderHtml) {
	            var self = this, arrayBuilder = viewportHtml, rowHeaderColumnCount = 0;
	            var concatOnRow = function (sourceRange, targetRange) {
	                var rangeBuilder = [], rowCount = sourceRange.length;
	                for (var row = 0; row < rowCount; row++) {
	                    rangeBuilder.push(sourceRange[row].concat(targetRange[row]));
	                }
	                return rangeBuilder;
	            };
	            if (rowHeaderHtml) {
	               
	               
	                rowHeaderColumnCount = rowHeaderHtml[0].length;
	                arrayBuilder = concatOnRow(rowHeaderHtml, viewportHtml);
	            }
	            if (colHeaderHtml) {
	                var colHeaderRowCount = colHeaderHtml.length;
	                var cornerHtml = null;
	                if (rowHeaderColumnCount) {
	                   
	                   
	                    cornerHtml = self._getRangeHtmlImp(null, 0, colHeaderRowCount, 0, rowHeaderColumnCount, null, [], [], false, null, null, null);
	                    colHeaderHtml = concatOnRow(cornerHtml, colHeaderHtml);
	                }
	               
	               
	               
	                arrayBuilder = colHeaderHtml.concat(arrayBuilder);
	            }
	            return self._buildStr(arrayBuilder);
	        },
	        _buildStr: function (arrayBuilder) {
	            var strBuilder = "";
	            var rowCount = arrayBuilder.length;
	            var row, col;
	            strBuilder += '<table>';
	            for (row = 0; row < rowCount; row++) {
	                strBuilder += '<tr>';
	                for (col = 0; col < arrayBuilder[row].length; col++) {
	                    strBuilder += arrayBuilder[row][col];
	                }
	                strBuilder += '</tr>';
	            }
	            strBuilder += '</table>';
	            return strBuilder;
	        },
	        _getRangeHtmlImp: function (sheet, row, rowCount, column, columnCount, sheetArea, ignoredRows, ignoredCols, includeStyle, actualRange, normalSpReg, htmlSp) {
	            var strBuilder = [];
	            for (var r = 0; r < rowCount; r++) {
	                var rowIndex = row + r;
	                if (ArrayHelper_contains(ignoredRows, rowIndex)) {
	                    continue;
	                }
	                var rowStrBuilder = [];
	                for (var c = 0; c < columnCount; c++) {
	                    var columnIndex = column + c;
	                    if (ArrayHelper_contains(ignoredCols, columnIndex)) {
	                        continue;
	                    }
	                    var colStrBuilder = "";
	                    if (includeStyle && sheet) {
	                       
	                        var span = sheet.getSpan(rowIndex, columnIndex, sheetArea);
	                        if (span && isPartSpan(span, actualRange, ignoredRows, ignoredCols)) {
	                            span = keyword_null;
	                        }
	                        if (span && (span.row !== rowIndex || span.col !== columnIndex)) {
	                            continue;
	                        }
	                    }
	                    colStrBuilder += '<td';
	                    if (includeStyle && sheet) {
	                        if (span) {
	                            if (span.rowCount > 1) {
	                                colStrBuilder += (' rowSpan=' + span.rowCount);
	                            }
	                            if (span.colCount > 1) {
	                                colStrBuilder += (' colSpan=' + span.colCount);
	                            }
	                        }
	                        var style = sheet.getActualStyle(rowIndex, columnIndex, sheetArea);
	                        colStrBuilder += ' style="';
	                       
	                        var backColor = style.backColor;
	                        if (backColor) {
	                            colStrBuilder += ('background-color: ' + backColor + ';');
	                        }
	                       
	                        var foreColor = style.foreColor;
	                        if (foreColor) {
	                            colStrBuilder += ('color: ' + foreColor + ';');
	                        }
	                       
	                        var font = style.font;
	                        if (font) {
	                            colStrBuilder += ('font: ' + font.replace(/"/g, "'") + ';');
	                        }
	                       
	                        var vAlign = style.vAlign;
	                        if (!isNullOrUndefined(vAlign)) {
	                            colStrBuilder += ('vertical-align: ' + convertVAlign(vAlign) + ';');
	                        }
	                       
	                        var hAlign = style.hAlign;
	                        if (!isNullOrUndefined(hAlign)) {
	                            var textAlign = convertHAlign(hAlign);
	                            if (textAlign) {
	                                colStrBuilder += ('text-align: ' + textAlign + ';');
	                            }
	                        }
	                       
	                        var borderLeft = style.borderLeft;
	                        if (borderLeft) {
	                            colStrBuilder += ('border-left: ' + convertLineBorder(borderLeft) + ';');
	                        }
	                       
	                        var borderRight = style.borderRight;
	                        if (borderRight) {
	                            colStrBuilder += ('border-right: ' + convertLineBorder(borderRight) + ';');
	                        }
	                       
	                        var borderTop = style.borderTop;
	                        if (borderTop) {
	                            colStrBuilder += ('border-top: ' + convertLineBorder(borderTop) + ';');
	                        }
	                       
	                        var borderBottom = style.borderBottom;
	                        if (borderBottom) {
	                            colStrBuilder += ('border-bottom: ' + convertLineBorder(borderBottom) + ';');
	                        }
	                        colStrBuilder += '"';
	                    }
	                    colStrBuilder += '>';
	                    if (includeStyle && sheet) {
	                       
	                        var textDecoration = style.textDecoration;
	                        var hasLineThrough = (textDecoration & 2 ) === 2 ,
	                            hasUnderline = (textDecoration & 1 ) === 1 ;
	                        if (hasLineThrough) {
	                            colStrBuilder += ('<s>');
	                        }
	                        if (hasUnderline) {
	                            colStrBuilder += ('<u>');
	                        }
	                    }
	                    var cellText = sheet ? sheet.getText(rowIndex, columnIndex, sheetArea) : '';
	
	                    if (!cellText) {
	                        if (browser.chrome) {
	                            cellText = ' ';
	                        } else if (browser.safari) {
	                            cellText = '&nbsp;';
	                        }
	                    } else {
	                       
	                       
	                        if ((cellText[0] === ' ' || cellText[cellText.length - 1] === ' ')
	                            && typeof sheet.getValue(rowIndex, columnIndex, sheetArea) === 'number') {
	                            cellText = cellText.trim();
	                        }
	                       
	                       
	                        cellText = StringHelper._escapeHtml(cellText).replace(normalSpReg, htmlSp);
	                    }
	                    colStrBuilder += cellText;
	                    if (includeStyle) {
	                        if (hasUnderline) {
	                            colStrBuilder += ('</u>');
	                        }
	                        if (hasLineThrough) {
	                            colStrBuilder += ('</s>');
	                        }
	                    }
	                    colStrBuilder += '</td>';
	                    rowStrBuilder.push(colStrBuilder);
	                }
	                strBuilder.push(rowStrBuilder);
	            }
	            return strBuilder;
	        },
	        _getMeasureContainer: function () {
	            var self = this;
	            if (!self._measureContainer) {
	                var container = document.createElement('div');
	                container.style.display = 'none';
	
	                var host = self._owner.getHost();
	                if (host) {
	                    host.appendChild(container);
	                }
	                self._measureContainer = container;
	            }
	            return self._measureContainer;
	        },
	        _getTempContainner: function () {
	            var self = this;
	            if (!self._tempContainer) {
	                var container = document.createElement('div');
	                container.style.display = 'none';
	
	                var host = self._owner.getHost();
	                if (host) {
	                    host.appendChild(container);
	                }
	                self._tempContainer = container;
	            }
	            return self._tempContainer;
	        },
	        _setRangeHtml: function (html, sheet, row, column) {
	            var container = this._getMeasureContainer();
	            container.innerHTML = html;
	            var tables = container.getElementsByTagName('table');
	            if (tables.length > 0) {
	                var tableData = this._getTableData(tables[0], true);
	                for (var r = 0; r < tableData.length; r++) {
	                    var tableRowData = tableData[r];
	                    var rowIndex = row + r;
	                    for (var c = 0; c < tableRowData.length; c++) {
	                        var tableCellData = tableRowData[c];
	                        if (tableCellData) {
	                            var colIndex = column + c;
	                           
	                            sheet._setStyleWithoutLocked(rowIndex, colIndex, tableCellData.style);
	                           
	                            var spanRowCount = tableCellData.rowSpan, spanColCount = tableCellData.colSpan;
	                            if (spanRowCount > 1 || spanColCount > 1) {
	                                var span = sheet.getSpan(rowIndex, colIndex);
	                                if (span) {
	                                    span.row = rowIndex;
	                                    span.col = colIndex;
	                                    span.rowCount = spanRowCount;
	                                    span.colCount = spanColCount;
	                                } else {
	                                    sheet.addSpan(rowIndex, colIndex, spanRowCount, spanColCount);
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            container.innerHTML = '';
	        },
	        _getTableData: function (table, withStyle) {
	            var tempContainer = this._getTempContainner();
	            var tableData = [], spaceReg = /\s+/g;
	            for (var r = 0; r < table.rows.length; r++) {
	                var tableRow = table.rows[r];
	                if (!tableData[r]) {
	                    tableData[r] = [];
	                }
	                var tableRowData = tableData[r];
	                for (var c = 0, columnIndex = 0; c < tableRow.cells.length; c++) {
	                    var tableCell = tableRow.cells[c];
	                    while (tableRowData[columnIndex]) {
	                        columnIndex++;
	                    }
	                    var tableCellData = tableRowData[columnIndex] = {};
	                    if (withStyle) {
	                       
	                        var style = getStyleFromDOM(tableCell);
	                        tableCellData.style = style;
	                    }
	                   
	                   
	                   
	                    tempContainer.innerHTML = tableCell.innerHTML.replace(spaceReg, ' ');
	                    tableCellData.text = tempContainer.innerText;
	                   
	                    tableCellData.rowSpan = tableCell.rowSpan;
	                    tableCellData.colSpan = tableCell.colSpan;
	                    for (var j = 0; j < tableCell.rowSpan; j++) {
	                        for (var k = 0; k < tableCell.colSpan; k++) {
	                            if (j !== 0 || k !== 0) {
	                                if (!tableData[r + j]) {
	                                    tableData[r + j] = [];
	                                }
	                                var tempTableRowData = tableData[r + j];
	                                tempTableRowData[columnIndex + k] = {style: style, text: '', rowSpan: 1, colSpan: 1};
	                            }
	                        }
	                    }
	                    columnIndex += tableCell.colSpan;
	                }
	            }
	            tempContainer.innerHTML = '';
	            return tableData;
	        },
	        _getInnerText: function (element, removeEnter) {
	            var strBuilder = [];
	            if (element) {
	                var tables = element.getElementsByTagName('table');
	                if (tables.length > 0) {
	                    var tableData = this._getTableData(tables[0], false);
	                    var htmlSpReg = new RegExp(String.fromCharCode(160), 'g'), normalSp = String.fromCharCode(32);
	                    for (var r = 0, rc = tableData.length; r < rc; r++) {
	                        var tableRowData = tableData[r];
	                        for (var c = 0, cc = tableRowData.length; c < cc; c++) {
	                            var text = tableRowData[c] ? tableRowData[c].text : '';
	                            if (text.indexOf('\n') >= 0) {
	                                if (removeEnter) {
	                                    if (text.indexOf('\r\n') >= 0) {
	                                        text = text.split('\r\n').join('');
	                                    }
	                                    text = text.split('\n').join('');
	                                } else {
	                                    text = '"' + text + '"';
	                                }
	                            }
	                           
	                            strBuilder.push(text.replace(htmlSpReg, normalSp));
	
	                            if (c < cc - 1) {
	                                strBuilder.push('\t');
	                            }
	                        }
	
	                        if (r < rc - 1) {
	                            strBuilder.push('\r\n');
	                        }
	                    }
	                } else {
	                   
	                   
	                    strBuilder.push(element.innerText.trim());
	                }
	            }
	            return strBuilder.join('');
	        },
	        _reset: function () {
	            var self = this;
	            self._fromSheet = keyword_null;
	            self._ranges = keyword_null;
	            self._isCutting = false;
	        }
	    };
	
	    function isPartSpan(span, range, ignoredRows, ignoredCols) {
	        if (!range.containsRange(span)) {
	            return true;
	        }
	        for (var i = 0; i < ignoredRows.length; i++) {
	            if (span.row <= ignoredRows[i] && ignoredRows[i] < span.row + span.rowCount) {
	                return true;
	            }
	        }
	        for (i = 0; i < ignoredCols.length; i++) {
	            if (span.col <= ignoredCols[i] && ignoredCols[i] < span.col + span.colCount) {
	                return true;
	            }
	        }
	        return false;
	    }
	
	    function formatClipboardData(data) {
	        var sbr = [];
	        if (data) {
	            var cellDelimiter = '"';
	            var inCell = false;
	            for (var i = 0; i < data.length; i++) {
	                var previousChar = i > 0 ? data[i - 1] : '';
	                var tempChar = data[i];
	                if (tempChar === cellDelimiter) {
	                    inCell = !inCell;
	                    sbr.push(cellDelimiter);
	                } else if (!inCell && tempChar === '\n' && previousChar !== '\r') {
	                    sbr.push('\r\n');
	                } else {
	                    sbr.push(tempChar);
	                }
	            }
	            return sbr.join('');
	        }
	        return '';
	    }
	
	    function convertHAlign(hAlign) {
	        var dict = {
	            0: 'left',
	            1: 'center',
	            2: 'right'
	        };
	        return dict[hAlign];
	    }
	
	    function convertVAlign(vAlign) {
	        var dict = {
	            0: 'top',
	            1: 'middle',
	            2: 'bottom'
	        };
	        return dict[vAlign];
	    }
	
	    function convertLineBorder(border) {
	        var dict = {
	            0: 'none',
	            1: 'solid',
	            2: 'solid',
	            3: 'dashed',
	            4: 'dotted',
	            5: 'solid',
	            6: 'double',
	            7: 'dotted',
	            8: 'dashed',
	            9: 'dashed',
	            10: 'dashed',
	            11: 'dashed',
	            12: 'dashed',
	            13: 'dashed'
	        };
	        var lineWidthDict = {
	            9 : 0.5,
	            1 : 0.5,
	            3 : 0.5,
	            4 : 0.5,
	            7 : 0.5,
	            11 : 0.5,
	            2 : 1,
	            10 : 1,
	            12 : 1,
	            8 : 1,
	            13 : 1,
	            5 : 1.5,
	            6 : 1.5
	        };
	        return lineWidthDict[border.style] + 'pt ' + dict[border.style] + ' ' + border.color;
	    }
	
	    function convertToHAlign(cssHAlign) {
	        var dict = {
	            'left': 0,
	            'center': 1,
	            'right': 2
	        };
	        return dict[cssHAlign];
	    }
	
	    function convertToVAlign(cssVAlign) {
	        var dict = {
	            'top': 0,
	            'middle': 1,
	            'bottom': 2
	        };
	        return dict[cssVAlign];
	    }
	
	    function convertToLineBorder(cssBorderColor, cssBorderStyle, cssBorderWidth) {
	        var dict = {
	            'none': 0,
	            'solid': 1,
	            'dashed': 3,
	            'dotted': 4,
	            'double': 6
	        };
	       
	       
	       
	       
	        if ((browser.msie || browser.edge) && cssBorderWidth === '2px') {
	            dict.solid = 5;
	        } else {
	            cssBorderWidth = Math.round(parseFloat(cssBorderWidth) * 10 * 3 / 4) / 10;
	            if (cssBorderWidth <= 0.5) {
	                dict.solid = 1;
	            } else if (cssBorderWidth <= 1) {
	                dict.solid = 2;
	                dict.dashed = 8;
	            } else if (cssBorderWidth <= 1.5) {
	                dict.solid = 5;
	            }
	        }
	        return new LineBorder(cssBorderColor, dict[cssBorderStyle]);
	    }
	
	    function convertToTextDecoration(cssTextDecoration) {
	        var dict = {
	            'underline': 1,
	            'line-through': 2,
	           
	            'none': 0
	        };
	        return dict[cssTextDecoration];
	    }
	
	    function isTransparent(color) {
	        return Common._ColorHelper._fromString(color).a === 0;
	    }
	
	    function isBlack(color) {
	        var colorObj = Common._ColorHelper._fromString(color);
	        return colorObj.a !== 0 && colorObj.r === 0 && colorObj.g === 0 && colorObj.b === 0;
	    }
	
	    function getStyleFromDOM(element) {
	        var fontElement = element.getElementsByTagName('font')[0];
	        var cssStyle = getComputedStyle(element);
	        var inlineStyle = element.style;
	        var style = new Style();
	       
	        var backgroundColor = cssStyle.backgroundColor;
	        if (backgroundColor && !isTransparent(backgroundColor)) {
	            style.backColor = backgroundColor;
	        }
	       
	        var color = cssStyle.color;
	        if (fontElement) {
	            color = fontElement.color;
	        }
	        if (color && !isBlack(color)) {
	            style.foreColor = color;
	        }
	       
	        if (fontElement) {
	            style.font = _StyleHelper._buildFontString(getComputedStyle(fontElement));
	        } else {
	            var font = _StyleHelper._buildFontString(cssStyle);
	            if (font) {
	                style.font = font;
	            }
	        }
	       
	        var verticalAlign = cssStyle.verticalAlign;
	        if (verticalAlign) {
	            style.vAlign = convertToVAlign(verticalAlign);
	        }
	       
	       
	       
	        var textAlignInline = inlineStyle.textAlign;
	        var textAlignCss = cssStyle.textAlign;
	        if (browser.msie || browser.edge) {
	            if (textAlignInline !== '') {
	                style.hAlign = convertToHAlign(textAlignInline);
	            } else {
	                style.hAlign = convertToHAlign('general');
	            }
	        } else if (textAlignCss) {
	            style.hAlign = convertToHAlign(textAlignCss);
	        }
	       
	        var borderLeftStyle = cssStyle.borderLeftStyle;
	        if (borderLeftStyle !== 'none') {
	            style.borderLeft = convertToLineBorder(cssStyle.borderLeftColor, borderLeftStyle, cssStyle.borderLeftWidth);
	        }
	       
	        var borderRightStyle = cssStyle.borderRightStyle;
	        if (borderRightStyle !== 'none') {
	            style.borderRight = convertToLineBorder(cssStyle.borderRightColor, borderRightStyle, cssStyle.borderRightWidth);
	        }
	       
	        var borderTopStyle = cssStyle.borderTopStyle;
	        if (borderTopStyle !== 'none') {
	            style.borderTop = convertToLineBorder(cssStyle.borderTopColor, borderTopStyle, cssStyle.borderTopWidth);
	        }
	       
	        var borderBottomStyle = cssStyle.borderBottomStyle;
	        if (borderBottomStyle !== 'none') {
	            style.borderBottom = convertToLineBorder(cssStyle.borderBottomColor, borderBottomStyle, cssStyle.borderBottomWidth);
	        }
	       
	        var textDecoration = convertToTextDecoration(browser.chrome ? cssStyle.textDecorationLine : cssStyle.textDecoration);
	        if (element.getElementsByTagName('u').length > 0) {
	            textDecoration |= convertToTextDecoration('underline');
	        }
	        if (element.getElementsByTagName('s').length > 0) {
	            textDecoration |= convertToTextDecoration('line-through');
	        }
	        if (textDecoration !== 0 ) {
	            style.textDecoration = textDecoration;
	        }
	        return style;
	    }
	
	    exports._ClipboardHelper = _ClipboardHelper;
	    module.exports = exports;
	
	}());

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var keyword_null = null, keyword_undefined = void 0, const_string = 'string', Math_min = Math.min,
	        Math_floor = Math.floor, Math_max = Math.max;
	    var exports = __webpack_require__(1);
	    var Style = __webpack_require__(12).Style;
	    var Common = __webpack_require__(5);
	    var util_common = __webpack_require__(3);
	    var StyleHelper = __webpack_require__(11)._StyleHelper;
	    var $ = __webpack_require__(4).GC$, $_each = $.each, $_isEmptyObject = $.isEmptyObject,
	        $_inherit = $.inherit, $_extend = $.extend;
	    var UNDERSCORE_DIRTY_NODES = 'dirtyNodes';
	
	    var addElements = Common._addElements;
	    var deleteElements = Common._deleteElements;
	    var isNullOrUndefined = Common._Types._isNullOrUndefined;
	    var createRange = util_common._createRange;
	    var util_common_util = util_common.util;
	    var convertRichTextValue = util_common_util._convertRichTextValue;
	    var tryAddCacheToRichText = util_common_util._tryAddCacheToRichText;
	    var sR = function () {
	        return Common._getResource(exports.SR)();
	    };
	
	    function _hasOwnProperty(obj, p) {
	        return obj.hasOwnProperty(p);
	    }
	
	    function getRowCount(obj) {
	        return obj.rowCount;
	    }
	
	    function getColCount(obj) {
	        return obj.colCount;
	    }
	
	    function defineProperty(obj, propName, initValue, setCallback) {
	        var data = initValue;
	        Object.defineProperty(obj, propName, {
	            get: function () {
	                return data;
	            },
	            set: function (value) {
	                var oldValue = data;
	                data = value;
	                setCallback(this, value, propName, oldValue);
	            }
	        });
	    }
	
	   
	    
	    exports.StorageType = {
	        
	        data: 0x01,
	        
	        style: 0x02,
	        
	        comment: 0x04,
	        
	        tag: 0x08,
	        
	        sparkline: 0x10,
	        
	        axis: 0x20,
	        
	        bindingPath: 0x40
	    };
	
	   
	   
	    var _SpanModel = (function () {
	        function _SpanModel() {
	            defineProperty(this, 'spans', [], updateCache);
	            this._lastNonNullColumn = -1;
	            this._lastNonNullRow = -1;
	            this.cache = {};
	            this.suspendUpdatingCache = false;
	        }
	
	        function updateCache(model, ranges) {
	            model.cache = {};
	            if (ranges) {
	                ranges.forEach(function (range) {
	                    _onSpanAdded(model, range);
	                });
	            }
	        }
	
	        function _onSpanAdded(model, range) {
	            model._lastNonNullRow = Math_max(model._lastNonNullRow, range.row + getRowCount(range) - 1);
	            model._lastNonNullColumn = Math_max(model._lastNonNullColumn, range.col + getColCount(range) - 1);
	            if (!model.suspendUpdatingCache) {
	                for (var r = 0; r < range.rowCount; r++) {
	                    for (var c = 0; c < range.colCount; c++) {
	                        model.cache[(range.row + r) + "_" + (range.col + c)] = range;
	                    }
	                }
	            }
	        }
	
	        function _onSpanRemoved(model, range) {
	            if (!model.suspendUpdatingCache) {
	                for (var r = 0; r < range.rowCount; r++) {
	                    for (var c = 0; c < range.colCount; c++) {
	                        model.cache[(range.row + r) + "_" + (range.col + c)] = keyword_undefined;
	                    }
	                }
	            }
	        }
	
	        var proto = {
	            find: function (row, col) {
	                return this.cache[row + "_" + col] || keyword_null;
	            },
	            get: function (row, col) {
	                return this.find(row, col) || createRange(row, col, 1, 1);
	            },
	            remove: function (range, changeInfo) {
	                var index = this.spans.indexOf(range);
	                if (index >= 0) {
	                    if (changeInfo) {
	                        changeInfo[0].push("spans");
	                        changeInfo[1] = this.spans.slice(0);
	                    }
	
	                    this.removeSpan(index, 1);
	                } else if (changeInfo) {
	                    changeInfo.length = 0;
	                }
	            },
	            removeSpan: function (index, count) {
	                for (var i = 0; i < count; i++) {
	                    _onSpanRemoved(this, this.spans[index + i]);
	                }
	                this.spans.splice(index, count);
	            },
	            update: function (index, range) {
	                var self = this;
	                _onSpanRemoved(self, self.spans[index]);
	                self.spans[index] = range;
	                _onSpanAdded(self, range);
	            },
	            add: function (range, changeInfo) {
	                if (changeInfo) {
	                    changeInfo[0].push("spans");
	                    changeInfo[1] = this.spans.slice(0);
	                }
	
	                _onSpanAdded(this, range);
	                this.spans.push(range);
	            },
	            _copy: function (fromRow, fromColumn, toRow, toColumn, rowCount, columnCount, changeInfo) {
	                var self = this;
	                var changed = false, oldSpans = self.spans.slice(0);
	                var cellSpanCount = self.spans.length;
	                var cellSpan, cellSpanRow, cellSpanCol;
	                var i;
	                var tempRanges = [];
	                for (i = 0; i < cellSpanCount; i++) {
	                    cellSpan = self.spans[i];
	                    cellSpanCol = cellSpan.col;
	                    cellSpanRow = cellSpan.row;
	                    if ((fromRow === -1 || fromRow <= cellSpanRow && cellSpanRow < fromRow + rowCount) && (fromColumn === -1 || fromColumn <= cellSpanCol && cellSpanCol < fromColumn + columnCount)) {
	                        tempRanges.push(createRange(fromRow === -1 ? cellSpanRow : toRow + cellSpanRow - fromRow, fromColumn === -1 ? cellSpanCol : toColumn + cellSpanCol - fromColumn, getRowCount(cellSpan), getColCount(cellSpan)));
	                        changed = true;
	                    } else if ((fromRow === -1 || toRow <= cellSpanRow && cellSpanRow < toRow + rowCount) && (fromColumn === -1 || toColumn <= cellSpanCol && cellSpanCol < toColumn + columnCount)) {
	                        self.removeSpan(i, 1);
	                        i--;
	                        cellSpanCount--;
	                        changed = true;
	                    }
	                }
	                for (i = 0; i < tempRanges.length; i++) {
	                    cellSpan = tempRanges[i];
	                    if (!self._isValid(self.spans, 0, self.spans.length, cellSpan)) {
	                        throw new Error(sR().Exp_OverlappingSpans);
	                    }
	                    self.add(cellSpan);
	                }
	
	                if (changeInfo) {
	                    if (changed) {
	                        changeInfo[0].push("spans");
	                        changeInfo[1] = oldSpans;
	                    } else {
	                        changeInfo.length = 0;
	                    }
	                }
	            },
	            _isValid: function (list, start, end, cellRange) {
	                for (var i = start; i < end && i < list.length; i++) {
	                    if (list[i].intersect(cellRange.row, cellRange.col, getRowCount(cellRange), getColCount(cellRange))) {
	                        return false;
	                    }
	                }
	                return true;
	            },
	            getSpans: function (range) {
	                var spans = this.spans;
	                if (!range) {
	                    return spans.slice(0);
	                }
	                var t = [];
	                for (var i = 0; i < spans.length; i++) {
	                    var rg = spans[i];
	                    if (rg.intersect(range.row, range.col, getRowCount(range), getColCount(range))) {
	                        t.push(rg);
	                    }
	                }
	                return t;
	            },
	            _hasPartSpans: function (row, column, rowCount, columnCount) {
	                var spans = this.spans;
	                for (var i = 0; i < spans.length; i++) {
	                    var rg = spans[i];
	                    if (rg.intersect(row, column, rowCount, columnCount)) { 
	                        if (row !== -1 && (rg.row < row || rg.row + getRowCount(rg) > row + rowCount) ||
	                            column !== -1 && (rg.col < column || rg.col + getColCount(rg) > column + columnCount)) {
	                            return true;
	                        }
	                    }
	                }
	                return false;
	            },
	            _hasSpans: function (row, column, rowCount, columnCount) {
	                var ret = false;
	                var spans = this.spans;
	                for (var i = 0, length = spans.length; i < length; i++) {
	                    if (row >= 0 || column >= 0) {
	                        while (i < length && !spans[i].intersect(row, column, rowCount, columnCount)) {
	                            i++;
	                        }
	                    }
	                    if (i < length) {
	                        ret = true;
	                        break;
	                    }
	                }
	
	                return ret;
	            },
	            _clear: function (row, col, rowCount, colCount, changeInfo) {
	                var spans = this.spans;
	                var changed = false, oldSpans = spans.slice(0);
	                for (var i = 0; i < spans.length; i++) {
	                    var span = spans[i], spanRow = span.row, spanCol = span.col;
	                    if ((row === -1 || row <= spanRow && spanRow < row + rowCount) && (col === -1 || col <= spanCol && spanCol < col + colCount)) {
	                        this.removeSpan(i--, 1);
	                        changed = true;
	                    }
	                }
	
	                if (changeInfo) {
	                    if (changed) {
	                        changeInfo[0].push("spans");
	                        changeInfo[1] = oldSpans;
	                    } else {
	                        changeInfo.length = 0;
	                    }
	                }
	            },
	            _move: function (fromRow, fromCol, toRow, toCol, rowCount, colCount, changeInfo) {
	                var self = this;
	                var changed = false, oldSpans = self.spans.slice(0);
	                var tmpList = [];
	                var changeList = [];
	                var cellRangeCount = self.spans.length;
	                var cellSpan, cellSpanRow, cellSpanCol;
	                var i, cr;
	                for (i = 0; i < cellRangeCount; i++) {
	                    cellSpan = self.spans[i];
	                    cellSpanRow = cellSpan.row;
	                    cellSpanCol = cellSpan.col;
	                    if ((fromRow === -1 || fromRow <= cellSpanRow && cellSpanRow < fromRow + rowCount) && (fromCol === -1 || fromCol <= cellSpanCol && cellSpanCol < fromCol + colCount)) {
	                        cr = createRange(fromRow === -1 ? cellSpanRow : toRow + cellSpanRow - fromRow, fromCol === -1 ? cellSpanCol : toCol + cellSpanCol - fromCol, getRowCount(cellSpan), getColCount(cellSpan));
	                        changeList.push(cr);
	                        changed = true;
	                    } else if ((fromRow === -1 || toRow <= cellSpanRow && cellSpanRow < toRow + rowCount) && (fromCol === -1 || toCol <= cellSpanCol && cellSpanCol < toCol + colCount)) {
	                        changed = true;
	                    } else {
	                        tmpList.push(cellSpan);
	                    }
	                }
	                if (changed) {
	                    if (changeList.length > 0) {
	                        for (i = 0; i < changeList.length; i++) {
	                            cr = changeList[i];
	                            if (!self._isValid(tmpList, 0, tmpList.length, cr)) {
	                                throw new Error(sR().Exp_OverlappingSpans);
	                            }
	                            tmpList.push(cr);
	                        }
	                    }
	                    self.spans.length = 0;
	                    self.cache = {};
	                    for (i = 0; i < tmpList.length; i++) {
	                        self.add(tmpList[i]);
	                    }
	
	                    if (changeInfo) {
	                        changeInfo[0].push("spans");
	                        changeInfo[1] = oldSpans;
	                    }
	                } else if (changeInfo) {
	                    changeInfo.length = 0;
	                }
	            },
	            _addRows: function (row, count, changeInfo) {
	                var self = this, spans = self.spans;
	                self.suspendUpdatingCache = true;
	                var changed = false, oldSpans = spans.slice(0);
	                var countOld = spans.length;
	                for (var i = 0; i < countOld; i++) {
	                    var cellSpan = spans[i], cellSpanRow = cellSpan.row, cellSpanCol = cellSpan.col,
	                        cellSpanRowCount = getRowCount(cellSpan), cellSpanColCount = getColCount(cellSpan);
	                    if (cellSpanRow >= row) {
	                        self.update(i, createRange(cellSpanRow + count, cellSpanCol, cellSpanRowCount, cellSpanColCount));
	                        changed = true;
	                    } else if (row < cellSpanRow + cellSpanRowCount) {
	                        self.update(i, createRange(cellSpanRow, cellSpanCol, cellSpanRowCount + count, cellSpanColCount));
	                        changed = true;
	                    }
	                }
	                self.suspendUpdatingCache = false;
	               
	                if (changed) {
	                    updateCache(self, spans);
	                }
	
	                if (changeInfo) {
	                    if (changed) {
	                        changeInfo[0].push("spans");
	                        changeInfo[1] = oldSpans;
	                    } else {
	                        changeInfo.length = 0;
	                    }
	                }
	            },
	            _addColumns: function (column, count, changeInfo) {
	                var self = this, spans = self.spans;
	                self.suspendUpdatingCache = true;
	                var changed = false, oldSpans = spans.slice(0);
	                var countOld = spans.length;
	                for (var i = 0; i < countOld; i++) {
	                    var cellSpan = spans[i], cellSpanRow = cellSpan.row, cellSpanCol = cellSpan.col,
	                        cellSpanRowCount = getRowCount(cellSpan), cellSpanColCount = getColCount(cellSpan);
	                    if (cellSpanCol >= column) {
	                        self.update(i, createRange(cellSpanRow, cellSpanCol + count, cellSpanRowCount, cellSpanColCount));
	                        changed = true;
	                    } else if (column < cellSpanCol + cellSpanColCount) {
	                        self.update(i, createRange(cellSpanRow, cellSpanCol, cellSpanRowCount, cellSpanColCount + count));
	                        changed = true;
	                    }
	                }
	                self.suspendUpdatingCache = false;
	               
	                if (changed) {
	                    updateCache(self, spans);
	                }
	
	                if (changeInfo) {
	                    if (changed) {
	                        changeInfo[0].push("spans");
	                        changeInfo[1] = oldSpans;
	                    } else {
	                        changeInfo.length = 0;
	                    }
	                }
	            },
	            _removeRows: function (row, count, changeInfo) {
	                var self = this, spans = self.spans;
	                self.suspendUpdatingCache = true;
	                var changed = false, oldSpans = spans.slice(0);
	                var delList = [];
	                var countOld = spans.length;
	                var i;
	                for (i = 0; i < countOld; i++) {
	                    var cellSpan = spans[i], cellSpanRow = cellSpan.row, cellSpanCol = cellSpan.col,
	                        cellSpanRowCount = getRowCount(cellSpan), cellSpanColCount = getColCount(cellSpan);
	                    if (cellSpanRow >= row) {
	                        if (cellSpanRow < row + count) {
	                           
	                            delList.push(i);
	                            changed = true;
	                        } else {
	                            self.update(i, createRange(cellSpanRow - count, cellSpanCol, cellSpanRowCount, cellSpanColCount));
	                            changed = true;
	                        }
	                    } else if (row < cellSpanRow + cellSpanRowCount) {
	                        var range = createRange(cellSpanRow, cellSpanCol, cellSpanRowCount - Math_min(cellSpanRow + cellSpanRowCount - row, count), cellSpanColCount);
	                        self.update(i, range);
	                        if (range.rowCount === 1 && range.colCount === 1) {
	                            delList.push(i);
	                        }
	                        changed = true;
	                    }
	                }
	                for (i = delList.length - 1; i >= 0; i--) {
	                    var index = delList[i];
	                    self.removeSpan(index, 1);
	                }
	                self.suspendUpdatingCache = false;
	               
	                if (changed) {
	                    updateCache(self, spans);
	                }
	
	                if (changeInfo) {
	                    if (changed) {
	                        changeInfo[0].push("spans");
	                        changeInfo[1] = oldSpans;
	                    } else {
	                        changeInfo.length = 0;
	                    }
	                }
	            },
	            _removeColumns: function (column, count, changeInfo) {
	                var self = this, spans = self.spans;
	                self.suspendUpdatingCache = true;
	                var changed = false, oldSpans = spans.slice(0);
	                var delList = [];
	                var countOld = spans.length;
	                var i;
	                for (i = 0; i < countOld; i++) {
	                    var cellSpan = spans[i], cellSpanRow = cellSpan.row, cellSpanCol = cellSpan.col,
	                        cellSpanRowCount = getRowCount(cellSpan), cellSpanColCount = getColCount(cellSpan);
	                    if (cellSpanCol >= column) {
	                        if (cellSpanCol < column + count) {
	                           
	                            delList.push(i);
	                            changed = true;
	                        } else {
	                            self.update(i, createRange(cellSpanRow, cellSpanCol - count, cellSpanRowCount, cellSpanColCount));
	                            changed = true;
	                        }
	                    } else if (column < cellSpanCol + cellSpanColCount) {
	                        var range = createRange(cellSpanRow, cellSpanCol, cellSpanRowCount, cellSpanColCount - Math_min(cellSpanCol + cellSpanColCount - column, count));
	                        self.update(i, range);
	                        if (range.rowCount === 1 && range.colCount === 1) {
	                            delList.push(i);
	                        }
	                        changed = true;
	                    }
	                }
	                for (i = delList.length - 1; i >= 0; i--) {
	                    var index = delList[i];
	                    self.removeSpan(index, 1);
	                }
	                self.suspendUpdatingCache = false;
	               
	                if (changed) {
	                    updateCache(self, spans);
	                }
	
	                if (changeInfo) {
	                    if (changed) {
	                        changeInfo[0].push("spans");
	                        changeInfo[1] = oldSpans;
	                    } else {
	                        changeInfo.length = 0;
	                    }
	                }
	            },
	            toJSON: function () {
	                var array = this.spans.slice(0);
	                return array.length === 0 ? keyword_undefined : array;
	            },
	            fromJSON: function (setting) {
	                if (!setting) {
	                    return;
	                }
	                this.spans = [];
	                var spans = setting;
	                for (var i = 0; i < spans.length; i++) {
	                    var cr = spans[i];
	                    this.add(createRange(cr.row, cr.col, getRowCount(cr), getColCount(cr)));
	                }
	            }
	        };
	
	        $_extend(_SpanModel.prototype, proto);
	        return _SpanModel;
	    })();
	   
	
	   
	   
	    var _CellOverflowLayoutModel = (function (_super) {
	        $_inherit(_CellOverflowLayoutModel, _super);
	
	        function _CellOverflowLayoutModel() {
	            _super.call(this);
	            this.headingOverflowlayout = keyword_null;
	            this.trailingOverflowLayout = keyword_null;
	        }
	
	       
	        _CellOverflowLayoutModel.prototype.find = function (col) {
	            var self = this, count = self.length, cellOverflowLayout;
	            for (var i = 0; i < count; i++) {
	                cellOverflowLayout = self[i];
	                if (cellOverflowLayout.contains(col)) {
	                    return cellOverflowLayout;
	                }
	            }
	            return keyword_null;
	        };
	        return _CellOverflowLayoutModel;
	    })(Array);
	    exports._CellOverflowLayoutModel = _CellOverflowLayoutModel;
	
	    function _CellOverflowLayout(column, startColumn, endColumn, valueWidth, columnWidth, backgroundWidth, backgroundLeftWidth, backgroundRightWidth) {
	        var self = this;
	        self.column = column;
	        self.startColumn = startColumn;
	        self.endColumn = endColumn;
	        self.valueWidth = valueWidth;
	        self.columnWidth = columnWidth;
	        self.backgroundWidth = backgroundWidth;
	        self.backgroundLeftWidth = backgroundLeftWidth;
	        self.backgroundRightWidth = backgroundRightWidth;
	    }
	
	    _CellOverflowLayout.prototype.contains = function (col) {
	        return col >= this.startColumn && col <= this.endColumn;
	    };
	    exports._CellOverflowLayout = _CellOverflowLayout;
	   
	
	   
	   
	    var _SelectionModel = (function () {
	        function _SelectionModel() {
	            this.selections = [];
	            this.selectionPolicy = 2 ;
	            this.selectionUnit = 0 ;
	        }
	
	       
	        function _normalizeRange(range, sheetRowCount, sheetColCount) {
	            var rg = createRange(-1, -1, -1, -1);
	            if (range) {
	                var rangeCol = range.col, rangeRow = range.row, isWholeCol = rangeRow === -1,
	                    isWholeRow = rangeCol === -1;
	                rg.row = isWholeCol ? 0 : rangeRow;
	                rg.rowCount = isWholeCol ? sheetRowCount : getRowCount(range);
	                rg.col = isWholeRow ? 0 : rangeCol;
	                rg.colCount = isWholeRow ? sheetColCount : getColCount(range);
	            }
	            return rg;
	        }
	
	        var proto = {
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	            getProperty: function (prop) {
	                return this[prop];
	            },
	            setProperty: function (prop, value, changeInfo) {
	                if (changeInfo) {
	                    changeInfo[0].push(prop);
	                    changeInfo[1] = this[prop];
	                }
	
	                this[prop] = value;
	            },
	            clear: function (changeInfos) {
	                if (changeInfos) {
	                    changeInfos.push(['selections', this.get()]);
	                    changeInfos.push(['activeSelectedRangeIndex', this.activeSelectedRangeIndex]);
	                }
	
	                this.selections = [];
	                this.activeSelectedRangeIndex = -1;
	            },
	            add: function (row, col, rowCount, colCount, changeInfos) {
	                if (changeInfos) {
	                    changeInfos.push(['selections', this.get()]);
	                    changeInfos.push(['activeSelectedRangeIndex', this.activeSelectedRangeIndex]);
	                }
	
	                var self = this, selectionPolicy = self.selectionPolicy, selectionUnit = self.selectionUnit;
	                if (selectionPolicy === 0 ) {
	                    rowCount = Math_min(rowCount, 1);
	                    colCount = Math_min(colCount, 1);
	                    self.clear();
	                } else if (selectionPolicy === 1 ) {
	                    self.clear();
	                }
	                if (selectionUnit === 1 ) {
	                    col = -1;
	                    colCount = -1;
	                } else if (selectionUnit === 2 ) {
	                    row = -1;
	                    rowCount = -1;
	                }
	                self.selections.push(createRange(row, col, rowCount, colCount));
	                self.activeSelectedRangeIndex = self.selections.length - 1;
	            },
	            get: function () {
	                return this.selections.slice(0);
	            },
	            set: function (ranges, changeInfos) {
	                if (changeInfos) {
	                    changeInfos.push(['selections', this.get()]);
	                    changeInfos.push(['activeSelectedRangeIndex', this.activeSelectedRangeIndex]);
	                }
	
	                this.selections = ranges;
	                if (this.activeSelectedRangeIndex >= ranges.length) {
	                    this.activeSelectedRangeIndex = 0;
	                }
	            },
	            toJSON: function () {
	                var self = this;
	                var sdata = {};
	                var selectionPolicy = self.selectionPolicy,
	                    selectionUnit = self.selectionUnit,
	                    activeSelectedRangeIndex = self.activeSelectedRangeIndex,
	                    length = self.selections.length;
	                if (selectionPolicy !== 2 ) {
	                    sdata.selectionPolicy = selectionPolicy;
	                }
	                if (selectionUnit !== 0 ) {
	                    sdata.selectionUnit = selectionUnit;
	                }
	                if (activeSelectedRangeIndex !== 0) {
	                    sdata.activeSelectedRangeIndex = activeSelectedRangeIndex;
	                }
	                sdata.length = length;
	                for (var i = 0; i < length; i++) {
	                    sdata[i] = self.selections[i];
	                }
	                return $_isEmptyObject(sdata) ? keyword_undefined : sdata;
	            },
	            fromJSON: function (selections) {
	                if (!selections) {
	                    return;
	                }
	                var self = this;
	                self.clear();
	
	                var selectionPolicy = selections.selectionPolicy;
	                var selectionUnit = selections.selectionUnit;
	                var count = selections.length;
	                if (isNullOrUndefined(count)) {
	                    count = 1;
	                }
	                for (var i = 0; i < count; i++) {
	                    var cr = selections[i];
	                    self.selections.push(createRange(cr ? cr.row : 0, cr ? cr.col : 0, cr ? getRowCount(cr) : 1, cr ? getColCount(cr) : 1));
	                }
	                self.activeSelectedRangeIndex = selections.activeSelectedRangeIndex || 0;
	                if (!isNullOrUndefined(selectionPolicy)) {
	                    self.selectionPolicy = selectionPolicy;
	                }
	                if (!isNullOrUndefined(selectionUnit)) {
	                    self.selectionUnit = selectionUnit;
	                }
	            },
	            _isColumnSelected: function (c) {
	                var selections = this.selections;
	                for (var i = 0; i < selections.length; i++) {
	                    var selectedRange = selections[i];
	                    var col = selectedRange.col === -1 ? 0 : selectedRange.col;
	                    if (selectedRange.row === -1 && c >= col && c < col + getColCount(selectedRange)) {
	                        return true;
	                    }
	                }
	                return false;
	            },
	            _isRowSelected: function (r) {
	                var selections = this.selections;
	                for (var i = 0; i < selections.length; i++) {
	                    var selectedRange = selections[i];
	                    var row = selectedRange.row === -1 ? 0 : selectedRange.row;
	                    if (selectedRange.col === -1 && r >= row && r < row + getRowCount(selectedRange)) {
	                        return true;
	                    }
	                }
	                return false;
	            },
	            _isSelected: function (r, c, sheetArea, sheetRowCount, sheetColCount, considerAdjacentCell) {
	                var selected = false;
	                var selections = this.selections;
	                var adjustIndex = considerAdjacentCell ? 1 : 0;
	                for (var i = 0, count = selections.length; i < count; i++) {
	                    var cr = selections[i];
	                    var selectedRange = _normalizeRange(cr, sheetRowCount, sheetColCount),
	                        selectedRow = selectedRange.row, selectedCol = selectedRange.col;
	                    var containRow = selectedRow - adjustIndex <= r && r < selectedRow + getRowCount(selectedRange) + adjustIndex,
	                        containCol = selectedCol - adjustIndex <= c && c < selectedCol + getColCount(selectedRange) + adjustIndex;
	                    if (sheetArea === 3  || isNullOrUndefined(sheetArea)) {
	                        selected = containRow && containCol;
	                    } else if (sheetArea === 2 ) {
	                        selected = containRow;
	                    } else if (sheetArea === 1 ) {
	                        selected = containCol;
	                    } else if (sheetArea === 0 ) {
	                        selected = cr.row === -1 && cr.col === -1;
	                    }
	                    if (selected) {
	                        break;
	                    }
	                }
	
	                return selected;
	            },
	            _isAllSelected: function (r, c, sheetArea, sheetRowCount, sheetColCount) {
	                var selections = this.selections;
	
	                var selected = false;
	                for (var i = 0; i < selections.length; i++) {
	                    var selectedRange = selections[i], selectedRow = selectedRange.row, selectedCol = selectedRange.col,
	                        selectedRowCount = getRowCount(selectedRange), selectedColCount = getColCount(selectedRange);
	                    var isWholeRow = selectedCol === -1, isWholeCol = selectedRow === -1;
	                    if (!isNullOrUndefined(sheetArea) && sheetArea !== 3 ) {
	                        if (sheetArea === 2 ) {
	                            var row = isWholeCol ? 0 : selectedRow;
	                            selected = isWholeRow && r >= row && r < row + selectedRowCount;
	                        } else if (sheetArea === 1 ) {
	                            var col = isWholeRow ? 0 : selectedCol;
	                            selected = isWholeCol && c >= col && c < col + selectedColCount;
	                        } else if (sheetArea === 0 ) {
	                            selected = isWholeCol && isWholeRow && selectedRowCount === sheetRowCount && selectedColCount === sheetColCount;
	                        }
	
	                        if (selected) {
	                            break;
	                        }
	                    }
	                }
	                return selected;
	            }
	        };
	
	        $_extend(_SelectionModel.prototype, proto);
	        return _SelectionModel;
	    })();
	   
	
	   
	    var _LayoutModel = (function (_super) {
	        $_inherit(_LayoutModel, _super);
	
	        function _LayoutModel() {
	            _super.call(this);
	        }
	
	        function _find(model, row, col, x, y) {
	            var count = model.length, layout, found = false;
	            for (var i = 0; i < count; i++) {
	                layout = model[i];
	                if (!isNullOrUndefined(row) && !isNullOrUndefined(col)) {
	                    found = layout.contains(row, col);
	                } else if (!isNullOrUndefined(row)) {
	                    found = layout.row === row;
	                } else if (!isNullOrUndefined(col)) {
	                    found = layout.col === col;
	                } else if (!isNullOrUndefined(x)) {
	                    found = layout.containsX(x);
	                } else {
	                    found = layout.containsY(y);
	                }
	                if (found) {
	                    return layout;
	                }
	            }
	            return keyword_null;
	        }
	
	        function _findNearXY(model, x, y) {
	            var ret = keyword_null, count = model.length, isFindX = !isNullOrUndefined(x);
	            if (count > 0) {
	                ret = isFindX ? model.findX(x) : model.findY(y);
	                if (!ret) {
	                    if (isFindX && x < model[0].x || !isFindX && y < model[0].y) {
	                        ret = model[0];
	                    } else {
	                        ret = model[count - 1];
	                    }
	                }
	            }
	            return ret;
	        }
	
	        var proto = {
	            findCell: function (row, col) {
	                var count = this.length, layout;
	                for (var i = 0; i < count; i++) {
	                    layout = this[i];
	                    if (layout.contains(row, col)) {
	                        return layout;
	                    }
	                }
	                return keyword_null;
	            },
	            findRow: function (row) {
	                var count = this.length, layout;
	                for (var i = 0; i < count; i++) {
	                    layout = this[i];
	                    if (layout.row === row) {
	                        return layout;
	                    }
	                }
	                return keyword_null;
	            },
	            findCol: function (col) {
	                var count = this.length, layout;
	                for (var i = 0; i < count; i++) {
	                    layout = this[i];
	                    if (layout.col === col) {
	                        return layout;
	                    }
	                }
	                return keyword_null;
	            },
	            findX: function (x) {
	                return _find(this, keyword_undefined, keyword_undefined, x);
	            },
	            findY: function (y) {
	                return _find(this, keyword_undefined, keyword_undefined, keyword_undefined, y);
	            },
	            findNearX: function (x) {
	                return _findNearXY(this, x);
	            },
	            findNearY: function (y) {
	                return _findNearXY(this, keyword_undefined, y);
	            }
	        };
	
	        $_extend(_LayoutModel.prototype, proto);
	        return _LayoutModel;
	    })(Array);
	    exports._LayoutModel = _LayoutModel;
	
	    function _Layout(row, col, x, y, width, height, rowCount, colCount) {
	        var self = this;
	        self.rowCount = rowCount;
	        self.colCount = colCount;
	        self.row = row;
	        self.col = col;
	        self.x = x;
	        self.y = y;
	        self.width = width;
	        self.height = height;
	    }
	
	    _Layout.prototype = {
	        contains: function (row, col) {
	            var self = this;
	            return row < self.row + getRowCount(self) && self.row <= row && col < self.col + getColCount(self) && self.col <= col;
	        },
	        intersect: function (rect) {
	            var self = this;
	            return (self.x < 0 || rect.x < self.x + self.width && self.x < rect.x + rect.width) && (self.y < 0 || rect.y < self.y + self.height && self.y < rect.y + rect.height);
	        },
	        containsX: function (x) {
	            return this.x <= x && x < this.x + this.width;
	        },
	        containsY: function (y) {
	            return this.y <= y && y < this.y + this.height;
	        }
	    };
	    exports._Layout = _Layout;
	   
	
	   
	    function _SheetModel(rowCount, colCount) {
	        var self = this;
	        self._rowCount = rowCount;
	        self._colCount = colCount;
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	        self.dataTable = {};
	       
	       
	       
	       
	       
	       
	       
	       
	       
	        self.rowDataArray = [];
	       
	       
	       
	       
	       
	       
	       
	       
	       
	        self.columnDataArray = [];
	       
	       
	       
	       
	        self.defaultDataNode = keyword_null;
	        self._dirtyNodes = {};
	        self._dirtySuspended = 0;
	        self._lastNonNullColumn = -1;
	        self._lastNonNullRow = -1;
	    }
	
	    function _setNode4Swap(or, oc, row, col, node, dataTable, rowDataArray, columnDataArray) {
	        if (row >= 0 && col >= 0) {
	            if (!dataTable[row]) {
	                dataTable[row] = {};
	            }
	            var dr = dataTable[row];
	            dr[col] = node;
	        } else if (row >= 0 && col === -1 && or >= 0 && oc === -1) {
	            rowDataArray[row] = node;
	        } else if (col >= 0 && row === -1 && oc >= 0 && or === -1) {
	            columnDataArray[col] = node;
	        }
	    }
	
	    _SheetModel.prototype = {
	        constructor: _SheetModel,
	        getRowCount: function () {
	            return this._rowCount;
	        },
	        getColumnCount: function () {
	            return this._colCount;
	        },
	        setRowCount: function (c) {
	            this._rowCount = c;
	        },
	        setColumnCount: function (c) {
	            this._colCount = c;
	        },
	        _updateDirty: function (row, col, dirtyOption, changeInfo) {
	            var self = this, dirtyNodes = self._dirtyNodes;
	            if (self._dirtySuspended > 0) {
	                return;
	            }
	            if (row >= 0 && col >= 0) {
	                if (changeInfo) {
	                    changeInfo.type = 'updateDirty';
	                    changeInfo.row = row;
	                    changeInfo.col = col;
	                    if (!dirtyNodes[row]) {
	                        changeInfo.isEmptyRow = true;
	                    } else if (!dirtyNodes[row][col]) {
	                        changeInfo.isEmptyCol = true;
	                    }
	                }
	                if (!dirtyNodes[row]) {
	                    dirtyNodes[row] = {};
	                }
	                var dnr = dirtyNodes[row];
	                if (!dnr[col]) {
	                    dnr[col] = {};
	                }
	                var node = dnr[col];
	                if (dnr.rs !== 'n') {
	                    dnr.rs = 'e';
	                }
	                var originalItem = dirtyOption._originalItem;
	                var oldValue = dirtyOption._oldValue;
	                if (!isNullOrUndefined(originalItem)) {
	                    if (changeInfo) {
	                        changeInfo.originalItem = dnr.originalItem;
	                    }
	                    dnr.originalItem = originalItem;
	                }
	                if (!isNullOrUndefined(oldValue)) {
	                    if (changeInfo) {
	                        changeInfo.oldValue = node.oldValue;
	                    }
	                    node.oldValue = oldValue;
	                }
	            }
	        },
	        _undoUpdateDirty: function (changeInfo) {
	            var dirtyNodes = this._dirtyNodes;
	            var row = changeInfo.row, col = changeInfo.col;
	            if (changeInfo.isEmptyRow) {
	                delete dirtyNodes[row];
	            } else if (changeInfo.isEmptyCol) {
	                delete dirtyNodes[row][col];
	            } else {
	                if (changeInfo.hasOwnProperty('originalItem')) {
	                    if (isNullOrUndefined(changeInfo.originalItem) && !isNullOrUndefined(dirtyNodes[row].originalItem)) {
	                        delete dirtyNodes[row].originalItem;
	                    } else {
	                        dirtyNodes[row].originalItem = changeInfo.originalItem;
	                    }
	                }
	                if (changeInfo.hasOwnProperty('oldValue')) {
	                    if (isNullOrUndefined(changeInfo.oldValue) && !isNullOrUndefined(dirtyNodes[row][col].oldValue)) {
	                        delete dirtyNodes[row][col].oldValue;
	                    } else {
	                        dirtyNodes[row][col].oldValue = changeInfo.oldValue;
	                    }
	                }
	            }
	        },
	        getValue: function (row, col, valueType) {
	            var node = this._getNode(row, col);
	            if (node && !isNullOrUndefined(node.value)) {
	                if (valueType !== 1 ) {
	                    return convertRichTextValue(node.value);
	                }
	                if (!isNullOrUndefined(node.value.richText)) {
	                    return $_extend(true, {}, node.value);
	                }
	                return node.value;
	            }
	            return keyword_null;
	        },
	        setValue: function (row, col, value, valueChangeInfo, dirtyChangeInfo) {
	            var node = this._getNode(row, col, true, valueChangeInfo ? valueChangeInfo[0] : keyword_undefined);
	            if (node && node.value !== value) {
	                var oldValue = node.value;
	                node.value = value;
	                this._updateDirty(row, col, {_oldValue: oldValue}, dirtyChangeInfo);
	
	                if (valueChangeInfo) {
	                    valueChangeInfo[0].push('value');
	                    valueChangeInfo[1] = oldValue;
	                }
	            } else if (valueChangeInfo) {
	                valueChangeInfo.length = 0;
	            }
	        },
	        getStyle: function (row, col, needClone) {
	            var node = this._getNode(row, col);
	            var style = node && node.style;
	            if (style && needClone && style.clone) {
	                style = style.clone(true);
	            }
	            return style;
	        },
	        setStyle: function (row, col, value, changeInfo) {
	            var node = this._getNode(row, col, true, changeInfo ? changeInfo[0] : keyword_undefined);
	            if (node && node.style !== value) {
	                var oldStyle = node.style;
	                node.style = value;
	
	                if (changeInfo) {
	                    changeInfo[0].push('style');
	                    changeInfo[1] = oldStyle;
	                }
	            } else if (changeInfo) {
	                changeInfo.length = 0;
	            }
	        },
	        getValueForKey: function (row, col, key) {
	            var node = this._getNode(row, col);
	            return node && node[key];
	        },
	        setValueForKey: function (row, col, key, value, changeInfo) {
	            var node = this._getNode(row, col, true, changeInfo ? changeInfo[0] : keyword_undefined);
	            if (node && node[key] !== value) {
	                var oldValue = node[key];
	                node[key] = value;
	
	                if (changeInfo) {
	                    changeInfo[0].push(key);
	                    changeInfo[1] = oldValue;
	                }
	            } else if (changeInfo) {
	                changeInfo.length = 0;
	            }
	        },
	        _addRows: function (row, count, isUndoDeleteRows) {
	            var self = this, oldRowCount = self._rowCount, dataTable = self.dataTable, dirtyNodes = self._dirtyNodes;
	            if (0 <= row && row <= oldRowCount && count >= 0) {
	                addElements(dataTable, oldRowCount, row, count);
	                addElements(self.rowDataArray, oldRowCount, row, count);
	                addElements(dirtyNodes, oldRowCount, row, count);
	                self._rowCount += count;
	               
	                if (!isUndoDeleteRows) {
	                    for (var i = 0; i < count; i++) {
	                        dataTable[row + i] = {rs: 'n'};
	                        dirtyNodes[row + i] = dataTable[row + i];
	                    }
	                }
	            }
	        },
	        _deleteRows: function (row, count, changes) {
	            var self = this, oldRowCount = self._rowCount;
	            if (0 <= row && row < oldRowCount && count > 0) {
	                if (row + count > oldRowCount) {
	                    count = oldRowCount - row;
	                }
	
	                if (changes) {
	                    for (var i = 0; i < count; i++) {
	                        var rowIndex = row + i;
	                        changes.push([['dataTable', rowIndex], self.dataTable[rowIndex]]);
	                        changes.push([['rowDataArray', rowIndex], self.rowDataArray[rowIndex]]);
	                        changes.push([[UNDERSCORE_DIRTY_NODES, rowIndex], self._dirtyNodes[rowIndex]]);
	                    }
	                }
	
	                deleteElements(self.dataTable, oldRowCount, row, count);
	                deleteElements(self.rowDataArray, oldRowCount, row, count);
	                deleteElements(self._dirtyNodes, oldRowCount, row, count);
	                self._rowCount -= count;
	            }
	        },
	        _addColumns: function (col, count) {
	            var self = this, oldColCount = self._colCount;
	            if (0 <= col && col <= oldColCount && count >= 0) {
	                for (var i = 0; i < self._rowCount; i++) {
	                    var tr = self.dataTable[i];
	                    if (tr && col < oldColCount) {
	                        addElements(tr, oldColCount, col, count);
	                    }
	                }
	                addElements(self.columnDataArray, oldColCount, col, count);
	                self._colCount += count;
	            }
	        },
	        _deleteColumns: function (col, count, changes) {
	            var self = this, oldColCount = self._colCount;
	            if (0 <= col && col < oldColCount && count > 0) {
	                for (var i = 0; i < self._rowCount; i++) {
	                    var tr = self.dataTable[i];
	                    if (tr) {
	
	                        if (changes) {
	                            for (var j = 0; j < count; j++) {
	                                var colIndex = col + j;
	                                changes.push([['dataTable', i, colIndex], tr[colIndex]]);
	                            }
	                        }
	                        deleteElements(tr, oldColCount, col, count);
	                    }
	                }
	
	                if (changes) {
	                    for (var k = 0; k < count; k++) {
	                        var columnIndex = col + k;
	                        changes.push([['columnDataArray', columnIndex], self.columnDataArray[columnIndex]]);
	                    }
	                }
	
	                deleteElements(self.columnDataArray, oldColCount, col, count);
	                if (col + count > oldColCount) {
	                    count = oldColCount - col;
	                }
	                self._colCount -= count;
	            }
	        },
	        _getNode: function (row, col, create, paths) {
	            var self = this, dataTable = self.dataTable, columnDataArray = self.columnDataArray,
	                rowDataArray = self.rowDataArray;
	            var node = keyword_null;
	            if (row < self._rowCount && col < self._colCount) {
	                if (row >= 0 && col >= 0) {
	                    var dr = dataTable[row];
	                    if (create && !dr) {
	                        dr = dataTable[row] = {};
	                        if (row > self._lastNonNullRow) {
	                            self._lastNonNullRow = row;
	                        }
	                    }
	                    if (dr) {
	                        node = dr[col];
	                        if (create && !node) {
	                            node = dr[col] = {};
	                            if (self._lastNonNullColumn < col) {
	                                self._lastNonNullColumn = col;
	                            }
	                        }
	                    }
	                    if (paths) {
	                        paths.push('dataTable', row, col);
	                    }
	                } else if (row === -1 && col >= 0) {
	                    node = columnDataArray[col];
	                    if (create && !node) {
	                        node = columnDataArray[col] = {};
	                        if (self._lastNonNullColumn < col) {
	                            self._lastNonNullColumn = col;
	                        }
	                    }
	                    if (paths) {
	                        paths.push('columnDataArray', col);
	                    }
	                } else if (row >= 0 && col === -1) {
	                    node = rowDataArray[row];
	                    if (create && !node) {
	                        node = rowDataArray[row] = {};
	                        if (self._lastNonNullRow < row) {
	                            self._lastNonNullRow = row;
	                        }
	                    }
	                    if (paths) {
	                        paths.push('rowDataArray', row);
	                    }
	                } else if (row === -1 && col === -1) {
	                    node = self.defaultDataNode;
	                    if (create && !node) {
	                        node = self.defaultDataNode = {};
	                    }
	                    if (paths) {
	                        paths.push('defaultDataNode');
	                    }
	                }
	            }
	            return node;
	        },
	        setNode: function (row, col, nodeValue) {
	            var self = this, dataTable = self.dataTable, columnDataArray = self.columnDataArray,
	                rowDataArray = self.rowDataArray;
	            if (row < self._rowCount && col < self._colCount) {
	                if (row >= 0 && col >= 0) {
	                    var dr = dataTable[row];
	                    if (!dr) {
	                        dr = dataTable[row] = {};
	                    }
	                    dr[col] = nodeValue;
	                } else if (row === -1 && col >= 0) {
	                    columnDataArray[col] = nodeValue;
	                } else if (col === -1 && row >= 0) {
	                    rowDataArray[row] = nodeValue;
	                }
	            }
	        },
	        _swapNode: function (row, col, row2, col2, changeInfos) {
	            var paths, paths2;
	            if (changeInfos) {
	                paths = [];
	                paths2 = [];
	            }
	            var self = this, dataTable = self.dataTable, rowDataArray = self.rowDataArray,
	                columnDataArray = self.columnDataArray;
	            var node = self._getNode(row, col, keyword_undefined, paths);
	            var node2 = self._getNode(row2, col2, keyword_undefined, paths2);
	            if (changeInfos) {
	                changeInfos.push([paths, node]);
	                changeInfos.push([paths2, node2]);
	            }
	
	            if (node) {
	                _setNode4Swap(row, col, row2, col2, node, dataTable, rowDataArray, columnDataArray);
	            } else if (node2) {
	                _setNode4Swap(row, col, row2, col2, keyword_null, dataTable, rowDataArray, columnDataArray);
	            }
	            if (node2) {
	                _setNode4Swap(row2, col2, row, col, node2, dataTable, rowDataArray, columnDataArray);
	            } else if (node) {
	                _setNode4Swap(row2, col2, row, col, keyword_null, dataTable, rowDataArray, columnDataArray);
	            }
	        },
	        _nextNonNullRow: function (row) {
	            row++;
	            var rowCount = this._rowCount, dataTable = this.dataTable;
	            while (row >= 0 && row < rowCount) {
	                if (dataTable[row]) {
	                    break;
	                }
	                row++;
	            }
	            if (row < rowCount) {
	                return row;
	            }
	            return -1;
	        },
	        _nextNonNullColumn: function (row, col) {
	            var self = this;
	            var dr = keyword_null, colCount = self._colCount;
	            if (row >= 0 && row < self._rowCount) {
	                dr = self.dataTable[row];
	            }
	            if (dr) {
	                col++;
	                while (col >= 0 && col < colCount) {
	                    if (dr[col]) {
	                        break;
	                    }
	                    col++;
	                }
	                if (col < colCount) {
	                    return col;
	                }
	            }
	            return -1;
	        },
	        clear: function (row, column, rowCount, columnCount, type, ignoredRowList, changeInfos) {
	            var self = this, oldRowCount = self._rowCount, oldColCount = self._colCount;
	            var nodes = [];
	            var node, c, r;
	            var needChangeInfo = !!changeInfos, pathsArray = [], paths;
	            if (row >= 0 && column >= 0) {
	                rowCount = Math_min(rowCount, oldRowCount - row);
	                columnCount = Math_min(columnCount, oldColCount - column);
	                if (rowCount > 0 && columnCount > 0) {
	                    for (r = row; r < row + rowCount; r++) {
	                        if (!ignoredRowList || Common._ArrayHelper._indexOf(ignoredRowList, r) < 0) {
	                            for (c = column; c < column + columnCount; c++) {
	                                if (needChangeInfo) {
	                                    paths = [];
	                                }
	                                node = self._getNode(r, c, keyword_undefined, paths);
	                                if (node) {
	                                    nodes.push(node);
	
	                                    if (needChangeInfo) {
	                                        pathsArray.push(paths);
	                                    }
	                                   
	                                    if ((type & 1 ) > 0 && !isNullOrUndefined(node.value)) {
	                                        var dirtyChangeInfo;
	                                        if (needChangeInfo) {
	                                            dirtyChangeInfo = {};
	                                        }
	                                        self._updateDirty(r, c, {_oldValue: node.value}, dirtyChangeInfo);
	                                        if (dirtyChangeInfo) {
	                                            changeInfos.push(dirtyChangeInfo);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            } else if (row >= 0 && column === -1) {
	                rowCount = Math_min(rowCount, oldRowCount - row);
	                if (rowCount > 0) {
	                    for (r = row; r < row + rowCount; r++) {
	                        if (needChangeInfo) {
	                            paths = [];
	                        }
	                        node = self._getNode(r, -1, keyword_undefined, paths);
	                        if (node) {
	                            nodes.push(node);
	
	                            if (needChangeInfo) {
	                                pathsArray.push(paths);
	                            }
	                        }
	                    }
	                }
	            } else if (row === -1 && column >= 0) {
	                columnCount = Math_min(columnCount, oldColCount - column);
	                if (columnCount > 0) {
	                    for (c = column; c < column + columnCount; c++) {
	                        if (needChangeInfo) {
	                            paths = [];
	                        }
	                        node = self._getNode(-1, c, keyword_undefined, paths);
	                        if (node) {
	                            nodes.push(node);
	
	                            if (needChangeInfo) {
	                                pathsArray.push(paths);
	                            }
	                        }
	                    }
	                }
	            } else if (row === -1 && column === -1) {
	                if (needChangeInfo) {
	                    paths = [];
	                }
	                node = self._getNode(-1, -1, keyword_undefined, paths);
	                if (node) {
	                    nodes.push(node);
	
	                    if (needChangeInfo) {
	                        pathsArray.push(paths);
	                    }
	                }
	            }
	
	            for (var i = 0; i < nodes.length; i++) {
	                node = nodes[i];
	                if (node) {
	                    var propertyNameOldValueArray = needChangeInfo ? [] : keyword_undefined;
	                    if ((type & 8 ) > 0) {
	                        if (propertyNameOldValueArray) {
	                            propertyNameOldValueArray.push(['tag', node.tag]);
	                        }
	                        node.tag = keyword_null;
	                    }
	                    if ((type & 2 ) > 0) {
	                        if (propertyNameOldValueArray) {
	                            propertyNameOldValueArray.push(['style', node.style]);
	                        }
	                        node.style = keyword_null;
	                    }
	                    if ((type & 1 ) > 0) {
	                        if (propertyNameOldValueArray) {
	                            propertyNameOldValueArray.push(['value', node.value]);
	                        }
	                        node.value = keyword_null;
	                    }
	                    if ((type & 16 ) > 0) {
	                        if (propertyNameOldValueArray) {
	                            propertyNameOldValueArray.push(['sparkline', node.sparkline]);
	                        }
	                        node.sparkline = keyword_null;
	                    }
	                    if ((type & 64 ) > 0) {
	                        if (propertyNameOldValueArray) {
	                            propertyNameOldValueArray.push(['bindingPath', node.bindingPath]);
	                        }
	                        node.bindingPath = keyword_null;
	                    }
	                    if ((type & 4 ) > 0) {
	                        if (propertyNameOldValueArray) {
	                            propertyNameOldValueArray.push(['comment', node.comment]);
	                        }
	                        node.comment = keyword_null;
	                    }
	
	                    if (needChangeInfo) {
	                        propertyNameOldValueArray.forEach(function (propertyNameOldValue) {
	                            var tmp = pathsArray[i].slice(0);
	                            tmp.push(propertyNameOldValue[0]);
	                            propertyNameOldValue[0] = tmp;
	                            changeInfos.push(propertyNameOldValue);
	                        });
	                    }
	                }
	            }
	        },
	        toJSON: function (sheetArea, serializationOption) {
	           
	            function _toJSONNode(node, sheetArea, checkDefaultValue) {  
	                if (!node) {
	                    return keyword_null;
	                }
	                var jsonNode = {};
	               
	
	               
	                var nodeValue = node.value;
	                if (!isNullOrUndefined(nodeValue)) {
	                    jsonNode.value = nodeValue;
	                }
	               
	                var ignoreStyle = serializationOption && serializationOption.ignoreStyle;
	                if (!ignoreStyle) {
	                    var nodeStyle = node.style;
	                    if (typeof nodeStyle === "string") {
	                        jsonNode.style = nodeStyle;
	                    } else if (nodeStyle) {
	                        var style = nodeStyle.toJSON(sheetArea, checkDefaultValue), nodeStyleFont = nodeStyle.font;
	                        if (style) {
	                           
	                            if (nodeStyleFont) {
	                                style.font = StyleHelper._normalizeFont(nodeStyleFont);
	                            }
	                           
	                            style.name = keyword_undefined;
	                            jsonNode.style = style;
	                        }
	                    }
	                }
	
	               
	                var nodeBindingPath = node.bindingPath;
	                if (!isNullOrUndefined(nodeBindingPath)) {
	                    jsonNode.bindingPath = nodeBindingPath;
	                }
	               
	                var nodeTag = node.tag;
	                if (!isNullOrUndefined(nodeTag)) {
	                    jsonNode.tag = nodeTag;
	                }
	
	                return jsonNode;
	            }
	
	            var self = this;
	            var jsonData = {};
	           
	            var ndata = {};
	            var r = self._nextNonNullRow(-1), c;
	            while (r >= 0) {
	                var ndr = {}, hasRowData = false;
	                c = self._nextNonNullColumn(r, -1);
	                while (c >= 0) {
	                    var node = self._getNode(r, c);
	                    if (node) {
	                        var ndc = _toJSONNode(node);
	                        if (!$_isEmptyObject(ndc)) {
	                            ndr[c] = ndc;
	                            hasRowData = true;
	                        }
	                    }
	                    c = self._nextNonNullColumn(r, c);
	                }
	                if (hasRowData) {
	                    ndata[r] = ndr;
	                }
	                r = self._nextNonNullRow(r);
	            }
	            if (!$_isEmptyObject(ndata)) {
	                jsonData['dataTable'] = ndata;
	            }
	           
	            var nRowData = [];
	            var rowData = self.rowDataArray;
	            for (r = 0; r < self._rowCount; r++) {
	                if (_hasOwnProperty(rowData, r) && rowData[r]) {
	                    var rowDataJSON = _toJSONNode(rowData[r]);
	                    if (!$_isEmptyObject(rowDataJSON)) {
	                        nRowData[r] = rowDataJSON;
	                    }
	                }
	            }
	            if (nRowData.length > 0) {
	                jsonData['rowDataArray'] = nRowData;
	            }
	           
	            var nColData = [];
	            var colData = self.columnDataArray;
	            for (c = 0; c < self._colCount; c++) {
	                if (_hasOwnProperty(colData, c) && colData[c]) {
	                    var colDataJSON = _toJSONNode(colData[c]);
	                    if (!$_isEmptyObject(colDataJSON)) {
	                        nColData[c] = colDataJSON;
	                    }
	                }
	            }
	            if (nColData.length > 0) {
	                jsonData['columnDataArray'] = nColData;
	            }
	           
	            var defaultDataNode = _toJSONNode(self.defaultDataNode, sheetArea, true);
	            if (!$_isEmptyObject(defaultDataNode)) {
	                jsonData['defaultDataNode'] = defaultDataNode;
	            }
	            return jsonData;
	        },
	        fromJSON: function (setting, noSchema, options) {
	
	            if (!setting) {
	                return;
	            }
	            var self = this;
	           
	            self._dirtySuspended++;
	
	           
	            var data = setting.dataTable, r, c;
	            var rowCount = self._rowCount;
	            var colCount = self._colCount;
	            var dr, node;
	            if (data) {
	                for (r = 0; r < rowCount; r++) {
	                    dr = data[r];
	                    if (dr) {
	                        for (c = 0; c < colCount; c++) {
	                            node = dr[c];
	                            if (node) {
	                                _copyFromJSONNode(node, self._getNode(r, c, true), noSchema, r, c, options);
	                            }
	                        }
	                    }
	                }
	            }
	           
	            var rowData = setting.rowDataArray || setting._rowDataArray;
	            if (rowData) {
	                for (r = 0; r < rowCount; r++) {
	                    if (_hasOwnProperty(rowData, r) && rowData[r]) {
	                        _copyFromJSONNode(rowData[r], self._getNode(r, -1, true), noSchema, r, -1, options);
	                    }
	                }
	            }
	           
	            var colData = setting.columnDataArray || setting._columnDataArray;
	            if (colData) {
	                for (c = 0; c < colCount; c++) {
	                    if (_hasOwnProperty(colData, c) && colData[c]) {
	                        _copyFromJSONNode(colData[c], self._getNode(-1, c, true), noSchema, -1, c, options);
	                    }
	                }
	            }
	           
	            var defDataNode = setting.defaultDataNode || setting._defaultDataNode;
	            if (defDataNode) {
	                _copyFromJSONNode(defDataNode, self._getNode(-1, -1, true), noSchema, -1, -1, options);
	            }
	
	           
	            self._dirtySuspended--;
	        }
	    };
	   
	
	   
	
	    function _AxisModel() {
	        this.infos = [];
	    }
	
	    var _AxisModel_prototype = _AxisModel.prototype = {
	        _addItems: function (index, count) {
	            var infos = this.infos, length = infos.length;
	            if (0 <= index && index <= length && count > 0) {
	                addElements(infos, length, index, count);
	            }
	        },
	        _deleteItems: function (index, count, changes) {
	            var infos = this.infos, length = infos.length;
	            if (0 <= index && index < length && count > 0) {
	                count = Math_min(count, length - index);
	
	                if (changes) {
	                    for (var i = 0; i < count; i++) {
	                        var tmpIndex = index + i;
	                        changes.push([['infos', tmpIndex], infos[tmpIndex]]);
	                    }
	                }
	
	                deleteElements(infos, length, index, count);
	            }
	        },
	        _getItemCount: function () {
	            return this.infos.length;
	        },
	        _getItems: function () {
	            return this.infos;
	        },
	        _getItem: function (index) {
	            return this.infos[index];
	        },
	        _setItem: function (index, item, changeInfo) {
	            var oldItem = this.infos[index];
	            this.infos[index] = item;
	
	            if (changeInfo) {
	                changeInfo[0].push('infos', index);
	                changeInfo[1] = oldItem;
	            }
	        },
	        getSize: function (index) {
	            var info = this.infos[index], size = keyword_null;
	            if (info) {
	                if (info.visible === false) {
	                    size = 0;
	                } else {
	                    size = Math_floor(info.size);
	                }
	            }
	            return size;
	        },
	        getActualSize: function (index) {
	            var info = this.infos[index];
	            return info ? Math_floor(info.size) : keyword_null;
	        },
	        setSize: function (index, value, changeInfo) {
	            var infos = this.infos;
	            var info = infos[index];
	            if (!info) {
	                info = infos[index] = {};
	            }
	            var oldSize = info.size;
	            if (oldSize !== value) {
	                info.size = value;
	            }
	
	            if (changeInfo) {
	                changeInfo[0].push('infos', index, 'size');
	                changeInfo[1] = oldSize;
	            }
	        },
	        toJSON: function () {
	            var infos = this.infos;
	            var array = [];
	            for (var i = 0; i < infos.length; i++) {
	                if (!isNullOrUndefined(infos[i])) {
	                    array[i] = infos[i];
	                }
	            }
	            return array.length > 0 ? array : keyword_undefined;
	        },
	        fromJSON: function (setting) {
	            if (setting) {
	                this.infos = setting;
	            }
	        }
	    };
	    $_each({visible: true, resizable: true, pageBreak: false}, function (p, v) {
	        var partOfName = p[0].toUpperCase() + p.substr(1);
	        _AxisModel_prototype['get' + partOfName] = function (index) {
	            var result = v;
	            var info = this.infos[index];
	            if (info && !isNullOrUndefined(info[p])) {
	                result = info[p];
	            }
	            return result;
	        };
	        _AxisModel_prototype['set' + partOfName] = function (index, value, changeInfo) {
	            var infos = this.infos;
	            var info = infos[index];
	            if (!info) {
	                info = infos[index] = {};
	            }
	            var oldValue = info[p];
	            if (oldValue !== value) {
	                info[p] = value;
	            }
	
	            if (changeInfo) {
	                changeInfo[0].push('infos', index, p);
	                changeInfo[1] = oldValue;
	            }
	        };
	    });
	
	    function _copyFromJSONNode(node, targetNode, noSchema, row, col, options) {
	        if (node) {
	           
	           
	            var nodeValue = node.value;
	            if (nodeValue !== keyword_undefined) {
	               
	                if (nodeValue !== keyword_null && (nodeValue._calcError || nodeValue._error && nodeValue._code)) {
	                    var CalcEngine_module = __webpack_require__(2);
	                    var value = CalcEngine_module && CalcEngine_module.CalcError.parse(nodeValue._calcError || nodeValue._error);
	                    if (value !== keyword_undefined) {
	                        value = tryAddCacheToRichText(value);
	                        nodeValue = value;
	                    }
	                }
	                targetNode.value = nodeValue;
	            }
	           
	            var nodeStyle = node.style, sheet = options && options.sheet;
	            if (nodeStyle !== keyword_undefined && !options.ignoreStyle) {
	                var style = keyword_null;
	                if (typeof (nodeStyle) === const_string) {
	                    targetNode.style = nodeStyle;
	                    style = sheet && (sheet._getNamedStyleImp(nodeStyle, false) || sheet.parent && sheet.parent._getNamedStyleImp(nodeStyle, false));
	                } else if (nodeStyle) {
	                    style = new Style();
	                    style.fromJSON(nodeStyle, noSchema);
	                   
	                    style.name = keyword_undefined;
	                    targetNode.style = style;
	                }
	               
	                style && style.validator && options && options.setValidator && options.setValidator(row, col, style.validator);
	            }
	           
	            var nodeVisualState = node.visualState;
	            if (nodeVisualState !== keyword_undefined) {
	                targetNode.visualState = nodeVisualState;
	            }
	           
	            var nodeBindingPath = node.bindingPath;
	            if (nodeBindingPath !== keyword_undefined) {
	                targetNode.bindingPath = nodeBindingPath;
	            }
	           
	            var tagObj = node.tag;
	            if (tagObj !== keyword_undefined) {
	                var typeName = tagObj.typeName;
	                if (typeof typeName === const_string) {
	                    var tagClass = util_common.getTypeFromString(typeName);
	                    if (tagClass) {
	                        tagObj = new tagClass();
	                        if (tagObj.fromJSON) {
	                            tagObj.fromJSON(node.tag);
	                        }
	                    }
	                }
	                targetNode.tag = tagObj;
	            }
	        }
	    }
	
	   
	
	   
	    var DEFAULT_ROW_HEIGHT = 20;
	    var DEFAULT_COL_WIDTH = 62;
	    var DEFAULT_ROW_HEADER_COL_WIDTH = 40;
	    var DEFAULT_COL_HEADER_ROW_HEIGHT = 20;
	
	    function _SheetModelManager(sheet, viewportRowCount, viewportColCount, colHeaderRowCount, rowHeaderColCount, name) {
	        var self = this;
	        self._sheet = sheet;
	        self.sheetModels = [
	            keyword_undefined,
	            new _SheetModel(colHeaderRowCount, viewportColCount),
	            new _SheetModel(viewportRowCount, rowHeaderColCount),
	            new _SheetModel(viewportRowCount, viewportColCount)
	        ];
	
	        var rowInfos = self.rowInfos = [];
	        rowInfos[0 ] = rowInfos[1 ] = new _AxisModel();
	        rowInfos[2 ] = rowInfos[3 ] = new _AxisModel();
	
	        var colInfos = self.colInfos = [];
	        colInfos[0 ] = colInfos[2 ] = new _AxisModel();
	        colInfos[1 ] = colInfos[3 ] = new _AxisModel();
	
	        self.spanModels = [
	            keyword_undefined,
	            new _SpanModel(),
	            new _SpanModel(),
	            new _SpanModel()
	        ];
	
	        self.selectionModel = new _SelectionModel();
	
	        self.name = name || '';
	        self.zoomFactor = 1;
	
	        function setCallback(obj, value, propName, oldValue) {
	            if (self._inTransaction > 0) {
	                self._changes.push([['defaults', propName], oldValue]);
	            }
	        }
	
	        var defaults = self.defaults = {};
	        defineProperty(defaults, 'rowHeight', DEFAULT_ROW_HEIGHT, setCallback);
	        defineProperty(defaults, 'colWidth', DEFAULT_COL_WIDTH, setCallback);
	        defineProperty(defaults, 'rowHeaderColWidth', DEFAULT_ROW_HEADER_COL_WIDTH, setCallback);
	        defineProperty(defaults, 'colHeaderRowHeight', DEFAULT_COL_HEADER_ROW_HEIGHT, setCallback);
	
	        self._inTransaction = 0;
	
	        _SheetModelManager._callFeatureHandler(this, 'init');
	    }
	
	    function undoChange(root, change) {
	        var paths = change[0];
	        var node = root;
	        for (var i = 0; i < paths.length - 1; i++) {
	            if (isNullOrUndefined(node)) {
	                return;
	            }
	            var propName = paths[i];
	            if (propName === UNDERSCORE_DIRTY_NODES) {
	                node = node._dirtyNodes;
	            } else {
	                node = node[propName];
	            }
	        }
	        node[paths[i]] = change[1];
	    }
	
	    _SheetModelManager.prototype = {
	        addRows: function (row, rowCount, sheetModelOnly, isUndoDeleteRows) {
	            var self = this;
	            var changeInfo;
	            if (self._inTransaction > 0) {
	               
	               
	
	                changeInfo = {row: row, rowCount: rowCount, type: 'addRows'};
	                self._changes.push(changeInfo);
	            }
	
	            self._getSheetModel(3 )._addRows(row, rowCount, isUndoDeleteRows);
	            self._getSheetModel(2 )._addRows(row, rowCount, isUndoDeleteRows);
	
	            self._getSpanModel(3 )._addRows(row, rowCount);
	            self._getSpanModel(2 )._addRows(row, rowCount);
	
	            self._getAxisModel(true, 3 )._addItems(row, rowCount);
	
	            if (!sheetModelOnly) {
	                _SheetModelManager._callFeatureHandler(self, 'addRows', {
	                    row: row,
	                    rowCount: rowCount,
	                    changes: self._changes
	                });
	            }
	
	           
	           
	           
	           
	           
	
	           
	           
	           
	           
	        },
	        _undoAddRows: function (changeInfo) {
	            this.deleteRows(changeInfo.row, changeInfo.rowCount, true);
	
	           
	           
	           
	           
	        },
	        deleteRows: function (row, rowCount, sheetModelOnly) {
	            var self = this;
	
	            var changeInfo, viewportSheetModelChanges, rowHeaderSheetModelChanges, viewportSpanModelChanges,
	                rowHeaderSpanModelChanges, viewportAxisModelChanges;
	            if (self._inTransaction > 0) {
	                viewportSheetModelChanges = [];
	                rowHeaderSheetModelChanges = [];
	                viewportSpanModelChanges = [['spanModels', 3 ], keyword_undefined];
	                rowHeaderSpanModelChanges = [['spanModels', 2 ], keyword_undefined];
	                viewportAxisModelChanges = [];
	
	                changeInfo = {row: row, rowCount: rowCount, type: 'deleteRows'};
	                self._changes.push(changeInfo);
	            }
	
	            self._getSheetModel(3 )._deleteRows(row, rowCount, viewportSheetModelChanges);
	            self._getSheetModel(2 )._deleteRows(row, rowCount, rowHeaderSheetModelChanges);
	
	            self._getSpanModel(3 )._removeRows(row, rowCount, viewportSpanModelChanges);
	            self._getSpanModel(2 )._removeRows(row, rowCount, rowHeaderSpanModelChanges);
	
	            self._getAxisModel(true, 3 )._deleteItems(row, rowCount, viewportAxisModelChanges);
	
	            if (!sheetModelOnly) {
	                _SheetModelManager._callFeatureHandler(self, 'deleteRows', {
	                    row: row,
	                    rowCount: rowCount,
	                    changes: self._changes
	                });
	            }
	
	            if (changeInfo) {
	                var changes = changeInfo.changes = [];
	                var partPath = ['sheetModels', 3 ];
	                for (var i = 0; i < viewportSheetModelChanges.length; i++) {
	                    viewportSheetModelChanges[i][0] = partPath.concat(viewportSheetModelChanges[i][0]);
	
	                    changes.push(viewportSheetModelChanges[i]);
	                }
	
	                partPath = ['sheetModels', 2 ];
	                for (i = 0; i < rowHeaderSheetModelChanges.length; i++) {
	                    rowHeaderSheetModelChanges[i][0] = partPath.concat(rowHeaderSheetModelChanges[i][0]);
	
	                    changes.push(rowHeaderSheetModelChanges[i]);
	                }
	
	                if (viewportSpanModelChanges.length > 0) {
	                    changes.push(viewportSpanModelChanges);
	                }
	
	                if (rowHeaderSpanModelChanges.length > 0) {
	                    changes.push(rowHeaderSpanModelChanges);
	                }
	
	                partPath = ['rowInfos', 3 ];
	                for (i = 0; i < viewportAxisModelChanges.length; i++) {
	                    viewportAxisModelChanges[i][0] = partPath.concat(viewportAxisModelChanges[i][0]);
	
	                    changes.push(viewportAxisModelChanges[i]);
	                }
	            }
	        },
	        _undoDeleteRows: function (changeInfo) {
	            this.addRows(changeInfo.row, changeInfo.rowCount, true, true);
	
	            var changes = changeInfo.changes;
	            for (var j = changes.length - 1; j >= 0; j--) {
	                undoChange(this, changes[j]);
	            }
	        },
	        addColumns: function (col, colCount, sheetModelOnly) {
	            var self = this;
	
	            var changeInfo;
	            if (self._inTransaction > 0) {
	               
	               
	
	                changeInfo = {col: col, colCount: colCount, type: 'addColumns'};
	                self._changes.push(changeInfo);
	            }
	
	            self._getSheetModel(3 )._addColumns(col, colCount);
	            self._getSheetModel(1 )._addColumns(col, colCount);
	
	            self._getSpanModel(3 )._addColumns(col, colCount);
	            self._getSpanModel(1 )._addColumns(col, colCount);
	
	            self._getAxisModel(false, 3 )._addItems(col, colCount);
	
	            if (!sheetModelOnly) {
	                _SheetModelManager._callFeatureHandler(self, 'addColumns', {
	                    col: col,
	                    colCount: colCount,
	                    changes: self._changes
	                });
	            }
	
	           
	           
	           
	           
	           
	
	           
	           
	           
	           
	        },
	        _undoAddColumns: function (changeInfo) {
	            this.deleteColumns(changeInfo.col, changeInfo.colCount, true);
	
	           
	           
	           
	           
	        },
	        deleteColumns: function (col, colCount, sheetModelOnly) {
	            var self = this;
	
	            var changeInfo, viewportSheetModelChanges, colHeaderSheetModelChanges, viewportSpanModelChanges,
	                colHeaderSpanModelChanges, viewportAxisModelChanges;
	            if (self._inTransaction > 0) {
	                viewportSheetModelChanges = [];
	                colHeaderSheetModelChanges = [];
	                viewportSpanModelChanges = [['spanModels', 3 ], keyword_undefined];
	                colHeaderSpanModelChanges = [['spanModels', 1 ], keyword_undefined];
	                viewportAxisModelChanges = [];
	
	                changeInfo = {col: col, colCount: colCount, type: 'deleteColumns'};
	                self._changes.push(changeInfo);
	            }
	
	            self._getSheetModel(3 )._deleteColumns(col, colCount, viewportSheetModelChanges);
	            self._getSheetModel(1 )._deleteColumns(col, colCount, colHeaderSheetModelChanges);
	
	            self._getSpanModel(3 )._removeColumns(col, colCount, viewportSpanModelChanges);
	            self._getSpanModel(1 )._removeColumns(col, colCount, colHeaderSpanModelChanges);
	
	            self._getAxisModel(false, 3 )._deleteItems(col, colCount, viewportAxisModelChanges);
	
	            if (!sheetModelOnly) {
	                _SheetModelManager._callFeatureHandler(self, 'deleteColumns', {
	                    col: col,
	                    colCount: colCount,
	                    changes: self._changes
	                });
	            }
	
	            if (changeInfo) {
	                var changes = changeInfo.changes = [];
	                var partPath = ['sheetModels', 3 ];
	                for (var i = 0; i < viewportSheetModelChanges.length; i++) {
	                    viewportSheetModelChanges[i][0] = partPath.concat(viewportSheetModelChanges[i][0]);
	
	                    changes.push(viewportSheetModelChanges[i]);
	                }
	
	                partPath = ['sheetModels', 1 ];
	                for (i = 0; i < colHeaderSheetModelChanges.length; i++) {
	                    colHeaderSheetModelChanges[i][0] = partPath.concat(colHeaderSheetModelChanges[i][0]);
	
	                    changes.push(colHeaderSheetModelChanges[i]);
	                }
	
	                if (viewportSpanModelChanges.length > 0) {
	                    changes.push(viewportSpanModelChanges);
	                }
	
	                if (colHeaderSpanModelChanges.length > 0) {
	                    changes.push(colHeaderSpanModelChanges);
	                }
	
	                partPath = ['colInfos', 3 ];
	                for (i = 0; i < viewportAxisModelChanges.length; i++) {
	                    viewportAxisModelChanges[i][0] = partPath.concat(viewportAxisModelChanges[i][0]);
	
	                    changes.push(viewportAxisModelChanges[i]);
	                }
	            }
	        },
	        _undoDeleteColumns: function (changeInfo) {
	            this.addColumns(changeInfo.col, changeInfo.colCount, true);
	
	            var changes = changeInfo.changes;
	            for (var j = changes.length - 1; j >= 0; j--) {
	                undoChange(this, changes[j]);
	            }
	        },
	        getRowCount: function (sheetArea) {
	            return this._getSheetModel(sheetArea).getRowCount();
	        },
	        setRowCount: function (rowCount, sheetArea, sheetModelOnly) {
	            var self = this;
	            var oldRowCount = self.getRowCount(sheetArea);
	
	            if (self._inTransaction > 0) {
	                self._changes.push({oldRowCount: oldRowCount, sheetArea: sheetArea, type: 'setRowCount'});
	            }
	
	            if (sheetArea === 3  || sheetArea === 2 ) {
	                if (oldRowCount > rowCount) {
	                    self.deleteRows(rowCount, oldRowCount - rowCount, sheetModelOnly);
	                }
	                self._getSheetModel(3 ).setRowCount(rowCount);
	                self._getSheetModel(2 ).setRowCount(rowCount);
	            } else if (sheetArea === 1 ) {
	                if (oldRowCount > rowCount) {
	                    self._getAxisModel(true, sheetArea)._deleteItems(rowCount, oldRowCount - rowCount);
	                }
	                self._getSheetModel(sheetArea).setRowCount(rowCount);
	            }
	        },
	        _undoSetRowCount: function (change) {
	            this.setRowCount(change.oldRowCount, change.sheetArea, true);
	        },
	        getColumnCount: function (sheetArea) {
	            return this._getSheetModel(sheetArea).getColumnCount();
	        },
	        setColumnCount: function (colCount, sheetArea, sheetModelOnly) {
	            var self = this;
	            var oldColCount = self.getColumnCount(sheetArea);
	
	            if (self._inTransaction > 0) {
	                self._changes.push({oldColCount: oldColCount, sheetArea: sheetArea, type: 'setColumnCount'});
	            }
	
	            if (sheetArea === 3  || sheetArea === 1 ) {
	                if (oldColCount > colCount) {
	                    self.deleteColumns(colCount, oldColCount - colCount, sheetModelOnly);
	                }
	                self._getSheetModel(3 ).setColumnCount(colCount);
	                self._getSheetModel(1 ).setColumnCount(colCount);
	            } else if (sheetArea === 2 ) {
	                if (oldColCount > colCount) {
	                    self._getAxisModel(false, sheetArea)._deleteItems(colCount, oldColCount - colCount);
	                }
	                self._getSheetModel(sheetArea).setColumnCount(colCount);
	            }
	        },
	        _undoSetColumnCount: function (change) {
	            this.setColumnCount(change.oldColCount, change.sheetArea, true);
	        },
	        getLastNonNullRow: function (sheetArea) {
	            var itemCount = this._getAxisModel(true, sheetArea)._getItemCount();
	            return Math_max(this._getSheetModel(sheetArea)._lastNonNullRow, this._getSpanModel(sheetArea)._lastNonNullRow, Math_max(itemCount - 1, 0));
	        },
	        getLastNonNullCol: function (sheetArea) {
	            var itemCount = this._getAxisModel(false, sheetArea)._getItemCount();
	            return Math_max(this._getSheetModel(sheetArea)._lastNonNullColumn, this._getSpanModel(sheetArea)._lastNonNullColumn, Math_max(itemCount - 1, 0));
	        },
	        toJSON: function (serializationOption) {
	            var self = this;
	            var json = {};
	           
	            json.data = self._getSheetModel(3 ).toJSON(3 , serializationOption);
	            json.rowHeaderData = self._getSheetModel(2 ).toJSON(2 , serializationOption);
	            json.colHeaderData = self._getSheetModel(1 ).toJSON(1 , serializationOption);
	
	           
	            json.rows = self._getAxisModel(true, 3 ).toJSON();
	            json.columns = self._getAxisModel(false, 3 ).toJSON();
	            json.rowHeaderColInfos = self._getAxisModel(false, 2 ).toJSON();
	            json.colHeaderRowInfos = self._getAxisModel(true, 1 ).toJSON();
	
	            var ignoreStyle = serializationOption && serializationOption.ignoreStyle;
	            if (!ignoreStyle) {
	               
	                json.spans = self._getSpanModel(3 ).toJSON();
	                json.rowHeaderSpan = self._getSpanModel(2 ).toJSON();
	                json.colHeaderSpan = self._getSpanModel(1 ).toJSON();
	            }
	
	           
	            json.selections = self.selectionModel.toJSON();
	           
	            json.tag = self.getValueForKey(-1, -1, 'tag', 3 );
	           
	            var optionDefaults = self.defaults;
	            var defaults = {
	                colHeaderRowHeight: optionDefaults.colHeaderRowHeight,
	                colWidth: optionDefaults.colWidth,
	                rowHeaderColWidth: optionDefaults.rowHeaderColWidth,
	                rowHeight: optionDefaults.rowHeight
	            };
	            var isSameWithDefaults = defaults.rowHeight === DEFAULT_ROW_HEIGHT &&
	                defaults.colWidth === DEFAULT_COL_WIDTH &&
	                defaults.rowHeaderColWidth === DEFAULT_ROW_HEADER_COL_WIDTH &&
	                defaults.colHeaderRowHeight === DEFAULT_COL_HEADER_ROW_HEIGHT;
	            if (!isSameWithDefaults) {
	                json.defaults = defaults;
	            }
	            return json;
	        },
	        fromJSON: function (setting, noSchema, options) {
	            var self = this;
	           
	            self._getSheetModel(3 ).fromJSON(setting.data, noSchema, options, 3 );
	            self._getSheetModel(2 ).fromJSON(setting.rowHeaderData, noSchema, options, 2 );
	            self._getSheetModel(1 ).fromJSON(setting.colHeaderData, noSchema, options, 1 );
	
	           
	            self._getAxisModel(true, 3 ).fromJSON(setting.rows);
	            self._getAxisModel(false, 3 ).fromJSON(setting.columns);
	            self._getAxisModel(false, 2 ).fromJSON(setting.rowHeaderColInfos);
	            self._getAxisModel(true, 1 ).fromJSON(setting.colHeaderRowInfos);
	
	            var ignoreStyle = options && options.ignoreStyle;
	            if (!ignoreStyle) {
	               
	                self._getSpanModel(3 ).fromJSON(setting.spans);
	                self._getSpanModel(2 ).fromJSON(setting.rowHeaderSpan);
	                self._getSpanModel(1 ).fromJSON(setting.colHeaderSpan);
	            }
	
	           
	            self.selectionModel.fromJSON(setting.selections);
	           
	            var tagObj = setting.tag;
	            if (tagObj !== keyword_undefined) {
	                var tagTypeName = tagObj.typeName;
	                if (typeof tagTypeName === const_string) {
	                    var tagClass = util_common.getTypeFromString(tagTypeName);
	                    if (tagClass) {
	                        tagObj = new tagClass();
	                        if (tagObj.fromJSON) {
	                            tagObj.fromJSON(setting.tag);
	                        }
	                    }
	                }
	                self.do('setValueForKey', -1, -1, 'tag', tagObj, 3 );
	            }
	           
	            var setting_defaults = setting.defaults;
	            if (setting_defaults !== keyword_undefined) {
	                var defaults = self.defaults;
	                defaults.colHeaderRowHeight = setting_defaults.colHeaderRowHeight;
	                defaults.colWidth = setting_defaults.colWidth;
	                defaults.rowHeaderColWidth = setting_defaults.rowHeaderColWidth;
	                defaults.rowHeight = setting_defaults.rowHeight;
	            }
	        },
	        startTransaction: function () {
	            if (this._inTransaction === 0) {
	                
	                this._changes = [];
	                var sheet = this._sheet, needEvent = !sheet.isEventSuspended();
	                if (needEvent) {
	                    this._changes.events = [];
	                }
	
	               
	               
	               
	            }
	            this._inTransaction++;
	        },
	        endTransaction: function () {
	            this._inTransaction--;
	            if (this._inTransaction === 0) {
	                _SheetModelManager._callFeatureHandler(this, 'endTransaction');
	                var changes = this._changes;
	                this._changes = keyword_undefined;
	                var events = changes.events;
	                if (events && events.length === 0) {
	                    delete changes.events;
	                }
	                return changes;
	            }
	            return [];
	        },
	        _getChangesForCalcEngine: function () {
	            var changes = this._changes;
	            if (changes) {
	                if (!changes.calc) {
	                    changes.calc = [];
	                }
	                return changes.calc;
	            }
	        },
	        undo: function (changes) {
	            for (var j = changes.length - 1; j >= 0; j--) {
	                var change = changes[j];
	                var changeType = change.type;
	                if (!changeType) {
	                    undoChange(this, change);
	                } else if (changeType === 'addRows') {
	                    this._undoAddRows(change);
	                } else if (changeType === 'addColumns') {
	                    this._undoAddColumns(change);
	                } else if (changeType === 'deleteRows') {
	                    this._undoDeleteRows(change);
	                } else if (changeType === 'deleteColumns') {
	                    this._undoDeleteColumns(change);
	                } else if (changeType === 'setRowCount') {
	                    this._undoSetRowCount(change);
	                } else if (changeType === 'setColumnCount') {
	                    this._undoSetColumnCount(change);
	                } else if (changeType === 'setZoomFactor') {
	                    this._undoSetZoomFactor(change.value);
	                } else if (changeType === 'updateDirty') {
	                    this._undoUpdateDirty(change);
	                } else if (changeType === 'setName') {
	                    this._undoSetName(change.value);
	                }
	            }
	           
	            var sheet = this._sheet;
	            sheet._composedDefaultStyle = {};
	            sheet._clearStyleCache();
	
	           
	
	           
	            var calcChanges = changes && changes.calc;
	            if (calcChanges && calcChanges.length) {
	                sheet._undoCalcChange(calcChanges);
	            }
	
	           
	            _SheetModelManager._callFeatureHandler(this, 'undo', changes);
	
	            var events = changes && changes.events;
	            if (events) {
	                this._raiseUndoEvents(events);
	            }
	
	        },
	        do: function () {
	            var self = this;
	            var methodName = arguments[0], methodArgs = Array.prototype.slice.call(arguments, 1);
	            if (methodName && self[methodName]) {
	                self[methodName].apply(self, methodArgs);
	            }
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	        },
	
	       
	        _getSheetModel: function (sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            return this.sheetModels[sheetArea];
	        },
	        _resetSheetModel: function (rowCount, colCount, sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            this.sheetModels[sheetArea] = new _SheetModel(rowCount, colCount);
	        },
	        _addEventItem: function () {
	            var self = this, changes = self._changes, events = changes && changes.events;
	            if (events) {
	                events.push(arguments);
	            }
	        },
	        _raiseUndoEvents: function (events) {
	            var sheet = this._sheet;
	            while (events.length) {
	                var args = events.pop(), eventType = args[0], fn;
	                if (eventType === 'cellChanged') {
	                    fn = sheet._raiseCellChanged;
	                } else if (eventType === 'rowChanged') {
	                    fn = sheet._raiseRowChanged;
	                } else if (eventType === 'columnChanged') {
	                    fn = sheet._raiseColumnChanged;
	                }
	                if (fn) {
	                    fn.apply(sheet, [].slice.call(args, 1));
	                }
	            }
	        },
	        getValue: function (row, col, sheetArea, sheetModelOnly, valueType) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	
	            if (!sheetModelOnly) {
	                var argObj = {row: row, col: col, sheetArea: sheetArea, isValueGet: false, value: keyword_undefined};
	                _SheetModelManager._callFeatureHandler(this, 'getValue', argObj, function () {
	                    return argObj.isValueGet;
	                });
	                if (argObj.isValueGet) {
	                    return argObj.value;
	                }
	            }
	
	            return this._getSheetModel(sheetArea).getValue(row, col, valueType);
	        },
	        setValue: function (row, col, value, sheetArea, sheetModelOnly, ignoreEvent) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	
	            var oldValue, _this = this;
	           
	            var sheet = _this._sheet, needEvent = !ignoreEvent && !sheet.isEventSuspended();
	            if (needEvent) {
	                oldValue = sheet.getValue(row, col, sheetArea, 1 );
	            }
	
	            var isValueSet = false;
	            if (!sheetModelOnly) {
	                var argObj = {
	                    row: row,
	                    col: col,
	                    value: value,
	                    sheetArea: sheetArea,
	                    isValueSet: false,
	                    changes: _this._changes
	                };
	                _SheetModelManager._callFeatureHandler(_this, 'setValue', argObj, function () {
	                    return argObj.isValueSet;
	                });
	                isValueSet = argObj.isValueSet;
	            }
	
	            if (!isValueSet) {
	                var valueChangeInfo, dirtyChangeInfo;
	                if (_this._inTransaction > 0) {
	                    valueChangeInfo = [['sheetModels', sheetArea], keyword_undefined];
	                    dirtyChangeInfo = {sheetArea: sheetArea};
	                }
	                _this._getSheetModel(sheetArea).setValue(row, col, value, valueChangeInfo, dirtyChangeInfo);
	                if (valueChangeInfo && valueChangeInfo.length > 0) {
	                    _this._changes.push(valueChangeInfo);
	                }
	               
	                if (dirtyChangeInfo && dirtyChangeInfo.type) {
	                    _this._changes.push(dirtyChangeInfo);
	                }
	            }
	
	            if (needEvent && oldValue !== value) {
	                sheet._raiseCellChanged('value', row, col, sheetArea, oldValue, value);
	            }
	        },
	        getStyle: function (row, col, sheetArea) {
	            return this._getSheetModel(sheetArea).getStyle(row, col, this._inTransaction > 0);
	        },
	        setStyle: function (row, col, style, sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var changeInfo = this._inTransaction > 0 ? [['sheetModels', sheetArea], keyword_undefined] : keyword_undefined;
	
	            this._getSheetModel(sheetArea).setStyle(row, col, style, changeInfo);
	
	            if (changeInfo && changeInfo.length > 0) {
	                this._changes.push(changeInfo);
	            }
	        },
	        getValueForKey: function (row, col, key, sheetArea) {
	            return this._getSheetModel(sheetArea).getValueForKey(row, col, key);
	        },
	        setValueForKey: function (row, col, key, value, sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var changeInfo = this._inTransaction > 0 ? [['sheetModels', sheetArea], keyword_undefined] : keyword_undefined;
	
	            this._getSheetModel(sheetArea).setValueForKey(row, col, key, value, changeInfo);
	
	            if (changeInfo && changeInfo.length > 0) {
	                this._changes.push(changeInfo);
	            }
	        },
	        clear: function (row, column, rowCount, columnCount, type, ignoredRowList, sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var changeInfos = this._inTransaction > 0 ? [] : keyword_undefined;
	
	            this._getSheetModel(sheetArea).clear(row, column, rowCount, columnCount, type, ignoredRowList, changeInfos);
	
	            _SheetModelManager._callFeatureHandler(this, 'clear', {
	                row: row, col: column, rowCount: rowCount, colCount: columnCount,
	                type: type, ignoredRowList: ignoredRowList, sheetArea: sheetArea, changes: this._changes
	            });
	
	            if (changeInfos) {
	                var partOfPath = ['sheetModels', sheetArea];
	                changeInfos.forEach(function (info) {
	                    info[0] = partOfPath.concat(info[0]);
	                });
	                Array.prototype.push.apply(this._changes, changeInfos);
	            }
	        },
	        swapNode: function (row, col, row2, col2, sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var changeInfos = this._inTransaction > 0 ? [] : keyword_undefined;
	
	            this._getSheetModel(sheetArea)._swapNode(row, col, row2, col2, changeInfos);
	
	            if (changeInfos) {
	                var partOfPath = ['sheetModels', sheetArea];
	                changeInfos.forEach(function (info) {
	                    info[0] = partOfPath.concat(info[0]);
	                });
	                Array.prototype.push.apply(this._changes, changeInfos);
	            }
	        },
	        _updateDirty: function (row, col, dirtyOption, sheetArea) {
	            var changeInfo;
	            if (this._inTransaction > 0) {
	                changeInfo = {sheetArea: sheetArea};
	                if (isNullOrUndefined(sheetArea)) {
	                    changeInfo.sheetArea = 3 ;
	                }
	            }
	            this._getSheetModel(sheetArea)._updateDirty(row, col, dirtyOption, changeInfo);
	            if (changeInfo) {
	                this._changes.push(changeInfo);
	            }
	        },
	        _undoUpdateDirty: function (changeInfo) {
	            this._getSheetModel(changeInfo.sheetArea)._undoUpdateDirty(changeInfo);
	        },
	        _getDirtyNodes: function (sheetArea) {
	            return this._getSheetModel(sheetArea)._dirtyNodes;
	        },
	        _clearDirtyNodes: function (sheetArea) {
	            this._getSheetModel(sheetArea)._dirtyNodes = {};
	        },
	        _suspendDirty: function (sheetArea) {
	            this._getSheetModel(sheetArea)._dirtySuspended++;
	        },
	        _resumeDirty: function (sheetArea) {
	            var sheetModel = this._getSheetModel(sheetArea);
	            sheetModel._dirtySuspended--;
	            var dirtySuspended = sheetModel._dirtySuspended;
	            if (dirtySuspended < 0) {
	                sheetModel._dirtySuspended = 0;
	            }
	        },
	
	        getName: function () {
	            return this.name || '';
	        },
	        setName: function (name) {
	            var _this = this;
	            if (_this._inTransaction > 0) {
	                _this._changes.push({type: 'setName', value: _this.name});
	            }
	            _this.name = name;
	        },
	        _undoSetName: function (name) {
	            this._sheet.name(name);
	        },
	        getZoomFactor: function () {
	            return this.zoomFactor;
	        },
	        setZoomFactor: function (zoomFactor) {
	            var _this = this;
	            if (_this._inTransaction > 0) {
	                _this._changes.push({type: 'setZoomFactor', value: _this.zoomFactor});
	            }
	            _this.zoomFactor = zoomFactor;
	        },
	        _undoSetZoomFactor: function (zoomFactor) {
	            this._sheet.zoom(zoomFactor);
	        },
	
	       
	        _getSpanModel: function (sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            return this.spanModels[sheetArea];
	        },
	        _resetSpanModel: function (sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            this.spanModels[sheetArea] = new _SpanModel();
	        },
	        getSpans: function (range, sheetArea) {
	            return this._getSpanModel(sheetArea).getSpans(range);
	        },
	        getSpan: function (row, col, sheetArea) {
	            return this._getSpanModel(sheetArea).get(row, col);
	        },
	        _hasSpans: function (row, col, rowCount, colCount, sheetArea) {
	            return this._getSpanModel(sheetArea)._hasSpans(row, col, rowCount, colCount);
	        },
	        _hasPartSpans: function (row, col, rowCount, colCount, sheetArea) {
	            return this._getSpanModel(sheetArea)._hasPartSpans(row, col, rowCount, colCount);
	        },
	        findSpan: function (row, col, sheetArea) {
	            return this._getSpanModel(sheetArea).find(row, col);
	        },
	        removeSpan: function (range, sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var changeInfo = this._inTransaction > 0 ? [['spanModels', sheetArea], keyword_undefined] : keyword_undefined;
	
	            this._getSpanModel(sheetArea).remove(range, changeInfo);
	
	            if (changeInfo && changeInfo.length > 0) {
	                this._changes.push(changeInfo);
	            }
	        },
	        addSpan: function (range, sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var changeInfo = this._inTransaction > 0 ? [['spanModels', sheetArea], keyword_undefined] : keyword_undefined;
	
	            this._getSpanModel(sheetArea).add(range, changeInfo);
	
	            if (changeInfo && changeInfo.length > 0) {
	                this._changes.push(changeInfo);
	            }
	        },
	        clearSpan: function (row, col, rowCount, colCount, sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var changeInfo = this._inTransaction > 0 ? [['spanModels', sheetArea], keyword_undefined] : keyword_undefined;
	
	            this._getSpanModel(sheetArea)._clear(row, col, rowCount, colCount, changeInfo);
	
	            if (changeInfo && changeInfo.length > 0) {
	                this._changes.push(changeInfo);
	            }
	        },
	        moveSpan: function (fromRow, fromCol, toRow, toCol, rowCount, colCount, sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var changeInfo = this._inTransaction > 0 ? [['spanModels', sheetArea], keyword_undefined] : keyword_undefined;
	
	            this._getSpanModel(sheetArea)._move(fromRow, fromCol, toRow, toCol, rowCount, colCount, changeInfo);
	
	            if (changeInfo && changeInfo.length > 0) {
	                this._changes.push(changeInfo);
	            }
	        },
	        copySpan: function (fromRow, fromCol, toRow, toCol, rowCount, colCount, sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var changeInfo = this._inTransaction > 0 ? [['spanModels', sheetArea], keyword_undefined] : keyword_undefined;
	
	            this._getSpanModel(sheetArea)._copy(fromRow, fromCol, toRow, toCol, rowCount, colCount, changeInfo);
	
	            if (changeInfo && changeInfo.length > 0) {
	                this._changes.push(changeInfo);
	            }
	        },
	
	        addSelection: function (row, col, rowCount, colCount) {
	            var changeInfos = this._inTransaction > 0 ? [] : keyword_undefined;
	
	            this.selectionModel.add(row, col, rowCount, colCount, changeInfos);
	
	            if (changeInfos) {
	                for (var i = 0; i < changeInfos.length; i++) {
	                    var changeInfo = changeInfos[i];
	                    changeInfo[0] = ['selectionModel'].concat(changeInfo[0]);
	                    this._changes.push(changeInfo);
	                }
	            }
	        },
	        getSelections: function () {
	            return this.selectionModel.get();
	        },
	        setSelections: function (ranges) {
	            var changeInfos = this._inTransaction > 0 ? [] : keyword_undefined;
	
	            this.selectionModel.set(ranges, changeInfos);
	
	            if (changeInfos) {
	                for (var i = 0; i < changeInfos.length; i++) {
	                    var changeInfo = changeInfos[i];
	                    changeInfo[0] = ['selectionModel'].concat(changeInfo[0]);
	                    this._changes.push(changeInfo);
	                }
	            }
	        },
	        clearSelection: function () {
	            var changeInfos = this._inTransaction > 0 ? [] : keyword_undefined;
	
	            this.selectionModel.clear(changeInfos);
	
	            if (changeInfos) {
	                for (var i = 0; i < changeInfos.length; i++) {
	                    var changeInfo = changeInfos[i];
	                    changeInfo[0] = ['selectionModel'].concat(changeInfo[0]);
	                    this._changes.push(changeInfo);
	                }
	            }
	        },
	        getActiveSelectedRangeIndex: function () {
	            return this.selectionModel.getProperty('activeSelectedRangeIndex');
	        },
	        setActiveSelectedRangeIndex: function (value) {
	            var changeInfo = this._inTransaction > 0 ? [['selectionModel'], keyword_undefined] : keyword_undefined;
	
	            this.selectionModel.setProperty('activeSelectedRangeIndex', value, changeInfo);
	
	            if (changeInfo) {
	                this._changes.push(changeInfo);
	            }
	        },
	        getSelectionPolicy: function () {
	            return this.selectionModel.getProperty('selectionPolicy');
	        },
	        setSelectionPolicy: function (value) {
	            var changeInfo = this._inTransaction > 0 ? [['selectionModel'], keyword_undefined] : keyword_undefined;
	
	            this.selectionModel.setProperty('selectionPolicy', value, changeInfo);
	
	            if (changeInfo) {
	                this._changes.push(changeInfo);
	            }
	        },
	        getSelectionUnit: function () {
	            return this.selectionModel.getProperty('selectionUnit');
	        },
	        setSelectionUnit: function (value) {
	            var changeInfo = this._inTransaction > 0 ? [['selectionModel'], keyword_undefined] : keyword_undefined;
	
	            this.selectionModel.setProperty('selectionUnit', value, changeInfo);
	
	            if (changeInfo) {
	                this._changes.push(changeInfo);
	            }
	        },
	        _isColumnSelected: function (col) {
	            return this.selectionModel._isColumnSelected(col);
	        },
	        _isRowSelected: function (row) {
	            return this.selectionModel._isRowSelected(row);
	        },
	        _isSelected: function (row, col, sheetArea, sheetRowCount, sheetColCount, considerAdjacentCell) {
	            return this.selectionModel._isSelected(row, col, sheetArea, sheetRowCount, sheetColCount, considerAdjacentCell);
	        },
	        _isAllSelected: function (row, col, sheetArea, sheetRowCount, sheetColCount) {
	            return this.selectionModel._isAllSelected(row, col, sheetArea, sheetRowCount, sheetColCount);
	        },
	
	       
	        _getAxisModel: function (isRow, sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var infos = isRow ? this.rowInfos : this.colInfos;
	            return infos[sheetArea];
	        },
	        _resetAxisModel: function (isRow, sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var infos = isRow ? this.rowInfos : this.colInfos;
	            infos[sheetArea] = new _AxisModel();
	        },
	        getPageBreak: function (isRow, sheetArea, index) {
	            var axisModel = this._getAxisModel(isRow, sheetArea);
	            return axisModel.getPageBreak(index);
	        },
	        setPageBreak: function (isRow, sheetArea, index, value) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var changeInfo = this._inTransaction > 0 ? [[isRow ? 'rowInfos' : 'colInfos', sheetArea], keyword_undefined] : keyword_undefined;
	
	            var axisModel = this._getAxisModel(isRow, sheetArea);
	            axisModel.setPageBreak(index, value, changeInfo);
	
	            if (changeInfo) {
	                this._changes.push(changeInfo);
	            }
	        },
	        getVisible: function (isRow, sheetArea, index) {
	            var axisModel = this._getAxisModel(isRow, sheetArea);
	            return axisModel.getVisible(index);
	        },
	        setVisible: function (isRow, sheetArea, index, value) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var changeInfo = this._inTransaction > 0 ? [[isRow ? 'rowInfos' : 'colInfos', sheetArea], keyword_undefined] : keyword_undefined;
	
	            var axisModel = this._getAxisModel(isRow, sheetArea);
	            axisModel.setVisible(index, value, changeInfo);
	
	            if (changeInfo) {
	                this._changes.push(changeInfo);
	            }
	        },
	        getResizable: function (isRow, sheetArea, index) {
	            var axisModel = this._getAxisModel(isRow, sheetArea);
	            return axisModel.getResizable(index);
	        },
	        setResizable: function (isRow, sheetArea, index, value) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var changeInfo = this._inTransaction > 0 ? [[isRow ? 'rowInfos' : 'colInfos', sheetArea], keyword_undefined] : keyword_undefined;
	
	            var axisModel = this._getAxisModel(isRow, sheetArea);
	            axisModel.setResizable(index, value, changeInfo);
	
	            if (changeInfo) {
	                this._changes.push(changeInfo);
	            }
	        },
	        getSize: function (isRow, sheetArea, index) {
	            var axisModel = this._getAxisModel(isRow, sheetArea);
	            return axisModel.getSize(index);
	        },
	        getActualSize: function (isRow, sheetArea, index) {
	            var axisModel = this._getAxisModel(isRow, sheetArea);
	            return axisModel.getActualSize(index);
	        },
	        setSize: function (isRow, sheetArea, index, value) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var changeInfo = this._inTransaction > 0 ? [[isRow ? 'rowInfos' : 'colInfos', sheetArea], keyword_undefined] : keyword_undefined;
	
	            var axisModel = this._getAxisModel(isRow, sheetArea);
	            axisModel.setSize(index, value, changeInfo);
	
	            if (changeInfo) {
	                this._changes.push(changeInfo);
	            }
	        },
	        _getItemCount: function (isRow, sheetArea) {
	            var axisModel = this._getAxisModel(isRow, sheetArea);
	            return axisModel._getItemCount();
	        },
	        _getItems: function (isRow, sheetArea) {
	            var axisModel = this._getAxisModel(isRow, sheetArea);
	            return axisModel._getItems();
	        },
	        _getItem: function (isRow, sheetArea, index) {
	            var axisModel = this._getAxisModel(isRow, sheetArea);
	            return axisModel._getItem(index);
	        },
	        setItem: function (isRow, sheetArea, index, value) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var changeInfo = this._inTransaction > 0 ? [[isRow ? 'rowInfos' : 'colInfos', sheetArea], keyword_undefined] : keyword_undefined;
	
	            var axisModel = this._getAxisModel(isRow, sheetArea);
	            axisModel._setItem(index, value, changeInfo);
	
	            if (changeInfo) {
	                this._changes.push(changeInfo);
	            }
	        }
	    };
	    util_common._defineFeature(_SheetModelManager);
	    exports._SheetModelManager = _SheetModelManager;
	   
	
	    module.exports = exports;
	
	}());

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var exports = __webpack_require__(1);
	    var util_common = __webpack_require__(3);
	    var _ImageLoader = __webpack_require__(9)._ImageLoader;
	    var Style = __webpack_require__(12).Style;
	    var WORKSHEET_MODEL_MODULE = __webpack_require__(16);
	    var $ = __webpack_require__(4).GC$;
	    var Common = __webpack_require__(5);
	
	    var util_common_util = util_common._util;
	    var _DPIHelper = util_common._DPIHelper;
	    var createElement = util_common_util._createElement;
	    var tryAddCacheToRichText = util_common_util._tryAddCacheToRichText;
	    var createRange = util_common._createRange;
	    var isNullOrUndefined = Common._Types._isNullOrUndefined;
	    var _CachePool = util_common._CachePool;
	    var Rect = util_common.Rect;
	    var Events = util_common.Events;
	    var defProperty = util_common_util._defProperty;
	    var createOptions = util_common_util._createOptions;
	    var isValidSheetName = util_common_util._isValidSheetName;
	    var _FocusHelper = util_common._FocusHelper;
	    var _ThemeStyleHelper = util_common._ThemeStyleHelper;
	    var Themes = util_common.Themes;
	    var Theme = util_common.Theme;
	    var _Layout = WORKSHEET_MODEL_MODULE._Layout;
	    var _LayoutModel = WORKSHEET_MODEL_MODULE._LayoutModel;
	    var $_each = $.each, $_isEmptyObject = $.isEmptyObject;
	    var hasOwnProperty = Common._hasOwnProperty;
	    var tryConvertDateToOADate = util_common_util._tryConvertDateToOADate;
	    var tryConvertOADateToDate = util_common_util._tryConvertOADateToDate;
	    var DOCUMENT = document, convertToInt = parseInt, convertToFloat = parseFloat,
	        isNotANumber = isNaN,
	        keyword_null = null, keyword_undefined = void 0, Math_min = Math.min, Math_max = Math.max,
	        Math_floor = Math.floor,
	        const_undefined = 'undefined',
	        const_string = 'string', cssWidth = 'width', cssHeight = 'height', cssBlack = 'black', const_tag = 'tag',
	        const_onLayoutChanged = 'onLayoutChanged', const_onPaintSuspend = 'onPaintSuspend',
	        const_isVisible = 'isVisible', const_resizable = 'resizable',
	        _gcSheet = '.gcSheet', _gcSheetInternal = '.gcSheetInternal';
	    var tableStyleProperties = {
	        backColor: true,
	        foreColor: true,
	        font: true,
	        borderLeft: true,
	        borderTop: true,
	        borderRight: true,
	        borderBottom: true,
	        textDecoration: true
	    };
	   
	    
	    exports.RangeChangedAction = {
	        
	        dragDrop: 0,
	        
	        dragFill: 1,
	        
	        clear: 2,
	        
	        paste: 3,
	        
	        sort: 4,
	        
	        setArrayFormula: 5,
	        
	        evaluateFormula: 6
	    };
	
	   
	    
	    exports.SheetArea = {
	        
	        corner: 0,
	        
	        colHeader: 1,
	        
	        rowHeader: 2,
	        
	        viewport: 3
	    };
	
	   
	    
	    exports.HeaderAutoText = {
	        
	        blank: 0,
	        
	        numbers: 1,
	        
	        letters: 2
	    };
	
	   
	    
	    exports.ValueType = {
	        
	        normal: 0,
	        
	        richText: 1
	    };
	
	    function sR() {
	        return Common._getResource(exports.SR)();
	    }
	
	    function getDirtyOrInsertRows(sheet, isDirtyRows) {
	        var rows = [];
	        var dirtyNodes = sheet._modelManager._getDirtyNodes(), t, node, obj;
	        if (dirtyNodes) {
	            for (t in dirtyNodes) {
	                if (hasOwnProperty(dirtyNodes, t)) {
	                    node = dirtyNodes[t];
	                    if (node && node.rs === (isDirtyRows ? 'e' : 'n')) {
	                        obj = {
	                            row: +t,
	                            item: sheet.getDataItem && sheet.getDataItem(t)
	                        };
	                        if (isDirtyRows) {
	                            obj.originalItem = node.originalItem;
	                        }
	                        rows.push(obj);
	                    }
	                }
	            }
	        }
	        return rows;
	    }
	
	    function getColsWidth(cachePool, c1, c2) {
	        var width = 0;
	        for (var c = c1; c <= c2; c++) {
	            width += cachePool._getZoomColWidth(c);
	        }
	        return width;
	    }
	
	    function getRowsHeight(cachePool, r1, r2) {
	        var height = 0;
	        for (var r = r1; r <= r2; r++) {
	            height += cachePool._getZoomRowHeight(r);
	        }
	        return height;
	    }
	
	    function getColumnCount(obj) {
	        return obj.getColumnCount();
	    }
	
	    function getRowCount(obj) {
	        return obj.getRowCount();
	    }
	
	    function getFrozenTrailingColumnCount(obj) {
	        return obj.frozenTrailingColumnCount();
	    }
	
	    function getFrozenTrailingRowCount(obj) {
	        return obj.frozenTrailingRowCount();
	    }
	
	    function getFrozenColumnCount(obj) {
	        return obj.frozenColumnCount();
	    }
	
	    function getFrozenRowCount(obj) {
	        return obj.frozenRowCount();
	    }
	
	
	   
	    function object_defineProperty(obj, pn, callback) {
	        Object.defineProperty(obj, pn, {
	            get: function () {
	                return this['_' + pn];
	            },
	            set: function (value) {
	                var old = this['_' + pn];
	                if (old !== value) {
	                    this['_' + pn] = value;
	                    if (callback) {
	                        callback(pn, value, old); 
	                    }
	                }
	            }
	        });
	    }
	
	    var defaultOptions = {
	        rowHeaderVisible: true,
	        colHeaderVisible: true,
	        clipBoardOptions: 0 ,
	        frozenlineColor: cssBlack,
	        rowHeaderAutoText: 1 ,
	        colHeaderAutoText: 2 ,
	        rowHeaderAutoTextIndex: -1,
	        colHeaderAutoTextIndex: -1,
	        sheetTabColor: keyword_null,
	        selectionBackColor: keyword_null,
	        selectionBorderColor: keyword_null,
	        allowCellOverflow: true,
	        isProtected: false,
	        protectionOptions: {},
	        gridline: {},
	
	        sheetAreaOffset : {
	            left : 0,
	            top : 0
	        }
	    };
	
	   
	    
	   
	    
	
	   
	    
	    function Worksheet(name) {
	        var self = this;
	        self._id = Worksheet._ID++;
	        self.options = createOptions(defaultOptions, function (pn, value, old) {
	            self._onOptionChanged(pn, value, old);
	        });
	        self._init(name);
	    }
	
	    util_common._defineFeature(Worksheet);
	    Worksheet._ID = 1;
	    Worksheet._defaultOptions = defaultOptions;
	    Worksheet._defaultRowCount = 200;
	    Worksheet._defaultColCount = 20;
	    Worksheet._defaultRowHeaderColumnCount = 1;
	    Worksheet._defaultColHeaderRowCount = 1;
	
	    function getDirtyValue(sheet, row, col, oldValue) {
	        return {
	            row: row,
	            col: col,
	            newValue: sheet.getValue(row, col),
	            oldValue: oldValue
	        };
	    }
	
	    Worksheet.prototype = {
	        constructor: Worksheet,
	
	       
	
	        _onOptionChanged: function (pn, value, old) { 
	            var self = this;
	            var parent = self.parent;
	            switch (pn) {
	                case 'allowCellOverflow':
	                case 'colHeaderAutoText':
	                case 'colHeaderAutoTextIndex':
	                case 'colHeaderVisible':
	                case 'frozenlineColor':
	                case 'rowHeaderAutoText':
	                case 'rowHeaderAutoTextIndex':
	                case 'rowHeaderVisible':
	                case 'selectionBackColor':
	                case 'selectionBorderColor':
	                    self._invalidate();
	                    break;
	                case 'sheetAreaOffset':
	                    var sheetAreaOffsetCallback = function () {
	                        self._invalidate();
	                    };
	                    var sheetAreaOffsetObj = self.options.sheetAreaOffset;
	                    ['left', 'top'].forEach(function (prop) {
	                        var oldPropertyValue = value[prop];
	                        object_defineProperty(sheetAreaOffsetObj, prop, sheetAreaOffsetCallback);
	                        sheetAreaOffsetObj[prop] = oldPropertyValue;
	                    });
	                    break;
	                case 'gridline':
	                    var callback = function () {
	                        self._invalidate();
	                    };
	                    var gridlineObj = self.options.gridline;
	                    ['color', 'showHorizontalGridline', 'showVerticalGridline'].forEach(function (prop) {
	                        var oldPropertyValue = value[prop];
	                        object_defineProperty(gridlineObj, prop, callback);
	                        gridlineObj[prop] = oldPropertyValue;
	                    });
	                    break;
	                case 'isProtected':
	                    parent && parent.undoManager().clear();
	                    self._adjustActiveCellToSelectable();
	                    Worksheet._callFeatureHandler(self, 'onProtectChanged');
	                    self._invalidate();
	                    break;
	                case 'protectionOptions':
	                    self._adjustActiveCellToSelectable();
	                    Worksheet._callFeatureHandler(self, 'onProtectChanged');
	                    break;
	                case 'sheetTabColor':
	                    parent && parent._doTabHSResize();
	                    break;
	               
	               
	            }
	        },
	       
	        
	        name: function (value) {
	            var self = this, parent = self.parent;
	            if (arguments.length === 0) {
	                return self._modelManager ? self._modelManager.getName() : '';
	            }
	
	            if (!isValidSheetName(value, parent ? parent.sheets : null, self)) {
	                throw sR().Exp_NotSupported;
	            }
	            self._setNameCore(value);
	            if (parent) {
	                parent._doTabHSResize();
	            }
	            return self;
	        },
	        _setNameCore: function (name, isFromJSON) {
	            var self = this;
	            var oldName = self.name();
	            if (!isFromJSON) {
	                Worksheet._callFeatureHandler(self, "beforeSetName", { oldName: oldName, newName: name });
	            }
	            this._modelManager.do('setName', name);
	            if (!isFromJSON) {
	                Worksheet._callFeatureHandler(self, "setName", { oldName: oldName, newName: name });
	            }
	        },
	       
	        
	        visible: defProperty('visible', true, function (value) {
	            var self = this, parent = self.parent;
	            var sheets = parent.sheets;
	            var sheetCount = sheets.length;
	            var index = $.inArray(self, sheets);
	            var activeSheetIndex = parent.getActiveSheetIndex();
	            if (value) {
	                if (activeSheetIndex < 0) {
	                    parent._setActiveSheetIndexImp(index, 1 );
	                } else {
	                    parent._doTabHSResize();
	                }
	            } else if (index === activeSheetIndex) {
	                var n = index + 1;
	                while (n < sheetCount && !sheets[n].visible()) {
	                    n++;
	                }
	                if (n >= sheetCount) {
	                    n = index - 1;
	                    while (n >= 0 && !sheets[n].visible()) {
	                        n--;
	                    }
	                }
	
	                if (n < parent._tab._firstTab) {
	                    parent._tab._firstTab = n;
	                }
	
	                if (n < 0) {
	                   
	                    self._dispose(false);
	                    parent._activeSheetIndex = n;
	                    parent._doResize();
	                } else {
	                    parent._setActiveSheetIndexImp(n, 1 );
	                }
	            } else {
	                parent._doTabHSResize();
	            }
	        }),
	       
	        
	        addRows: function (row, count) {
	            if (count <= 0) {
	                return;
	            }
	            var self = this, oldRowCount = getRowCount(self);
	            if (row < 0 || row > oldRowCount) {
	                row = oldRowCount;
	            }
	            self.suspendPaint();
	            try {
	                var args = {
	                    changeType: 'addingRows',
	                    row: row,
	                    rowCount: count,
	                    canAdd: true
	                };
	                Worksheet._callFeatureHandler(self, const_onLayoutChanged, args);
	                if (!args.canAdd) {
	                    return;
	                }
	                if (!isNullOrUndefined(args.newRow)) {
	                    row = args.newRow;
	                }
	
	               
	                this._modelManager.do('addRows', row, count);
	
	                self._needSyncVScrollbarSize = true;
	
	                var changeType = 'addRows';
	                Worksheet._callFeatureHandler(self, const_onLayoutChanged, {
	                    changeType: changeType,
	                    row: row,
	                    oldValue: oldRowCount,
	                    rowCount: count
	                });
	                Worksheet._callFeatureHandler(self, const_onLayoutChanged, {
	                    changeType: 'addRows2',
	                    row: row,
	                    oldValue: oldRowCount,
	                    rowCount: count
	                });
	                self._raiseRowChanged(row, 3, changeType, count, oldRowCount);
	            } finally {
	                self.resumePaint();
	            }
	        },
	       
	        
	        deleteRows: function (row, count) {
	            var self = this, oldRowCount = getRowCount(self);
	            if (0 > row || row >= oldRowCount || count <= 0) {
	                return;
	            }
	            self.suspendPaint();
	            try {
	                var args = {
	                    changeType: 'deletingRows',
	                    row: row,
	                    rowCount: count,
	                    canDelete: true
	                };
	                Worksheet._callFeatureHandler(self, const_onLayoutChanged, args);
	                if (!args.canDelete) {
	                    return;
	                }
	
	               
	                self._modelManager.do('deleteRows', row, count);
	
	               
	                var top = self._scrollTopRow;
	                if (top >= 0) {
	                    var newTop = -1;
	                    var frozenRowCount = getFrozenRowCount(self);
	                    for (var t = top; t >= frozenRowCount; t--) {
	                        if (self.getRowVisible(t) && self._getZoomRowHeight(t) > 0) {
	                            newTop = t;
	                            break;
	                        }
	                    }
	                    if (newTop === -1) {
	                        newTop = 0;
	                    }
	                    if (top !== newTop) {
	                        self._setTopRow(newTop);
	                    }
	                }
	               
	                var rowCount = oldRowCount;
	                if (self.getActiveRowIndex() >= rowCount) {
	                    self.setActiveCell(rowCount - 1, self.getActiveColumnIndex());
	                }
	                self._needSyncVScrollbarSize = true;
	
	                var changeType = 'deleteRows';
	                Worksheet._callFeatureHandler(self, const_onLayoutChanged, {
	                    changeType: changeType,
	                    row: row,
	                    oldValue: oldRowCount,
	                    rowCount: count
	                });
	
	                self._raiseRowChanged(row, 3, changeType, count, oldRowCount);
	            } finally {
	                self.resumePaint();
	            }
	        },
	       
	        
	        addColumns: function (col, count) {
	            if (count <= 0) {
	                return;
	            }
	            var self = this, oldColCount = getColumnCount(self);
	            if (col < 0 || col > oldColCount) {
	                col = oldColCount;
	            }
	
	            var args = {
	                changeType: 'addingColumns',
	                col: col,
	                colCount: count,
	                canAdd: true
	            };
	            Worksheet._callFeatureHandler(self, const_onLayoutChanged, args);
	            if (!args.canAdd) {
	                return;
	            }
	
	           
	            self._modelManager.do('addColumns', col, count);
	
	            self._needSyncHScrollbarSize = true;
	
	            var changeType = 'addColumns';
	            Worksheet._callFeatureHandler(self, const_onLayoutChanged, {
	                changeType: changeType,
	                col: col,
	                oldValue: oldColCount,
	                colCount: count
	            });
	
	            self._raiseColumnChanged(col, 3, changeType, count, oldColCount);
	            self._invalidate();
	        },
	       
	        
	        deleteColumns: function (col, count) {
	            var self = this, oldColCount = getColumnCount(self);
	            if (0 > col || col >= oldColCount || count <= 0) {
	                return;
	            }
	
	            var args = {
	                changeType: 'deletingColumns',
	                col: col,
	                colCount: count,
	                canDelete: true
	            };
	            Worksheet._callFeatureHandler(self, const_onLayoutChanged, args);
	            if (!args.canDelete) {
	                return;
	            }
	
	           
	            self._modelManager.do('deleteColumns', col, count);
	
	           
	            var left = self._scrollLeftCol;
	            if (left >= 0) {
	                var newLeft = -1;
	                var frozenColCount = getFrozenColumnCount(self);
	                for (var t = left; t >= frozenColCount; t--) {
	                    if (self.getColumnVisible(t) && self._getZoomColumnWidth(t) > 0) {
	                        newLeft = t;
	                        break;
	                    }
	                }
	                if (newLeft === -1) {
	                    newLeft = 0;
	                }
	                if (left !== newLeft) {
	                    self._setLeftColumn(newLeft);
	                }
	            }
	           
	            var columnCount = oldColCount;
	            if (self.getActiveColumnIndex() >= columnCount) {
	                self.setActiveCell(self.getActiveRowIndex(), columnCount - 1);
	            }
	            self._needSyncHScrollbarSize = true;
	
	            var changeType = 'deleteColumns';
	            Worksheet._callFeatureHandler(self, const_onLayoutChanged, {
	                changeType: changeType,
	                col: col,
	                oldValue: oldColCount,
	                colCount: count
	            });
	
	            self._raiseColumnChanged(col, 3, changeType, count, oldColCount);
	            self._invalidate();
	        },
	       
	        
	        frozenColumnCount: defProperty('frozenColumnCount', 0, function (value) {
	            var self = this;
	            if (self._scrollLeftCol < value) {
	                self._scrollLeftCol = value;
	            }else if(value === '' || value === 0 || value === null) {
	                self._scrollLeftCol = 0;
	            }
	            self._needSyncHScrollbarSize = true;
	            self._invalidate();
	        }, function (value) {
	            return value >= 0;
	        }),
	       
	        
	        frozenRowCount: defProperty('frozenRowCount', 0, function (value) {
	            var self = this;
	            if (self._scrollTopRow < value) {
	                self._scrollTopRow = value;
	            }else if(value === '' || value === 0 || value === null) {
	                self._scrollTopRow = 0;
	            }
	            self._needSyncVScrollbarSize = true;
	            self._invalidate();
	        }, function (value) {
	            return value >= 0;
	        }),
	       
	        
	        frozenTrailingRowCount: defProperty('frozenTrailingRowCount', 0, function () {
	            var self = this;
	            self._needSyncVScrollbarSize = true;
	            self._invalidate();
	        }, function (value) {
	            return value >= 0;
	        }),
	       
	        
	        frozenTrailingColumnCount: defProperty('frozenTrailingColumnCount', 0, function () {
	            var self = this;
	            self._needSyncHScrollbarSize = true;
	            self._invalidate();
	        }, function (value) {
	            return value >= 0;
	        }),
	       
	        
	        getRowCount: function (sheetArea) {
	            if (sheetArea === 0 ) {
	                return 0;
	            }
	            return this._modelManager.getRowCount(sheetArea);
	        },
	       
	        
	        getColumnCount: function (sheetArea) {
	            if (sheetArea === 0 ) {
	                return 0;
	            }
	            return this._modelManager.getColumnCount(sheetArea);
	        },
	       
	        
	        setRowCount: function (rowCount, sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	
	            var self = this;
	            var args = {
	                changeType: 'settingRowCount',
	                rowCount: rowCount,
	                sheetArea: sheetArea,
	                canSet: true
	            };
	            Worksheet._callFeatureHandler(self, const_onLayoutChanged, args);
	            if (!args.canSet) {
	                return;
	            }
	
	            self.setRowCountCore(rowCount, sheetArea);
	        },
	        setRowCountCore: function (rowCount, sheetArea) {
	            rowCount = convertToInt(rowCount, 10);
	            if (isNotANumber(rowCount)) {
	                return;
	            }
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var self = this;
	            var dataModelRowCount = self.getRowCount(sheetArea);
	            if (rowCount < 0 || rowCount === dataModelRowCount) {
	                return;
	            }
	            if (sheetArea === 3  || sheetArea === 2 ) {
	                self._modelManager.do('setRowCount', rowCount, sheetArea);
	                if (getFrozenRowCount(self) > rowCount) {
	                    self.frozenRowCount(rowCount);
	                }
	            } else if (sheetArea === 1 ) {
	                self._modelManager.do('setRowCount', rowCount, sheetArea);
	            }
	
	            Worksheet._callFeatureHandler(self, const_onLayoutChanged, {
	                changeType: 'setRowCount',
	                rowCount: rowCount,
	                sheetArea: sheetArea
	            });
	
	            self._needSyncVScrollbarSize = true;
	            if (self._activeRowIndex >= rowCount && (sheetArea === 3  || sheetArea === 2 )) {
	                self.setActiveCell(rowCount - 1, self.getActiveColumnIndex());
	            }
	            self._invalidate();
	            self.clearPendingChanges();
	        },
	       
	        
	        setColumnCount: function (colCount, sheetArea) {
	            colCount = convertToInt(colCount, 10);
	            if (isNotANumber(colCount)) {
	                return;
	            }
	            var self = this;
	            var dataModelColumnCount = self.getColumnCount(sheetArea);
	            if (colCount < 0 || colCount === dataModelColumnCount) {
	                return;
	            }
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            if (sheetArea === 3  || sheetArea === 1 ) {
	                self._modelManager.do('setColumnCount', colCount, sheetArea);
	                if (getFrozenColumnCount(self) > colCount) {
	                    self.frozenColumnCount(colCount);
	                }
	            } else if (sheetArea === 2 ) {
	                self._modelManager.do('setColumnCount', colCount, sheetArea);
	            }
	
	            Worksheet._callFeatureHandler(self, const_onLayoutChanged, {
	                changeType: 'setColumnCount',
	                colCount: colCount,
	                sheetArea: sheetArea
	            });
	
	            self._needSyncHScrollbarSize = true;
	            if (self._activeColIndex >= colCount && (sheetArea === 3  || sheetArea === 1 )) {
	                self.setActiveCell(self.getActiveRowIndex(), colCount - 1);
	            }
	            self._invalidate();
	            self.clearPendingChanges();
	        },
	       
	        
	        getText: function (row, col, sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var self = this, v = self.getValue(row, col, sheetArea);
	            var ct = self.getCellType(row, col, sheetArea),
	                fmt = self._getStyleProperty(row, col, 'formatter', sheetArea);
	            if (!fmt) {
	                fmt = self._getStyleProperty(row, col, '_autoFormatter', sheetArea);
	            }
	            var formattedData = {}, quotePrefix = self._getStyleProperty(row, col, 'quotePrefix', sheetArea);
	            v = ct.format(v, fmt, formattedData, {
	                sheet: self,
	                row: row,
	                col: col,
	                sheetArea: sheetArea,
	                quotePrefix: quotePrefix
	            });
	            if (v && typeof v === 'string') {
	                v = v.replace(/\r\n?/g, '\n');
	            }
	            return v;
	        },
	       
	        
	        setText: function (row, col, value, sheetArea) {
	            var self = this;
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	
	            var tempText = value;
	            var arg = {value: value};
	            Worksheet._callFeatureHandler(self, 'settingText', arg);
	            value = arg.value;
	
	            var t = value;
	            var ct = self.getCellType(row, col, sheetArea);
	            var formatStr = self.getFormatter && self.getFormatter(row, col, sheetArea);
	            if (ct && formatStr) {
	                var context = {
	                    sheet: self,
	                    row: row,
	                    col: col,
	                    sheetArea: sheetArea
	                };
	               
	                t = ct.parse(tempText, formatStr, context);
	                t = isNullOrUndefined(t) ? value : t;
	            }
	            self._setValueInternal(row, col, t, sheetArea);
	            self._invalidate();
	        },
	       
	        
	        getValue: function (row, col, sheetArea, valueType) {
	            if (sheetArea === 0 ) {
	                return keyword_null;
	            }
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var self = this, options = self.options;
	            var modelManager = self._modelManager;
	            var rowCount = modelManager.getRowCount(sheetArea), columnCount = modelManager.getColumnCount(sheetArea);
	            var t = self._getValueImp(modelManager, row, col, sheetArea, valueType);
	            var index;
	            if (sheetArea === 1 ) {
	                if (isNullOrUndefined(t)) {
	                    var bm = self._bindingManager;
	                    if (bm && bm._dataSource) {
	                        var ci = self._modelManager._getItem(false, 3 , col),
	                            colHeaderAutoTextIndex = options.colHeaderAutoTextIndex;
	                        if (ci && ((colHeaderAutoTextIndex >= 0 && row === colHeaderAutoTextIndex) || (colHeaderAutoTextIndex === -1 && row === (rowCount - 1)))) {
	                            t = ci.displayName || ci.name;
	                        }
	                    }
	                    if (isNullOrUndefined(t)) {
	                        index = options.colHeaderAutoTextIndex;
	                        if (index < 0 || index >= rowCount) {
	                            index = rowCount - 1;
	                        }
	                        if (row === index) {
	                            var colHeaderAutoText = options.colHeaderAutoText;
	                            if (colHeaderAutoText === 2 ) {
	                                t = self._indexToLetters(col + 1);
	                            } else if (colHeaderAutoText === 1 ) {
	                                t = col + 1;
	                            }
	                        }
	                    }
	                }
	            } else if (sheetArea === 2  && isNullOrUndefined(t)) {
	                index = options.rowHeaderAutoTextIndex;
	                if (index < 0 || index >= columnCount) {
	                    index = columnCount - 1;
	                }
	                if (col === index) {
	                    var rowHeaderAutoText = options.rowHeaderAutoText;
	                    if (rowHeaderAutoText === 2 ) {
	                        t = self._indexToLetters(row + 1);
	                    } else if (rowHeaderAutoText === 1 ) {
	                        t = row + 1;
	                    }
	                }
	            }
	            return t;
	        },
	       
	        
	        setValue: function (row, col, value, sheetArea, ignoreRecalc) {
	            this._setValueInternal(row, col, value, sheetArea, ignoreRecalc);
	           
	            this._invalidate();
	        },
	        _setValueInternal: function (row, col, value, sheetArea, ignoreRecalc) {
	            if (sheetArea === 0 ) {
	                return;
	            }
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var self = this;
	            var modelManager = self._modelManager;
	            var rowCount = modelManager.getRowCount(sheetArea), colCount = modelManager.getColumnCount(sheetArea);
	            if (row < 0 || row >= rowCount || col < 0 || col >= colCount) {
	                return;
	            }
	            var isViewport = (sheetArea === 3 );
	            value = tryConvertDateToOADate(value);
	            value = tryAddCacheToRichText(value);
	
	            modelManager.do('setValue', row, col, value, sheetArea);
	
	
	            if (isViewport && !ignoreRecalc && exports._supportsCalc) {
	                self._recalcCell(row, col);
	            }
	
	            self._updateTableSlicer && self._updateTableSlicer(row, col, 1, 1, sheetArea);
	
	            var conditionalFormats = self.conditionalFormats;
	            if (conditionalFormats) {
	                conditionalFormats._clearCache();
	            }
	        },
	       
	        
	        getActualStyle: function (row, column, sheetArea, sheetStyleOnly, notClone, isForFilter) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            if (sheetArea === 0 ) {
	                return new Style();
	            }
	            if (row === -1 && column === -1) {
	                return this.getDefaultStyle(sheetArea);
	            }
	            var self = this, info, composedStyle, cellStyle, rowStyle, colStyle, cache = self._styleComposeCache,
	                cellCache,
	                rowCache, colCache, sheetAreaCache, cellStyleKey, rowStyleKey, colStyleKey;
	            var STR__SPREADJSDEFAULT = '__spreadJSDefault', STR__UNDEFINED = '__undefined';
	            var modelManager = this._modelManager;
	            cellStyle = modelManager.getStyle(row, column, sheetArea);
	            rowStyle = modelManager.getStyle(row, -1, sheetArea);
	            colStyle = modelManager.getStyle(-1, column, sheetArea);
	            cellStyle = cellStyle ? cellStyle : keyword_null;
	            rowStyle = rowStyle ? rowStyle : keyword_null;
	            colStyle = colStyle ? colStyle : keyword_null;
	            cellStyleKey = STR__UNDEFINED;
	            if (cellStyle) {
	                cellStyleKey = cellStyle.charAt ? cellStyle : STR__SPREADJSDEFAULT + cellStyle._id;
	            }
	            rowStyleKey = STR__UNDEFINED;
	            if (rowStyle) {
	                rowStyleKey = rowStyle.charAt ? rowStyle : STR__SPREADJSDEFAULT + rowStyle._id;
	            }
	            colStyleKey = STR__UNDEFINED;
	            if (colStyle) {
	                colStyleKey = colStyle.charAt ? colStyle : STR__SPREADJSDEFAULT + colStyle._id;
	            }
	            sheetAreaCache = cache[sheetArea];
	            cellCache = sheetAreaCache[cellStyleKey];
	            var tables = self.tables,
	                table = (sheetArea === 3 && tables && !isForFilter) ? tables.find(row, column) : keyword_null;
	            if (!table) {
	                if (!cellCache) {
	                    cellCache = sheetAreaCache[cellStyleKey] = {};
	                }
	                rowCache = cellCache[rowStyleKey];
	                if (!rowCache) {
	                    rowCache = cellCache[rowStyleKey] = {};
	                } else {
	                    colCache = rowCache[colStyleKey];
	                }
	            }
	            if (!colCache) {
	                composedStyle = self._getCompositeStyle(row, column, sheetArea, cellStyle, rowStyle, colStyle, table, isForFilter);
	            }
	            if (sheetArea === 3  && !sheetStyleOnly) {
	                if (!colCache) {
	                    var f = composedStyle.formatter;
	                    if (f && f.hasFormatedColor && f.hasFormatedColor() && !isForFilter) {
	                        var clr = {value: keyword_null};
	                        f.format(self.getValue(row, column), clr);
	                        if (clr.value) {
	                            info = new Style();
	                            info.foreColor = clr.value;
	                        }
	                    }
	                }
	                var conditionalFormats = self.conditionalFormats;
	                if (conditionalFormats) {
	                    info = conditionalFormats._applyFormats(info, row, column, sheetArea);
	                }
	            }
	            if (info) {
	                info._compose(colCache ? colCache : composedStyle);
	                composedStyle = info;
	            } else if (colCache) {
	                return notClone ? colCache : colCache.clone(true);
	            }
	            if (isNullOrUndefined(composedStyle.locked)) {
	                composedStyle.locked = true;
	            }
	            composedStyle = composedStyle._normalize(self._currentTheme);
	            if (!info && !table) {
	                rowCache[colStyleKey] = composedStyle.clone(true);
	            }
	            return composedStyle;
	        },
	        _getStyleProperty: function (row, col, property, sheetArea) {
	            if (sheetArea === 0 ) {
	                return keyword_undefined;
	            }
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var self = this, s, parentName, temp, modelManager = self._modelManager;
	            var result, hasResult = false, themeFont;
	            if (sheetArea === 3 ) {
	                if (property === 'foreColor') {
	                    var f = self._getStyleProperty(row, col, 'formatter', sheetArea);
	                    if (f && f.hasFormatedColor && f.hasFormatedColor()) {
	                        var clr = {value: keyword_null};
	                        f.format(self.getValue(row, col), clr);
	                        if (clr.value) {
	                            result = clr.value;
	                            hasResult = true;
	                        }
	                    }
	                }
	                var conditionalFormats = self.conditionalFormats;
	                if (conditionalFormats && (conditionalFormats.count() > 0)) {
	                    var cs = conditionalFormats._getConditionalStyle(row, col, property, sheetArea);
	                    hasResult = cs._hasResult;
	                    result = cs._result;
	                }
	            }
	            var level = 0;
	            while (!hasResult && level <= 4) {
	                if (level === 0) {
	                    s = modelManager.getStyle(row, col, sheetArea);
	                } else if (level === 1) {
	                    var tables = self.tables,
	                        table = (sheetArea === 3 && tables) ? tables.find(row, col) : keyword_null;
	                    if (table && tableStyleProperties[property]) {
	                        s = table._getStyle(row, col, property);
	                    }
	                } else if (level === 2) {
	                    s = modelManager.getStyle(row, -1, sheetArea);
	                } else if (level === 3) {
	                    s = modelManager.getStyle(-1, col, sheetArea);
	                } else {
	                    s = self.getDefaultStyle(sheetArea);
	                }
	                level++;
	                if (s && s.charAt && (typeof s === const_string)) {
	                    s = self._name2Style(s);
	                }
	                if (!s) {
	                    continue;
	                }
	                if (property === 'font' && s.themeFont && !themeFont) {
	                    themeFont = s.themeFont;
	                }
	                if (s[property] !== keyword_undefined) {
	                    result = s[property];
	                    hasResult = true;
	                    break;
	                }
	               
	                parentName = s.parentName;
	                while (parentName) {
	                    temp = self._name2Style(parentName);
	                    if (!temp) {
	                        break;
	                    }
	                    if (temp[property] !== keyword_undefined) {
	                        result = temp[property];
	                        hasResult = true;
	                        break;
	                    }
	                    parentName = temp.parentName;
	                }
	            }
	            if (property === 'locked') {
	                return (isNullOrUndefined(result)) ? true : result;
	            } else if (hasResult || themeFont) {
	                if (property === 'foreColor' || property === 'backColor' || property === 'font' ||
	                    property === 'borderLeft' || property === 'borderTop' || property === 'borderRight' || property === 'borderBottom') {
	                    s = new Style();
	                    s[property] = result;
	                    if (property === 'font' && themeFont) {
	                        s.themeFont = themeFont;
	                    }
	                    s._normalize(self._currentTheme);
	                    result = s[property];
	                }
	                return result;
	            }
	            return keyword_undefined;
	        },
	       
	        
	        getStyle: function (row, col, sheetArea) {
	            return this._getStyleImp(row, col, sheetArea, true);
	        },
	        _getStyleImp: function (row, col, sheetArea, clearCache) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            if (sheetArea !== 0 ) {
	                var modelManager = this._modelManager;
	                var result = modelManager.getStyle(row, col, sheetArea);
	                if (result instanceof Style) {
	                    if (clearCache) {
	                        this._clearStyleCache();
	                    }
	                    return result;
	                } else if (typeof (result) === const_string) {
	                    var namedStyle = this._name2Style(result);
	                    if (namedStyle !== keyword_null) {
	                        var tmp = new Style();
	                        tmp._compose(namedStyle);
	                        if (clearCache) {
	                            this._clearStyleCache();
	                        }
	                        return tmp;
	                    }
	                }
	            }
	            return keyword_null;
	        },
	       
	        
	        addNamedStyle: function (style) {
	            this._addNamedStyleImp(style);
	            this._invalidate();
	        },
	        _addNamedStyleImp: function (style) {
	            if (style) {
	                if (!style.name) {
	                    throw new Error(sR.Exp_EmptyNamedStyle);
	                }
	                var name = style.name.toUpperCase();
	                this._namedStyles[name] = style;
	            }
	        },
	       
	        
	        getNamedStyle: function (name) {
	            return this._getNamedStyleImp(name, true);
	        },
	        _getNamedStyleImp: function (name, clearCache) {
	            var namedStyles = this._namedStyles;
	            if (namedStyles && name) {
	                name = name.toUpperCase();
	                var result = namedStyles[name];
	                if (result && clearCache) {
	                    this._clearStyleCache();
	                }
	                return result;
	            }
	            return keyword_null;
	        },
	        _clearStyleCache: function () {
	            this._styleComposeCache = [{}, {}, {}, {}];
	        },
	       
	        
	        removeNamedStyle: function (name) {
	            var namedStyles = this._namedStyles;
	            if (namedStyles && name) {
	                name = name.toUpperCase();
	                if (hasOwnProperty(namedStyles, name)) {
	                    delete namedStyles[name];
	                    this._clearStyleCache();
	                    this._invalidate();
	                }
	            }
	        },
	       
	        
	        getNamedStyles: function () {
	            var namedStylesClone = [],
	                namedStyles = this._namedStyles;
	            if (namedStyles) {
	                $_each(namedStyles, function (index, item) {
	                    namedStylesClone.push(item);
	                });
	            }
	            this._clearStyleCache();
	            return namedStylesClone;
	        },
	       
	        
	        setStyle: function (row, col, value, sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var self = this;
	            self._setStyleObject(row, col, value, sheetArea);
	            if (row === -1 && col === -1) {
	                self._composedDefaultStyle[sheetArea] = keyword_null;
	            }
	            if (row === -1 || col === -1) { 
	               
	                if (value && value.validator && (value.validator.condition() && value.validator.condition().conType() === 4 )) {
	                    value.validator.condition().getExpected(this, row < 0 ? 0 : row, col < 0 ? 0 : col);
	                }
	            }
	            self._clearStyleCache();
	           
	            self._invalidate();
	        },
	        _setStyleWithoutLocked: function (row, col, value, sheetArea) {
	            var self = this;
	            if (!self.options.isProtected) {
	                self.setStyle(row, col, value, sheetArea);
	            } else {
	                var oldStyle = self.getStyle(row, col, sheetArea), oldLocked;
	                if (value) {
	                    oldLocked = oldStyle ? oldStyle.locked : keyword_undefined;
	                    if (value.locked !== oldLocked) {
	                        value.locked = oldLocked;
	                    }
	                    self.setStyle(row, col, value, sheetArea);
	                } else if (oldStyle) {
	                    oldLocked = oldStyle.locked;
	                    if (oldLocked !== keyword_undefined) {
	                        value = new Style();
	                        value.locked = oldLocked;
	                    }
	                    self.setStyle(row, col, value, sheetArea);
	                }
	            }
	        },
	       
	        
	        getStyleName: function (row, col, sheetArea) {
	            var style = this._getStyleObject(row, col, sheetArea);
	            if (style instanceof Style) {
	                return style.name;
	            }
	            return style;
	        },
	       
	        
	        setStyleName: function (row, col, value, sheetArea) {
	            if (typeof value === const_string) {
	                this._setStyleObject(row, col, value, sheetArea);
	                this._invalidate();
	            }
	        },
	        _getStyleObject: function (row, col, sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var result;
	            if (sheetArea !== 0 ) {
	                result = this._modelManager.getStyle(row, col, sheetArea);
	            }
	            return result || keyword_null;
	        },
	        _setStyleObject: function (row, col, value, sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            if (sheetArea !== 0 ) {
	                var self = this, oldStyleObject = self._getStyleObject(row, col, sheetArea);
	                var modelManager = self._modelManager;
	                var rowCount = modelManager.getRowCount(sheetArea), colCount = modelManager.getColumnCount(sheetArea);
	                if (row < -1 || row >= rowCount || col < -1 || col >= colCount) {
	                    return;
	                }
	                var oldValue = modelManager.getStyle(row, col, sheetArea);
	                modelManager.do('setStyle', row, col, value, sheetArea);
	                var oldTypeName = oldStyleObject && oldStyleObject.cellType && oldStyleObject.cellType.typeName || keyword_null,
	                    newTypeName = value && value.cellType && value.cellType.typeName || keyword_null; 
	
	               
	                if (row === self._activeRowIndex && col === self._activeColIndex &&
	                    oldTypeName !== newTypeName && _FocusHelper._isActiveElement(self)) {
	                    self._eventHandler._changeFocusHolder();
	                }
	
	                var pn = '[styleinfo]';    
	                if (row !== -1 && col !== -1) {
	                    self._raiseCellChanged(pn, row, col, sheetArea, oldValue, value);
	                } else if (row !== -1 && col === -1) {
	                    self._raiseRowChanged(row, sheetArea, pn, value, oldValue);
	                } else if (row === -1 && col !== -1) {
	                    self._raiseColumnChanged(col, sheetArea, pn, value, oldValue);
	                }
	            }
	        },
	       
	        
	        getDefaultStyle: function (sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var self = this;
	            var composedDefaultStyle = self._composedDefaultStyle, cachedStyle = composedDefaultStyle[sheetArea];
	            if (cachedStyle) {
	                return cachedStyle;
	            }
	            if (sheetArea !== 0 ) {
	                var modelManager = self._modelManager;
	                var sheetDefStyle = modelManager.getStyle(-1, -1, sheetArea);
	                if (typeof (sheetDefStyle) === const_string) {
	                    sheetDefStyle = self._name2Style(sheetDefStyle);
	                }
	                if (!sheetDefStyle) {
	                    sheetDefStyle = new Style();
	                    modelManager.do('setStyle', -1, -1, sheetDefStyle, sheetArea);
	                }
	                var isHeader = (sheetArea === 1  || sheetArea === 2 );
	                if (typeof (sheetDefStyle.hAlign) === const_undefined) {
	                    sheetDefStyle.hAlign = isHeader ? 1  : 3 ;
	                }
	                if (typeof (sheetDefStyle.vAlign) === const_undefined) {
	                    sheetDefStyle.vAlign = isHeader ? 1  : 0 ;
	                }
	                if (typeof (sheetDefStyle.imeMode) === const_undefined) {
	                    sheetDefStyle.imeMode = 1 ;
	                }
	                if (!sheetDefStyle.font && typeof (sheetDefStyle.themeFont) === const_undefined) {
	                    sheetDefStyle.themeFont = 'Body';
	                }
	                composedDefaultStyle[sheetArea] = sheetDefStyle;
	                return sheetDefStyle;
	            }
	            var defStyle = new Style();
	            defStyle.locked = true;
	            composedDefaultStyle[sheetArea] = defStyle;
	            return defStyle;
	        },
	
	       
	        
	        setDefaultStyle: function (style, sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var self = this;
	            if (sheetArea !== 0 ) {
	                self._modelManager.do('setStyle', -1, -1, style, sheetArea);
	            }
	            self._composedDefaultStyle[sheetArea] = keyword_null;
	            self._clearStyleCache();
	            self._invalidate();
	        },
	        _name2Style: function (name) {
	            var style = this._getNamedStyleImp(name, false);
	            if (style) {
	                return style;
	            }
	            var parent = this.parent;
	            if (parent) {
	                return parent._getNamedStyleImp(name, false);
	            }
	            return keyword_null;
	        },
	        _getCompositeStyle: function (row, column, sheetArea, cellStyle, rowStyle, colStyle, table, hasTableStyle, isForFilter) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var self = this, destInfo = new Style();
	            if (sheetArea !== 0 ) {
	                var temp, parentName, changed = false,
	                    modelManager = self._modelManager, tables = self.tables;
	                var rowCount = modelManager.getRowCount(sheetArea), colCount = modelManager.getColumnCount(sheetArea), s;
	               
	                if (0 <= row && row < rowCount && 0 <= column && column < colCount) {
	                    s = cellStyle !== keyword_undefined ? cellStyle : modelManager.getStyle(row, column, sheetArea);
	                   
	                    if (s && s.charAt) {
	                        s = self._name2Style(s);
	                    }
	                    if (s) {
	                        destInfo._compose(s, true, 10 );
	                        changed = true;
	                       
	                        parentName = s.parentName;
	                        while (parentName) {
	                            temp = self._name2Style(parentName);
	                            if (!temp) {
	                                break;
	                            }
	                            destInfo._compose(temp, false, 10 );
	                            parentName = temp.parentName;
	                        }
	                    }
	                }
	                if (hasTableStyle) {
	                    return destInfo;
	                }
	               
	                if (table === keyword_undefined && !isForFilter) {
	                    table = (sheetArea === 3 && tables) ? tables.find(row, column) : keyword_null;
	                }
	                if (table && !isForFilter) {
	                    table._compose(row, column, destInfo);
	                    changed = true;
	                }
	               
	                if (0 <= row && row < rowCount) {
	                    s = rowStyle !== keyword_undefined ? rowStyle : modelManager.getStyle(row, -1, sheetArea);
	                    if (s && s.charAt) {
	                        s = self._name2Style(s);
	                    }
	                    if (s) {
	                        destInfo._compose(s, !changed, 30 );
	                        changed = true;
	                       
	                        parentName = s.parentName;
	                        while (parentName) {
	                            temp = self._name2Style(parentName);
	                            if (!temp) {
	                                break;
	                            }
	                            destInfo._compose(temp, false, 30 );
	                            parentName = temp.parentName;
	                        }
	                    }
	                }
	               
	                if (0 <= column && column < colCount) {
	                    s = colStyle !== keyword_undefined ? colStyle : modelManager.getStyle(-1, column, sheetArea);
	                    if (s && s.charAt) {
	                        s = self._name2Style(s);
	                    }
	                    if (s) {
	                        destInfo._compose(s, !changed, 40 );
	                        changed = true;
	                       
	                        parentName = s.parentName;
	                        while (parentName) {
	                            temp = self._name2Style(parentName);
	                            if (!temp) {
	                                break;
	                            }
	                            destInfo._compose(temp, false, 40 );
	                            parentName = temp.parentName;
	                        }
	                    }
	                }
	            }
	           
	            var sheetInfo = self.getDefaultStyle(sheetArea);
	            if (sheetInfo && sheetInfo.charAt) {
	                sheetInfo = self._name2Style(sheetInfo);
	            }
	            if (sheetInfo) {
	                destInfo._compose(sheetInfo, !changed, 50 );
	               
	                parentName = sheetInfo.parentName;
	                while (parentName) {
	                    temp = self._name2Style(parentName);
	                    if (!temp) {
	                        break;
	                    }
	                    destInfo._compose(temp, false, 50 );
	                    parentName = temp.parentName;
	                }
	            }
	            return destInfo;
	        },
	       
	        
	        getCellType: function (row, col, sheetArea) {
	            return this._getStyleProperty(row, col, 'cellType', sheetArea) || this._getDefaultCellType(sheetArea);
	        },
	        _getDefaultCellType: function (sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var CellTypes = __webpack_require__(13).CellTypes;
	            var defaultCellType = this._defaultCellType;
	            if (!defaultCellType) {
	                defaultCellType = this._defaultCellType = new CellTypes.Text();
	            }
	            if (sheetArea === 3 ) {
	                return defaultCellType;
	            } else if (sheetArea === 1 ) {
	                return new CellTypes.ColumnHeader();
	            } else if (sheetArea === 2 ) {
	                return new CellTypes.RowHeader();
	            } else if (sheetArea === 0 ) {
	                return new CellTypes.Corner();
	            }
	            return defaultCellType;
	        },
	       
	        
	        setCellType: function (row, col, value, sheetArea) {
	            var style = this._getStyleImp(row, col, sheetArea);
	            if (!style) {
	                style = new Style();
	            }
	            style.cellType = value;
	            this.setStyle(row, col, style, sheetArea);
	        },
	        _addSpanImp: function (row, col, rowCount, colCount, sheetArea) {
	            var self = this;
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var modelManager = self._modelManager;
	            modelManager.do('clearSpan', row, col, rowCount, colCount, sheetArea);
	            var r = createRange(row, col, rowCount, colCount);
	            var actualRange = self._getActualRange(r, sheetArea);
	            var newRange = self._adjustSpanRange(actualRange, sheetArea);
	            modelManager.do('addSpan', newRange, sheetArea);
	           
	            if (sheetArea === 3 ) {
	                var selections = self.getSelections();
	                for (var i = 0; i < selections.length; i++) {
	                    if (selections[i].intersect(row, col, rowCount, colCount)) {
	                        selections[i] = selections[i].union(r);
	                    }
	                }
	
	                modelManager.do('setSelections', selections);
	            }
	            self._invalidate();
	        },
	        _adjustSpanRange: function (range, sheetArea) {
	            var sheetRowCount = this.getRowCount(sheetArea), sheetColumnCount = this.getColumnCount(sheetArea);
	            var row = range.row, col = range.col, rowCount = range.rowCount, colCount = range.colCount;
	            if (row + rowCount > sheetRowCount) {
	                rowCount = sheetRowCount - row;
	            }
	            if (col + colCount > sheetColumnCount) {
	                colCount = sheetColumnCount - col;
	            }
	            return createRange(row, col, rowCount, colCount);
	        },
	       
	        
	        addSpan: function (row, col, rowCount, colCount, sheetArea) {
	            var self = this;
	            if (rowCount === 1 && colCount === 1 || sheetArea === 0 ) {
	                return;
	            }
	            var sheetRowCount = self.getRowCount(sheetArea), sheetColumnCount = self.getColumnCount(sheetArea);
	            if (row >= sheetRowCount || col >= sheetColumnCount || row < -1 || col < -1) {
	                return;
	            }
	            var canSpan = true;
	            if (exports._supportsCalc && (sheetArea === 3  || isNullOrUndefined(sheetArea))) {
	                canSpan = self._checkArrayFormula(row, col, rowCount, colCount, false);
	            }
	            if (canSpan) {
	                var modelManager = self._modelManager;
	                if (modelManager._hasPartSpans(row, col, rowCount, colCount, sheetArea)) {
	                    throw new Error(sR().Exp_InvalidRange);
	                }
	                self._addSpanImp(row, col, rowCount, colCount, sheetArea);
	
	                var e = {
	                    sheet: self,
	                    row: row,
	                    col: col,
	                    rowCount: rowCount,
	                    colCount: colCount,
	                    sheetArea: sheetArea,
	                    changeType: 'addSpan'
	                };
	
	                Worksheet._callFeatureHandler(self, const_onLayoutChanged, e);
	
	                self._trigger('spanChanged', e);
	            }
	        },
	       
	        
	        removeSpan: function (row, col, sheetArea) {
	            var self = this;
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var modelManager = self._modelManager;
	            var span = modelManager.findSpan(row, col, sheetArea);
	            if (span && span.row === row && span.col === col) {
	                modelManager.do('removeSpan', span, sheetArea);
	            }
	
	            var e = {
	                sheet: self,
	                row: row,
	                col: col,
	                sheetArea: sheetArea,
	                changeType: 'removeSpan'
	            };
	            Worksheet._callFeatureHandler(self, const_onLayoutChanged, e);
	            self._trigger('spanChanged', e);
	
	            self._invalidate();
	        },
	       
	        
	        getSpans: function (range, sheetArea) {
	            if (sheetArea === 0 ) {
	                return [];
	            }
	            return this._modelManager.getSpans(range, sheetArea);
	        },
	        getSpan: function (row, col, sheetArea) {
	            if (sheetArea === 0 ) {
	                return keyword_null;
	            }
	            return this._modelManager.findSpan(row, col, sheetArea);
	        },
	
	       
	        
	        repaint: function (clipRect) {
	            if (this._layoutSuspended <= 0) {
	                this._render.repaint(clipRect);
	            }
	        },
	        _scrollByMoveCell: function (cellRowIndex, cellColIndex) {
	            var self = this;
	            var frozenRowCount = getFrozenRowCount(self);
	            var frozenColCount = getFrozenColumnCount(self);
	            var firstCol = frozenColCount ? self._getNextVisualColumn(frozenColCount - 1) : self._getFirstVisualColumn();
	            var firstRow1 = frozenRowCount ? self._getNextVisualRow(frozenRowCount - 1) : self._getFirstVisualRow();
	            if (cellColIndex < self._scrollLeftCol && cellColIndex >= firstCol) {
	                self._setLeftColumn(self._getPrevVisualColumn(cellColIndex + 1));
	            }
	            if (cellColIndex > self._getLastFullyVisibleColumn() && cellColIndex <= self._getLastVisualColumn()) {
	                var w = 0;
	                var c = cellColIndex;
	                var sheetLayout1 = self._getSheetLayout();
	                var tempSpan = self._modelManager.findSpan(cellRowIndex, c);
	                if (tempSpan) {
	                    c = tempSpan.col + tempSpan.colCount - 1;
	                }
	                while (c > self._scrollLeftCol) {
	                    w += self._getZoomColumnWidth(c);
	                    if (w > sheetLayout1._viewportWidth) {
	                        break;
	                    }
	                    c--;
	                }
	                var newLeftCol = self._getNextVisualColumn(c);
	                self._setLeftColumn(newLeftCol);
	            }
	            if (cellRowIndex < self._scrollTopRow && cellRowIndex >= firstRow1) {
	                self._setTopRow(self._getPrevVisualRow(cellRowIndex + 1));
	            }
	            if (cellRowIndex > self._getLastFullyVisibleRow() && cellRowIndex <= self._getLastVisualRow()) {
	                self._getFirstVisualRow();
	                var h = 0;
	                var r = cellRowIndex;
	                var tempSpan1 = self._modelManager.findSpan(r, cellColIndex);
	                if (tempSpan1) {
	                    r = tempSpan1.row + tempSpan1.rowCount - 1;
	                }
	                var sheetLayout = self._getSheetLayout();
	                while (r > self._scrollTopRow) {
	                    h += self._getZoomRowHeight(r);
	                    if (h > sheetLayout._viewportHeight) {
	                        break;
	                    }
	                    r--;
	                }
	                var newTopRow = self._getNextVisualRow(r);
	                self._setTopRow(newTopRow);
	            }
	           
	           
	           
	           
	           
	           
	            if (cellColIndex === self._getLastVisualColumn()) {
	                self._setLeftColumn(self._getLastPageLeftColumn());
	            }
	        },
	       
	        
	        hitTest: function (x, y, forMove, ignoreProtected) {
	            var self = this;
	            self._getSheetLayout();
	            var target = {
	                x: x,
	                y: y//,
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	            };
	            var rowOutlines = self.rowOutlines, columnOutlines = self.columnOutlines, outlineHitInfo, rowViewportIndex,
	                colViewportIndex;
	            if (rowOutlines) {
	                outlineHitInfo = rowOutlines.hitTest(self, x, y);
	            }
	            if (!outlineHitInfo && columnOutlines) {
	                outlineHitInfo = columnOutlines.hitTest(self, x, y);
	            }
	            if (outlineHitInfo) {
	                target.outlineHitInfo = outlineHitInfo;
	            } else {
	                rowViewportIndex = self._getRowViewportIndexFromY(y);
	                colViewportIndex = self._getColumnViewportIndexFromX(x);
	                target.rowViewportIndex = rowViewportIndex;
	                target.colViewportIndex = colViewportIndex;
	                target.row = self._getRowIndexFromY(y, rowViewportIndex);
	                target.col = self._getColumnIndexFromX(x, colViewportIndex);
	               
	                if (rowViewportIndex >= 0 && rowViewportIndex <= 2 && colViewportIndex >= 0) {
	                    var cellLayout = self._getCellLayoutByCell(rowViewportIndex, colViewportIndex, keyword_undefined, target.row, target.col);
	                    if (cellLayout && forMove !== true) {
	                        target.row = cellLayout.row;
	                        target.col = cellLayout.col;
	                    }
	                }
	                target.hitTestType = self._getSheetArea(rowViewportIndex, colViewportIndex);
	                var eventHandler = self._eventHandler;
	               
	               
	               
	                var dragMergeInfo = eventHandler._getDragMergeInfo && eventHandler._getDragMergeInfo(target, x, y);
	                if (dragMergeInfo) {
	                    target.dragMergeInfo = dragMergeInfo;
	                } else {
	                    var dragInfo = eventHandler._getDragInfo && eventHandler._getDragInfo(target, x, y);
	                    if (dragInfo) {
	                        target.dragInfo = dragInfo;
	                    } else {
	                        var resizeInfo = eventHandler._getResizingRowCol(target, x, y, 5);
	                        if (resizeInfo) {
	                            target.resizeInfo = resizeInfo;
	                        } else {
	                            var formulaRangeInfo = eventHandler._getFormulaRangeHitInfo ? eventHandler._getFormulaRangeHitInfo(target, x, y) : keyword_null;
	                            if (formulaRangeInfo) {
	                                target.formulaRangeHitInfo = formulaRangeInfo;
	                            } else {
	                                var comments = self._modelManager._comments,
	                                    commentHitInfo = comments && comments.hitTest(x, y);
	                                if (commentHitInfo) {
	                                    target.commentHitInfo = commentHitInfo;
	                                } else {
	                                    var floatingObjectModel = self._floatingObjectModel,
	                                        floatObjectInfo = floatingObjectModel && floatingObjectModel.hitTest(x, y, ignoreProtected);
	                                    var shapeHitInfo;
	                                    if(self.shapes) {
	                                        shapeHitInfo = self.shapes.hitTest(x, y);
	                                    }
	                                    if(shapeHitInfo) {
	                                        target.shapeHitInfo = shapeHitInfo;
	                                    } else if (floatObjectInfo) {
	                                        target.floatingObjectHitInfo = floatObjectInfo;
	                                    } else {
	                                        var rowFilter = self._rowFilter,
	                                            filterButtonHitInfo = rowFilter && rowFilter.hitTest(target, x, y);
	                                        if (!filterButtonHitInfo) {
	                                            var tableManager = self.tables,
	                                                table = tableManager && tableManager.find(target.row, target.col),
	                                                tableFilter = table && table._rowFilter;
	                                            filterButtonHitInfo = tableFilter && tableFilter.hitTest(target, x, y);
	                                        }
	                                        if (filterButtonHitInfo) {
	                                            target.filterButtonHitInfo = filterButtonHitInfo;
	                                        } else {
	                                            target.cellTypeHitInfo = self._getCellTypeHitInfo(target, x, y);
	                                        }
	                                    }
	
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            return target;
	        },
	       
	        
	        getCellRect: function (row, col, rowViewportIndex, colViewportIndex) {
	            var sheetArea = 3 ;
	            if (rowViewportIndex === -1) {
	                sheetArea = 1 ;
	            } else if (colViewportIndex === -1) {
	                sheetArea = 2 ;
	            }
	           
	           
	           
	            var self = this;
	            var sheetLayout = self._getSheetLayout();
	            if (rowViewportIndex === -1 && colViewportIndex === -1) {
	               
	                return new Rect(sheetLayout._headerX, sheetLayout._headerY, sheetLayout._rowHeaderWidth, sheetLayout._colHeaderHeight);
	            }
	            var bounds = self._getBounds();
	            if (isNullOrUndefined(rowViewportIndex)) {
	                rowViewportIndex = self._getRowViewportIndex(row);
	            }
	            if (isNullOrUndefined(colViewportIndex)) {
	                colViewportIndex = self._getColumnViewportIndex(col);
	            }
	            var rowLayout = self._getRowLayout(rowViewportIndex, sheetArea).findRow(row);
	            var colLayout = self._getColumnLayout(colViewportIndex, sheetArea).findCol(col);
	            var cellLayout = self._getCellLayout(rowViewportIndex, colViewportIndex, sheetArea).findCell(row, col);
	            if (cellLayout) {
	                return new Rect(cellLayout.x - bounds.x, cellLayout.y - bounds.y, cellLayout.width, cellLayout.height);
	            }
	            if (rowLayout && colLayout) {
	                return new Rect(colLayout.x - bounds.x, rowLayout.y - bounds.y, colLayout.width, rowLayout.height);
	            }
	            return new Rect();
	        },
	        _setActiveCellCore: function (row, col, doNotSetFocus) {
	            var self = this, eventHandler = self._eventHandler;
	            var activeCellChanged = false;
	            if (!isNullOrUndefined(row)) {
	                self._activeRowIndex = row;
	                activeCellChanged = true;
	            }
	            if (!isNullOrUndefined(col)) {
	                self._activeColIndex = col;
	                activeCellChanged = true;
	            }
	            if (!doNotSetFocus && eventHandler && activeCellChanged) {
	                eventHandler._changeFocusHolder();
	            }
	        },
	        _setActiveCellImp: function (row, col, rowViewportIndex, colViewportIndex, doNotSetFocus) {
	            var self = this, activeRowIndex = self._activeRowIndex, activeColIndex = self._activeColIndex;
	            var span = self._modelManager.getSpan(row, col);
	            self._activeRowCount = span.rowCount;
	            self._activeColCount = span.colCount;
	            if (self._layoutSuspended <= 0) {
	                var activeSpan = self._modelManager.getSpan(activeRowIndex, activeColIndex);
	                self._render._repaintSelection(createRange(activeRowIndex, activeColIndex, activeSpan.rowCount, activeSpan.colCount));
	            }
	            self._activeRowViewportIndex = rowViewportIndex;
	            self._activeColViewportIndex = colViewportIndex;
	            self._setActiveCellCore(row, col, doNotSetFocus);
	            self._leadingCellRow = row;
	            self._leadingCellCol = col;
	           
	           
	           
	           
	           
	        },
	       
	        
	        setActiveCell: function (row, col, rowViewportIndex, colViewportIndex) {
	           
	            this._setActiveCellAndSelection(row, col, rowViewportIndex, colViewportIndex, 2 );
	        },
	        _setActiveCellAndSelection: function (row, col, rowViewportIndex, colViewportIndex, focusPolicy) {
	            var self = this;
	            var rowCount = getRowCount(self);
	            var colCount = getColumnCount(self);
	            if (row < 0) {
	                row = 0;
	            } else if (row >= rowCount) {
	                row = rowCount - 1;
	            }
	            if (col < 0) {
	                col = 0;
	            } else if (col >= colCount) {
	                col = colCount - 1;
	            }
	            self._clearSelectionImp();
	           
	            var setFocus = (focusPolicy === 2 ) ? _FocusHelper._isActiveElement(self) : focusPolicy === 1;
	            self._setActiveCellImp(row, col, rowViewportIndex, colViewportIndex, !setFocus);
	            var span = self._modelManager.getSpan(row, col);
	            self._setSelectedRange(span.row, span.col, span.rowCount, span.colCount);
	            self._invalidate();
	        },
	       
	        
	        getActiveRowIndex: function () {
	            return this._activeRowIndex;
	        },
	       
	        
	        getActiveColumnIndex: function () {
	            return this._activeColIndex;
	        },
	       
	        
	        getRowResizable: function (row, sheetArea) {
	            return this._modelManager.getResizable(true, sheetArea, row);
	        },
	       
	        
	        setRowResizable: function (row, value, sheetArea) {
	            this._setRowColInfo(row, value, const_resizable, true, sheetArea);
	        },
	        _setRowColInfo: function (index, value, property, isRow, sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var self = this, modelManager = self._modelManager, oldValue;
	            switch (property) {
	                case const_resizable:
	                    oldValue = modelManager.getResizable(isRow, sheetArea, index);
	                    modelManager.do('setResizable', isRow, sheetArea, index, value);
	                    break;
	                case 'pageBreak':
	                    oldValue = modelManager.getPageBreak(isRow, sheetArea, index);
	                    modelManager.do('setPageBreak', isRow, sheetArea, index, value);
	                    break;
	                case const_isVisible:
	                    oldValue = modelManager.getVisible(isRow, sheetArea, index);
	                    modelManager.do('setVisible', isRow, sheetArea, index, value);
	                    if (isRow && exports._supportsCalc && sheetArea === 3  && oldValue !== value) {
	                        self.recalcRows([index]);
	                    }
	                    break;
	                case cssHeight:
	                    oldValue = modelManager.getSize(isRow, sheetArea, index);
	                    modelManager.do('setSize', isRow, sheetArea, index, value);
	                    if (exports._supportsCalc && sheetArea === 3  && oldValue !== value && (oldValue === 0 || value === 0)) {
	                        self.recalcRows([index]);
	                    }
	                    break;
	                case cssWidth:
	                    oldValue = modelManager.getSize(isRow, sheetArea, index);
	                    modelManager.do('setSize', isRow, sheetArea, index, value);
	                    break;
	            }
	            if (isRow) {
	                self._raiseRowChanged(index, sheetArea, property, value, oldValue);
	            } else {
	                self._raiseColumnChanged(index, sheetArea, property, value, oldValue);
	            }
	        },
	       
	        
	        getColumnResizable: function (col, sheetArea) {
	            return this._modelManager.getResizable(false, sheetArea, col);
	        },
	       
	        
	        setColumnResizable: function (col, value, sheetArea) {
	            this._setRowColInfo(col, value, const_resizable, false, sheetArea);
	        },
	       
	        
	        getRowHeight: function (row, sheetArea) {
	            var self = this;
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            if (sheetArea === 3  || sheetArea === 2 ) {
	                var rowCount = self.getRowCount(sheetArea);
	                if (row < 0 || row >= rowCount) {
	                    return 0;
	                }
	
	                var providers = self._rowStateProviders;
	                for (var i = 0; i < providers.length; i++) {
	                    var p = providers[i];
	                    if (!p._isVisible(row)) {
	                        return 0;
	                    }
	                }
	            }
	            var defaults = self.defaults, dh = defaults.rowHeight;
	            if (sheetArea === 1 ) {
	                dh = defaults.colHeaderRowHeight;
	            }
	            var h = self._modelManager.getSize(true, sheetArea, row);
	            return (h || h === 0) ? h : Math_floor(dh);
	        },
	        _getActualRowHeight: function (row, sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var self = this, defaults = self.defaults, dh = defaults.rowHeight;
	            if (sheetArea === 1 ) {
	                dh = defaults.colHeaderRowHeight;
	            }
	            var h = self._modelManager.getActualSize(true, sheetArea, row);
	            return (h || h === 0) ? h : Math_floor(dh);
	        },
	       
	        
	        setRowHeight: function (row, value, sheetArea) {
	            this._setRowColInfo(row, value, cssHeight, true, sheetArea);
	            this._needSyncVScrollbarSize = true;
	           
	            this._invalidate();
	        },
	       
	        
	        getRowVisible: function (row, sheetArea, ignoreFilterAndGroup) {
	            var self = this;
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	
	            if (!ignoreFilterAndGroup && (sheetArea === 3  || sheetArea === 2 )) {
	                var providers = self._rowStateProviders;
	                for (var i = 0; i < providers.length; i++) {
	                    var p = providers[i];
	                    if (!p._isVisible(row)) {
	                        return false;
	                    }
	                }
	            }
	            return this._modelManager.getVisible(true, sheetArea, row);
	        },
	       
	        
	        setRowVisible: function (row, value, sheetArea) {
	            var self = this;
	            self._setRowColInfo(row, value, const_isVisible, true, sheetArea);
	            self._needSyncVScrollbarSize = true;
	            self._invalidate();
	        },
	       
	        
	        getColumnWidth: function (col, sheetArea) {
	            var self = this;
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var defaults = self.defaults, dw = defaults.colWidth;
	            if (sheetArea === 2 ) {
	                dw = defaults.rowHeaderColWidth;
	            }
	            if (sheetArea === 3  || sheetArea === 1 ) {
	                var colCount = self.getColumnCount(sheetArea);
	                if (col < 0 || col >= colCount) {
	                    return 0;
	                }
	
	                var providers = self._colStateProviders;
	                for (var i = 0; i < providers.length; i++) {
	                    var p = providers[i];
	                    if (!p._isVisible(col)) {
	                        return 0;
	                    }
	                }
	            }
	            var w = this._modelManager.getSize(false, sheetArea, col);
	            return (w || w === 0) ? w : Math_floor(dw);
	        },
	        _getActualColumnWidth: function (col, sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var self = this, defaults = self.defaults, dw = defaults.colWidth;
	            if (sheetArea === 2 ) {
	                dw = defaults.rowHeaderColWidth;
	            }
	            var w = self._modelManager.getActualSize(false, sheetArea, col);
	            return (w || w === 0) ? w : Math_floor(dw);
	        },
	       
	        
	        setColumnWidth: function (col, value, sheetArea) {
	            this._setRowColInfo(col, value, cssWidth, false, sheetArea);
	            this._needSyncHScrollbarSize = true;
	           
	            this._invalidate();
	        },
	       
	        
	        getColumnVisible: function (col, sheetArea) {
	            var self = this;
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            if (sheetArea === 3  || sheetArea === 1 ) {
	                var providers = self._colStateProviders;
	                for (var i = 0; i < providers.length; i++) {
	                    var p = providers[i];
	                    if (!p._isVisible(col)) {
	                        return false;
	                    }
	                }
	            }
	            return self._modelManager.getVisible(false, sheetArea, col);
	        },
	       
	        
	        setColumnVisible: function (col, value, sheetArea) {
	            var self = this;
	            self._setRowColInfo(col, value, const_isVisible, false, sheetArea);
	            self._needSyncHScrollbarSize = true;
	            self._invalidate();
	        },
	       
	        
	        zoom: function (factor) {
	            var self = this;
	            if (arguments.length === 0) {
	                return self._modelManager.getZoomFactor();
	            }
	
	            factor = convertToFloat(factor);
	            if (!isNotANumber(factor) && isFinite(factor)) {
	                if (factor > 4) {
	                    factor = 4;
	                } else if (factor < 0.25) {
	                    factor = 0.25;
	                }
	                self._zoomInternal(factor);
	                self._needSyncHScrollbarSize = true;
	                self._needSyncVScrollbarSize = true;
	                self._invalidate();
	            }
	            return self;
	        },
	        _zoomInternal: function (factor) {
	            this._modelManager.do('setZoomFactor', factor);
	            Worksheet._callFeatureHandler(this, const_onLayoutChanged, {changeType: 'zoomSheet'});
	        },
	       
	        
	        invalidateLayout: function () {
	            var self = this, eventHandler = self._eventHandler;
	            self._layoutModel = keyword_null;
	            self._rowLayoutCache = {colHeader: keyword_null, viewport: keyword_null, colFooter: keyword_null};
	            self._colLayoutCache = {rowHeader: keyword_null, viewport: keyword_null};
	
	            Worksheet._callFeatureHandler(self, const_onLayoutChanged, {changeType: 'invalidateLayout'});
	
	           
	           
	           
	
	           
	            if (eventHandler && eventHandler._updateValidationUI && _FocusHelper._isActiveElement(self)) {
	                eventHandler._updateValidationUI(self._activeRowIndex, self._activeColIndex);
	            }
	           
	            if (self._needSyncHScrollbarSize) {
	                self._syncHScrollbarSize();
	                self._needSyncHScrollbarSize = false;
	            }
	            if (self._needSyncVScrollbarSize) {
	                self._syncVScrollbarSize();
	                self._needSyncVScrollbarSize = false;
	            }
	            self._dirty = true;
	        },
	        _invalidate: function () {
	            var self = this;
	            if (self._layoutSuspended <= 0) {
	                self.invalidateLayout();
	                self.repaint();
	            }
	        },
	       
	        
	        getViewportHeight: function (rowViewportIndex) {
	            var layout = this._getSheetLayout();
	            if (rowViewportIndex === 0) {
	                return layout._frozenHeight;
	            } else if (rowViewportIndex === 1) {
	                return layout._viewportHeight;
	            } else if (rowViewportIndex === 2) {
	                return layout._frozenTrailingHeight;
	            }
	            return 0;
	        },
	       
	        
	        getViewportWidth: function (columnViewportIndex) {
	            var layout = this._getSheetLayout();
	            if (columnViewportIndex === 0) {
	                return layout._frozenWidth;
	            } else if (columnViewportIndex === 1) {
	                return layout._viewportWidth;
	            } else if (columnViewportIndex === 2) {
	                return layout._frozenTrailingWidth;
	            }
	            return 0;
	        },
	       
	        
	        getViewportTopRow: function (rowViewportIndex) {
	            var self = this;
	            var frozenRowCount = getFrozenRowCount(self);
	            if (rowViewportIndex === 0) {
	                return 0;
	            } else if (rowViewportIndex === 1) {
	                return Math_max(frozenRowCount, self._scrollTopRow);
	            } else if (rowViewportIndex === 2) {
	                return Math_max(frozenRowCount, getRowCount(self) - getFrozenTrailingRowCount(self));
	            }
	            return -1;
	        },
	       
	        
	        getViewportBottomRow: function (rowViewportIndex) {
	            var self = this;
	           
	            if (rowViewportIndex === 2) {
	                return getRowCount(self) - 1;
	            }
	            var topRow = self.getViewportTopRow(rowViewportIndex);
	            var viewportHeight = self.getViewportHeight(rowViewportIndex);
	            var rowHeightTotal = 0;
	            var rowCount = 0;
	            var rc = getRowCount(self) - getFrozenTrailingRowCount(self);
	            if (rowViewportIndex === 0) {
	                rc = Math_min(getFrozenRowCount(self), rc);
	            }
	            for (var index = topRow; (index < rc) && (rowHeightTotal < viewportHeight); index++, rowCount++) {
	                rowHeightTotal += self._getZoomRowHeight(index);
	            }
	            return topRow + rowCount - 1;
	        },
	       
	        
	        getViewportLeftColumn: function (columnViewportIndex) {
	            var self = this;
	            var frozenColCount = getFrozenColumnCount(self);
	            if (columnViewportIndex === 0) {
	                return 0;
	            } else if (columnViewportIndex === 1) {
	                return Math_max(frozenColCount, self._scrollLeftCol);
	            } else if (columnViewportIndex === 2) {
	                return Math_max(frozenColCount, getColumnCount(self) - getFrozenTrailingColumnCount(self));
	            }
	            return -1;
	        },
	       
	        
	        getViewportRightColumn: function (columnViewportIndex) {
	            var self = this;
	           
	            if (columnViewportIndex === 2) {
	                return getColumnCount(self) - 1;
	            }
	            var leftColumn = self.getViewportLeftColumn(columnViewportIndex);
	            var viewportWidth = self.getViewportWidth(columnViewportIndex);
	            var columnCount = 0;
	            var columnWidthTotal = 0;
	            var cc = getColumnCount(self) - getFrozenTrailingColumnCount(self);
	            if (columnViewportIndex === 0) {
	                cc = Math_min(getFrozenColumnCount(self), cc);
	            }
	            for (var index = leftColumn; (index < cc) && (columnWidthTotal < viewportWidth); index++, columnCount++) {
	                columnWidthTotal += self._getZoomColumnWidth(index);
	            }
	            return leftColumn + columnCount - 1;
	        },
	
	       
	        
	        showCell: function (row, col, verticalPosition, horizontalPosition) {
	            var self = this;
	            if (row < 0 || row >= getRowCount(self) || col < 0 || col >= getColumnCount(self)) {
	                return;
	            }
	            var columnViewportIndex = self._getColumnViewportIndex(col);
	            var rowViewportIndex = self._getRowViewportIndex(row);
	            var topRow = self.getViewportTopRow(rowViewportIndex);
	            var leftColumn = self.getViewportLeftColumn(columnViewportIndex);
	           
	            if (columnViewportIndex === 1) {
	                col = self._getNewLeftColumn(col, horizontalPosition);
	            }
	           
	            if (rowViewportIndex === 1) {
	                row = self._getNewTopRow(row, verticalPosition);
	            }
	            var needRepaint = false;
	            if (rowViewportIndex === 1 && row !== topRow) {
	                row = Math_min(row, self._getLastVisualScrollRow());
	                self._scrollTopRow = row;
	                self._syncVScrollbarPosition();
	                needRepaint = true;
	            }
	            if (columnViewportIndex === 1 && col !== leftColumn) {
	                col = Math_min(col, self._getLastVisualScrollColumn());
	                self._scrollLeftCol = col;
	                self._syncHScrollbarPosition();
	                needRepaint = true;
	            }
	            if (needRepaint) {
	                var sp = self.parent;
	                if (sp && !sp.options.scrollbarShowMax) {
	                    self._needSyncHScrollbarSize = true;
	                    self._needSyncVScrollbarSize = true;
	                }
	                self._invalidate();
	            }
	        },
	        _getRowViewportIndex: function (row) {
	            var self = this, rowViewportIndex = 1;
	            if (row < getFrozenRowCount(self)) {
	                rowViewportIndex = 0;
	            } else if (row >= getRowCount(self) - getFrozenTrailingRowCount(self)) {
	                rowViewportIndex = 2;
	            }
	            return rowViewportIndex;
	        },
	        _getColumnViewportIndex: function (col) {
	            var self = this, columnViewportIndex = 1;
	            if (col < getFrozenColumnCount(self)) {
	                columnViewportIndex = 0;
	            } else if (col >= getColumnCount(self) - getFrozenTrailingColumnCount(self)) {
	                columnViewportIndex = 2;
	            }
	            return columnViewportIndex;
	        },
	        _getNewLeftColumn: function (col, horizontalPosition) {
	            var self = this, cachePool = self._cachePool, columnViewportIndex = self._getColumnViewportIndex(col),
	                leftColumn = self.getViewportLeftColumn(columnViewportIndex), dWidth;
	            if (horizontalPosition !== 0 ) {
	                if (horizontalPosition === 1 ) {
	                    dWidth = Math_floor((self.getViewportWidth(columnViewportIndex) - cachePool._getZoomColWidth(col)) / 2);
	                    for (; 0 < col; col--) {
	                        dWidth -= cachePool._getZoomColWidth(col - 1);
	                        if (dWidth < 0) {
	                            break;
	                        }
	                    }
	                } else if (horizontalPosition === 2 ) {
	                    dWidth = self.getViewportWidth(columnViewportIndex) - cachePool._getZoomColWidth(col);
	                    for (; 0 < col; col--) {
	                        dWidth -= cachePool._getZoomColWidth(col - 1);
	                        if (dWidth < 0) {
	                            break;
	                        }
	                    }
	                } else if (horizontalPosition === 3  && col >= leftColumn) {
	                    dWidth = self.getViewportWidth(columnViewportIndex) - cachePool._getZoomColWidth(col);
	                    for (; leftColumn < col; col--) {
	                        dWidth -= cachePool._getZoomColWidth(col - 1);
	                        if (dWidth < 0) {
	                            break;
	                        }
	                    }
	                }
	            }
	            return col;
	        },
	
	        _getNewTopRow: function (row, verticalPosition) {
	            var self = this, cachePool = self._cachePool, rowViewportIndex = self._getRowViewportIndex(row),
	                topRow = self.getViewportTopRow(rowViewportIndex), height;
	            if (verticalPosition !== 0 ) {
	                if (verticalPosition === 1 ) {
	                    height = Math_floor((self.getViewportHeight(rowViewportIndex) - cachePool._getZoomRowHeight(row)) / 2);
	                    for (; 0 < row; row--) {
	                        height -= cachePool._getZoomRowHeight(row - 1);
	                        if (height < 0) {
	                            break;
	                        }
	                    }
	                } else if (verticalPosition === 2 ) {
	                    height = self.getViewportHeight(rowViewportIndex) - cachePool._getZoomRowHeight(row);
	                    for (; 0 < row; row--) {
	                        height -= cachePool._getZoomRowHeight(row - 1);
	                        if (height < 0) {
	                            break;
	                        }
	                    }
	                } else if (verticalPosition === 3  && (!(row < topRow || topRow === -1))) {
	                    height = self.getViewportHeight(rowViewportIndex) - cachePool._getZoomRowHeight(row);
	                    for (; topRow < row; row--) {
	                        height -= cachePool._getZoomRowHeight(row - 1);
	                        if (height < 0) {
	                            break;
	                        }
	                    }
	                }
	            }
	            return row;
	        },
	       
	        
	        showColumn: function (col, horizontalPosition) {
	            this.showCell(this._scrollTopRow, col, 0 , horizontalPosition);
	        },
	       
	        
	        showRow: function (row, verticalPosition) {
	            this.showCell(row, this._scrollLeftCol, verticalPosition, 0 );
	        },
	
	       
	        
	        suspendEvent: function () {
	            this._eventSuspended++;
	        },
	       
	        
	        resumeEvent: function () {
	            this._eventSuspended--;
	            if (this._eventSuspended < 0) {
	                this._eventSuspended = 0;
	            }
	        },
	        isEventSuspended: function () {
	            return this._eventSuspended > 0;
	        },
	       
	       
	        
	        currentTheme: function (value) {
	            var self = this;
	            if (arguments.length === 0) {
	                if (!self._currentTheme) {
	                    self._resetCurrentTheme();
	                }
	                return self._currentTheme;
	            }
	
	            if (typeof value === const_string) {
	                if (Themes[value]) {
	                    value = Themes[value];
	                } else {
	                    value = new Theme(value);
	                }
	            }
	            self._currentTheme = value;
	            self._render._resetDefaultFont();
	            self._clearStyleCache();
	            self._invalidate();
	            return self;
	        },
	        _getDefaultTheme: function () {
	            var themeStyle = _ThemeStyleHelper._getCssClassThemeStyle(''),
	                themeVersion = convertToInt(themeStyle.zIndex),
	                theme = Themes.Office2007;
	            if (themeVersion > 2007 ) {
	                theme = Themes.Office;
	            }
	            return theme;
	        },
	        _resetCurrentTheme: function () {
	            this._currentTheme = this._getDefaultTheme();
	            this._clearStyleCache();
	        },
	       
	        
	        reset: function () {
	            var self = this;
	            self._resetImp();
	            self._invalidate();
	        },
	        _resetImp: function () {
	            var self = this;
	            self._initializeActiveCell();
	            self._activeRowViewportIndex = 0;
	            self._activeColViewportIndex = 0;
	            self._initOptions();
	           
	            self._layoutModel = keyword_null;
	            self._rowLayoutCache = {colHeader: keyword_null, viewport: keyword_null, colFooter: keyword_null};
	            self._colLayoutCache = {rowHeader: keyword_null, viewport: keyword_null};
	           
	            self._scrollTopRow = 0;
	            self._scrollLeftCol = 0;
	           
	            self.frozenRowCount(0);
	            self.frozenColumnCount(0);
	            self.frozenTrailingRowCount(0);
	            self.frozenTrailingColumnCount(0);
	            this._eventHandler = new exports._SheetEventHandler(this);
	           
	            var parent = self.parent;
	            if (parent) {
	                var activeSheet = parent.getActiveSheet();
	                if (activeSheet && self.name() === activeSheet.name()) {
	                    self._setHost(parent._vp);
	                }
	            }
	           
	            self._styleComposeCache = [{}, {}, {}, {}];
	            self._cachePool = new _CachePool(self);
	            self._composedDefaultStyle = {};
	            if (exports._supportsCalc) {
	                self.resetCalc();
	            }
	           
	            self._modelManager = new WORKSHEET_MODEL_MODULE._SheetModelManager(self, Worksheet._defaultRowCount, Worksheet._defaultColCount, Worksheet._defaultColHeaderRowCount, Worksheet._defaultRowHeaderColumnCount, self.name());
	            self.defaults = self._modelManager.defaults;
	           
	            self._resetCurrentTheme();
	           
	            self._namedStyles = {};
	           
	            self._needSyncHScrollbarSize = true;
	            self._needSyncVScrollbarSize = true;
	            if (self.parent && self.parent._paintSuspended) {
	                self._layoutSuspended = self.parent._paintSuspended;
	            } else {
	                self._layoutSuspended = 0;
	            }
	            if (self.parent && self.parent._eventSuspended) {
	                self._eventSuspended = self.parent._eventSuspended;
	            } else {
	                self._eventSuspended = 0;
	            }
	            self._dirtySuspended = 0;
	            self._disposed = false;
	
	            self._containerDiv = keyword_null;
	
	            self._rowStateProviders = [];
	            self._colStateProviders = [];
	
	            Worksheet._callFeatureHandler(self, 'init');
	        },
	        _initOptions: function () {
	            var self = this;
	            $_each(defaultOptions, function (prop, value) {
	                if (!isNullOrUndefined(value)) {
	                    var propertyValue = value;
	                    if (prop === 'gridline') {
	                        propertyValue = {
	                            color: _ThemeStyleHelper._getCssClassThemeStyle('gc-gridlineColor').borderTopColor,
	                            showVerticalGridline: true,
	                            showHorizontalGridline: true
	                        };
	                    } else if (typeof propertyValue === 'object') {
	                        propertyValue = $.extend({}, value);
	                    }
	                    self.options[prop] = propertyValue;
	                }
	            });
	        },
	        _onAttached: function (parent) {
	            var self = this;
	            self.parent = parent;
	           
	           
	            for (var i = 0; i < parent._paintSuspended; i++) {
	                self.suspendPaint();
	            }
	            self._eventSuspended = parent._eventSuspended;
	            Worksheet._callFeatureHandler(self, 'attach', parent);
	        },
	        _canChange: function (row, column, rowCount, columnCount, lockErrorMsg, arrayFormulaErrorMsg, isAllowDragInsert) {
	            var self = this;
	
	           
	            if (!isAllowDragInsert && self.options.isProtected && self._isAnyCellInRangeLocked(createRange(row, column, rowCount, columnCount))) {
	                lockErrorMsg && self._raiseInvalidOperation(1 , lockErrorMsg);
	                return false;
	            }
	            if (exports._supportsCalc && !self._checkArrayFormula(row, column, rowCount, columnCount)) {
	                arrayFormulaErrorMsg && self._raiseInvalidOperation(1 , arrayFormulaErrorMsg);
	                return false;
	            }
	            return true;
	        },
	       
	        
	        clear: function (row, column, rowCount, columnCount, area, storageType) {
	            if (area !== 0 ) {
	                this._clearCore(row, column, rowCount, columnCount, area, storageType);
	            }
	        },
	        _clearCore: function (row, column, rowCount, columnCount, area, storageType, ignoreFilteredOutRow, ignoreTable) {
	            var self = this;
	            try {
	                var supportsCalc = exports._supportsCalc;
	                supportsCalc && self.suspendCalcService();
	                self.suspendPaint();
	                var defaults = self.defaults;
	                var r, c, i, j;
	                var viewport = 3 ;
	                if (isNullOrUndefined(area) || area === viewport) {
	                    if (exports._supportsCalc && !self._checkArrayFormula(row, column, rowCount, columnCount)) {
	                        return false;
	                    }
	                   
	                    if (storageType & 1  && self.getDataSource && self.getDataSource()) {
	                        self.suspendEvent();
	                        for (r = row; r < row + rowCount; r++) {
	                            if (ignoreFilteredOutRow && self._isRowFilterOut && self._isRowFilterOut(r)) {
	                                continue;
	                            }
	                            for (c = column; c < column + columnCount; c++) {
	                                self.setValue(r, c, keyword_null, area);
	                            }
	                        }
	                        self.resumeEvent();
	                    }
	                }
	
	                var e = {
	                    changeType: 'clear',
	                    row: row,
	                    col: column,
	                    rowCount: rowCount,
	                    colCount: columnCount,
	                    sheetArea: area,
	                    type: storageType,
	                    ignoreTable: ignoreTable
	                };
	               
	                Worksheet._callFeatureHandler(self, const_onLayoutChanged, e);
	
	                var modelManager = self._modelManager;
	                var calcBlock = supportsCalc && self._getCalcModel();
	                r = row === -1 ? 0 : row;
	                var rc = row === -1 ? modelManager.getRowCount(area) : rowCount;
	                c = column === -1 ? 0 : column;
	                var cc = column === -1 ? modelManager.getColumnCount(area) : columnCount;
	                var hiddenRowList = [];
	                for (var rowIndex = r; rowIndex < rc; rowIndex++) {
	                    if (ignoreFilteredOutRow && self._isRowFilterOut && self._isRowFilterOut(rowIndex)) {
	                        hiddenRowList.push(rowIndex);
	                    }
	                }
	                modelManager.do('clear', r, c, rc, cc, storageType, hiddenRowList, area);
	                if (calcBlock && (storageType & 1 )) {
	                    calcBlock._unlinkCellExpression(r, c, rc, cc);
	                    calcBlock.clear(r, c, rc, cc, modelManager._getChangesForCalcEngine());
	                }
	                if ((storageType & 8 ) && (!(row >= 0 && column >= 0))) {
	                    if (column >= 0) {
	                        for (j = 0; j < cc; j++) {
	                            self.setTag(-1, c + j, keyword_null, area);
	                        }
	                    } else if (row >= 0) {
	                        for (i = 0; i < rc; i++) {
	                            if (ignoreFilteredOutRow && self._isRowFilterOut && self._isRowFilterOut(r + i)) {
	                                continue;
	                            }
	                            self.setTag(r + i, -1, keyword_null, area);
	                        }
	                    } else {
	                        self.setTag(-1, -1, keyword_null, area);
	                    }
	                }
	                if ((storageType & 2 ) && (!(row >= 0 && column >= 0))) {
	                    if (column >= 0) {
	                        for (j = 0; j < cc; j++) {
	                            self.setStyle(-1, c + j, keyword_null, area);
	                        }
	                    } else if (row >= 0) {
	                        for (i = 0; i < rc; i++) {
	                            if (ignoreFilteredOutRow && self._isRowFilterOut && self._isRowFilterOut(r + i)) {
	                                continue;
	                            }
	                            self.setStyle(r + i, -1, keyword_null, area);
	                        }
	                    } else {
	                        self.setStyle(-1, -1, keyword_null, area);
	                    }
	                }
	                if (storageType & 32 ) {
	                    if (row < 0) {
	                        for (j = 0; j < cc; j++) {
	                            self.setColumnVisible(c + j, true, area);
	                            self.setColumnResizable(c + j, true, area);
	                            self.setColumnWidth(c + j, (area === 2 ) ? defaults.rowHeaderColWidth : defaults.colWidth, area);
	                        }
	                    }
	                    if (column < 0) {
	                        for (i = 0; i < rc; i++) {
	                            if (ignoreFilteredOutRow && self._isRowFilterOut && self._isRowFilterOut(r + i)) {
	                                continue;
	                            }
	                            self.setRowVisible(r + i, true, area);
	                            self.setRowResizable(r + i, true, area);
	                            self.setRowHeight(r + i, (area === 1 ) ? defaults.colHeaderRowHeight : defaults.rowHeight, area);
	                        }
	                    }
	                }
	                if ((isNullOrUndefined(area) || area === viewport) && (supportsCalc && (storageType & 1 ) === 1 )) {
	                    var calcModel = self._getCalcModel();
	                    if (calcModel) {
	                        calcModel._addCellsToDirty(row, column, rowCount, columnCount);
	                    }
	                }
	
	                var changedCells = [];
	                for (i = 0; i < rc; i++) {
	                    for (j = 0; j < cc; j++) {
	                        changedCells.push({row: r + i, col: c + j});
	                    }
	                }
	                self._raiseRangeDataChanged(row, column, rc, cc, changedCells, 2 , area);
	            } finally {
	                self.resumePaint();
	                supportsCalc && self.resumeCalcService(false);
	            }
	        },
	        _adjustActiveCellToSelectable: function () {
	            var self = this;
	            var options = self.options, protectionOption = options.protectionOptions;
	            if (options.isProtected && protectionOption && (protectionOption.allowSelectLockedCells === false || protectionOption.allowSelectUnlockedCells === false)) {
	                var oldRow = self._activeRowIndex, oldCol = self._activeColIndex;
	                if (!self._canSelect(oldRow, oldCol)) {
	                    self._clearSelectionImp();
	                    self._moveActiveCellRight(oldRow, oldCol, true);
	                    self._moveActiveCellEnd(4 , oldRow, oldCol);
	                }
	            }
	        },
	       
	        
	        setArray: function (row, column, array, setFormula) {
	            var self = this;
	            setFormula = exports._supportsCalc && setFormula;
	            var rowCount = getRowCount(self), columnCount = getColumnCount(self);
	            if (array && 0 <= row && row < rowCount && 0 <= column && column < columnCount) {
	                exports._supportsCalc && self.suspendCalcService();
	                self.suspendPaint();
	                try {
	                    var r, c;
	                    $_each(array, function (i, v) {
	                        if (!($.isArray(v))) {
	                            r = row + i;
	                            c = column;
	                            if (r < rowCount && c < columnCount) {
	                                if (setFormula) {
	                                    self.setFormula(r, c, v);
	                                } else {
	                                    self.setValue(r, c, v, 3 , true);
	                                }
	                            }
	                        } else {
	                            $_each(v, function (j, vv) {
	                                r = row + i;
	                                c = column + j;
	                                if (r < rowCount && c < columnCount) {
	                                    if (setFormula) {
	                                        self.setFormula(r, c, vv);
	                                    } else {
	                                        self.setValue(r, c, vv, 3 , true);
	                                    }
	                                }
	                            });
	                        }
	                    });
	                } finally {
	                    exports._supportsCalc && self.resumeCalcService();
	                    self.resumePaint();
	                }
	            }
	        },
	       
	        
	        getArray: function (row, column, rowCount, columnCount, getFormula) {
	            var self = this;
	            var array = [];
	            var rc = getRowCount(self), cc = getColumnCount(self);
	            getFormula = getFormula && exports._supportsCalc;
	            if (0 <= row && row < rc && 0 <= column && column < cc) {
	                if (row + rowCount > rc) {
	                    rowCount = rc - row;
	                }
	                if (column + columnCount > cc) {
	                    columnCount = cc - column;
	                }
	                for (var i = 0; i < rowCount; i++) {
	                    array[i] = [];
	                    for (var j = 0; j < columnCount; j++) {
	                        if (getFormula) {
	                            array[i][j] = self.getFormula(row + i, column + j);
	                        } else {
	                            array[i][j] = self.getValue(row + i, column + j);
	                        }
	                    }
	                }
	            }
	            return array;
	        },
	
	       
	        
	        setTag: function (row, col, tag, sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var self = this;
	            if (sheetArea !== 0 ) {
	                var modelManager = self._modelManager;
	                var rowCount = modelManager.getRowCount(sheetArea), colCount = modelManager.getColumnCount(sheetArea);
	                if (row < -1 || row >= rowCount || col < -1 || col >= colCount) {
	                    return;
	                }
	                tag = tryConvertDateToOADate(tag);
	                var oldTag, isEventsSuspended = (self._eventSuspended > 0);
	                if (!isEventsSuspended) {
	                    oldTag = self.getTag(row, col, sheetArea);
	                }
	                modelManager.do('setValueForKey', row, col, const_tag, tag, sheetArea);
	
	                if (!isEventsSuspended && oldTag !== tag) {
	                    if (row !== -1 && col !== -1) {
	                        self._raiseCellChanged(const_tag, row, col, sheetArea, oldTag, tag);
	                    } else if (row !== -1 && col === -1) {
	                        self._raiseRowChanged(row, sheetArea, const_tag, tag, oldTag);
	                    } else if (row === -1 && col !== -1) {
	                        self._raiseColumnChanged(col, sheetArea, const_tag, tag, oldTag);
	                    }
	                }
	            }
	        },
	       
	        
	        getTag: function (row, col, sheetArea) {
	            var self = this;
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            if (sheetArea !== 0 ) {
	                var tag = self._modelManager.getValueForKey(row, col, const_tag, sheetArea);
	                return tryConvertOADateToDate(tag);
	            }
	            return keyword_null;
	        },
	       
	        
	        tag: function (value) {
	            var self = this;
	            if (arguments.length === 0) {
	                var tag = self._modelManager.getValueForKey(-1, -1, const_tag, 3 );
	                return tryConvertOADateToDate(tag);
	            }
	
	            self._modelManager.do('setValueForKey', -1, -1, const_tag, tryConvertDateToOADate(value), 3 );
	            return self;
	        },
	       
	        
	        getParent: function () {
	            return this.parent;
	        },
	
	       
	        
	        getDirtyRows: function () {
	            return getDirtyOrInsertRows(this, true);
	        },
	       
	        
	        getInsertRows: function () {
	            return getDirtyOrInsertRows(this, false);
	        },
	       
	        
	        getDeletedRows: function () {
	            var rows = [], deletedRows = this._deletedRows;
	            if (deletedRows) {
	                $_each(deletedRows, function (i, v) {
	                    if (v && !$.isFunction(v)) {
	                        rows.push({row: v.row, originalItem: v.data});
	                    }
	                });
	            }
	            return rows;
	        },
	       
	        
	        hasPendingChanges: function () {
	            var self = this, deletedRows = self._deletedRows;
	            if (deletedRows && deletedRows.length > 0) {
	                return true;
	            }
	            var dirtyNodes = self._modelManager._getDirtyNodes();
	            return !$_isEmptyObject(dirtyNodes);
	        },
	       
	        
	        clearPendingChanges: function () {
	            this._modelManager._clearDirtyNodes();
	            this._deletedRows = [];
	        },
	       
	        
	        getDirtyCells: function (row, col, rowCount, colCount) {
	            var self = this;
	            if (isNullOrUndefined(row)) {
	                row = -1;
	            }
	            if (isNullOrUndefined(col)) {
	                col = -1;
	            }
	            if (isNullOrUndefined(rowCount) || rowCount <= 0) {
	                rowCount = 1;
	            }
	            if (isNullOrUndefined(colCount) || colCount <= 0) {
	                colCount = 1;
	            }
	            var cells = [];
	            var dirtyNodes = self._modelManager._getDirtyNodes();
	            if (!$_isEmptyObject(dirtyNodes)) {
	                var rowArray = [];
	                if (row >= 0) {
	                    for (var rowIndex = row; rowIndex < row + rowCount; rowIndex++) {
	                        rowArray.push(rowIndex);
	                    }
	                } else {
	                    for (var r in dirtyNodes) {
	                        if (hasOwnProperty(dirtyNodes, r)) {
	                            rowArray.push(convertToInt(r));
	                        }
	                    }
	                }
	                var dirtyRow, node;
	                $_each(rowArray, function (i, index) {
	                    dirtyRow = dirtyNodes[index];
	                    if (dirtyRow && dirtyRow.rs === 'e') {
	                        if (col >= 0) {
	                            for (var columnIndex = col; columnIndex < col + colCount; columnIndex++) {
	                                node = dirtyRow[columnIndex];
	                                if (node) {
	                                    cells.push(getDirtyValue(self, index, columnIndex, node.oldValue));
	                                }
	                            }
	                        } else {
	                            for (var colIndex in dirtyRow) {
	                                if (!isNotANumber(colIndex)) {
	                                    node = dirtyRow[colIndex];
	                                    if (node) {
	                                        cells.push(getDirtyValue(self, index, convertToInt(colIndex), node.oldValue));
	                                    }
	                                }
	                            }
	                        }
	                    }
	                });
	            }
	            return cells;
	        },
	       
	        
	        suspendDirty: function () {
	            this._dirtySuspended++;
	            this._modelManager._suspendDirty();
	        },
	       
	        
	        resumeDirty: function () {
	            var self = this;
	            self._dirtySuspended--;
	            if (self._dirtySuspended < 0) {
	                self._dirtySuspended = 0;
	            }
	            self._modelManager._resumeDirty();
	        },
	       
	        
	        isDirtySuspended: function () {
	            return this._dirtySuspended > 0;
	        },
	
	       
	       
	        _init: function (name) {
	            this._setBounds(new Rect(0, 0, 0, 0));
	            this._resetImp();
	            this._setNameCore(name);
	        },
	        _getCanvasOffset: function () {
	            var sheet = this;
	            var t = $(sheet._getCanvas()).offset();
	            if (t) {
	                t.top += DOCUMENT.body.clientTop || 0;
	                t.left += DOCUMENT.body.clientLeft || 0;
	            } else {
	                t = {top: 0, left: 0};
	            }
	            var canvasOffset = sheet._getCanvas().canvasOffset;
	            if (canvasOffset) {
	                t = canvasOffset;
	            }
	            return t;
	        },
	
	        _setHost: function (host) {
	            if (!host) {
	                return;
	            }
	
	            var self = this;
	            self._disposed = false;
	
	           
	            var oldCanvas = self._canvas;
	            if (oldCanvas) {
	                self._dispose(false);
	            }
	
	            var canvas = createElement('canvas');
	            $(canvas).attr('id', host.getAttribute('id') + '_vp').html(sR().NeedCanvasSupport).appendTo(host);
	            _DPIHelper._adjustDevicePixel(canvas, keyword_null, self);
	            self._canvas = canvas;
	
	            self._doResize();
	            self.repaint();
	           
	            if (self.parent) {
	                self.parent._paintWorkbookBackgroundImage();
	            }
	
	            Worksheet._callFeatureHandler(self, 'setHost', $(canvas));
	        },
	        _doResize: function () {
	            var sheet = this;
	            var canvas = sheet._getCanvas();
	            if (!canvas || !canvas.parentNode) {
	                return;
	            }
	
	            var computedStyle = getComputedStyle(canvas.parentNode);
	            var parentWidthCss = computedStyle.width;
	            var parentHeightCss = computedStyle.height;
	            var pxIndex = parentWidthCss.indexOf('px');
	            if (pxIndex > 0) {
	                parentWidthCss = parentWidthCss.substring(0, pxIndex);
	            }
	            pxIndex = parentHeightCss.indexOf('px');
	            if (pxIndex > 0) {
	                parentHeightCss = parentHeightCss.substring(0, pxIndex);
	            }
	            var parentWidth = convertToInt(parentWidthCss);
	            var parentHeight = convertToInt(parentHeightCss);
	            if (isNotANumber(parentWidth)) {
	                parentWidth = $(canvas.parentNode).width();
	            }
	            if (isNotANumber(parentHeight)) {
	                parentHeight = $(canvas.parentNode).height();
	            }
	            if (parentWidth === 0 || parentHeight === 0) {
	                return;
	            }
	            var width = Math_max(parentWidth, 0), height = Math_max(parentHeight, 0);
	            canvas.style.display = 'none';
	            canvas.style.display = '';
	            canvas.width = width;
	            canvas.height = height;
	            canvas.style.width = width + 'px';
	            canvas.style.height = height + 'px';
	
	            width = canvas.clientWidth || canvas.width;
	            height = canvas.clientHeight || canvas.height;
	            sheet._bounds.width = width;
	            sheet._bounds.height = height;
	            _DPIHelper._setSize(canvas, width, height);
	            sheet.invalidateLayout();
	        },
	        _dispose: function (clearCache) {
	            var self = this;
	            _DPIHelper._disposeSheet(self);
	
	            if (self.isEditing && self.isEditing()) {
	                self._endEditCore();
	            }
	
	            Worksheet._callFeatureHandler(self, 'dispose', clearCache);
	            var canvas = self._canvas, parentNode;
	            if (canvas) {
	                parentNode = canvas.parentNode;
	                if (parentNode) {
	                    parentNode.removeChild(canvas);
	                }
	                self._canvas = keyword_null;
	            }
	
	            self._disposeStringWidthPre();
	
	            if (clearCache !== false) {
	                self._disposed = true;
	                var cutCopyIndicatorManager = self._cutCopyIndicatorManager;
	                if (cutCopyIndicatorManager) {
	                    cutCopyIndicatorManager._dispose();
	                }
	                self.parent = keyword_null;
	                self._modelManager = keyword_null;
	                self._cachePool = keyword_null;
	                if (self._imageLoader) {
	                    self._imageLoader._dispose();
	                    self._imageLoader = keyword_null;
	                }
	                if (_FocusHelper._isActiveElement(self)) {
	                    _FocusHelper._setActiveElement(keyword_null, true);
	                }
	            }
	        },
	        _disposeStringWidthPre: function () {
	            var pre = this._editingPre;
	            if (pre) {
	                $(pre).remove();
	                this._editingPre = keyword_undefined;
	            }
	        },
	        _getValueImp: function (modelManager, row, col, sheetArea, valueType) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var t = modelManager.getValue(row, col, sheetArea, keyword_undefined, valueType);
	
	            t = tryConvertOADateToDate(t);
	
	            return t;
	        },
	
	        _getActualRange: function (range, sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var actualRange = createRange(-1, -1, -1, -1);
	            if (range) {
	                var self = this, row = range.row, col = range.col, rowCount = range.rowCount, colCount = range.colCount;
	                if (col === -1) {
	                    col = 0;
	                    colCount = self.getColumnCount(sheetArea);
	                }
	                if (row === -1) {
	                    row = 0;
	                    rowCount = self.getRowCount(sheetArea);
	                }
	                actualRange.col = col;
	                actualRange.row = row;
	                actualRange.colCount = colCount;
	                actualRange.rowCount = rowCount;
	            }
	            return actualRange;
	        },
	       
	        getRangeRect: function (rowViewportIndex, colViewportIndex, range) {
	           
	           
	           
	           
	            var rect = new Rect(-1, -1, -1, -1), self = this, layout = self._getSheetLayout();
	            if (layout.width === 0 || layout.height === 0) {
	                return rect;
	            }
	            var colLayouts = self._getViewportColumnLayout(colViewportIndex),
	                rowLayouts = self._getViewportRowLayout(rowViewportIndex);
	            if (!colLayouts || colLayouts.length === 0 || !rowLayouts || rowLayouts.length === 0) {
	                return rect;
	            }
	            var actualRange = self._getActualRange(range), cachePool = self._cachePool;
	            var row1 = actualRange.row, row2 = actualRange.row + actualRange.rowCount - 1,
	                col1 = actualRange.col, col2 = actualRange.col + actualRange.colCount - 1,
	                firstRow = getFrozenRowCount(self), lastRow = getRowCount(self) - getFrozenTrailingRowCount(self) - 1,
	                firstCol = getFrozenColumnCount(self),
	                lastCol = getColumnCount(self) - getFrozenTrailingColumnCount(self) - 1,
	                vLeftCol = colLayouts[0].col, vRightCol = colLayouts[colLayouts.length - 1].col,
	                vTopRow = rowLayouts[0].row, vBottomRow = rowLayouts[rowLayouts.length - 1].row;
	
	            function getPrevVisualCol(col, endCol) {
	                while (col > endCol) {
	                    col--;
	                    if (self.getColumnVisible(col)) {
	                        return col;
	                    }
	                }
	                return col;
	            }
	
	            function getNextVisualCol(col, endCol) {
	                while (col < endCol) {
	                    col++;
	                    if (self.getColumnVisible(col)) {
	                        return col;
	                    }
	                }
	                return col;
	            }
	
	            function getPrevVisualRow(row, endRow) {
	                while (row > endRow) {
	                    row--;
	                    if (self.getRowVisible(row)) {
	                        return row;
	                    }
	                }
	                return row;
	            }
	
	            function getNextVisualRow(row, endRow) {
	                while (row < endRow) {
	                    row++;
	                    if (self.getRowVisible(row)) {
	                        return row;
	                    }
	                }
	                return row;
	            }
	
	            if (col1 < vLeftCol) {
	                col1 = getPrevVisualCol(vLeftCol, col1);
	            }
	            if (col2 > vRightCol) {
	                col2 = getNextVisualCol(vRightCol, col2);
	            }
	            if (row1 < vTopRow) {
	                row1 = getPrevVisualRow(vTopRow, row1);
	            }
	            if (row2 > vBottomRow) {
	                row2 = getNextVisualRow(vBottomRow, row2);
	            }
	            if (col2 < col1 || row2 < row1) {
	                return rect;
	            }
	
	           
	            if (colViewportIndex === 0) {
	                if (col1 < firstCol) {
	                    rect.x = layout._frozenX + getColsWidth(cachePool, 0, col1 - 1);
	                    rect.width = getColsWidth(cachePool, col1, col2);
	                }
	            } else if (colViewportIndex === 1) {
	                if (col1 <= lastCol && col2 >= firstCol) {
	                    if (col1 < vLeftCol) {
	                        rect.x = colLayouts[0].x - getColsWidth(cachePool, col1, vLeftCol - 1);
	                    } else {
	                        rect.x = colLayouts[0].x + getColsWidth(cachePool, vLeftCol, col1 - 1);
	                    }
	                    rect.width = getColsWidth(cachePool, col1, col2);
	                }
	            } else if (colViewportIndex === 2 && col2 > lastCol) {
	                if (col1 < vLeftCol) {
	                    rect.x = layout._frozenTrailingX - getColsWidth(cachePool, col1, vLeftCol - 1);
	                } else {
	                    rect.x = layout._frozenTrailingX + getColsWidth(cachePool, vLeftCol, col1 - 1);
	                }
	                rect.width = getColsWidth(cachePool, col1, col2);
	            }
	           
	            if (rowViewportIndex === 0) {
	                if (row1 < firstRow) {
	                    rect.y = layout._frozenY + getRowsHeight(cachePool, 0, row1 - 1);
	                    rect.height = getRowsHeight(cachePool, row1, row2);
	                }
	            } else if (rowViewportIndex === 1) {
	                if (row1 <= lastRow && row2 >= firstRow) {
	                    if (row1 < vTopRow) {
	                        rect.y = rowLayouts[0].y - getRowsHeight(cachePool, row1, vTopRow - 1);
	                    } else {
	                        rect.y = rowLayouts[0].y + getRowsHeight(cachePool, vTopRow, row1 - 1);
	                    }
	                    rect.height = getRowsHeight(cachePool, row1, row2);
	                }
	            } else if (rowViewportIndex === 2 && row2 > lastRow) {
	                if (row1 < vTopRow) {
	                    rect.y = layout._frozenTrailingY - getRowsHeight(cachePool, row1, vTopRow - 1);
	                } else {
	                    rect.y = layout._frozenTrailingY + getRowsHeight(cachePool, vTopRow, row1 - 1);
	                }
	                rect.height = getRowsHeight(cachePool, row1, row2);
	            }
	            return rect;
	        },
	        _getRangeWholeRect: function (range) {
	            var self = this;
	            var rect = new Rect(-1, -1, -1, -1), layout = self._getSheetLayout();
	            if (layout.width === 0 || layout.height === 0) {
	                return rect;
	            }
	            var actualRange = self._getActualRange(range);
	            var frozenColCount = getFrozenColumnCount(self), frozenRowCount = getFrozenRowCount(self),
	                frozenTrailingColCount = getFrozenTrailingColumnCount(self),
	                frozenTrailingRowCount = getFrozenTrailingRowCount(self);
	            var cachePool = self._cachePool;
	            var row1 = actualRange.row, row2 = actualRange.row + actualRange.rowCount - 1,
	                col1 = actualRange.col, col2 = actualRange.col + actualRange.colCount - 1,
	                rowCount = getRowCount(self), colCount = getColumnCount(self), colLayout, rowLayout;
	           
	            if (col1 < frozenColCount) {
	                rect.x = layout._frozenX + getColsWidth(cachePool, 0, col1 - 1);
	                rect.width = getColsWidth(cachePool, col1, Math_min(col2, frozenColCount - 1));
	               
	                if (frozenColCount <= col2 && col2 < colCount - frozenTrailingColCount) {
	                    colLayout = self._getViewportColumnLayout(1);
	                    if (colLayout && colLayout.length > 0) {
	                        rect.width += getColsWidth(cachePool, colLayout[0].col, Math_min(col2, colLayout[colLayout.length - 1].col));
	                    }
	                } else if (col2 >= colCount - frozenTrailingColCount) {
	                    colLayout = self._getViewportColumnLayout(2);
	                    if (colLayout && colLayout.length > 0) {
	                        rect.width = colLayout[0].x - rect.x;
	                        rect.width += getColsWidth(cachePool, colCount - frozenTrailingColCount, Math_min(col2, colCount - 1));
	                    }
	                }
	            } else if (col1 < colCount - frozenTrailingColCount) {
	                colLayout = self._getViewportColumnLayout(1);
	                if (!colLayout || colLayout.length === 0 || col1 > colLayout[colLayout.length - 1].col || col2 < colLayout[0].col) {
	                    return rect;
	                }
	                rect.x = layout._viewportX + getColsWidth(cachePool, colLayout[0].col, col1 - 1);
	               
	                if (frozenColCount <= col2 && col2 < colCount - frozenTrailingColCount) {
	                    rect.width = getColsWidth(cachePool, Math_max(col1, colLayout[0].col), Math_min(col2, colLayout[colLayout.length - 1].col));
	                } else if (col2 >= colCount - frozenTrailingColCount) {
	                    colLayout = self._getViewportColumnLayout(2);
	                    if (colLayout && colLayout.length > 0) {
	                        rect.width = colLayout[0].x - rect.x;
	                        rect.width += getColsWidth(cachePool, colCount - frozenTrailingColCount, Math_min(col2, colCount - 1));
	                    }
	                }
	            } else if (col1 < colCount) {
	                colLayout = self._getViewportColumnLayout(2);
	                if (colLayout && colLayout.length > 0) {
	                    rect.x = layout._frozenTrailingX + getColsWidth(cachePool, colLayout[0].col, col1 - 1);
	                    rect.width = getColsWidth(cachePool, col1, Math_min(col2, colCount - 1));
	                }
	            }
	           
	            if (row1 < frozenRowCount) {
	                rect.y = layout._frozenY + getRowsHeight(cachePool, 0, row1 - 1);
	                rect.height = getRowsHeight(cachePool, row1, Math_min(row2, frozenRowCount - 1));
	               
	                if (frozenRowCount <= row2 && row2 < rowCount - frozenTrailingRowCount) {
	                    rowLayout = self._getViewportRowLayout(1);
	                    if (rowLayout && rowLayout.length > 0) {
	                        rect.height += getRowsHeight(cachePool, rowLayout[0].row, Math_min(row2, rowLayout[rowLayout.length - 1].row));
	                    }
	                } else if (row2 >= rowCount - frozenTrailingRowCount) {
	                    rowLayout = self._getViewportRowLayout(2);
	                    if (rowLayout && rowLayout.length > 0) {
	                        rect.height = rowLayout[0].y - rect.y;
	                        rect.height += getRowsHeight(cachePool, rowCount - frozenTrailingRowCount, Math_min(row2, rowCount - 1));
	                    }
	                }
	            } else if (row1 < rowCount - frozenTrailingRowCount) {
	                rowLayout = self._getViewportRowLayout(1);
	                if (!rowLayout || rowLayout.length === 0 || row1 > rowLayout[rowLayout.length - 1].row || row2 < rowLayout[0].row) {
	                    return rect;
	                }
	                rect.y = layout._viewportY + getRowsHeight(cachePool, rowLayout[0].row, row1 - 1);
	               
	                if (frozenRowCount <= row2 && row2 < rowCount - frozenTrailingRowCount) {
	                    rect.height = getRowsHeight(cachePool, Math_max(row1, rowLayout[0].row), Math_min(row2, rowLayout[rowLayout.length - 1].row));
	                } else if (row2 >= rowCount - frozenTrailingRowCount) {
	                    rowLayout = self._getViewportRowLayout(2);
	                    if (rowLayout && rowLayout.length > 0) {
	                        rect.height = rowLayout[0].y - rect.y;
	                        rect.height += getRowsHeight(cachePool, rowCount - frozenTrailingRowCount, Math_min(row2, rowCount - 1));
	                    }
	                }
	            } else if (row1 < rowCount) {
	                rowLayout = self._getViewportRowLayout(2);
	                if (rowLayout && rowLayout.length > 0) {
	                    rect.y = layout._frozenTrailingY + getRowsHeight(cachePool, rowLayout[0].row, row1 - 1);
	                    rect.height += getRowsHeight(cachePool, row1, Math_min(row2, rowCount - 1));
	                }
	            }
	            return rect;
	        },
	        _getCanvas: function () {
	            return this._canvas;
	        },
	        _getStringWidth: function (value, font) {
	           
	           
	            return this._getStringWidthByCanvas(value, font) + 1;
	        },
	        _getStringWidthByCanvas: function (value, font) {
	            var currentFont = '', render = this._render;
	            if (font) {
	                currentFont = font;
	            } else {
	                currentFont = render._getZoomFont(render._getDefaultFont());
	            }
	            return util_common._WordWrapHelper._measureText(value, currentFont);
	        },
	        _getColumnViewportIndexFromX: function (x) {
	            var layout = this._getSheetLayout();
	            var colViewportIndex = keyword_null;
	            if (layout._headerX < x && x < layout._headerX + layout._rowHeaderWidth) {
	                colViewportIndex = -1;
	            } else if (layout._frozenX < x && x < layout._frozenX + layout._frozenWidth) {
	                colViewportIndex = 0;
	            } else if (layout._viewportX < x && x < layout._viewportX + layout._viewportWidth) {
	                colViewportIndex = 1;
	            } else if (layout._frozenTrailingX < x && x < layout._frozenTrailingX + layout._frozenTrailingWidth) {
	                colViewportIndex = 2;
	            }
	            return colViewportIndex;
	        },
	        _getRowViewportIndexFromY: function (y) {
	            var layout = this._getSheetLayout();
	            var rowViewportIndex = keyword_null;
	            if (layout._headerY < y && y < layout._headerY + layout._colHeaderHeight) {
	                rowViewportIndex = -1;
	            } else if (layout._frozenY < y && y < layout._frozenY + layout._frozenHeight) {
	                rowViewportIndex = 0;
	            } else if (layout._viewportY < y && y < layout._viewportY + layout._viewportHeight) {
	                rowViewportIndex = 1;
	            } else if (layout._frozenTrailingY < y && y < layout._frozenTrailingY + layout._frozenTrailingHeight) {
	                rowViewportIndex = 2;
	            }
	            return rowViewportIndex;
	        },
	        _getRowIndexFromY: function (y, rowViewportIndex) {
	            var rowLayouts;
	            if (rowViewportIndex === -1) {
	                rowLayouts = this._getColumnHeaderRowLayout();
	            } else {
	                rowLayouts = this._getViewportRowLayout(rowViewportIndex);
	            }
	            if (rowLayouts) {
	                var rowLayout = rowLayouts.findY(y);
	                if (rowLayout) {
	                    return rowLayout.row;
	                }
	            }
	        },
	        _getColumnIndexFromX: function (x, colViewportIndex) {
	            var colLayouts;
	            if (colViewportIndex === -1) {
	                colLayouts = this._getRowHeaderColumnLayout();
	            } else {
	                colLayouts = this._getViewportColumnLayout(colViewportIndex);
	            }
	            if (colLayouts) {
	                var colLayout = colLayouts.findX(x);
	                if (colLayout) {
	                    return colLayout.col;
	                }
	            }
	        },
	        _isActiveCell: function (r, c) {
	            var self = this;
	            return (self._activeRowIndex <= r && r < self._activeRowIndex + self._activeRowCount && self._activeColIndex <= c && c < self._activeColIndex + self._activeColCount);
	        },
	        _isColumnSelected: function (c) {
	            return this._modelManager._isColumnSelected(c);
	        },
	        _isRowSelected: function (r) {
	            return this._modelManager._isRowSelected(r);
	        },
	        _isSelected: function (r, c, sheetArea, considerAdjacentCell) {
	            var self = this;
	            var sheetRowCount = getRowCount(self);
	            var sheetColCount = getColumnCount(self);
	            return this._modelManager._isSelected(r, c, sheetArea, sheetRowCount, sheetColCount, considerAdjacentCell);
	        },
	        _isAllSelected: function (r, c, sheetArea) {
	            var self = this;
	
	            var sheetRowCount = getRowCount(self);
	            var sheetColCount = getColumnCount(self);
	            return this._modelManager._isAllSelected(r, c, sheetArea, sheetRowCount, sheetColCount);
	        },
	        _isHover: function (r, c, sheetArea) {
	            var self = this, inSpans, span, hovered;
	            var target = self._currentTarget;
	            if (target && !target.resizeInfo && !isNullOrUndefined(sheetArea)) {
	                var hitTestType = target.hitTestType, target_row = target.row, target_col = target.col;
	                if (sheetArea === 1 ) {
	                    inSpans = false;
	                    span = self._modelManager.findSpan(target_row, target_col, 1 );
	                    if (span) {
	                        inSpans = span.contains(r, c, 1, 1);
	                    }
	                    hovered = (r === target_row && c === target_col) || (inSpans);
	                    return (hitTestType === sheetArea && hovered);
	                } else if (sheetArea === 2 ) {
	                    inSpans = false;
	                    span = self._modelManager.findSpan(target_row, target_col, 2 );
	                    if (span) {
	                        inSpans = span.contains(r, c, 1, 1);
	                    }
	                    hovered = (r === target_row && c === target_col) || (inSpans);
	                    return (hitTestType === sheetArea && hovered);
	                } else if (sheetArea === 3 ) {
	                    return (hitTestType === sheetArea && r === target_row && c === target_col);
	                } else if (sheetArea === 0 ) {
	                    return (hitTestType === sheetArea);
	                }
	            }
	            return false;
	        },
	        _indexToLetters: util_common_util._indexToLetters, 
	        _getSheetArea: function (rowViewportIndex, colViewportIndex) {
	            if (rowViewportIndex >= 0 && rowViewportIndex <= 2 && colViewportIndex >= 0) {
	                return 3 ;
	            } else if (rowViewportIndex >= 0 && rowViewportIndex <= 2 && colViewportIndex < 0) {
	                return 2 ;
	            } else if (rowViewportIndex < 0 && colViewportIndex >= 0) {
	                return 1 ;
	            } else if (rowViewportIndex < 0 && colViewportIndex < 0) {
	                return 0 ;
	            }
	           
	           
	           
	            return keyword_null;
	        },
	        _setFocus: function (doNotGetCellTypeFocus) {
	            var eventHandler = this._eventHandler;
	            if (eventHandler) {
	                eventHandler._setFocus(doNotGetCellTypeFocus);
	            }
	        },
	        _getHost: function () {
	            var self = this, host;
	            var workbook = self.parent;
	            host = workbook && workbook._host;
	            if (!host) {
	                var sheetCanvas = self._canvas;
	                host = sheetCanvas && sheetCanvas.parentElement;
	            }
	            return host;
	        },
	        _initializeActiveCell: function () {
	            var self = this;
	            var row = 0, col = 0, rowCount = 1, colCount = 1;
	            self._activeRowIndex = row;
	            self._activeColIndex = col;
	            self._activeRowCount = rowCount;
	            self._activeColCount = colCount;
	            self._leadingCellRow = row;
	            self._leadingCellCol = col;
	        },
	
	        _getZoomRowHeight: function (row, sheetArea, keepOriginalValue) {
	            var self = this, height = self.getRowHeight(row, sheetArea), zoomFactor = self.zoom();
	            if (zoomFactor !== 1) {
	                height *= zoomFactor;
	            }
	            return keepOriginalValue ? height : Math_floor(height);
	        },
	        _getZoomColumnWidth: function (col, sheetArea, keepOriginalValue) {
	            var self = this, width = self.getColumnWidth(col, sheetArea), zoomFactor = self.zoom();
	            if (zoomFactor !== 1) {
	                width *= zoomFactor;
	            }
	            return keepOriginalValue ? width : Math_floor(width);
	        },
	
	        _createLayout: function () {
	            var self = this;
	            var sheetBounds = self._getBounds();
	            var options = self.options, offsetLeft = options.sheetAreaOffset.left, offsetTop = options.sheetAreaOffset.top;
	
	            var bounds = new Rect(sheetBounds.x + offsetLeft, sheetBounds.y + offsetTop,
	                Math_max(0, sheetBounds.width - offsetLeft), Math_max(0, sheetBounds.height - offsetTop));
	            var totalWidth = bounds.width;
	            var totalHeight = bounds.height;
	            var layout = {
	                x: bounds.x,
	                y: bounds.y,
	                width: bounds.width,
	                height: bounds.height,
	                _rowHeaderWidth: 0,
	                _colHeaderHeight: 0,
	                _frozenWidth: 0,
	                _frozenHeight: 0,
	                _frozenTrailingWidth: 0,
	                _frozenTrailingHeight: 0,
	                _footerHeight: 0,
	                _footerWidth: 0,
	                _footerX: 0,
	                _footerY: 0,
	                _frozenX: 0,
	                _frozenY: 0,
	                _frozenTrailingX: 0,
	                _frozenTrailingY: 0,
	                _viewportX: 0,
	                _viewportY: 0,
	                _viewportHeight: 0,
	                _viewportWidth: 0,
	                _headerX: 0,
	                _headerY: 0,
	                _headerCornerRect: function () {
	                    var owner = this;
	                    return new Rect(owner.x, owner.y, owner._rowHeaderWidth, owner._colHeaderHeight);
	                },
	                _colHeaderRect: function (colViewportIndex) {
	                    var owner = this;
	                    if (colViewportIndex === 0) {
	                        return new Rect(owner._frozenX, owner.y, owner._frozenWidth, owner._colHeaderHeight);
	                    } else if (colViewportIndex === 1) {
	                        return new Rect(owner._viewportX, owner.y, owner._viewportWidth, owner._colHeaderHeight);
	                    } else if (colViewportIndex === 2) {
	                        return new Rect(owner._frozenTrailingX, owner.y, owner._frozenTrailingWidth, owner._colHeaderHeight);
	                    }
	                    return keyword_null;
	                },
	                _rowHeaderRect: function (rowViewportIndex) {
	                    var owner = this;
	                    if (rowViewportIndex === 0) {
	                        return new Rect(owner.x, owner._frozenY, owner._rowHeaderWidth, owner._frozenHeight);
	                    } else if (rowViewportIndex === 1) {
	                        return new Rect(owner.x, owner._viewportY, owner._rowHeaderWidth, owner._viewportHeight);
	                    } else if (rowViewportIndex === 2) {
	                        return new Rect(owner.x, owner._frozenTrailingY, owner._rowHeaderWidth, owner._frozenTrailingHeight);
	                    }
	                    return keyword_null;
	                },
	                _viewportRect: function (rowViewportIndex, colViewportIndex) {
	                    var owner = this;
	                    if (rowViewportIndex === 0) {
	                        if (colViewportIndex === 0) {
	                            return new Rect(owner._frozenX, owner._frozenY, owner._frozenWidth, owner._frozenHeight);
	                        } else if (colViewportIndex === 1) {
	                            return new Rect(owner._viewportX, owner._frozenY, owner._viewportWidth, owner._frozenHeight);
	                        } else if (colViewportIndex === 2) {
	                            return new Rect(owner._frozenTrailingX, owner._frozenY, owner._frozenTrailingWidth, owner._frozenHeight);
	                        }
	                    } else if (rowViewportIndex === 1) {
	                        if (colViewportIndex === 0) {
	                            return new Rect(owner._frozenX, owner._viewportY, owner._frozenWidth, owner._viewportHeight);
	                        } else if (colViewportIndex === 1) {
	                            return new Rect(owner._viewportX, owner._viewportY, owner._viewportWidth, owner._viewportHeight);
	                        } else if (colViewportIndex === 2) {
	                            return new Rect(owner._frozenTrailingX, owner._viewportY, owner._frozenTrailingWidth, owner._viewportHeight);
	                        }
	                    } else if (rowViewportIndex === 2) {
	                        if (colViewportIndex === 0) {
	                            return new Rect(owner._frozenX, owner._frozenTrailingY, owner._frozenWidth, owner._frozenTrailingHeight);
	                        } else if (colViewportIndex === 1) {
	                            return new Rect(owner._viewportX, owner._frozenTrailingY, owner._viewportWidth, owner._frozenTrailingHeight);
	                        } else if (colViewportIndex === 2) {
	                            return new Rect(owner._frozenTrailingX, owner._frozenTrailingY, owner._frozenTrailingWidth, owner._frozenTrailingHeight);
	                        }
	                    }
	                    return keyword_null;
	                }
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	            };
	            if (self._getOutlineLayout) {
	                var groupLayout = self._getOutlineLayout(), outlineBorder = 0;
	                if(groupLayout.width > 0) {
	                    layout.x += groupLayout.width + outlineBorder;
	                    totalWidth -= groupLayout.width + outlineBorder;
	                }
	                if(groupLayout.height > 0) {
	                    layout.y += groupLayout.height + outlineBorder;
	                    totalHeight -= groupLayout.height + outlineBorder;
	                }
	            }
	            var r, rc, c, cc;
	            if (options.rowHeaderVisible) {
	                cc = self.getColumnCount(2 );
	                for (c = 0; c < cc; c++) {
	                    layout._rowHeaderWidth += self._getZoomColumnWidth(c, 2 );
	                }
	            }
	            if (options.colHeaderVisible) {
	                rc = self.getRowCount(1 );
	                for (r = 0; r < rc; r++) {
	                    layout._colHeaderHeight += self._getZoomRowHeight(r, 1 );
	                }
	            }
	            var frozenColCount = getFrozenColumnCount(self);
	            if (frozenColCount > 0) {
	                cc = getColumnCount(self);
	                for (c = 0; c < frozenColCount && c < cc; c++) {
	                    if (self.getColumnVisible(c)) {
	                        layout._frozenWidth += self._getZoomColumnWidth(c);
	                    }
	                }
	            }
	            var frozenRowCount = getFrozenRowCount(self);
	            if (frozenRowCount > 0) {
	                rc = getRowCount(self);
	                for (r = 0; r < frozenRowCount && r < rc; r++) {
	                    if (self.getRowVisible(r)) {
	                        layout._frozenHeight += self._getZoomRowHeight(r);
	                    }
	                }
	            }
	            var frozenTrailingColCount = getFrozenTrailingColumnCount(self);
	            if (frozenTrailingColCount > 0) {
	                cc = getColumnCount(self);
	                for (c = Math_max(frozenColCount, cc - frozenTrailingColCount); c < cc; c++) {
	                    layout._frozenTrailingWidth += self._getZoomColumnWidth(c);
	                }
	            }
	            var frozenTrailingRowCount = getFrozenTrailingRowCount(self);
	            if (frozenTrailingRowCount > 0) {
	                rc = getRowCount(self);
	                for (r = Math_max(frozenRowCount, rc - frozenTrailingRowCount); r < rc; r++) {
	                    layout._frozenTrailingHeight += self._getZoomRowHeight(r);
	                }
	            }
	            totalWidth -= layout._rowHeaderWidth;
	            totalHeight -= layout._colHeaderHeight;
	            totalWidth -= layout._frozenWidth;
	            totalHeight -= layout._frozenHeight;
	            totalWidth -= layout._frozenTrailingWidth;
	            totalHeight -= layout._frozenTrailingHeight;
	            totalHeight -= layout._footerHeight;
	            layout._viewportWidth = Math_max(0, totalWidth);
	            layout._viewportHeight = Math_max(0, totalHeight);
	            layout._headerX = layout.x;
	            layout._headerY = layout.y;
	            layout._frozenX = layout._headerX + layout._rowHeaderWidth;
	            layout._frozenY = layout._headerY + layout._colHeaderHeight;
	            layout._viewportX = layout._frozenX + layout._frozenWidth;
	            layout._viewportY = layout._frozenY + layout._frozenHeight;
	            layout._frozenTrailingX = layout._viewportX + layout._viewportWidth;
	            layout._frozenTrailingY = layout._viewportY + layout._viewportHeight;
	            layout._footerX = layout._headerX;
	            layout._footerY = layout.y + layout.height - layout._footerHeight;
	            return layout;
	        },
	        _getSheetLayout: function () {
	            var self = this;
	            if (!self._layoutModel) {
	                self._layoutModel = self._createLayout();
	            }
	            return self._layoutModel;
	        },
	        _getColumnLayout: function (colViewportIndex, sheetArea) {
	            if (isNullOrUndefined(sheetArea) || sheetArea === 3  || sheetArea === 1 ) {
	                return this._getViewportColumnLayout(colViewportIndex);
	            } else if (sheetArea === 2 ) {
	                return this._getRowHeaderColumnLayout();
	            }
	            return keyword_null;
	        },
	        _getRowHeaderColumnLayout: function () {
	            var self = this;
	            if (!self._colLayoutCache.rowHeader) {
	                self._colLayoutCache.rowHeader = self._createRowHeaderColumnLayout();
	            }
	            return self._colLayoutCache.rowHeader;
	        },
	        _getViewportColumnLayout: function (colViewportIndex) {
	            var self = this;
	            if (!self._colLayoutCache.viewport) {
	                self._colLayoutCache.viewport = {};
	            }
	            if (!self._colLayoutCache.viewport[colViewportIndex]) {
	                self._colLayoutCache.viewport[colViewportIndex] = self._createViewportColumnLayout(colViewportIndex);
	            }
	            return self._colLayoutCache.viewport[colViewportIndex];
	        },
	        _createRowHeaderColumnLayout: function () {
	            var colLayouts = new _LayoutModel();
	            var layout = this._getSheetLayout();
	            var colX = layout._headerX, colWidth;
	            var colCount = this.getColumnCount(2 );
	            for (var col = 0; col < colCount; col++) {
	                colWidth = this._getZoomColumnWidth(col, 2 );
	                colLayouts.push(new _Layout(-1, col, colX, -1, colWidth, -1));
	                colX += colWidth;
	            }
	            return colLayouts;
	        },
	        _createViewportColumnLayout: function (colViewportIndex) {
	            var self = this;
	            var colLayouts = new _LayoutModel();
	            var layout = self._getSheetLayout();
	            var colCount = getColumnCount(self), col, colX, colWidth, cachePool = self._cachePool;
	            var frozenColCount = getFrozenColumnCount(self);
	            var frozenTrailingColCount = getFrozenTrailingColumnCount(self);
	            if (colViewportIndex === 0) {
	                colX = layout._frozenX;
	                colCount = Math_min(frozenColCount, colCount);
	                for (col = 0; col < colCount; col++) {
	                    colWidth = cachePool._getZoomColWidth(col);
	                    colLayouts.push(new _Layout(-1, col, colX, -1, colWidth, -1));
	                    colX += colWidth;
	                }
	            } else if (colViewportIndex === 1) {
	                colX = layout._viewportX;
	                colCount = colCount - frozenTrailingColCount;
	                var viewportWidth = layout._viewportWidth;
	                var leftCol = Math_max(frozenColCount, self._scrollLeftCol);
	                for (col = leftCol; (viewportWidth > 0 && col < colCount); col++) {
	                    colWidth = cachePool._getZoomColWidth(col);
	                    colLayouts.push(new _Layout(-1, col, colX, -1, colWidth, -1));
	                    colX += colWidth;
	                    viewportWidth -= colWidth;
	                }
	            } else if (colViewportIndex === 2) {
	                colX = layout._frozenTrailingX;
	                for (col = Math_max(frozenColCount, colCount - frozenTrailingColCount); col < colCount; col++) {
	                    colWidth = cachePool._getZoomColWidth(col);
	                    colLayouts.push(new _Layout(-1, col, colX, -1, colWidth, -1));
	                    colX += colWidth;
	                }
	            }
	            return colLayouts;
	        },
	        _getRowLayout: function (rowViewportIndex, sheetArea) {
	            if (isNullOrUndefined(sheetArea) || sheetArea === 3  || sheetArea === 2 ) {
	                return this._getViewportRowLayout(rowViewportIndex);
	            } else if (sheetArea === 1 ) {
	                return this._getColumnHeaderRowLayout();
	            }
	           
	           
	           
	            return keyword_null;
	        },
	        _getAllRowLayout: function (sheetArea) {
	            var rowLayout = new _LayoutModel();
	            for (var index = 0; index < 3; index++) {
	                var layout = this._getRowLayout(index, sheetArea);
	                if (layout && layout.length > 0) {
	                    rowLayout = ($.merge(rowLayout, layout));
	                }
	            }
	            return rowLayout;
	        },
	        _getAllColumnLayout: function (sheetArea) {
	            var columnLayout = new _LayoutModel();
	            for (var index = 0; index < 3; index++) {
	                var layout = this._getColumnLayout(index, sheetArea);
	                if (layout && layout.length > 0) {
	                    columnLayout = ($.merge(columnLayout, layout));
	                }
	            }
	            return columnLayout;
	        },
	        _getColumnHeaderRowLayout: function () {
	            var self = this;
	            if (!self._rowLayoutCache.colHeader) {
	                self._rowLayoutCache.colHeader = self._createColumnHeaderRowLayout();
	            }
	            return self._rowLayoutCache.colHeader;
	        },
	        _getViewportRowLayout: function (viewportIndex) {
	            var self = this;
	            if (!self._rowLayoutCache.viewport) {
	                self._rowLayoutCache.viewport = {};
	            }
	            if (!self._rowLayoutCache.viewport[viewportIndex]) {
	                self._rowLayoutCache.viewport[viewportIndex] = self._createViewportRowLayout(viewportIndex);
	            }
	            return self._rowLayoutCache.viewport[viewportIndex];
	        },
	        _createColumnHeaderRowLayout: function () {
	            var rowLayouts = new _LayoutModel();
	            var layout = this._getSheetLayout();
	            var rowY = layout._headerY, rowHeight;
	            var rowCount = this.getRowCount(1 );
	            for (var row = 0; row < rowCount; row++) {
	                rowHeight = this._getZoomRowHeight(row, 1 );
	                rowLayouts.push(new _Layout(row, -1, -1, rowY, -1, rowHeight));
	                rowY += rowHeight;
	            }
	            return rowLayouts;
	        },
	        _createViewportRowLayout: function (rowViewportIndex) {
	            var self = this;
	            var rowLayouts = new _LayoutModel();
	            var frozenRowCount = getFrozenRowCount(self);
	            var frozenTrailingRowCount = getFrozenTrailingRowCount(self);
	            var layout = self._getSheetLayout();
	            var rowCount = getRowCount(self), row, rowY, rowHeight, cachePool = self._cachePool;
	            if (rowViewportIndex === 0) {
	                rowY = layout._frozenY;
	                rowCount = Math_min(frozenRowCount, rowCount);
	                for (row = 0; row < rowCount; row++) {
	                    rowHeight = cachePool._getZoomRowHeight(row);
	                    rowLayouts.push(new _Layout(row, -1, -1, rowY, -1, rowHeight));
	                    rowY += rowHeight;
	                }
	            } else if (rowViewportIndex === 1) {
	                rowY = layout._viewportY;
	                rowCount = rowCount - frozenTrailingRowCount;
	                var viewportHeight = layout._viewportHeight;
	                var topRow = Math_max(frozenRowCount, self._scrollTopRow);
	                for (row = topRow; (viewportHeight > 0 && row < rowCount); row++) {
	                    rowHeight = cachePool._getZoomRowHeight(row);
	                    rowLayouts.push(new _Layout(row, -1, -1, rowY, -1, rowHeight));
	                    rowY += rowHeight;
	                    viewportHeight -= rowHeight;
	                }
	            } else if (rowViewportIndex === 2) {
	                rowY = layout._frozenTrailingY;
	                for (row = Math_max(frozenRowCount, rowCount - frozenTrailingRowCount); row < rowCount; row++) {
	                    rowHeight = cachePool._getZoomRowHeight(row);
	                    rowLayouts.push(new _Layout(row, -1, -1, rowY, -1, rowHeight));
	                    rowY += rowHeight;
	                }
	            }
	            return rowLayouts;
	        },
	        _getCellLayout: function (rowViewportIndex, colViewportIndex, sheetArea) {
	            var self = this;
	            var rowCount = self.getRowCount(sheetArea);
	            var colCount = self.getColumnCount(sheetArea);
	            var rowLayoutModel = self._getRowLayout(rowViewportIndex, sheetArea);
	            var colLayoutModel = self._getColumnLayout(colViewportIndex, sheetArea);
	            var cellLayoutModel = new _LayoutModel();
	            if (rowLayoutModel && rowLayoutModel.length > 0 && colLayoutModel && colLayoutModel.length > 0) {
	                var topRow = rowLayoutModel[0].row;
	                var leftCol = colLayoutModel[0].col;
	                var bottomRow = rowLayoutModel[rowLayoutModel.length - 1].row;
	                var rightCol = colLayoutModel[colLayoutModel.length - 1].col;
	               
	                var spans = self.getSpans(createRange(topRow, leftCol, bottomRow - topRow + 1, rightCol - leftCol + 1), sheetArea);
	                if (spans && spans.length > 0) {
	                    self._addCellLayout(spans, topRow, leftCol, bottomRow, rightCol, cellLayoutModel, rowCount, colCount, sheetArea, rowLayoutModel, colLayoutModel);
	                }
	            }
	            return cellLayoutModel;
	        },
	        _getCellLayoutByCell: function (rowViewportIndex, colViewportIndex, sheetArea, row, col) {
	            var self = this;
	            var rowCount = self.getRowCount(sheetArea);
	            var colCount = self.getColumnCount(sheetArea);
	            var rowLayoutModel = self._getRowLayout(rowViewportIndex, sheetArea);
	            var colLayoutModel = self._getColumnLayout(colViewportIndex, sheetArea);
	            var cellLayoutModel = new _LayoutModel();
	            if (rowLayoutModel && rowLayoutModel.length > 0 && colLayoutModel && colLayoutModel.length > 0) {
	                var topRow = rowLayoutModel[0].row;
	                var leftCol = colLayoutModel[0].col;
	               
	                var spanCell = self.getSpan(row, col, sheetArea);
	                if (spanCell) {
	                    var spans = [];
	                    spans.push(spanCell);
	                    self._addCellLayout(spans, topRow, leftCol, spanCell.row + spanCell.rowCount, spanCell.col + spanCell.colCount,
	                        cellLayoutModel, rowCount, colCount, sheetArea, rowLayoutModel, colLayoutModel);
	                }
	                if (cellLayoutModel.length > 0) {
	                    return cellLayoutModel[0];
	                }
	                return keyword_null;
	            }
	            return keyword_null;
	        },
	        _addCellLayout: function (spans, topRow, leftCol, bottomRow, rightCol, cellLayoutModel, rowCount, colCount, sheetArea, rowLayoutModel, colLayoutModel) {
	            var spanCount = spans.length;
	            if (spanCount <= 0) {
	                return;
	            }
	            var self = this, i;
	            var lastRow = bottomRow + 1;
	            var lastCol = rightCol + 1;
	            var heights = [];
	            var widths = [];
	            var xs = [];
	            var ys = [];
	            var x = 0;
	            var y = 0;
	            for (i = topRow - 1; i >= 0; i--) {
	                heights[i] = self._getZoomRowHeight(i, sheetArea);
	                y -= heights[i];
	                ys[i] = y;
	            }
	            y = 0;
	            for (i = topRow; i < lastRow; i++) {
	                ys[i] = y;
	                heights[i] = self._getZoomRowHeight(i, sheetArea);
	                y += heights[i];
	            }
	            for (i = leftCol - 1; i >= 0; i--) {
	                widths[i] = self._getZoomColumnWidth(i, sheetArea);
	                x -= widths[i];
	                xs[i] = x;
	            }
	            x = 0;
	            for (i = leftCol; i < lastCol; i++) {
	                xs[i] = x;
	                widths[i] = self._getZoomColumnWidth(i, sheetArea);
	                x += widths[i];
	            }
	            for (var k = 0; k < spanCount; k++) {
	                var cellSpan = spans[k];
	                if (cellSpan.intersect(topRow, leftCol, bottomRow - topRow + 1, rightCol - leftCol + 1)) {
	                    var lastRow1 = cellSpan.row + cellSpan.rowCount;
	                    if (lastRow1 > lastRow) {
	                        for (i = lastRow; i < lastRow1; i++) {
	                            heights.push(self._getZoomRowHeight(i, sheetArea));
	                            ys.push(ys[i - 1] + heights[i]);
	                        }
	                        lastRow = lastRow1;
	                    }
	                    var lastCol1 = cellSpan.col + cellSpan.colCount;
	                    if (lastCol1 > lastCol) {
	                        for (i = lastCol; i < lastCol1; i++) {
	                            widths.push(self._getZoomColumnWidth(i, sheetArea));
	                            xs.push(xs[i - 1] + widths[i]);
	                        }
	                        lastCol = lastCol1;
	                    }
	                    var spanX = xs[cellSpan.col], spanY = ys[cellSpan.row], width = 0, height = 0, row, col;
	                    for (col = cellSpan.col; col < cellSpan.col + cellSpan.colCount && col < colCount; col++) {
	                        width += widths[col];
	                    }
	                    for (row = cellSpan.row; row < cellSpan.row + cellSpan.rowCount && row < rowCount; row++) {
	                        height += heights[row];
	                    }
	                    cellLayoutModel.push(new _Layout(cellSpan.row, cellSpan.col, colLayoutModel[0].x + spanX, rowLayoutModel[0].y + spanY, width, height, cellSpan.rowCount, cellSpan.colCount));
	                }
	            }
	        },
	        _syncHScrollbarPosition: function () {
	            var self = this, workbook = self.parent;
	            var newLefCol = self._getScrollableColumn(self._scrollLeftCol);
	            if (newLefCol !== -1 && newLefCol !== self._scrollLeftCol) {
	                self._scrollLeftCol = newLefCol;
	            }
	            if (workbook && workbook._scrollbarH) {
	                workbook._scrollbarH.value(self._getVisibleColIndex(self._scrollLeftCol));
	            }
	        },
	        _syncVScrollbarPosition: function () {
	            var self = this, workbook = self.parent;
	            var newTopRow = self._getScrollableRow(self._scrollTopRow);
	            if (newTopRow !== -1 && newTopRow !== self._scrollTopRow) {
	                self._scrollTopRow = newTopRow;
	            }
	            if (workbook && workbook._scrollbarV) {
	                workbook._scrollbarV.value(self._getVisibleRowIndex(self._scrollTopRow));
	            }
	        },
	        _syncHScrollbarSize: function () {
	            var self = this, sp = self.parent;
	            if (sp && sp._resizeHScrollBar) {
	                if (sp.options.scrollIgnoreHidden) {
	                    self._columnIndexInfo = self._getColumnIndexInfo(true);
	                }
	                sp._resizeHScrollBar();
	            }
	        },
	        _syncVScrollbarSize: function () {
	            var self = this, sp = self.parent;
	            if (sp && sp._resizeVScrollBar) {
	                if (sp.options.scrollIgnoreHidden) {
	                    self._rowIndexInfo = self._getRowIndexInfo(true);
	                }
	                sp._resizeVScrollBar();
	            }
	        },
	        _getFirstPageLeftColumn: function () {
	            var self = this;
	            var firstLeftCol = 0;
	            var frozenColCount = getFrozenColumnCount(self);
	            if (frozenColCount > 0) {
	                firstLeftCol = self._getNextVisualColumn(frozenColCount - 1);
	            } else {
	                firstLeftCol = self._getFirstVisualColumn();
	            }
	            return firstLeftCol;
	        },
	        _getFirstPageTopRow: function () {
	            var self = this;
	            var firsTopRow = 0;
	            var frozenRowCount = getFrozenRowCount(self);
	            if (frozenRowCount > 0) {
	                firsTopRow = self._getNextVisualRow(frozenRowCount - 1);
	            } else {
	                firsTopRow = self._getFirstVisualRow();
	            }
	            return firsTopRow;
	        },
	        _getFirstVisualColumn: function (sheetArea) {
	            return this._getNextVisualColumn(-1, sheetArea);
	        },
	        _getNextVisualColumn: function (col, sheetArea) {
	            var self = this;
	            var endCol = self.getColumnCount(sheetArea) - 1 - getFrozenTrailingColumnCount(self);
	            while (col < endCol) {
	                col++;
	                if (self.getColumnVisible(col, sheetArea) && self._getZoomColumnWidth(col, sheetArea) > 0) {
	                    return col;
	                }
	            }
	            return keyword_null;
	        },
	        _getPrevVisualColumn: function (col, sheetArea) {
	            var self = this, frozenColCount = getFrozenColumnCount(self);
	            while (col > frozenColCount) {
	                col--;
	                if (self.getColumnVisible(col, sheetArea) && self._getZoomColumnWidth(col, sheetArea) > 0) {
	                    return col;
	                }
	            }
	            return keyword_null;
	        },
	        _getFirstVisualRow: function (sheetArea) {
	            return this._getNextVisualRow(-1, sheetArea);
	        },
	        _getNextVisualRow: function (row, sheetArea, ignoreFrozenTrailingRow) {
	            var self = this;
	            var rowCount = self.getRowCount(sheetArea);
	            var endRow = ignoreFrozenTrailingRow ? rowCount - 1 : rowCount - 1 - getFrozenTrailingRowCount(self);
	            while (row < endRow) {
	                row++;
	                if (self.getRowVisible(row, sheetArea) && self._getZoomRowHeight(row, sheetArea) > 0) {
	                    return row;
	                }
	            }
	            return keyword_null;
	        },
	        _getPrevVisualRow: function (row, sheetArea, ignoreFrozenRow) {
	            var self = this, minRow = ignoreFrozenRow ? 0 : getFrozenRowCount(self);
	            while (row > minRow) {
	                row--;
	                if (self.getRowVisible(row, sheetArea) && self._getZoomRowHeight(row, sheetArea) > 0) {
	                    return row;
	                }
	            }
	            return keyword_null;
	        },
	
	        _invalidateVScrollbar: function () {
	            var sp = this.parent;
	            if (sp && sp.options.scrollIgnoreHidden) {
	                this._needSyncVScrollbarSize = true;
	            }
	            this._syncVScrollbarPosition();
	        },
	        _invalidateHScrollbar: function () {
	            var sp = this.parent;
	            if (sp && sp.options.scrollIgnoreHidden) {
	                this._needSyncHScrollbarSize = true;
	            }
	            this._syncHScrollbarPosition();
	        },
	        _getVisibleRowIndex: function (originalIndex) {
	            var sp = this.parent;
	            if (sp && sp.options.scrollIgnoreHidden) {
	                var visibleRowIndexInfo = this._getRowIndexInfo().visibleIndex;
	                return visibleRowIndexInfo[originalIndex];
	            }
	            return originalIndex;
	        },
	        _getOriginalRowIndex: function (visibleIndex) {
	            var sp = this.parent;
	            if (sp && sp.options.scrollIgnoreHidden) {
	                var originalRowIndexInfo = this._getRowIndexInfo().originalIndex;
	                return originalRowIndexInfo[visibleIndex];
	            }
	            return visibleIndex;
	        },
	        _getVisibleColIndex: function (originalIndex) {
	            var sp = this.parent;
	            if (sp && sp.options.scrollIgnoreHidden) {
	                var visibleColIndexInfo = this._getColumnIndexInfo().visibleIndex;
	                return visibleColIndexInfo[originalIndex];
	            }
	            return originalIndex;
	        },
	        _getOriginalColIndex: function (visibleIndex) {
	            var sp = this.parent;
	            if (sp && sp.options.scrollIgnoreHidden) {
	                var originalColIndexInfo = this._getColumnIndexInfo().originalIndex;
	                return originalColIndexInfo[visibleIndex];
	            }
	            return visibleIndex;
	        },
	       
	       
	       
	       
	        _getColumnIndexInfo: function (isUpdate) {
	            var self = this;
	            if (self._columnIndexInfo && !isUpdate) {
	                return self._columnIndexInfo;
	            }
	            var frozenColCount = getFrozenColumnCount(self);
	            var columnCount = getColumnCount(self) - getFrozenTrailingColumnCount(self) - frozenColCount,
	                startColumn = frozenColCount, lastColumn = startColumn + columnCount - 1, cachePool = self._cachePool,
	                columnIndexInfo = {
	                    visibleIndex: {},
	                    originalIndex: {}
	                };
	            if (lastColumn - startColumn + 1 <= 0) {
	                return columnIndexInfo;
	            }
	            var index = 0;
	            for (var col = startColumn; col <= lastColumn; col++) {
	                columnIndexInfo.originalIndex[index] = col;
	                columnIndexInfo.visibleIndex[col] = index;
	                if (cachePool._getZoomColWidth(col) > 0) {
	                    index++;
	                }
	            }
	            col--;
	            index--;
	            while (cachePool._getZoomColWidth(col) <= 0 && col >= startColumn) {
	                columnIndexInfo.originalIndex[index] = col;
	                columnIndexInfo.visibleIndex[col] = index;
	                col--;
	            }
	            return columnIndexInfo;
	        },
	        _getRowIndexInfo: function (isUpdate) {
	            var self = this;
	            if (self._rowIndexInfo && !isUpdate) {
	                return self._rowIndexInfo;
	            }
	            var frozenRowCount = getFrozenRowCount(self);
	            var rowCount = getRowCount(self) - getFrozenTrailingRowCount(self) - frozenRowCount,
	                startRow = frozenRowCount, lastRow = startRow + rowCount - 1, cachePool = self._cachePool,
	                rowIndexInfo = {
	                    visibleIndex: {},
	                    originalIndex: {}
	                };
	            if (lastRow - startRow + 1 <= 0) {
	                return rowIndexInfo;
	            }
	            var index = 0;
	            for (var row = startRow; row <= lastRow; row++) {
	                rowIndexInfo.originalIndex[index] = row;
	                rowIndexInfo.visibleIndex[row] = index;
	                if (cachePool._getZoomRowHeight(row) > 0) {
	                    index++;
	                }
	            }
	            row--;
	            index--;
	            while (cachePool._getZoomRowHeight(row) <= 0 && row >= startRow) {
	                rowIndexInfo.originalIndex[index] = row;
	                rowIndexInfo.visibleIndex[row] = index;
	                row--;
	            }
	            return rowIndexInfo;
	        },
	        _getScrollableRow: function (startRow, previous) {
	            var self = this, newTopRow;
	            var min = getFrozenRowCount(self);
	            var max = getRowCount(self) - getFrozenTrailingRowCount(self) - 1;
	            if (previous) {
	                if (startRow > max) {
	                    startRow = max;
	                }
	                newTopRow = self._getPrevVisualRow(startRow + 1);
	                if (newTopRow !== keyword_null && newTopRow >= min) {
	                    return newTopRow;
	                }
	            } else {
	                if (startRow < min) {
	                    startRow = min;
	                }
	                newTopRow = self._getNextVisualRow(startRow - 1);
	                if (newTopRow !== keyword_null && newTopRow <= max) {
	                    return newTopRow;
	                }
	            }
	            return -1;
	        },
	        _getScrollableColumn: function (startCol, previous) {
	            var self = this, newLeftCol;
	            var min = getFrozenColumnCount(self);
	            var max = getColumnCount(self) - getFrozenTrailingColumnCount(self) - 1;
	            if (previous) {
	                if (startCol > max) {
	                    startCol = max;
	                }
	                newLeftCol = self._getPrevVisualColumn(startCol + 1);
	                if (newLeftCol !== keyword_null && newLeftCol >= min) {
	                    return newLeftCol;
	                }
	            } else {
	                if (startCol < min) {
	                    startCol = min;
	                }
	                newLeftCol = self._getNextVisualColumn(startCol - 1);
	                if (newLeftCol !== keyword_null && newLeftCol <= max) {
	                    return newLeftCol;
	                }
	            }
	            return -1;
	        },
	        _getTopRowWhenLastRowShowComplete: function (viewportHeight, startRow, endRow) {
	            if (endRow < startRow) {
	                return endRow;
	            }
	            var totalHeight = 0, cachePool = this._cachePool;
	            for (var row = endRow, topRow = endRow; row >= startRow; row--) {
	                var rowHeight = cachePool._getZoomRowHeight(row);
	                if (rowHeight <= 0) {
	                    continue;
	                }
	                totalHeight += rowHeight;
	                if (totalHeight > viewportHeight) {
	                    break;
	                }
	                topRow = row;
	            }
	            return topRow;
	        },
	        _getLeftColWhenLastColShowComplete: function (viewportWidth, startColumn, endColumn) {
	            if (endColumn < startColumn) {
	                return endColumn;
	            }
	            var totalWidth = 0, cachePool = this._cachePool;
	            for (var col = endColumn, leftColumn = endColumn; col >= startColumn; col--) {
	                var columnWidth = cachePool._getZoomColWidth(col);
	                if (columnWidth <= 0) {
	                    continue;
	                }
	                totalWidth += columnWidth;
	                if (totalWidth > viewportWidth) {
	                    break;
	                }
	                leftColumn = col;
	            }
	            return leftColumn;
	        },
	        _getPageValueH: function () {
	            var layout = this._getSheetLayout(), viewportColLayout = this._getColumnLayout(1, 3 ),
	                totalWidth = 0, count = 0;
	            if (viewportColLayout) {
	                for (var i = 0; i < viewportColLayout.length; i++) {
	                    var columnWidth = viewportColLayout[i].width;
	                    totalWidth += columnWidth;
	                    if (columnWidth > 0) {
	                        count++;
	                    }
	                }
	            }
	            count = count === 0 ? 1 : count;
	            var average = totalWidth / count;
	            if (average === 0) {
	                return 1;
	            }
	            return Math_floor(layout._viewportWidth / average);
	        },
	        _getPageValueV: function () {
	            var layout = this._getSheetLayout(), viewportRowLayout = this._getRowLayout(1, 3 ),
	                totalHeight = 0, count = 0;
	            if (viewportRowLayout) {
	                for (var i = 0; i < viewportRowLayout.length; i++) {
	                    var rowHeight = viewportRowLayout[i].height;
	                    totalHeight += rowHeight;
	                    if (rowHeight > 0) {
	                        count++;
	                    }
	                }
	            }
	            count = count === 0 ? 1 : count;
	            var average = totalHeight / count;
	            if (average === 0) {
	                return 1;
	            }
	            return Math_floor(layout._viewportHeight / average);
	        },
	        _getLastVisualScrollRow: function (sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var self = this, sp = self.parent, startRow = getFrozenRowCount(self);
	            var frozenTrailingRowCount = getFrozenTrailingRowCount(self);
	            if (sp && sp.options.scrollbarMaxAlign) {
	                var layout = self._getSheetLayout();
	                return self._getTopRowWhenLastRowShowComplete(layout._viewportHeight, startRow, getRowCount(self) - frozenTrailingRowCount - 1);
	            }
	            var rowCount = self.getRowCount(sheetArea);
	            if (sheetArea === 3  || sheetArea === 2 ) {
	                rowCount = rowCount - frozenTrailingRowCount;
	            }
	            var lastScrollRow = self._getPrevVisualRow(rowCount, sheetArea);
	            if (lastScrollRow === keyword_null) {
	                lastScrollRow = startRow;
	            }
	            return lastScrollRow;
	        },
	        _getLastVisualScrollColumn: function (sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var self = this, sp = self.parent, startColumn = getFrozenColumnCount(self);
	            if (sp && sp.options.scrollbarMaxAlign) {
	                var layout = self._getSheetLayout();
	                return self._getLeftColWhenLastColShowComplete(layout._viewportWidth, startColumn, getColumnCount(self) - getFrozenTrailingColumnCount(self) - 1);
	            }
	            var colCount = self.getColumnCount(sheetArea);
	            if (sheetArea === 3  || sheetArea === 1 ) {
	                colCount = colCount - getFrozenTrailingColumnCount(self);
	            }
	            var lastScrollColumn = self._getPrevVisualColumn(colCount, sheetArea);
	            if (lastScrollColumn === keyword_null) {
	                lastScrollColumn = startColumn;
	            }
	            return lastScrollColumn;
	        },
	        _getLastNonNullRowAndCol: function () {
	            var self = this, lastNonNullRow = getFrozenRowCount(self), lastNonNullCol = getFrozenColumnCount(self),
	                maxRowIndex = getRowCount(self) - getFrozenTrailingRowCount(self) - 1,
	                maxColIndex = getColumnCount(self) - getFrozenTrailingColumnCount(self) - 1;
	
	            var modelManager = self._modelManager;
	            var viewportLastNonNullRow = modelManager.getLastNonNullRow(3 );
	            if (viewportLastNonNullRow > lastNonNullRow) {
	                lastNonNullRow = viewportLastNonNullRow;
	            }
	            var viewportLastNonNullColumn = modelManager.getLastNonNullCol(3 );
	            if (viewportLastNonNullColumn > lastNonNullCol) {
	                lastNonNullCol = viewportLastNonNullColumn;
	            }
	            var rowHeaderLastNonNullRow = modelManager.getLastNonNullRow(2 );
	            if (rowHeaderLastNonNullRow > lastNonNullRow) {
	                lastNonNullRow = rowHeaderLastNonNullRow;
	            }
	            var colHeaderLastNonNullColumn = modelManager.getLastNonNullCol(1 );
	            if (colHeaderLastNonNullColumn > lastNonNullCol) {
	                lastNonNullCol = colHeaderLastNonNullColumn;
	            }
	
	            var features = Worksheet._features;
	            if (features) {
	                $_each(features, function (n, f) {
	                    var t = f.lastNonNullRowAndCol;
	                    if (t) {
	                        var r = t.call(self);
	                        lastNonNullRow = Math_max(lastNonNullRow, r.lastNonNullRow);
	                        lastNonNullCol = Math_max(lastNonNullCol, r.lastNonNullCol);
	                    }
	                });
	            }
	
	            if (lastNonNullRow > maxRowIndex) {
	                lastNonNullRow = maxRowIndex;
	            }
	            if (lastNonNullCol > maxColIndex) {
	                lastNonNullCol = maxColIndex;
	            }
	            return {
	                lastNonNullRow: lastNonNullRow,
	                lastNonNullCol: lastNonNullCol
	            };
	        },
	        _setTopRow: function (row) {
	            var self = this;
	            var oldTopRow = self._scrollTopRow;
	            if (row >= self._getFirstPageTopRow() && row <= self._getLastVisualScrollRow() && row !== oldTopRow) {
	                var sp = self.parent;
	                if (sp) {
	                    sp._scrollService._vScrollTo(row);
	                    self._syncVScrollbarPosition();
	                }
	                if (sp && !sp.options.scrollbarShowMax) {
	                    self._syncVScrollbarSize();
	                }
	            }
	        },
	        _setLeftColumn: function (col) {
	            var self = this;
	            var oldLeftCol = self._scrollLeftCol;
	            if (col >= self._getFirstPageLeftColumn() && col <= self._getLastVisualScrollColumn() && col !== oldLeftCol) {
	                var sp = self.parent;
	                if (sp) {
	                    sp._scrollService._hScrollTo(col);
	                    self._syncHScrollbarPosition();
	                }
	                if (sp && !sp.options.scrollbarShowMax) {
	                    self._syncHScrollbarSize();
	                }
	            }
	        },
	
	
	        _getCellTypeHitInfo: function (target, x, y) {
	            var self = this;
	            var r = target.row, c = target.col, sheetArea = target.hitTestType;
	            if (isNullOrUndefined(r) || isNullOrUndefined(c)) {
	                return keyword_null;
	            }
	            var span = self.getSpan(r, c, sheetArea);
	            if (span) {
	                r = span.row;
	                c = span.col;
	            }
	            var cellStyle = self.getActualStyle(r, c, sheetArea);
	            var rowViewportIndex = sheetArea === 1  ? -1 : keyword_undefined,
	                colViewportIndex = sheetArea === 2  ? -1 : keyword_undefined;
	            var cellRect = self.getCellRect(r, c, rowViewportIndex, colViewportIndex);
	            var context = {
	                sheet: self,
	                row: r,
	                col: c,
	                sheetArea: sheetArea
	            };
	            var ct = (cellStyle.cellType || self._getDefaultCellType(sheetArea));
	            return ct._getHitInfoWrapper(x, y, cellStyle, cellRect, context);
	        },
	
	        _disposeUserEvents: function () {
	            this.unbindAll();
	            this._unbindAll();
	        },
	        _isAnyCellInRangeLocked: function (range) {
	            var ar = this._getActualRange(range), row = ar.row, col = ar.col, endRow = row + ar.rowCount,
	                endCol = col + ar.colCount, style;
	            for (var r = row; r < endRow; r++) {
	                for (var c = col; c < endCol; c++) {
	                    var span = this.getSpan(r, c);
	                    var actualRow = span ? span.row : r, actualCol = span ? span.col : c;
	                    style = this.getActualStyle(actualRow, actualCol);
	                    if (style.locked === true) {
	                        return true;
	                    }
	                }
	            }
	            return false;
	        },
	        _isValidRange: function (row, column, rowCount, columnCount, maxRowCount, maxColumnCount) {
	            if (-1 <= row && row < maxRowCount && -1 <= column && column < maxColumnCount) {
	                if (row === -1 && column === -1) {
	                    return true;
	                } else if (row === -1) {
	                    if (columnCount !== 0 && column + columnCount <= maxColumnCount) {
	                        return true;
	                    }
	                } else if (column === -1) {
	                    if (rowCount !== 0 && row + rowCount <= maxRowCount) {
	                        return true;
	                    }
	                } else if (columnCount !== 0 && column + columnCount <= maxColumnCount && rowCount !== 0 && row + rowCount <= maxRowCount) {
	                    return true;
	                }
	            }
	            return false;
	        },
	        _hasPartSpans: function (row, column, rowCount, columnCount) {
	            var self = this;
	            if (row < 0 && column < 0) {
	                return false;
	            }
	            if (row < 0) {
	                var columnHeaderSpanModel = self._modelManager._getSpanModel(1 );
	                if (columnHeaderSpanModel && columnHeaderSpanModel.spans && columnHeaderSpanModel.spans.length > 0) {
	                    return self._modelManager._hasPartSpans(-1, column, -1, columnCount, 1 );
	                }
	            }
	            if (column < 0) {
	                var rowHeaderSpanModel = self._modelManager._getSpanModel(2 );
	                if (rowHeaderSpanModel && rowHeaderSpanModel.spans && rowHeaderSpanModel.spans.length > 0) {
	                    return self._modelManager._hasPartSpans(row, -1, rowCount, -1, 2 );
	                }
	            }
	            var spanModel = self._modelManager._getSpanModel(3 );
	            if (spanModel && spanModel.spans && spanModel.spans.length > 0) {
	                return self._modelManager._hasPartSpans(row, column, rowCount, columnCount, 3 );
	            }
	            return false;
	        },
	       
	        
	        suspendPaint: function () {
	            var self = this;
	            var count = self._layoutSuspended;
	            self._layoutSuspended++;
	            if (count === 0) {
	                Worksheet._callFeatureHandler(self, const_onPaintSuspend, {
	                    suspend: true
	                });
	            }
	        },
	       
	        
	        resumePaint: function () {
	            var self = this;
	            self._layoutSuspended--;
	            if (self._layoutSuspended <= 0) {
	                self._layoutSuspended = 0;
	                Worksheet._callFeatureHandler(self, const_onPaintSuspend, {
	                    suspend: false
	                });
	
	                var parent = self.parent;
	                if (!parent || parent.getActiveSheet() === self) {
	                    self._invalidate();
	                }
	            }
	        },
	       
	        
	        isPaintSuspended: function () {
	            return this._layoutSuspended > 0;
	        },
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	
	        _cellRangeInflate: function (spans, cellRange) {
	            var self = this, spansLength = spans && spans.length;
	            for (var i = 0; i < spansLength; i++) {
	                var cr = spans[i];
	                if (cellRange.intersect(cr.row, cr.col, cr.rowCount, cr.colCount)) {
	                    spans.splice(i--, 1);
	                    return self._cellRangeInflate(spans, cellRange.union(cr));
	                }
	            }
	            return cellRange;
	        },
	        _getClipboardHelper: function () {
	            var self = this, parent = self.parent;
	            if (!self._clipboardHelper) {
	                self._clipboardHelper = parent && parent._clipboardHelper;
	            }
	            return self._clipboardHelper;
	        },
	
	        _getImageLoader: function () {
	            if (!this._imageLoader) {
	                var self = this;
	                self._imageLoader = new _ImageLoader(function () {
	                    if (self._imageLoader) {
	                        self.repaint();
	                    }
	                });
	            }
	            return this._imageLoader;
	        },
	       
	       
	        _commandManager: function () {
	            var self = this, parent = self.parent;
	            if (parent) {
	                return parent.commandManager();
	            }
	        },
	
	        _raiseInvalidOperation: function (invalidType, message) {
	            this._trigger(Events.InvalidOperation, {
	                sheet: this,
	                sheetName: this.name(),
	                invalidType: invalidType,
	                message: message
	            });
	        },
	        _raiseCellChanged: function (propertyName, row, column, sheetArea, oldValue, value) {
	            var args = {
	                sheet: this,
	                sheetName: this.name(),
	                row: row,
	                col: column,
	                sheetArea: sheetArea,
	                propertyName: propertyName,
	                oldValue: oldValue,
	                newValue: value
	            };
	            this._trigger(Events.CellChanged, args);
	            var modelManager = this._modelManager;
	            modelManager._addEventItem('cellChanged', propertyName, row, column, sheetArea, value, oldValue);
	        },
	        _raiseValueChanged: function (row, column, oldValue, newValue) {
	            this._trigger(Events.ValueChanged, {
	                sheet: this,
	                sheetName: this.name(),
	                row: row,
	                col: column,
	                oldValue: oldValue,
	                newValue: newValue
	            });
	        },
	        _raiseColumnChanged: function (col, sheetArea, propertyName, value, oldValue) {
	            var args = {
	                sheet: this,
	                sheetName: this.name(),
	                col: col,
	                sheetArea: sheetArea,
	                propertyName: propertyName,
	                newValue: value,
	                oldValue: oldValue
	            };
	            if (propertyName === 'addColumns' || propertyName === 'deleteColumns') {
	                args.count = value;
	            }
	            this._trigger(Events.ColumnChanged, args);
	            var modelManager = this._modelManager;
	            modelManager._addEventItem('columnChanged', col, sheetArea, propertyName, oldValue, value);
	        },
	        _raiseRowChanged: function (row, sheetArea, propertyName, value, oldValue) {
	            var args = {
	                sheet: this,
	                sheetName: this.name(),
	                row: row,
	                sheetArea: sheetArea,
	                propertyName: propertyName,
	                newValue: value,
	                oldValue: oldValue
	            };
	            if (propertyName === 'addRows' || propertyName === 'deleteRows') {
	                args.count = value;
	            }
	            this._trigger(Events.RowChanged, args);
	            var modelManager = this._modelManager;
	            modelManager._addEventItem('rowChanged', row, sheetArea, propertyName, oldValue, value);
	        },
	        _raiseSelectionChanging: function (oldSelection, newSelection) {
	            if (!this._isDeselecting && this._eventHandler._notEqualSelecions(oldSelection, newSelection)) {
	                this._trigger(Events.SelectionChanging, {
	                    sheet: this,
	                    sheetName: this.name(),
	                    oldSelections: oldSelection,
	                    newSelections: newSelection
	                });
	                return true;
	            }
	            return false;
	        },
	        _raiseSelectionChanged: function (oldSelections) {
	            this._trigger(Events.SelectionChanged, {
	                sheet: this,
	                sheetName: this.name(),
	                oldSelections: oldSelections,
	                newSelections: this.getSelections()
	            });
	        },
	        _raiseRangeDataChanged: function (row, column, rowCount, columnCount, changedCells, action, sheetArea, value) {
	            var args = {
	                sheet: this,
	                sheetName: this.name(),
	                row: row,
	                col: column,
	                rowCount: rowCount,
	                colCount: columnCount,
	                changedCells: changedCells,
	                action: action
	            };
	
	            if (sheetArea) {
	                args.sheetArea = sheetArea;
	            }
	
	            if (value) {
	                args.value = value;
	            }
	            if (changedCells && changedCells.length > 0) {
	                this._trigger(Events.RangeChanged, args);
	                this._trigger(Events.FormulatextboxRangeChanged, args);
	            }
	        },
	        _raiseEditorStatusChanged: function (oldStatus, newStatus) {
	            var args = {
	                sheet: this,
	                sheetName: this.name(),
	                oldStatus: oldStatus,
	                newStatus: newStatus
	            };
	
	            this._trigger(Events.EditorStatusChanged, args);
	        },
	
	        _getElem: function () {
	            if (!this._$elem) {
	                this._$elem = $(createElement('input'));
	            }
	            return this._$elem;
	        },
	       
	        
	        bind: function (type, data, fn) {
	            this._getElem().bind(type + _gcSheet, data, fn);
	        },
	       
	        
	        unbind: function (type, fn) {
	            this._getElem().unbind(type + _gcSheet, fn);
	        },
	        _trigger: function (type, data) {
	           
	            if (this.updateEventsData) {
	                this.updateEventsData(type, data);
	            }
	            if (this._eventSuspended === 0) {
	                this._getElem().trigger(type, data);
	            }
	        },
	       
	        
	        unbindAll: function () {
	            this.unbind(_gcSheet);
	        },
	        _bind: function (type, data, fn) {
	            if (type.indexOf('.') >= 0) {
	                this.bind(type, data, fn);
	            } else {
	                this.bind(type + _gcSheetInternal, data, fn);
	            }
	        },
	        _unbind: function (type, fn) {
	            if (type.indexOf('.') >= 0) {
	                this.unbind(type, fn);
	            } else {
	                this.unbind(type + _gcSheetInternal, fn);
	            }
	        },
	        _unbindAll: function () {
	            this.unbind(_gcSheetInternal);
	        },
	
	        _getBounds: function () {
	            var bounds = this._bounds;
	            return new Rect(bounds.x, bounds.y, bounds.width, bounds.height);
	        },
	        _setBounds: function (rect) {
	            this._bounds = new Rect(rect.x, rect.y, rect.width, rect.height);
	        }
	    };
	    exports.Worksheet = Worksheet;
	   
	
	   
	    
	
	   
	    
	
	   
	    
	
	   
	    
	
	   
	    
	
	   
	    
	
	   
	    
	
	   
	    
	
	   
	    
	
	   
	    
	
	   
	    
	
	   
	    
	
	   
	    
	
	   
	    
	
	   
	    
	
	   
	    
	
	   
	    
	    module.exports = exports;
	
	}());

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var Calc = __webpack_require__(2);
	    var Common = __webpack_require__(5);
	    var SheetsCalc = __webpack_require__(19);
	    var inherit = Common._Types._inherit, extend = Common._Types._extend;
	    var maxRowCount = Calc.maxRowCount = 1048576, maxColumnCount = Calc.maxColumnCount = 16384,
	        BAND_INDEX_CONST = Calc.BAND_INDEX_CONST, LetterPows = [1, 26, 676];
	    var keyword_undefined = void 0, keyword_null = null,
	        structReferenceKeywordsLlowercase = ['#all', '#data', '#headers', '#totals', '#this row'];
	
	    var Expression = Calc.Expression, isNumber = Calc.isNumber, isLetter = Calc._isLetter,
	        FormulaToken = Calc.FormulaToken, CalcErrorsRef = Calc.Errors.Reference;
	        
	    var indexToLetters = __webpack_require__(3)._util._indexToLetters;
	    function getColumnLettersInArray(column) {
	       
	        return indexToLetters(column + 1).split('');
	    }
	
	    function normalizeIndex(index, maxIndex) {
	        var firstInvalidIndex = maxIndex + 1;
	        if (index < 0) {
	            return index % firstInvalidIndex + firstInvalidIndex;
	        }
	        if (index > maxIndex) {
	            return index % firstInvalidIndex;
	        }
	        return index;
	    }
	
	    var ErrorSource = Calc.ErrorSource = (function (_super) {
	        inherit(ErrorSource, _super);
	        function ErrorSource(sheetName) {
	            _super.call(this, keyword_null);
	            this._sheetName = sheetName;
	        }
	
	        return ErrorSource;
	    })(Calc.CalcSource);
	    extend(ErrorSource.prototype, {
	        startCalculation: function () {
	        },
	        endCalculation: function () {
	        },
	        getValue: function () {
	            return CalcErrorsRef;
	        },
	        getReference: function () {
	            var ref = new Calc.CalcReference(self, [Calc._createCellIdentity(0, 0)]);
	            ref.getValue = function () {
	                return CalcErrorsRef;
	            };
	        },
	        referenceToArray: function () {
	            var result = [CalcErrorsRef];
	            result.isError = true;
	            return result;
	        },
	        getName: function () {
	            return this._sheetName;
	        },
	        setValue: function () {
	        }
	    });
	
	    function createErrorSource(name) {
	        return new ErrorSource(name);
	    }
	
	    function isCellIndexsValidate(baseRow, baseColumn, row, column, rowRelative, columnRelative, rangeType) {
	        return rangeType === 3  || row >= 0 && column >= 0 || rangeType === 1  && row >= 0 || rangeType === 2  && column >= 0;
	    }
	
	    function parseCellReference(charArray, isR1C1, baseRow, baseColumn) {
	        var bandIndex = BAND_INDEX_CONST;
	        var result = {
	            _row: bandIndex,
	            _col: bandIndex,
	            _rowRelative: true,
	            _columnRelative: true,
	            _success: false,
	            _endIndex: 0,
	            _isFullMatch: true
	        };
	        var read = isR1C1 ? readOneR1C1Element(charArray, baseRow, baseColumn, 0) : readOneA1Element(charArray, 0);
	        if (read._isRow) {
	            result._row = read._elementIndex;
	            result._rowRelative = read._isRelative;
	        } else {
	            result._col = read._elementIndex;
	            result._columnRelative = read._isRelative;
	        }
	        result._endIndex = read._endIndex;
	        result._success = read._success;
	        if (!read._success
	            || read._endIndex >= charArray.length) {
	            return result;
	        } else if (!isR1C1 && read._isRow
	            || isR1C1 && !read._isRow) {
	            return {_success: false};
	        }
	        var nextChar = charArray[result._endIndex];
	       
	        if (!isR1C1 && (isNumber(nextChar) || nextChar === '$')
	            || isR1C1 && (nextChar === 'C' || nextChar === 'c')) {
	           
	            var read2 = isR1C1 ? readOneR1C1Element(charArray, baseRow, baseColumn, result._endIndex) : readOneA1Element(charArray, result._endIndex);
	            result._endIndex = read2._endIndex;
	            if (!read2._success
	                || !isR1C1 && !read2._isRow
	                || isR1C1 && read2._isRow) {
	               
	               
	               
	               
	               
	               
	                result._success = false;
	                return result;
	            }
	            if (result._endIndex < charArray.length) {
	                result._isFullMatch = false;
	            }
	            if (isR1C1) {
	                result._col = read2._elementIndex;
	                result._columnRelative = read2._isRelative;
	            } else {
	                result._row = read2._elementIndex;
	                result._rowRelative = read2._isRelative;
	            }
	            result._success = true;
	        } else {
	            return {_success: false};
	        }
	        return result;
	    }
	
	    var powsTen = [1, 10, 100, 1000, 10000, 100000, 1000000, 1000000];
	
	    function readOneA1Element(charArray, startIndex) {
	        var result = {
	            _isRelative: true,
	            _success: false
	        };
	        var length = charArray.length;
	        if (startIndex >= length) {
	            return result;
	        }
	        if (charArray[startIndex] === '$') {
	            result._isRelative = false;
	            startIndex++;
	        }
	        if (startIndex >= length) {
	            return result;
	        }
	        var index = startIndex, intValue = 0;
	        var currentChar = charArray[index];
	        if (isNumber(currentChar) && currentChar !== '0') {
	            result._isRow = true;
	            while (index < length && isNumber(currentChar)) {
	                index++;
	                if (index < length) {
	                    currentChar = charArray[index];
	                }
	            }
	            if (index - startIndex > 7) {
	                return result;
	            }
	            for (var intIndex = index - 1, place = 0; intIndex >= startIndex; intIndex--, place++) {
	                intValue += (charArray[intIndex].charCodeAt() - 48) * powsTen[place];
	            }
	            if (intValue <= maxRowCount) {
	                result._elementIndex = intValue - 1;
	                result._endIndex = index;
	                result._success = true;
	                return result;
	            }
	        } else if (isLetter(currentChar)) {
	            result._isRow = false;
	            while (index < length && isLetter(currentChar)) {
	                index++;
	                if (index < length) {
	                    currentChar = charArray[index];
	                }
	            }
	            var letterLength = index - startIndex;
	            if (letterLength > 3) {
	                return result;
	            }
	            intValue = 0;
	            var last = index - 1;
	            for (var i = last; i >= startIndex; i--) {
	                intValue += ((charArray[i].charCodeAt(0) | 0x20) - 96) * LetterPows[last - i];
	            }
	            if (intValue <= maxColumnCount) {
	                result._elementIndex = intValue - 1;
	                result._endIndex = index;
	                result._success = true;
	                return result;
	            }
	        }
	        return result;
	    }
	
	    function readOneR1C1Element(charArray, baseRow, baseColumn, startIndex) {
	        var bandIndex = BAND_INDEX_CONST;
	        var result = {
	            endIndex: startIndex,
	            elementIndex: bandIndex,
	            isRow: true,
	            isRelative: false,
	            success: false
	        };
	        var length = charArray.length;
	        if (startIndex >= length) {
	            return result;
	        }
	        var index = startIndex;
	        var currentChar = charArray[index];
	        var baseIndex;
	        if (currentChar === 'R' || currentChar === 'r') {
	            result._isRow = true;
	            baseIndex = baseRow;
	        } else if (currentChar === 'C' || currentChar === 'c') {
	            result._isRow = false;
	            baseIndex = baseColumn;
	        } else {
	            return result;
	        }
	        startIndex++;
	        index++;
	        if (startIndex >= length) {
	            result._endIndex = startIndex;
	            result._elementIndex = baseIndex;
	            result._isRelative = true;
	            result._success = true;
	            return result;
	        }
	        currentChar = charArray[index];
	        if (currentChar === '[') {
	            startIndex++;
	            index++;
	            result._isRelative = true;
	        }
	        if (startIndex >= length) {
	            return result;
	        }
	        var isNegative = false;
	        currentChar = charArray[index];
	        if (result._isRelative && currentChar === '-') {
	            startIndex++;
	            index++;
	            isNegative = true;
	        }
	        if (startIndex >= length) {
	            return result;
	        }
	        currentChar = charArray[index];
	       
	        if (isNumber(currentChar)) {
	            while (index < length && isNumber(currentChar)) {
	                index++;
	                if (index < length) {
	                    currentChar = charArray[index];
	                }
	            }
	            var intValue = parseInt(charArray.slice(startIndex, index).join(''), 10);
	            if (result._isRelative) {
	                if (index >= length || charArray[index] !== ']') {
	                    return result;
	                }
	                index++;
	            }
	            if (intValue < (result._isRow ? maxRowCount : maxColumnCount)) {
	                if (result._isRelative) {
	                    intValue = isNegative ? -intValue : intValue;
	                    result._elementIndex = intValue + baseIndex;
	                } else {
	                    result._elementIndex = intValue - 1;
	                }
	                result._endIndex = index;
	                result._success = true;
	                return result;
	            }
	        } else if (result._isRelative) {
	            return result;
	        } else {
	            result._endIndex = startIndex;
	            result._elementIndex = baseIndex;
	            result._isRelative = true;
	            result._success = true;
	            return result;
	        }
	    }
	
	    function unparseRefenceExpressions(context, parser, expr, formula) {
	        var baseRow = context.row || 0, baseColumn = context.column || 0;
	        if (expr.source === Calc.BangSource ) {
	            formula.push('!');
	           
	           
	           
	        } else if (expr.source) {
	            var isSourceValid = unparseSource(context, formula, expr.source, expr.endSource);
	            if (!isSourceValid) {
	                formula.push('#', 'R', 'E', 'F', '!');
	                return;
	            }
	        }
	        if (expr.type === 8  || expr.type === 5 ) {
	            formula.push(expr.value.toString());
	        } else if (expr.value && expr._error) {
	            formula.push(expr.value.toString());
	        } else if (expr._isCell()) {
	            unparseCell(context.useR1C1, baseRow, baseColumn, expr.row, expr.column, expr.rowRelative, expr.columnRelative, formula);
	        } else {
	            unparseRange(context.source, context.useR1C1, baseRow, baseColumn, expr.row, expr.column, expr.endRow, expr.endColumn, expr.rowRelative, expr.columnRelative, expr.endRowRelative, expr.endColumnRelative, formula, expr._getRangeType());
	        }
	    }
	
	    function unparseCell(useR1C1, baseRow, baseColumn, row, column, rowRelative, columnRelative, formula, rangeType) {
	        rangeType = rangeType || 0 ;
	        var maxRowIndex = maxRowCount - 1;
	        if ((rangeType === 0  || rangeType === 1 ) && row > (-maxRowIndex) && row <= 2 * maxRowIndex) {
	            row += (rowRelative ? baseRow : 0);
	            row = normalizeIndex(row, maxRowIndex);
	        }
	        var maxColumnIndex = maxColumnCount - 1;
	        if ((rangeType === 0  || rangeType === 2 ) && column > -maxColumnIndex && column <= 2 * maxColumnIndex) {
	            column += (columnRelative ? baseColumn : 0);
	            column = normalizeIndex(column, maxColumnIndex);
	        }
	        if (!isCellIndexsValidate(baseRow, baseColumn, row, column, rowRelative, columnRelative, rangeType)) {
	            formula.push(Calc.Errors.Reference.toString());
	            return;
	        }
	        if (useR1C1) {
	            formula.push('R');
	            if (row >= 0 && (baseRow !== row || !rowRelative)) {
	                if (rowRelative) {
	                    formula.push('[' + (row - baseRow) + ']');
	                } else {
	                    row++;
	                    formula.push(row + '');
	                }
	            }
	            if (column < 0) {
	                return;
	            }
	            formula.push('C');
	            if (baseColumn !== column || !columnRelative) {
	                if (columnRelative) {
	                    formula.push('[' + (column - baseColumn) + ']');
	                } else {
	                    column++;
	                    formula.push(column + '');
	                }
	            }
	            if ((rowRelative && row < 0) || (!rowRelative && row <= 0)) {
	                return;
	            }
	        } else {
	            if (column >= 0) {
	                if (!columnRelative) {
	                    formula.push('$');
	                }
	                formula.push.apply(formula, getColumnLettersInArray(column));
	            }
	            if (row < 0) {
	                return;
	            }
	            row++;
	            if (!rowRelative) {
	                formula.push('$');
	            }
	            formula.push(row + '');
	        }
	    }
	
	    function unparseRange(source, useR1C1, baseRow, baseColumn, startRow, startColumn, endRow, endColumn, rowRelative, startColumnRelative, endRowRelative, endColumnRelative, formula, rangeType) {
	        rangeType = rangeType || 0 ;
	        if (rangeType === 3 ) {
	            startRow = 0;
	            endRow = source ? source.getRowCount() : maxRowCount - 1;
	            rangeType = 1;
	        }
	        unparseCell(useR1C1, baseRow, baseColumn, startRow, startColumn, rowRelative, startColumnRelative, formula, rangeType);
	       
	        var bandIndex = BAND_INDEX_CONST;
	        if (useR1C1 && startRow === endRow && startColumn === endColumn && (endRow === bandIndex || endColumn === bandIndex)) {
	            return;
	        }
	        if (endRow !== bandIndex || endColumn !== bandIndex) {
	            formula.push(':');
	            unparseCell(useR1C1, baseRow, baseColumn, endRow, endColumn, endRowRelative, endColumnRelative, formula, rangeType);
	        }
	    }
	
	    function unparseSource(context, formula, source, endSource) {
	        if (context.getExternalSourceToken) {
	            if (source !== Calc.BangSource) {
	                var sourceName = getValidSources(context, context.getExternalSourceToken(source).split(''), endSource && context.getExternalSourceToken(endSource).split(''));
	                if (sourceName.length > 0) {
	                    formula.push.apply(formula, sourceName);
	                } else {
	                    return false;
	                }
	            }
	            formula.push('!');
	            return true;
	        }
	        return false;
	    }
	
	    function getValidSources(context, charArray, charArray2) {
	        if (!charArray || charArray.length === 0
	            || needConvertToError(context, charArray) || needConvertToError(context, charArray2)) {
	            return [];
	        }
	        var result = charArray;
	        if (needAppendSingleQuote(charArray, false) || charArray2 && needAppendSingleQuote(charArray2, false)) {
	            result = ['\''];
	            for (var i = 0; i < charArray.length; i++) {
	                if (charArray[i] === '\'') {
	                    result.push('\'');
	                }
	                result.push(charArray[i]);
	            }
	            if (charArray2) {
	                result.push(':');
	                for (i = 0; i < charArray2.length; i++) {
	                    if (charArray2[i] === '\'') {
	                        result.push('\'');
	                    }
	                    result.push(charArray2[i]);
	                }
	            }
	            result.push('\'');
	           
	           
	           
	        }
	        if (charArray2) {
	            result.push(':');
	            for (i = 0; i < charArray2.length; i++) {
	                result.push(charArray2[i]);
	            }
	        }
	        return result;
	    }
	
	    function needConvertToError(context, nameArray) {
	        if (!nameArray || nameArray.length === 0 || !context._toStandard) {
	            return false;
	        }
	        var startIndex = nameArray[0] === '\'' ? 1 : 0;
	        return nameArray[startIndex] === '[' && nameArray.indexOf(']') > startIndex;
	    }
	
	    function validateSheetName(charArray, containsSpecial) {
	        if (!charArray || charArray.length === 0) {
	            return true;
	        }
	        if (!containsSpecial) {
	            if (Calc.isNumber(charArray[0])) {
	                return false;
	            }
	            var isStartWithCellRef = isStartWithCellReference(charArray);
	            if (isStartWithCellRef._success && isStartWithCellRef._endIndex <= charArray.length) {
	                return false;
	            }
	        }
	        var currentChar;
	        for (var i = 0; i < charArray.length; i++) {
	            currentChar = charArray[i];
	            if (containsSpecial) {
	                if (currentChar === '*' || currentChar === ':' || currentChar === '[' || currentChar === ']'
	                    || currentChar === '?' || currentChar === '\\' || currentChar === '/') {
	                    return false;
	                }
	            } else if (currentChar === ' ' || currentChar === '\'' || currentChar === '[' || currentChar === ']'
	                || currentChar === '?' || currentChar === '\\' || currentChar === '%' || currentChar === '"'
	                || currentChar === '(' || currentChar === ')' || currentChar === '|' || currentChar === '{'
	                || currentChar === '}' || currentChar === '#' || currentChar === '@' || currentChar === '!'
	                || currentChar === '$' || currentChar === '^' || currentChar === '\uff08' || currentChar === '\uff09'
	                || Calc.operaterTypesMap[currentChar]) {
	                return false;
	            }
	        }
	        return true;
	    }
	
	    SheetsCalc._validateSheetName = validateSheetName;
	
	    function validateWorkbook(charArray, containsSpecial) {
	        if (!charArray || charArray.length === 0) {
	            return true;
	        }
	        var currentChar;
	        for (var i = 0; i < charArray.length; i++) {
	            currentChar = charArray[i];
	            if (containsSpecial) {
	                if (currentChar === '*' || currentChar === ':' || currentChar === '[' || currentChar === ']' ||
	                    currentChar === '?') {
	                    return false;
	                }
	                if (currentChar === "'" && (i === 0 || i >= charArray.length - 1 || charArray.charAt(i + 1) !== "'")) {
	                    return false;
	                }
	            } else if (currentChar === "'" || currentChar === '[' || currentChar === ']' || currentChar === '?' ||
	                currentChar === '%' || Calc.operaterTypesMap[currentChar]) {
	                return false;
	            }
	        }
	        return true;
	    }
	
	    function needAppendSingleQuote(charArray, isR1C1) {
	        if (Calc.isDigit(charArray[0])) {
	            return true;
	        }
	        var workBookArray = [], workSheetArray = charArray;
	        if (charArray[0] === '[') {
	            var lastIndex = charArray.lastIndexOf(']');
	            if (lastIndex > 0) {
	                workBookArray = charArray.slice(1, lastIndex);
	                workSheetArray = charArray.slice(lastIndex + 1);
	            }
	        }
	        return !validateWorkbook(workBookArray) || !validateSheetName(workSheetArray, isR1C1);
	    }
	
	    function isStartWithCellReference(charArray) {
	        var result = parseCellReference(charArray, false, 0, 0);
	        if (!result._success) {
	            result = parseCellReference(charArray, true, 0, 0);
	        }
	        return result;
	    }
	
	
	    var SheetReferenceResolver = SheetsCalc.SheetReferenceResolver = function (sheet) {
	        this._sheet = sheet;
	        this.priority = 8000;
	    };
	    inherit(SheetReferenceResolver, Calc.TokenResolver);
	    function createNameExpr(stringValue) {
	        var expr1 = new Calc.Expression(8 );
	        expr1.value = stringValue;
	        return expr1;
	    }
	
	    function removeCurrentWorkbookReference(source) {
	        var result = source;
	        if (source && source.length >= 3 && source[0] === '[' && source[1] === '0' && source[2] === ']') {
	            result = source.length === 3 ? "" : source.subString(3);
	        }
	        return result;
	    }
	
	    extend(SheetReferenceResolver.prototype, {
	        resolveToken: function (parserContext, builder, originalTokens, currentTokenIndex) {
	            var isR1C1 = parserContext.useR1C1, baseRow = parserContext.row || 0, baseColumn = parserContext.column || 0, expr;
	            var length = originalTokens.length;
	            var currentToken = originalTokens[currentTokenIndex], stringValue = currentToken._stringValue,
	                currentTokenType = currentToken._type, currentTokenSubType = currentToken._subType, source, endSource, hasSource;
	            if (currentTokenType !== 0 && currentTokenSubType !== 6 ) {
	                return false;
	            }
	            if (currentTokenType === 0  && currentTokenSubType === 0   
	                && currentTokenIndex < length - 2
	                && originalTokens[currentTokenIndex + 1]._stringValue === ':'
	                && originalTokens[currentTokenIndex + 2]._subType === 12 
	                && originalTokens[currentTokenIndex + 2]._stringValue.indexOf(':') < 0 
	                || currentTokenType === 0  && currentTokenSubType === 12 ) {
	                var startSourceString, endSourceString;
	                if (!stringValue) {
	                } else if (stringValue.indexOf(':') > 0) {
	                    var rangeIndex = stringValue.indexOf(':');
	                    startSourceString = stringValue.substring(1, rangeIndex - 1);
	                    endSourceString = stringValue.substring(rangeIndex + 1, stringValue.length - 2);
	                } else {
	                    startSourceString = stringValue;
	                    if (startSourceString.charAt(0) === '\'') {
	                        startSourceString = startSourceString.substring(1, startSourceString.length - 1);
	                    }
	                    if (currentTokenSubType === 0 ) {
	                        endSourceString = originalTokens[currentTokenIndex + 2]._stringValue;
	                    }
	                }
	                currentTokenIndex++;
	                hasSource = !!startSourceString;
	                startSourceString = removeCurrentWorkbookReference(startSourceString);
	                if (startSourceString) {
	                    source = stringValue ? parserContext.getExternalSource('', startSourceString) : Calc.BangSource;
	                    source = source || createErrorSource(startSourceString);
	                    endSourceString = removeCurrentWorkbookReference(endSourceString);
	                    if (endSourceString) {
	                        endSource = parserContext.getExternalSource('', endSourceString);
	                        endSource = endSource || createErrorSource(endSourceString);
	                        currentTokenIndex += 2;
	                    }
	                }
	                currentToken = originalTokens[currentTokenIndex];
	                if (!currentToken) {
	                    return createNameExpr(stringValue);
	                }
	                stringValue = currentToken._stringValue;
	            }
	            var next = currentTokenIndex === length - 1 ? keyword_null : originalTokens[currentTokenIndex + 1];
	            if (isCellReferenceToken(originalTokens, currentToken, currentTokenIndex, isR1C1, true)) {
	                var cellRef = parseCellReference(currentToken._value, isR1C1, baseRow, baseColumn);
	                if (!cellRef._success && !hasSource) {
	                    return false;
	                }
	                currentToken._subType = 7 ;
	                if (!cellRef._success || !cellRef._isFullMatch) {
	                    expr = createNameExpr(stringValue);
	                } else {
	                    var row = cellRef._row, col = cellRef._col, rowRelative = cellRef._rowRelative,
	                        colRelative = cellRef._columnRelative;
	                    if (currentTokenIndex < length - 2 && next._type === 5  && next._stringValue === ':') {
	                        next = originalTokens[currentTokenIndex + 2];
	                        if (isCellReferenceToken(originalTokens, next, currentTokenIndex + 2, isR1C1, false)) {
	                            var nextCellRef = parseCellReference(next._value, isR1C1, baseRow, baseColumn);
	                            if (nextCellRef._success) { 
	                                if ((row === BAND_INDEX_CONST) === (nextCellRef._row === BAND_INDEX_CONST)
	                                    && (col === BAND_INDEX_CONST) === (nextCellRef._col === BAND_INDEX_CONST)) {
	                                    baseRow = row === BAND_INDEX_CONST ? 0 : baseRow;
	                                    baseColumn = col === BAND_INDEX_CONST ? 0 : baseColumn;
	                                    return {
	                                        index: currentTokenIndex + 3,
	                                        expr: Calc._createRangeExpression(source, endSource,
	                                            row - (rowRelative ? baseRow : 0), col - (colRelative ? baseColumn : 0),
	                                            nextCellRef._row - (nextCellRef._rowRelative ? baseRow : 0), nextCellRef._col - (nextCellRef._columnRelative ? baseColumn : 0),
	                                            rowRelative, colRelative, nextCellRef._rowRelative, nextCellRef._columnRelative)
	                                    };
	                                }
	                            }
	                        }
	                    }
	                    if (row === BAND_INDEX_CONST || col === BAND_INDEX_CONST) {
	                        if (isR1C1) {
	                            row = row - (row !== BAND_INDEX_CONST && rowRelative ? baseRow : 0);
	                            col = col - (col !== BAND_INDEX_CONST && colRelative ? baseColumn : 0);
	                            return {
	                                index: currentTokenIndex + 3,
	                                expr: Calc._createRangeExpression(source, endSource,
	                                    row, col,
	                                    row, col,
	                                    rowRelative, colRelative, rowRelative, colRelative)
	                            };
	                        }
	                        if (source) {
	                            expr = createNameExpr(stringValue);
	                        } else {
	                            return false;
	                        }
	                    }
	                    if (!expr) {
	                        return {
	                            index: currentTokenIndex + 1,
	                            expr: Calc._createCellExpression(source, endSource,
	                                row - (rowRelative ? baseRow : 0), col - (colRelative ? baseColumn : 0),
	                                rowRelative, colRelative)
	
	                        };
	                    }
	                }
	            } else if (currentToken._subType === 6 ) {
	                expr = new Calc.Expression(5 );
	                expr.value = Calc.CalcError.parse(currentToken._stringValue);
	            } else if (source) {
	                expr = createNameExpr(stringValue);
	            } else {
	                return false;
	            }
	            if (source) {
	                expr.source = source;
	            }
	            if (endSource) {
	                expr.endSource = endSource;
	            }
	            return {
	                index: currentTokenIndex + 1,
	                expr: expr
	            };
	        },
	        unparse: function (context, parser, expression, formulaChars) {
	            if (expression.type === 1  || expression.type === 8  || expression.type === 5 ) {
	                unparseRefenceExpressions(context, parser, expression, formulaChars);
	                return true;
	            }
	            return false;
	        }
	    });
	    function isCellReferenceToken(tokens, current, index, isR1C1, considerNext) {
	        return current._type === 0  && current._subType === 0 
	            || !isR1C1 && current._type === 0  && current._subType === 4      
	            && (!considerNext
	            || index < tokens.length - 2 && tokens[index + 1]._stringValue === ':'
	            && tokens[index + 2]._type === 0  && tokens[index + 2]._subType === 4 );
	    }
	
	    SheetsCalc.StructReferencePortions = {
	        ThisRow: 1,
	        Headers: 2,
	        Data: 3,
	        Totals: 8,
	        HeadersAndData: 6,
	        DataAndTotals: 12,
	        All: 14,
	        NotSpecific: 16
	    };
	
	    SheetsCalc.StructReferenceColumnSpecifier = {
	        All: 1,
	        NotSpecific: 1,
	        SingleColumn: 2,
	        ColumnRange: 4
	    };
	    function containsTable(table, row, col, rowCount, colCount) {
	        return row <= table.startRow() && col <= table.startColumn()
	            && row + rowCount > table.endRow() && col + colCount > table.endColumn();
	    }
	
	    var createTableExpression = function () {
	        var expr = new Expression(13 );
	        expr.tableName = function () {
	            return this._baseTable.tableName();
	        };
	        expr.baseTable = function () {
	            return this._baseTable;
	        };
	        expr._updateCatch = function () {
	            this._catchedTableStartColumn = this._baseTable.startColumn();
	        };
	        expr.columnReferenceStart = function () {
	            return this._columnReferenceStartInTable + this._baseTable.startColumn();
	        };
	        expr.columnReferenceEnd = function () {
	            return this._columnReferenceEndInTable + this._baseTable.startColumn();
	        };
	        expr.referencePortions = function () {
	            return this._referencePortions;
	        };
	        expr.referenceColumnSpecifier = function () {
	            return this._referenceColumnSpecifier;
	        };
	        expr.source = function () {
	            return this._baseTable.source();
	        };
	        expr.getRange = function (baseRow, baseColumn, getReference) {
	            var self = this, baseTable = self._baseTable;
	            self._updateCatch();
	            var startRow, startColumn, endRow, endColumn, rowCount, columnCount;
	            var tableStartRow = baseTable.startRow();
	            var tableEndRow = baseTable.endRow();
	            var tableHasTotalRow = baseTable.hasTotalsRow();
	            var tableHasHeadersRow = baseTable.hasHeadersRow();
	            switch (self._referencePortions) {
	                case 3 
	                :
	                case 16 
	                :
	                    startRow = tableHasHeadersRow ? tableStartRow + 1 : tableStartRow;
	                    endRow = tableHasTotalRow ? tableEndRow - 1 : tableEndRow;
	                    break;
	                case 2 
	                :
	                    if (!tableHasHeadersRow) {
	                        if (getReference) {
	                            startRow = tableStartRow - 1;
	                            endRow = tableStartRow - 1;
	                        } else {
	                            return keyword_null;
	                        }
	                    } else {
	                        startRow = tableStartRow;
	                        endRow = tableStartRow;
	                    }
	                    break;
	                case 8 
	                :
	                    if (!tableHasTotalRow) {
	                        if (getReference) {
	                            startRow = tableEndRow + 1;
	                            endRow = tableEndRow + 1;
	                        } else {
	                            return keyword_null;
	                        }
	                    } else {
	                        startRow = tableEndRow;
	                        endRow = tableEndRow;
	                    }
	                    break;
	                case 1 
	                :
	                    startRow = baseRow;
	                    endRow = baseRow;
	                    break;
	                case 6 
	                :
	                    startRow = tableStartRow + (getReference && !tableHasHeadersRow ? -1 : 0);
	                    endRow = tableHasTotalRow ? tableEndRow - 1 : tableEndRow;
	                    break;
	                case 12 
	                :
	                    startRow = tableHasHeadersRow ? tableStartRow + 1 : tableStartRow;
	                    endRow = tableEndRow + (getReference && !tableHasTotalRow ? 1 : 0);
	                    break;
	                case 14 
	                :
	                default:
	                    startRow = tableStartRow + (getReference && !tableHasHeadersRow ? -1 : 0);
	                    endRow = tableEndRow + (getReference && !tableHasTotalRow ? 1 : 0);
	                    break;
	            }
	            startColumn = self.columnReferenceStart();
	            endColumn = self.columnReferenceEnd();
	            if (endRow < startRow
	                || !getReference && startRow < tableStartRow
	                || !getReference && endRow > tableEndRow) {
	                return keyword_null;
	            }
	            rowCount = endRow - startRow + 1;
	            columnCount = endColumn - startColumn + 1;
	            return Calc._createRangeIdentity(startRow, startColumn, rowCount, columnCount);
	        };
	        expr.offsetWhenInsertRemoveColumn = function (index, count, isInsert) {
	            var self = this;
	            var startColumn = self._catchedTableStartColumn;
	            if (index < startColumn
	                || index === startColumn && isInsert
	                || index > self._columnReferenceEndInTable + startColumn) {
	                return self;
	            }
	            count = isInsert ? count : -count;
	            var minStartColumn = index - startColumn;
	            var newExpr = createTableExpression();
	            newExpr._baseTable = self._baseTable;
	            newExpr._columnReferenceEndInTable = self._columnReferenceEndInTable + count;
	            newExpr._columnReferenceStartInTable = self._columnReferenceStartInTable;
	            if (index <= startColumn + self._columnReferenceStartInTable) {
	                newExpr._columnReferenceStartInTable += count;
	                if (newExpr._columnReferenceStartInTable < minStartColumn) {
	                    newExpr._columnReferenceStartInTable = minStartColumn;
	                }
	            }
	            newExpr._referenceColumnSpecifier = self._referenceColumnSpecifier;
	            newExpr._referencePortions = self._referencePortions;
	            if (newExpr._columnReferenceEndInTable < newExpr._columnReferenceStartInTable) {
	                return Calc._referenceErrorExpr;
	            }
	            return newExpr;
	        };
	        expr.offsetWhenCopy = function (fromSource, targetSource, targetRow, targetColumn, offsetRow, offsetColumn, targetStartRow, targetStartColumn, rowCount, columnCount) {
	            var self = this;
	            var context = new SheetsCalc.SheetParserContext(targetSource._sheet, targetSource._service.useR1C1, Calc._createCellIdentity(targetRow, targetColumn));
	            var destTable = context.getTableByIndex(targetRow, targetColumn);
	            var newExpr = self.offset();
	            if (destTable) {
	                var fromRow = targetRow - offsetRow, fromColumn = targetColumn - offsetColumn, fromStartRow = targetStartRow - offsetRow, fromStartColumn = targetStartColumn - offsetColumn;
	                var sourceTable;
	                if (fromSource === targetSource) {
	                    sourceTable = context.getTableByIndex(fromRow, fromColumn);
	                } else {
	                    var sourceContext = new SheetsCalc.SheetParserContext(fromSource._sheet, fromSource._service.useR1C1, Calc._createCellIdentity(fromRow, fromColumn));
	                    sourceTable = sourceContext.getTableByIndex(fromRow, fromColumn);
	                }
	               
	                if (sourceTable !== destTable &&
	                    (sourceTable === self._baseTable
	                        && containsTable(sourceTable, fromStartRow, fromStartColumn, rowCount, columnCount)
	                        && containsTable(destTable, targetStartRow, targetStartColumn, rowCount, columnCount))) {
	                    newExpr._baseTable = destTable;
	                }
	            }
	            return newExpr;
	        };
	        expr._offsetColumn = function (offsetColumn) {
	            var self = this;
	            var newExpr = createTableExpression();
	            newExpr._baseTable = self._baseTable;
	            newExpr._columnReferenceEndInTable = self._columnReferenceEndInTable;
	            newExpr._columnReferenceStartInTable = self._columnReferenceStartInTable;
	            if (self._referenceColumnSpecifier === 2  && offsetColumn) {
	                var columnCount = self._baseTable.endColumn() - self._baseTable.startColumn() + 1;
	                offsetColumn %= columnCount;
	                newExpr._columnReferenceStartInTable += offsetColumn;
	                if (newExpr._columnReferenceStartInTable < 0) {
	                    newExpr._columnReferenceStartInTable += columnCount;
	                }
	                newExpr._columnReferenceEndInTable = newExpr._columnReferenceStartInTable;
	            }
	            newExpr._referenceColumnSpecifier = self._referenceColumnSpecifier;
	            newExpr._referencePortions = self._referencePortions;
	            return newExpr;
	        };
	        expr.offset = function () {
	            var self = this;
	            var newExpr = createTableExpression();
	            newExpr._baseTable = self._baseTable;
	            newExpr._referencePortions = self._referencePortions;
	            newExpr._columnReferenceStartInTable = self._columnReferenceStartInTable;
	            newExpr._columnReferenceEndInTable = self._columnReferenceEndInTable;
	            newExpr._referenceColumnSpecifier = self._referenceColumnSpecifier;
	            return newExpr;
	        };
	        expr._inTable = function (row, col) {
	            var table = this._baseTable;
	            return row >= table.startRow() && col >= table.startColumn()
	                && row <= table.endRow() && col <= table.endColumn();
	        };
	        return expr;
	    };
	
	    var StructureReferenceResolver = SheetsCalc.StructureReferenceResolver = function (sheet) {
	        Calc.TokenResolver.call(this);
	        this._sheet = sheet;
	        this.priority = 7900;
	    };
	    inherit(StructureReferenceResolver, Calc.TokenResolver);
	    extend(StructureReferenceResolver.prototype, {
	        resolveToken: function (parserContext, builder, originalTokens, currentTokenIndex) {
	            var value = originalTokens[currentTokenIndex];
	            if (value._type === 0  && value._subType === 0 ) {
	                value = value._stringValue;
	                if (value.charAt(value.length - 1) === ']') {
	                    try {
	                        var expr = createTableExpression();
	                        parseStructReferenceString(parserContext, value.split(''), expr);
	                        return expr;
	                    } catch (ex) {
	                       
	                    }
	                } else {
	                    var table = parserContext.getTableByName && parserContext.getTableByName(value);
	                    if (table) {
	                        return StructureReferenceResolver.create(table);
	                    }
	                }
	            }
	            return keyword_null;
	        },
	        unparse: function (context, parser, expr, formula) {
	            if (expr.type !== 13 ) {
	                return false;
	            }
	            var self = expr;
	            if(context._structureToRange) {
	                var range = self.getRange(context.row, context.column, true);
	                var rangeExpr = Calc._createRangeExpression(self.source(), keyword_null, range.row, range.col,
	                    range.row + range.rowCount - 1, range.col + range.colCount - 1, false, false, false, false);
	                unparseRefenceExpressions(context, parser, rangeExpr, formula);
	                return true;
	            }
	            if (self._referencePortions === 16 
	                && self._referenceColumnSpecifier === 1 ) {
	                formula.push(self._baseTable.tableName());
	                if (context._toStandard) {
	                    formula.push('[]');
	                }
	                return;
	            }
	            var inTable = context.source === self._baseTable.source() && self._inTable(context.row, context.column);
	            if (!inTable || context._toStandard) {
	                formula.push(self._baseTable.tableName());
	            }
	            formula.push('[');
	            if (self._referencePortions !== 16 ) {
	                var portionsString = getPortionsString(self._referencePortions, self._referenceColumnSpecifier !== 1 , context._toStandard);
	                formula.push(portionsString);
	            }
	            if (self._referenceColumnSpecifier !== 1 ) {
	                if (self._referencePortions === 1  && !context._toStandard
	                    || self._referencePortions === 16 ) {
	                } else {
	                    formula.push(', ');
	                }
	                var startColumnName = self._baseTable.getColumnName(self._columnReferenceStartInTable);
	                startColumnName = getValidaColumnString(startColumnName.split('')).join('');
	                if (self._referenceColumnSpecifier === 4 ) {
	                    var endColumnName = self._baseTable.getColumnName(self._columnReferenceEndInTable);
	                    endColumnName = getValidaColumnString(endColumnName.split('')).join('');
	                    formula.push('[', startColumnName, ']:[', endColumnName, ']');
	                } else if (self._referencePortions === 1  && !context._toStandard && !containsInvalidateColumnString(startColumnName)
	                    || self._referencePortions === 16 ) {
	                    formula.push(startColumnName);
	                } else {
	                    formula.push('[', startColumnName, ']');
	                }
	            }
	            formula.push(']');
	            return true;
	        }
	    });
	    StructureReferenceResolver.create = function (table, referencePortions, referenceColumnSpecifier, columnReferenceStartInTable, columnReferenceEndInTable) {
	        if (referencePortions === void 0) {
	            referencePortions = 16 ;
	        }
	        if (referenceColumnSpecifier === void 0) {
	            referenceColumnSpecifier = 1 ;
	        }
	        columnReferenceStartInTable = columnReferenceStartInTable || 0;
	        if (typeof columnReferenceEndInTable === 'undefined') {
	            columnReferenceEndInTable = table.endColumn() - table.startColumn();
	        }
	        var expr = createTableExpression();
	        expr._baseTable = table;
	        expr._referencePortions = referencePortions;
	        expr._columnReferenceStartInTable = columnReferenceStartInTable;
	        expr._columnReferenceEndInTable = columnReferenceEndInTable;
	        expr._referenceColumnSpecifier = referenceColumnSpecifier;
	        return expr;
	    };
	
	    function parseStructReferenceString(context, charArray, expr) {
	        var self = expr;
	        var charIndex = 0;
	        var currentChar = charArray[charIndex];
	        var rs = parseTableObject(context, charArray, charIndex, currentChar);
	        var table = rs._table;
	        if (!table) {
	            throwError();
	        }
	        self._baseTable = table;
	        charIndex = rs._charIndex;
	        charIndex++;
	        currentChar = charArray[charIndex];
	        var orgIndex = charIndex;
	        while (currentChar === ' ') {
	            charIndex++;
	            currentChar = charArray[charIndex];
	        }
	       
	       
	       
	        if (currentChar !== '@' && currentChar !== '[') {
	            charIndex = orgIndex;
	            currentChar = charArray[charIndex];
	        }
	        var lbracketLever = 1;
	        var hasPortion = false;
	        var hasColumn = false;
	        var structLen = charArray.length;
	        while (lbracketLever !== 0 && charIndex < structLen) {
	            if (currentChar === '[') {
	                lbracketLever++;
	                charIndex++;
	                currentChar = charArray[charIndex];
	            }
	            if (currentChar === '#') {
	                if (hasPortion && lbracketLever <= 1) {
	                    throwError();
	                }
	                rs = parsePortion(charArray, charIndex, currentChar, lbracketLever);
	                var portion = rs._portion;
	                charIndex = rs._charIndex;
	                currentChar = rs._currentChar;
	                lbracketLever = rs._lbracketLever;
	                if (hasPortion) {
	                    if (self._referencePortions === 2  && portion === 3 
	                        || portion === 2  && self._referencePortions === 3 ) {
	                        self._referencePortions = 6 ;
	                    } else if (self._referencePortions === 3  && portion === 8 
	                        || portion === 3  && self._referencePortions === 8 ) {
	                        self._referencePortions = 12 ;
	                    } else {
	                        throwError();
	                    }
	                } else {
	                    self._referencePortions = portion;
	                }
	                hasPortion = true;
	            } else if (currentChar === '@') {
	                if (lbracketLever > 1 || hasPortion) {
	                    throwError();
	                }
	                hasPortion = true;
	                self._referencePortions = 1 ;
	                charIndex++;
	                currentChar = charArray[charIndex];
	                while (currentChar === ' ') {
	                    charIndex++;
	                    currentChar = charArray[charIndex];
	                }
	                if (currentChar === ',') {
	                    throwError();
	                }
	            } else {
	                var columnsStartIndex = charIndex;
	                while (currentChar !== ']' && currentChar !== '[') {
	                    if (currentChar === '\'') {
	                        charIndex++;
	                    }
	                    if (currentChar === ',') {
	                        charIndex++;
	                        currentChar = charArray[charIndex];
	                        var commaIndex = charIndex;
	                        while (currentChar === ' ') {
	                            charIndex++;
	                            currentChar = charArray[charIndex];
	                        }
	                        if (currentChar === '[') {
	                            charIndex = commaIndex;
	                            currentChar = ',';
	                            break;
	                        }
	                    } else {
	                        charIndex++;
	                        currentChar = charArray[charIndex];
	                    }
	                }
	                if (charIndex > columnsStartIndex) {
	                    if (hasColumn
	                        || currentChar === '[' && lbracketLever > 1) {
	                        throwError();
	                    }
	                    rs = parseColumnRange(self, charArray, charIndex, currentChar, lbracketLever, columnsStartIndex);
	                    charIndex = rs._charIndex;
	                    currentChar = rs._currentChar;
	                    lbracketLever = rs._lbracketLever;
	                    hasColumn = true;
	                }
	                if (currentChar === ']') {
	                    lbracketLever--;
	                    if (lbracketLever === 0) {
	                        break;
	                    } else if (charIndex >= charArray.length) {
	                        throwError();
	                    }
	                    charIndex++;
	                    currentChar = charArray[charIndex];
	                }
	                if (currentChar === ',') {
	                    charIndex++;
	                    currentChar = charArray[charIndex];
	                }
	            }
	        }
	        if (!hasPortion) {
	            self._referencePortions = 16 ;
	        }
	        if (!hasColumn) {
	            self._columnReferenceStartInTable = 0;
	            self._columnReferenceEndInTable = self._baseTable.endColumn() - self._baseTable.startColumn();
	            self._referenceColumnSpecifier = 1 ;
	        }
	    }
	
	    function subString(charArray, start, end) {
	        return charArray.slice(start, end).join('');
	    }
	
	    function parseColumnRange(expr, charArray, charIndex, currentChar, lbracketLever, columnsStartIndex) {
	        var self = expr;
	        var columnStartString = [];
	        var columnEndString = '';
	        var istartStringWithBracket = false;
	        var isEndStringWithBracket = false;
	        if (lbracketLever > 1) {
	            istartStringWithBracket = true;
	            lbracketLever--;
	            columnStartString = charArray.slice(columnsStartIndex, charIndex);
	            charIndex++;
	            currentChar = charArray[charIndex];
	            if (currentChar === ':') {
	                charIndex++;
	                currentChar = charArray[charIndex];
	                isEndStringWithBracket = currentChar === '[';
	                var rs = getColumnEndString(charArray, charIndex, currentChar, lbracketLever);
	                columnEndString = rs._columnEndString;
	                charIndex = rs._charIndex;
	                currentChar = rs._currentChar;
	                lbracketLever = rs._lbracketLever;
	            }
	        } else if (currentChar === '[') {
	            isEndStringWithBracket = true;
	            var colonIndex = charIndex - 1;
	            currentChar = charArray[colonIndex];
	            while (currentChar === ' ') {
	                colonIndex--;
	                currentChar = charArray[colonIndex];
	            }
	            if (currentChar !== ':') {
	                throwError();
	            }
	            columnStartString = charArray.slice(columnsStartIndex, colonIndex);
	            columnStartString = trimStart(columnStartString);
	            currentChar = charArray[charIndex];
	            rs = getColumnEndString(charArray, charIndex, currentChar, lbracketLever);
	            columnEndString = rs._columnEndString;
	            charIndex = rs._charIndex;
	            currentChar = rs._currentChar;
	            lbracketLever = rs._lbracketLever;
	        } else {
	            if (self._referencePortions === keyword_undefined || self._referencePortions === 16 ) {
	                istartStringWithBracket = true;
	            }
	            var columnStrings = charArray.slice(columnsStartIndex, charIndex);
	            colonIndex = columnStrings.indexOf(':');
	            if (colonIndex > 0) {
	                columnStartString = columnStrings.slice(0, colonIndex);
	                columnEndString = columnStrings.slice(colonIndex + 1);
	                if (columnEndString[0] !== '[') {
	                    throwError();
	                }
	            } else {
	                columnStartString = columnStrings;
	            }
	        }
	       
	        var startIndex = getColumnIndex(self, columnStartString, istartStringWithBracket);
	        var endIndex;
	        if (columnEndString) {
	            endIndex = getColumnIndex(self, columnEndString, isEndStringWithBracket);
	            self._referenceColumnSpecifier = 4 ;
	        } else {
	            endIndex = startIndex;
	            self._referenceColumnSpecifier = 2 ;
	        }
	        if (startIndex > endIndex) {
	            var tmp = startIndex;
	            startIndex = endIndex;
	            endIndex = tmp;
	        }
	        self._columnReferenceStartInTable = startIndex;
	        self._columnReferenceEndInTable = endIndex;
	        charIndex++;
	        if (charIndex < charArray.length) {
	            currentChar = charArray[charIndex];
	            while (currentChar === ' ') {
	                charIndex++;
	                currentChar = charArray[charIndex];
	            }
	        }
	        return {
	            _charIndex: charIndex,
	            _currentChar: currentChar,
	            _lbracketLever: lbracketLever
	        };
	    }
	
	    function trimStart(s) {
	        var i = s.length - 1;
	        while (i >= 0 && s[i] === ' ') {
	            i--;
	        }
	        while (i >= 0 && s[i] !== ' ') {
	            i--;
	        }
	        if (i >= 0) {
	            return s.substr(i + 1, s.length - i - 1);
	        }
	        return s;
	    }
	
	    function trimEnd(s) {
	        var i = 0, length = s.length, start = 0;
	        while (i < length && s[i] === ' ') {
	            i++;
	        }
	        start = i;
	        i = length - 1;
	        while (i > start && s[i] === ' ') {
	            i++;
	        }
	        if (i >= start) {
	            return s.slice(start, i + 1);
	        }
	        return s;
	    }
	
	    function getColumnIndex(self, charArray, containsSpecial) {
	        if (charArray && validateColumnString(charArray, containsSpecial)) {
	            var sb = [];
	            for (var i = 0, columnStringLength = charArray.length; i < columnStringLength; i++) {
	                if (charArray[i] === '\'' && i < columnStringLength - 1 && charArray[i + 1] !== '\'') {
	                } else {
	                    sb.push(charArray[i]);
	                }
	            }
	            charArray = sb;
	            var index = self._baseTable.getColumnIndexInTable(charArray.join(''));
	            if (index < 0) {
	                throwError();
	            }
	            return index;
	        }
	        return -1;
	    }
	
	    function validateColumnString(columnCharArray, containsSpecial) {
	        if (containsSpecial) {
	            return true;
	        }
	        var currentChar = '';
	        currentChar = columnCharArray[0];
	        var previousChar = currentChar;
	        if (currentChar === '#' || currentChar === ' ' || currentChar === '@'
	            || currentChar === ' ' || currentChar === ','
	            || currentChar === ':' || currentChar === '[' || currentChar === ']') {
	            return false;
	        }
	        for (var index = 1; index < columnCharArray.length; index++) {
	            currentChar = columnCharArray[index];
	            if (currentChar === ' ' || currentChar === ',' || currentChar === ':'
	                || currentChar === '[' && previousChar !== '\''
	                || currentChar === ']' && previousChar !== '\''
	                || currentChar === '@' && previousChar !== '\''
	                || currentChar === '#' && previousChar !== '\'') {
	                return false;
	            }
	            previousChar = currentChar;
	        }
	        return true;
	    }
	
	    function getValidaColumnString(columnCharArray) {
	        var validaString = [];
	        var currentChar;
	        for (var index = 0; index < columnCharArray.length; index++) {
	            currentChar = columnCharArray[index];
	            if (currentChar === '['
	                || currentChar === ']'
	                || currentChar === '@'
	                || currentChar === '#'
	                || currentChar === '\'') {
	                validaString.push('\'');
	            }
	            validaString.push(currentChar);
	        }
	        return validaString;
	    }
	
	    function containsInvalidateColumnString(columnCharArray) {
	        var currentChar = '';
	        currentChar = columnCharArray[0];
	        if (currentChar === '#' || currentChar === ' ' || currentChar === '@'
	            || currentChar === ' ' || currentChar === ','
	            || currentChar === ':' || currentChar === '[' || currentChar === ']') {
	            return true;
	        }
	        for (var index = 1; index < columnCharArray.length; index++) {
	            currentChar = columnCharArray[index];
	            if (currentChar === ' ' || currentChar === ',' || currentChar === ':'
	                || currentChar === '['
	                || currentChar === ']'
	                || currentChar === '@'
	                || currentChar === '#') {
	                return true;
	            }
	        }
	        return false;
	    }
	
	    function getColumnEndString(charArray, charIndex, currentChar, lbracketLever) {
	        var inBracket = false;
	        if (currentChar === '[') {
	            inBracket = true;
	            lbracketLever++;
	            charIndex++;
	            currentChar = charArray[charIndex];
	            while (currentChar === ' ') {
	                charIndex++;
	                currentChar = charArray[charIndex];
	            }
	        }
	        var columnEndIndex = charIndex;
	        while (currentChar !== ']' && (currentChar !== ',' || lbracketLever > 1)) {
	            if (currentChar === '\'') {
	                charIndex++;
	            }
	            charIndex++;
	            currentChar = charArray[charIndex];
	        }
	        if (charIndex <= columnEndIndex) {
	            throwError();
	        }
	        var endString = charArray.slice(columnEndIndex, charIndex);
	        if (lbracketLever > 1) {
	            lbracketLever--;
	        }
	        if (!inBracket) {
	            endString = trimEnd(endString);
	        }
	        return {
	            _columnEndString: endString,
	            _charIndex: charIndex,
	            _currentChar: currentChar,
	            _lbracketLever: lbracketLever
	        };
	    }
	
	    var poritionMap = {
	        '#all': 14 ,
	        '#data': 3 ,
	        '#headers': 2 ,
	        '#totals': 8 ,
	        '#this row': 1 
	    };
	
	    function parsePortion(charArray, charIndex, currentChar, lbracketLever) {
	        var portion = 14 ;
	        var portionStartIndex = charIndex;
	        while (currentChar !== ']') {
	            if (currentChar === '\'') {
	                charIndex++;
	            }
	            charIndex++;
	            currentChar = charArray[charIndex];
	        }
	        var portionString = subString(charArray, portionStartIndex, charIndex).toLowerCase().trim();
	        var isPortionCorrect = false;
	        for (var i = 0; i < structReferenceKeywordsLlowercase.length; i++) {
	            var keyword = structReferenceKeywordsLlowercase[i];
	            if (portionString === keyword) {
	                portion = poritionMap[portionString];
	                isPortionCorrect = true;
	                break;
	            }
	        }
	        if (!isPortionCorrect) {
	            throwError();
	        }
	        charIndex++;
	        if (charIndex >= charArray.length) {
	            lbracketLever--;
	        } else {
	            currentChar = charArray[charIndex];
	            while (currentChar === ' ') {
	                charIndex++;
	                currentChar = charArray[charIndex];
	            }
	            if (currentChar === ',') {
	                if (lbracketLever <= 1) {
	                    throwError();
	                }
	                charIndex++;
	                currentChar = charArray[charIndex];
	                while (currentChar === ' ') {
	                    charIndex++;
	                    currentChar = charArray[charIndex];
	                }
	                if (currentChar === '[') {
	                    lbracketLever++;
	                    charIndex++;
	                    currentChar = charArray[charIndex];
	                }
	                while (currentChar === ' ') {
	                    charIndex++;
	                    currentChar = charArray[charIndex];
	                }
	            }
	            if (lbracketLever > 1) {
	                lbracketLever--;
	            }
	        }
	        return {_portion: portion, _charIndex: charIndex, _currentChar: currentChar, _lbracketLever: lbracketLever};
	    }
	
	    function parseTableObject(context, charArray, charIndex, currentChar) {
	        var table;
	        var lbracketIndex = 0;
	        var len = charArray.length;
	        while (currentChar !== '[' && charIndex < len) {
	            charIndex++;
	            currentChar = charArray[charIndex];
	        }
	        lbracketIndex = charIndex;
	        if (lbracketIndex > 0) {
	            var tableName = subString(charArray, 0, lbracketIndex);
	            table = context.getTableByName(tableName);
	        } else {
	            table = context.getTableByIndex(context.row, context.column);
	        }
	        return {_table: table, _charIndex: charIndex, _currentChar: currentChar};
	    }
	
	    function throwError() {
	        throw Common._getResource(Calc.SR)().Exp_FormulaInvalid;
	    }
	
	    function getPortionsString(portion, hasColumnSpecifier, toStandard) {
	        switch (portion) {
	            case 1 
	            :
	                return toStandard ? '[#This Row]' : '@';
	            case 2 
	            :
	                return hasColumnSpecifier ? '[#Headers]' : '#Headers';
	            case 3 
	            :
	                return hasColumnSpecifier ? '[#Data]' : '#Data';
	            case 8 
	            :
	                return hasColumnSpecifier ? '[#Totals]' : '#Totals';
	            case 6 
	            :
	                return '[#Headers], [#Data]';
	            case 12 
	            :
	                return '[#Data], [#Totals]';
	            case 14 
	            :
	            case 16 
	            :
	                break;
	            default:
	                break;
	        }
	        return hasColumnSpecifier ? '[#All]' : '#All';
	    }
	
	    var parserPrototype = Calc.Parser.prototype;
	   
	    parserPrototype.parseReferenceExpressionInfos = function (formula, source, baseRow, baseCol, culture, forceA1) {
	        var self = this;
	        self.setParserOption(culture);
	        var tokens = [], charArray = formula.split('');
	        try {
	            var context = source._getSheetSource().getParserContext(forceA1 ? false : source._getCalcServiceInternal().useR1C1, Calc._createCellIdentity(baseRow, baseCol), keyword_null);
	           
	            tokens = self.parseToTokens(context, charArray, false);
	        } catch (ex) {
	        }
	       
	        tokens = fillBlankToTokens(tokens, charArray);
	        return this.getExpressToken(tokens, charArray, source, baseRow, baseCol, forceA1);
	    };
	    function fillBlankToTokens(tokens, charArray) {
	        var offset = 0;
	        var blank;
	        tokens.unshift(new FormulaToken('=', 1 , 0, 0, 0 ));
	        
	        var tokenLen;
	        var refTokens1 = [], index1 = 0;
	        for (var k = tokens.length - 1; k > 0; k--) {
	            if (!(tokens[k]._index === tokens[k - 1]._index && tokens[k]._stringValue === tokens[k - 1]._stringValue)) {
	                refTokens1[index1++] = tokens[k];
	            }
	        }
	        refTokens1[index1++] = tokens[k];
	        refTokens1.reverse();
	
	        var refTokens = [], index = 0;
	        for (var i = 0; i < refTokens1.length - 1; i++, index++) {
	            tokenLen = getTokenLength(refTokens1[i]);
	            refTokens[index] = refTokens1[i];
	            offset = refTokens1[i + 1]._index - refTokens1[i]._index - tokenLen;
	            if (offset > 0) {
	                blank = new FormulaToken(charArray.slice(refTokens1[i]._index + tokenLen, refTokens1[i + 1]._index), 7 , refTokens1[i]._index + tokenLen);
	                refTokens[++index] = blank;
	            }
	        }
	        refTokens[index] = refTokens1[i];
	
	        tokenLen = getTokenLength(refTokens[index]);
	        if (refTokens.length > 0 && charArray.length > refTokens[index]._index + tokenLen) {
	            blank = new FormulaToken(charArray.slice(refTokens[index]._index + tokenLen, charArray.length), 7 , refTokens[index]._index + tokenLen);
	            refTokens[index + 1] = blank;
	        }
	        for (var j = 0; j < refTokens.length; j++) {
	            var tokenVAlue = refTokens[j]._stringValue.trim();
	            if (refTokens[j]._subType === 3 ) {
	                refTokens[j]._stringValue = '"' + refTokens[j]._stringValue + '"';
	            } else if (tokenVAlue === '(' || tokenVAlue === '{') {
	                refTokens[j]._type = 1 ;
	                refTokens[j]._subType = 1 ;
	            } else if (tokenVAlue === ')' || tokenVAlue === '}') {
	                refTokens[j]._type = 1 ;
	                refTokens[j]._subType = 2 ;
	            }
	        }
	        return refTokens;
	    }
	
	    function getTokenLength(token) {
	        if (token._type === 1  && token._stringValue === 'ARRAY') {
	            return 1;
	        }
	        if (token._type === 0  && token._subType === 3 ) {
	           
	            return (token._fullString || token._stringValue).length + 2;
	        }
	        if (token._type === 0   && token._subType === 12 ) {
	            return token._stringValue.length + 3;
	        }
	        return token._stringValue.length;
	    }
	
	    function addSheetRange(sheetRanges, source, range) {
	        if (!sheetRanges || !source) {
	            return;
	        }
	        var name = source.getName && source.getName() || '!';
	        var ranges = sheetRanges[name];
	        if (!ranges) {
	            ranges = sheetRanges[name] = [];
	            if (!sheetRanges.sheets) {
	                sheetRanges.sheets = [];
	            }
	            sheetRanges.sheets.push(name);
	        }
	        ranges.push(range);
	    }
	
	    parserPrototype.getExpressToken = function (refTokens, formula, source, baseRow, baseCol, forceA1) {
	        var context;
	        var evaluateContext = keyword_undefined;
	        var sheetSource = source._getSheetSource();
	        var service = source._getCalcServiceInternal();
	        if (service) {
	            context = new SheetsCalc.SheetParserContext(source, forceA1 ? false : service.useR1C1, Calc._createCellIdentity(baseRow, baseCol));
	            evaluateContext = new Calc.EvaluateContext(sheetSource, Calc._createCellIdentity(baseRow, baseCol), false);
	        } else {
	            context = new Calc.ParserContext(keyword_null, false, Calc._createCellIdentity(0, 0));
	        }
	        context.ignoreError = true;
	        var newTokens = [];
	       
	        for (var refIndex = 0; refIndex < refTokens.length; refIndex++) {
	            try {
	                var token = refTokens[refIndex];
	                if (token._stringValue === '[' || token._value[0] === '#' || token._subType === 3 ) {
	                    newTokens.push({
	                        text: token._fullString || token._stringValue,
	                        type: token._type,
	                        subType: token._subType,
	                        canDrag: false,
	                        ranges: token.ranges,
	                        value: token._stringValue
	                    });
	                    continue;
	                }
	                var exprInfos = [];
	                refIndex = this.buildExpressionInfo(context, refTokens, refIndex, exprInfos);
	                var canDrage;
	                if (exprInfos.length > 0) {
	                    for (var i = 0; i < exprInfos.length; i++) {
	                        var info = exprInfos[i];
	                        if (info instanceof FormulaToken) {
	                            newTokens.push({
	                                text: formula.slice(info._index, info._endIndex + 1).join(''),
	                                type: info._type,
	                                subType: info._subType,
	                                canDrag: canDrage,
	                                ranges: [],
	                                value: info._stringValue
	                            });
	                        } else if (info._expr) {
	                            var expr = info._expr;
	                            var exprString = formula.slice(info._index, info._endIndex + 1).join('');
	                            var ranges = [], sheetRanges = {};
	                            canDrage = true;
	                            var cellRange = expr.getRange && expr.getRange(baseRow, baseCol);
	                            if (expr.type === 8 ) {
	                                canDrage = false;
	                                if (evaluateContext) {
	                                    var nameRef = evaluateContext.getName(expr.value);
	                                    getRanges(nameRef, ranges, sheetRanges, evaluateContext, baseRow, baseCol);
	                                }
	                            } else if (expr.type === 13 ) {
	                                canDrage = false;
	                                if (expr.source() === sheetSource && cellRange) {
	                                    ranges.push(cellRange);
	                                } else {
	                                    ranges = null;
	                                }
	                                addSheetRange(sheetRanges, expr.source(), cellRange);
	                            } else if (expr.type === 1 ) {
	                                if (expr.endSource) {
	                                    var startSource = expr.source, endSource = expr.endSource;
	                                    var sources = startSource.getSources(endSource);
	                                    for (i = 0; i < sources.length; i++) {
	                                        if (sources[i] === sheetSource) {
	                                            ranges.push(cellRange);
	                                            break;
	                                        }
	                                        addSheetRange(sheetRanges, sources[i], cellRange);
	                                    }
	                                } else {
	                                    addSheetRange(sheetRanges, expr.source || sheetSource, cellRange);
	                                    if (!expr.source || expr.source === sheetSource) {
	                                        ranges.push(cellRange);
	                                    }
	                                }
	                            } else {
	                                ranges = null;
	                            }
	                            if (ranges && ranges.length > 0) {
	                                newTokens.push({
	                                    text: exprString,
	                                    type: 0 ,
	                                    subType: 7 ,
	                                    canDrag: canDrage,
	                                    ranges: ranges,
	                                    value: exprString,
	                                    sheetRanges: sheetRanges
	                                });
	                            } else {
	                                newTokens.push({
	                                    text: exprString,
	                                    type: token._type,
	                                    subType: token._subType,
	                                    canDrag: canDrage,
	                                    ranges: ranges,
	                                    value: exprString,
	                                    sheetRanges: sheetRanges
	                                });
	                            }
	                        }
	                    }
	                } else {
	                    newTokens.push({
	                        text: token._stringValue,
	                        type: token._type,
	                        subType: token._subType,
	                        canDrag: false,
	                        ranges: token.ranges,
	                        value: token._stringValue
	                    });
	                }
	            } catch (e) {
	                newTokens.push({
	                    text: token._stringValue,
	                    type: token._type,
	                    subType: token._subType,
	                    canDrag: false,
	                    ranges: token.ranges,
	                    value: token._stringValue
	                });
	            }
	        }
	        return newTokens;
	    };
	    function getRanges(expr, ranges, sheetRanges, evaluateContext, baseRow, baseCol) {
	        if (!expr) {
	            return;
	        }
	        while (expr.type === 10 ) {
	            expr = expr.value;
	        }
	        var cellRange;
	        if (expr.type === 12 ) {
	            var expendExpr = expr;
	            expr = expendExpr.value;
	        }
	        if (expr.type >= 2 && expr.type <= 6) {
	        } else if (expr.type === 1 ) {
	            cellRange = expr.getRange(baseRow, baseCol);
	            if (evaluateContext.source && (!expr.source || expr.source === evaluateContext.source)) {
	                ranges.push(cellRange);
	            }
	            addSheetRange(sheetRanges, expr.source || evaluateContext.source, cellRange);
	        } else if (expr.type === 13 ) {
	            cellRange = expr.getRange(baseRow, baseCol);
	            if (expr.source() === evaluateContext.source && cellRange) {
	                ranges.push(cellRange);
	            }
	            addSheetRange(sheetRanges, expr.source() || evaluateContext.source, cellRange);
	        } else if (expr.type === 8 ) {
	            var nameContext = keyword_null;
	            if (!expr.source) {
	                nameContext = evaluateContext;
	            } else if ((expr.source._getCalcServiceInternal())) {
	                nameContext = new Calc.EvaluateContext(expr.source, false, Calc._createCellIdentity(baseRow, baseCol));
	            }
	            getRanges(nameContext.getName(expr.value), ranges, sheetRanges, nameContext, baseRow, baseCol);
	        } else if (expr.type === 9 ) {
	            getRanges(expr.value, ranges, sheetRanges, evaluateContext, baseRow, baseCol);
	            if (expr.value2) {
	                getRanges(expr.value2, ranges, sheetRanges, evaluateContext, baseRow, baseCol);
	            }
	        } else if (expr.type === 7 ) {
	            for (var i = 0; i < expr.arguments.length; i++) {
	                getRanges(expr.arguments[i], ranges, sheetRanges, evaluateContext, baseRow, baseCol);
	            }
	        }
	    }
	
	    parserPrototype.buildExpressionInfo = function (context, tokens, tokenIndex, list) {
	        var token = tokens[tokenIndex];
	        if (!token || typeof token === 'function' || token._type !== 0 ) {
	            return tokenIndex;
	        }
	        var exprs = [];
	        var endTokenIndex = this.resolveToken(context, tokens, exprs, tokenIndex) - 1;
	        var expression = exprs[0];
	        if (expression.type === 1  || expression.type === 13 
	            || expression.type === 8  || expression.type === 5  && expression.source) {
	            var endToken = tokens[endTokenIndex];
	            var info = {_index: token._index, _endIndex: endToken._endIndex, _expr: expression};
	            list.push(info);
	            return endTokenIndex;
	        }
	        return tokenIndex;
	    };
	}());

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	    
	    var Common = __webpack_require__(5);
	    var Calc = __webpack_require__(2);
	    var Core = __webpack_require__(1);
	    var util_common = __webpack_require__(3).util;
	    var SheetsCalc = Core.CalcEngine = {};
	    Core._supportsCalc = true;
	    var Types = Common._Types, stringHelper = Common._StringHelper;
	    var _DateTimeHelper = Common._DateTimeHelper;
	    var extend = Types._extend;
	    var isEmptyObject = Types._isEmptyObject;
	    var keyword_null = null, keyword_undefined = void 0;
	    var CalcValueTypeStrings = ['v', 'n', 's', 'b', 'd', 'sn'];
	    var CalcErrorsValue = Calc.Errors.Value;
	    var Formatter = __webpack_require__(6);
	    var GeneralFormatter = Formatter && Formatter.GeneralFormatter;
	    var inherit = Types._inherit;
	    var isNumeric = function (value) {
	        return Calc.Convert._isNumber(value, true);
	    };    
	    var Convert = Calc.Convert;
	    var isError = Convert._isError;
	    var range_contains = Core.Range.prototype.contains;
	    var toUpperCase = Common._StringHelper._toUpperCase;
	
	    var Math_abs = Math.abs, Math_min = Math.min;
	    var BAND_INDEX_CONST = Calc.BAND_INDEX_CONST = -2147483648, MAX_ROW_COUNT = Calc.MAX_ROW_COUNT = 1048576,
	        MAX_COLUMN_COUNT = Calc.MAX_COLUMN_COUNT = 16384;
	    
	    var cellListeners = 'cellListeners', rowListeners = 'rowListeners', columnListeners = 'columnListeners',
	        rowSliceListeners = 'rowSliceListeners', nameIDListeners = 'nameIDListeners';
	    
	    var createCellIdentity = Calc._createCellIdentity = function (row, col) {
	        return { row: row, col: col };
	    };
	    var createRangeIdentity = Calc._createRangeIdentity = function (row, col, rowCount, colCount) {
	        return { row: row, col: col, rowCount: rowCount, colCount: colCount };
	    };
	    var createCellExpression = Calc._createCellExpression = function (source, endSource, row, col, rowRelative, columnRelative) {
	        var expr = new ReferenceExpression(1 );
	        expr.row = row;
	        expr.column = col;
	        expr.rowRelative = rowRelative;
	        expr.columnRelative = columnRelative;
	        if (source) {
	            expr.source = source;
	        }
	        if (endSource) {
	            expr.endSource = endSource;
	        }
	        return expr;
	    };
	    var createRangeExpression = Calc._createRangeExpression = function (source, endSource, row, col, endRow, endCol, rowRelative, columnRelative, endRowRelative, endColumnRelative) {
	        var expr = new ReferenceExpression(1 ), tmp;
	        expr.isFullRow = col === BAND_INDEX_CONST;
	        if (expr.isFullRow && row === 0 && endRow === Calc.MAX_ROW_COUNT - 1) {
	            row = endRow = BAND_INDEX_CONST;
	        }
	        expr.isFullColumn = row === BAND_INDEX_CONST;
	        if (row > endRow) {
	            tmp = row;
	            row = endRow;
	            endRow = tmp;
	            tmp = rowRelative;
	            rowRelative = endRowRelative;
	            endRowRelative = tmp;
	        }
	        if (col > endCol) {
	            tmp = col;
	            col = endCol;
	            endCol = tmp;
	            tmp = columnRelative;
	            columnRelative = endColumnRelative;
	            endColumnRelative = tmp;
	        }
	        expr.row = row;
	        expr.column = col;
	        expr.endRow = endRow;
	        expr.endColumn = endCol;
	        expr.rowRelative = rowRelative;
	        expr.columnRelative = columnRelative;
	        expr.endRowRelative = endRowRelative;
	        expr.endColumnRelative = endColumnRelative;
	        if (source) {
	            expr.source = source;
	        }
	        if (endSource) {
	            expr.endSource = endSource;
	        }
	        return expr;
	    };
	    
	    var createOperatorExpression = Calc._createOperatorExpression;
	    var createParenthesesExpression = Calc._createParenthesesExpression;
	    var createFunctionExpression = Calc._createFunctionExpression;
	    var createErrorExpression = Calc._createErrorExpression;
	    var createExpandExpression = Calc.createExpandExpression;
	    var createStringExpression = Calc.createStringExpression;
	    var createNumberExpression = Calc.createNumberExpression;
	    var CalcErrorsReference = Calc.Errors.Reference;
	    var CalcErrorsNotAvailable = Calc.Errors.NotAvailable;
	    var CalcErrorsName = Calc.Errors.Name;
	    var addElements = Common._addElements;
	    var deleteElements = Common._deleteElements;
	    var CalcReference = Calc.CalcReference;
	
	    Calc.supportRowColumnFormula = false;
	
	    var Worksheet = __webpack_require__(17).Worksheet;
	
	    extend(Calc.CalcService.prototype, {
	        parse: function (source, formula, row, col, culture, ignoreError, forceA1) {
	            var self = this, parseCache = self._parseCache, parseContext = self.getParserContext(source);
	            parseContext.useR1C1 = forceA1 ? false : self.useR1C1;
	            parseContext.ignoreError = ignoreError;
	            parseContext.row = row;
	            parseContext.column = col;
	            parseContext.culture = culture;
	            if (parseCache) {
	                if (!parseContext.useR1C1) {
	                    parseContext.useR1C1 = true;
	                    formula = self._parser.a1ToR1C1(parseContext, formula);
	                }
	                var cache = parseCache[formula];
	                if (cache) {
	                    return cache;
	                }
	
	                var expr = self._parser.parse(parseContext, formula);
	                parseCache[formula] = expr;
	                return expr;
	            }
	            return self._parser.parse(parseContext, formula);
	        },
	        unparse: function (source, expr, row, col, culture, toStandard) {
	            var parseContext = this.getParserContext(source);
	            parseContext.useR1C1 = this.useR1C1;
	            parseContext.row = row;
	            parseContext.column = col;
	            parseContext.culture = culture;
	            if (toStandard) {
	                parseContext._toStandard = true;
	                parseContext.useR1C1 = false;
	            }
	            var formula = this._parser.unparse(parseContext, expr);
	            parseContext._toStandard = false;
	            return formula;
	        },
	        recalculate: function (source, row, column, isAyncEvaluate) {
	            var model = this.getSourceModel(source);
	            if (column === -1) {
	                model._addCellsToDirty(row, 0, 1, model.cC());
	            } else if (row === -1) {
	                model._addCellsToDirty(0, column, model.rC(), 1);
	            } else {
	                model._addCellsToDirty(row, column, 1, 1);
	            }
	            if (!this.IsSuspended()) {
	                this.recalculateAll(false, isAyncEvaluate);
	            }
	        },
	        
	        recalculateByName: function (source, name) {
	            if (!name) {
	                return;
	            }
	            var model = this.getSourceModel(source);
	            var cellCalc = model._getNameIDCalc(toUpperCase(name), true);
	            this._addDirty(cellCalc, 3 );
	            if (!this.IsSuspended()) {
	                this.recalculateAll(false);
	            }
	        },
	        recalcRange: function (source, row, column, rowCount, columnCount) {
	            var model = this.getSourceModel(source);
	            if (column === -1) {
	                model._addCellsToDirty(row, 0, rowCount, model.cC());
	            } else if (row === -1) {
	                model._addCellsToDirty(0, column, model.rC(), columnCount);
	            } else {
	                model._addCellsToDirty(row, column, rowCount, columnCount);
	            }
	            if (!this.IsSuspended()) {
	                this.recalculateAll(false);
	            }
	        },
	        evaluate: function (source, formula, row, col) {
	            var self = this;
	            var expr = (formula instanceof Calc.Expression) ? formula : self.parse(source, formula, row, col);
	            return self._evaluator.evaluateExpression(expr, source.getEvaluatorContext(createCellIdentity(row, col), false), false);
	        },
	        _evaluateParsedFormula: function (source, expr, identity, isArrayFormula, convertNullToZero, rangeIdentity) {
	            var row = identity.row || 0, col = identity.col || 0, baseRow = rangeIdentity ? rangeIdentity.row : row,
	                baseCol = rangeIdentity ? rangeIdentity.col : col;
	            var evalContext = source.getEvaluatorContext(identity, isArrayFormula, rangeIdentity);
	            var val, acceptsArrayAndReference = arguments.length === 4 && isArrayFormula;
	            val = this._evaluator.evaluateExpression(expr, evalContext, convertNullToZero, acceptsArrayAndReference, acceptsArrayAndReference);
	            if (isArrayFormula && arguments.length <= 5) {
	                return val;
	            }
	            if (Convert._isReference(val)) {
	                var rc = val.getRowCount(0), cc = val.getColumnCount(0);
	                if (val.getRangeCount() !== 1) {
	                    return CalcErrorsValue;
	                }
	                try {
	                    var ro = isArrayFormula ? row - baseRow : row - val.getRow(0),
	                        co = isArrayFormula ? col - baseCol : col - val.getColumn(0), id1 = createCellIdentity(0, 0);
	                    if (rc === 1 && cc === 1) {
	                    } else if (rc === 1 && cc > 1 && co >= 0 && co < cc) {
	                        id1.col = co;
	                    } else if (rc > 1 && cc === 1 && ro >= 0 && ro < rc) {
	                        id1.row = ro;
	                    } else if (isArrayFormula && ro < rc && co < cc) {
	                        id1.row = ro;
	                        id1.col = co;
	                    } else if (isArrayFormula) {
	                        return CalcErrorsNotAvailable;
	                    } else {
	                        return CalcErrorsValue;
	                    }
	                    val = val.getValue(id1, 0);
	                } catch (iex) {
	                    return CalcErrorsValue;
	                }
	            } else if (Convert._isArray(val)) {
	                if (!isArrayFormula) {
	                    val = val.getValueByIndex(0);
	                } else {
	                    var arrayValue = val;
	                    var rc1 = arrayValue.getRowCount();
	                    var cc1 = arrayValue.getColumnCount();
	                    if (rc1 !== 1 && row - baseRow >= rc1 || cc1 !== 1 && col - baseCol >= cc1) {
	                        return CalcErrorsNotAvailable;
	                    }
	                    val = val.getValue(rc1 === 1 ? 0 : row - baseRow, cc1 === 1 ? 0 : col - baseCol);
	                }
	            }
	            if (val === keyword_undefined || val === keyword_null) {
	                return convertNullToZero === false ? val : 0;
	            }
	            return val;
	        },
	    });
	
	    var SheetRangeReference = SheetsCalc.SheetRangeReference = (function (_super) {
	        inherit(SheetRangeReference, _super);
	        function SheetRangeReference(references) {
	            _super.call(this, keyword_null);
	            this.references = references;
	        }
	
	        SheetRangeReference.prototype.toArray = function (valueType, toOneDimension, breakOnError, breakOnConvertError, ignoreBlank) {
	            var references = this.references;
	            var result = [];
	            for (var i = 0; i < references.length; i++) {
	                var arr = references[i]._source.referenceToArray(references[i], valueType, toOneDimension, breakOnError, breakOnConvertError, ignoreBlank);
	                if (arr.isError && breakOnError) {
	                    return arr;
	                }
	                if (toOneDimension) {
	                    Array.prototype.push.apply(result, arr);
	                } else {
	                    result.push(arr[0]);
	                }
	                if (!i) {
	                    result.rowCount = arr.rowCount;
	                    result.colCount = arr.colCount;
	                }
	            }
	            result.rangeCount = references.length;
	            return result;
	        };
	        return SheetRangeReference;
	    })(Calc.CalcReference);
	
	    var SheetParserContext = SheetsCalc.SheetParserContext = (function (_super) {
	        inherit(SheetParserContext, _super);
	        function SheetParserContext(sheet, useR1C1, identity, option) {
	            _super.call(this, sheet && sheet._getSheetSource(), useR1C1, identity, option);
	           
	           
	            if (!sheet) {
	                sheet = new Worksheet();
	            }
	            this._sheet = sheet;
	            this.row = identity && identity.row || 0;
	            this.column = identity && identity.col || 0;
	           
	            var service = sheet.getCalcService();
	            var resolves = service.getResolvers();
	            for (var i = 0; i < resolves.length; i++) {
	                if (resolves[i] instanceof SheetsCalc.SheetReferenceResolver) {
	                    return;
	                }
	            }
	
	            service.addResolver(new SheetsCalc.SheetReferenceResolver(sheet));
	            service.addResolver(new SheetsCalc.StructureReferenceResolver(sheet));
	        }
	
	        return SheetParserContext;
	    })(Calc.ParserContext);
	    extend(SheetParserContext.prototype, {
	        getExternalSource: function (bookName, sheetName) {
	            var self = this;
	            var workbook = self._sheet.parent;
	            if (bookName && (!workbook || workbook.name !== bookName)) {
	               
	                return keyword_null;
	            } else if (!workbook) {
	                return stringHelper._compareStringIgnoreCase(self._sheet.name(), sheetName) ? self._sheet._getSheetSource() : keyword_null;
	            }
	            var sc = workbook.sheets;
	            if (sc && sc.length > 0) {
	                for (var i = 0; i < sc.length; i++) {
	                    var sheet = sc[i];
	                    if (stringHelper._compareStringIgnoreCase(sheet.name(), sheetName)) {
	                        return sheet._getSheetSource();
	                    }
	                }
	            }
	
	            return Calc.ParserContext.prototype.getExternalSource.call(this, bookName, sheetName);
	        },
	        
	        getExternalSourceToken: function (source) {
	            return source.getName();
	        },
	        getTableByName: function (name) {
	            var tm = this._sheet.tables, table;
	            table = tm ? tm.findByName(name) : keyword_null;
	            if (!table) {
	                var sheets = this._sheet.parent && this._sheet.parent.sheets;
	                if (sheets) {
	                    for (var i = 0; i < sheets.length; i++) {
	                        tm = sheets[i].tables;
	                        if (tm) { 
	                            table = tm.findByName(name);
	                            if (table) {
	                                break;
	                            }
	                        }
	                    }
	                }
	            }
	            return table;
	        },
	        getTableByIndex: function (rowIndex, columnIndex) {
	            var tm = this._sheet.tables;
	            return tm ? tm.find(rowIndex, columnIndex) : keyword_null;
	        },
	        setSource: function (source) {
	            this.source = source;
	            if (source && source.getSheet) {
	                this._sheet = source.getSheet();
	            }
	        }
	    });
	
	    var getRangeForReference = Calc.getRangeForReference = function (expr, baseRow, baseColumn) {
	        var range = {
	            row: -1,
	            col: -1,
	            rowCount: -1,
	            colCount: -1
	        }, startRow, endRow, startCol, endCol;
	        if (expr.isFullRow) {
	            range.col = -1;
	            range.colCount = -1;
	        } else {
	            if (expr.columnRelative) {
	                startCol = expr.column + baseColumn;
	                startCol = startCol >= MAX_COLUMN_COUNT ? startCol % MAX_COLUMN_COUNT : startCol;
	            } else {
	                startCol = expr.column;
	            }
	            if (expr._isCell()) {
	                range.col = startCol;
	                range.colCount = 1;
	            } else {
	
	                if (expr.endColumnRelative) {
	                    endCol = expr.endColumn + baseColumn;
	                    endCol = endCol >= MAX_COLUMN_COUNT ? endCol % MAX_COLUMN_COUNT : endCol;
	                } else {
	                    endCol = expr.endColumn;
	                }
	                range.col = startCol <= endCol ? startCol : endCol;
	                range.colCount = Math_abs(endCol - startCol) + 1;
	            }
	        }
	        if (expr.isFullColumn) {
	            range.row = -1;
	            range.rowCount = -1;
	        } else {
	            if (expr.rowRelative) {
	                startRow = expr.row + baseRow;
	                startRow = startRow >= MAX_ROW_COUNT ? startRow % MAX_ROW_COUNT : startRow;
	            } else {
	                startRow = expr.row;
	            }
	            if (expr._isCell()) {
	                range.row = startRow;
	                range.rowCount = 1;
	            } else {
	                if (expr.endRowRelative) {
	                    endRow = expr.endRow + baseRow;
	                    endRow = endRow >= MAX_ROW_COUNT ? endRow % MAX_ROW_COUNT : endRow;
	                } else {
	                    endRow = expr.endRow;
	                }
	                range.row = startRow <= endRow ? startRow : endRow;
	                range.rowCount = Math_abs(endRow - startRow) + 1;
	            }
	        }
	        return range;
	    };
	
	    var isNullOrUndefined = Types._isNullOrUndefined;
	    var sR = function () {
	        return Common._getResource(Calc.SR)();
	    };
	    var createRange = Calc._createRange = function (row, col, rowCount, colCount) {
	        return { row: row, col: col, rowCount: rowCount, colCount: colCount };
	    };
	
	    var ReferenceExpression = Calc.ReferenceExpression = (function (_super) {
	        inherit(ReferenceExpression, _super);
	        function ReferenceExpression(type) {
	            _super.call(this, type);
	            var self = this;
	            self._isCell = function () {
	                return self.endRow === keyword_undefined || self.endColumn === keyword_undefined;
	            };
	            self._getRangeType = function () {
	                if (self.isFullRow && self.isFullColumn) {
	                    return 3 ;
	                } else if (self.isFullRow) {
	                    return 1 ;
	                } else if (self.isFullColumn) {
	                    return 2 ;
	                }
	                return 0 ;
	            };
	            self.getRange = function (baseRow, baseColumn) {
	                return getRangeForReference(self, baseRow, baseColumn);
	            };
	            self.offset = function (row, col, offsetAbsolute) {
	                if (self._isCell()) {
	                    return createCellExpression(self.source, self.endSource,
	                        self.row + ((self.rowRelative || offsetAbsolute) ? row : 0),
	                        self.column + ((self.columnRelative || offsetAbsolute) ? col : 0),
	                        self.rowRelative, self.columnRelative);
	                }
	                var newExpr = createRangeExpression(self.source, self.endSource,
	                    self.row + ((self.rowRelative || offsetAbsolute) ? row : 0),
	                    self.column + ((self.columnRelative || offsetAbsolute) ? col : 0),
	                    self.endRow + (!self.isFullColumn && (self.endRowRelative || offsetAbsolute) ? row : 0),
	                    self.endColumn + (!self.isFullRow && (self.endColumnRelative || offsetAbsolute) ? col : 0),
	                    self.rowRelative, self.columnRelative, self.endRowRelative, self.endColumnRelative);
	                newExpr.isFullRow = self.isFullRow;
	                newExpr.isFullColumn = self.isFullColumn;
	                return newExpr;
	            };
	            self.offset2 = function (row, col, endRow, endCol) {
	                var newExpr = createRangeExpression(self.source, self.endSource,
	                    self.row + (!self.isFullColumn ? row : 0),
	                    self.column + (!self.isFullRow ? col : 0),
	                    self.endRow + (!self.isFullColumn ? endRow : 0),
	                    self.endColumn + (!self.isFullRow ? endCol : 0),
	                    self.rowRelative, self.columnRelative, self.endRowRelative, self.endColumnRelative);
	                newExpr.isFullRow = self.isFullRow;
	                newExpr.isFullColumn = self.isFullColumn;
	                return newExpr;
	            };
	        }
	
	        return ReferenceExpression;
	    })(Calc.Expression);
	    extend(ReferenceExpression.prototype, {
	        offset: function (row, col, offsetAbsolute) {
	            var self = this;
	            var exprType = self.type;
	            if (exprType === 10 ) {
	                return createParenthesesExpression(self.value.offset(row, col, offsetAbsolute));
	            } else if (exprType === 7 ) {
	                var args = self.arguments, newArgs = [];
	                for (var i = 0; i < args.length; i++) {
	                    newArgs.push(args[i].offset(row, col, offsetAbsolute));
	                }
	                return createFunctionExpression(self.function, newArgs) ;
	            } else if (exprType === 9 ) {
	                return createOperatorExpression(self.operatorType, self.value.offset(row, col, offsetAbsolute), self.value2 && self.value2.offset(row, col, offsetAbsolute)) ;
	            }
	            return this;
	        }
	    });
	
	    extend(Calc.CalcReference.prototype, {
	        getRow: function (identityIndex) {
	            return this._identities ? this._identities[identityIndex || 0].row : 0;
	        },
	        getColumn: function (identityIndex) {
	            return this._identities ? this._identities[identityIndex || 0].col : 0;
	        },
	        getRowCount: function (identityIndex) {
	            return this._identities ? this._identities[identityIndex || 0].rowCount : this._source.getRowCount();
	        },
	        getColumnCount: function (identityIndex) {
	            return this._identities ? this._identities[identityIndex || 0].colCount : this._source.getColumnCount();
	        },
	        getValue: function (offsetIdentity, identityIndex) {
	            var rowOffset, columnOffset;
	            if (offsetIdentity.row !== keyword_undefined) {
	                rowOffset = offsetIdentity.row;
	                columnOffset = offsetIdentity.col;
	            } else {
	                rowOffset = arguments[1];
	                columnOffset = arguments[2];
	                identityIndex = arguments[0];
	            }
	            identityIndex = identityIndex || 0;
	            if (rowOffset >= 0 || columnOffset >= 0) {
	                var ranges = this._identities;
	                if (!ranges) {
	                    return this._source.getValue(rowOffset, columnOffset);
	                } else if (identityIndex < ranges.length) {
	                    return this._source.getValue(rowOffset + ranges[identityIndex].row, columnOffset + ranges[identityIndex].col);
	                }
	            }
	            return CalcErrorsReference;
	        },
	        getValueByIndex: function (index) {
	            var cc = this.getColumnCount(),
	                r = Math.floor(index / cc),
	                c = index % cc;
	            return this.getValue(r, c);
	        },
	        isHiddenRow: function (identityIndex, rowOffset, onlyFiltered) {
	            return this._source.isHiddenRow(rowOffset + this.getRow(identityIndex), onlyFiltered);
	        },
	        isSubtotal: function (identityIndex, rowOffset, columnOffset) {
	            var sheetSource = this._source;
	            if (identityIndex === 0 && rowOffset < sheetSource.getRowCount() && columnOffset < sheetSource.getColumnCount()) {
	                var expr = sheetSource.getCalcSourceModel()._getExpressionWithRowColumn(rowOffset, columnOffset);
	                return expr && expr.type === 7  && (expr.functionName === 'SUBTOTAL' || expr.functionName === 'AGGREGATE');
	            }
	            return false;
	        }
	    });
	
	    extend(Calc.CalcSource.prototype, {
	        referenceToArray: function (reference, valueType, toOneDimension, breakOnError, breakOnConvertError, ignoreBlank) {
	            var self = this, row, col, rowCount = 1, colCount = 1, startRow, startCol, rangeCount, result = [], value,
	                rowValues;
	            rangeCount = reference.getRangeCount();
	            if (rangeCount === 0) {
	                result.isError = true;
	                return result;
	            }
	            var maxRowCount = self.getRowCount(), maxColCount = self.getColumnCount();
	            toOneDimension = toOneDimension === keyword_undefined ? true : toOneDimension;
	            for (var rangeIndex = 0; rangeIndex < rangeCount; rangeIndex++) {
	                if (!toOneDimension) {
	                    rowValues = [];
	                    result.push(rowValues);
	                }
	                rowCount = reference.getRowCount(rangeIndex);
	                if (rowCount === 0) {
	                    result.isError = true;
	                    return result;
	                }
	                colCount = reference.getColumnCount(rangeIndex);
	                if (colCount === 0) {
	                    result.isError = true;
	                    return result;
	                }
	                startRow = reference.getRow(rangeIndex);
	                startCol = reference.getColumn(rangeIndex);
	                if (startRow >= maxRowCount || startCol >= maxColCount) {
	                    result = [keyword_null];
	                    result.rowCount = 1;
	                    result.colCount = 1;
	                    result.rangeCount = 1;
	                    return result;
	                }
	                if (startRow + rowCount > maxRowCount) {
	                    rowCount = maxRowCount - startRow;
	                }
	                if (startCol + colCount > maxColCount) {
	                    colCount = maxColCount - startCol;
	                }
	               
	               
	               
	               
	               
	                var colValues;
	                for (var i = 0; i < rowCount; i++) {
	                    row = startRow + i;
	                    if (!toOneDimension) {
	                        colValues = [];
	                        rowValues.push(colValues);
	                    }
	                    for (var j = 0; j < colCount; j++) {
	                        col = startCol + j;
	                        value = self.getValue(row, col);
	                        if (breakOnError && Convert._isError(value)) {
	                            result = [value];
	                            result.isError = true;
	                            return result;
	                        }
	                        value = Convert._convertValue(value, valueType, true, ignoreBlank);
	                        if (breakOnConvertError && value === Convert.CalcConvertedError) {
	                            result = [CalcErrorsValue];
	                            result.isError = true;
	                            return result;
	                        }
	                        if (value === keyword_null && ignoreBlank) {
	                        } else if (toOneDimension) {
	                            result.push(value);
	                        } else {
	                            colValues.push(value);
	                        }
	                    }
	                }
	            }
	            if (!toOneDimension && rangeCount === 1) {
	                result = result[0];
	            }
	            result.rowCount = rowCount;
	            result.colCount = colCount;
	            result.rangeCount = rangeCount;
	            return result;
	        },
	        getSheetReference: function () {
	            var self = this;
	            self._reference = self._reference || (new CalcReference(self));
	            return self._reference;
	        }
	    });
	
	    function shouldUseRange(row, col, rowCount, colCount) {
	        return (row === -1 && colCount > 127) || (col === -1 && rowCount > 127) || (rowCount * colCount > 127);
	    }
	
	    var CalcSourceModel = Calc.CalcSourceModel = (function () {
	        
	        function CalcSourceModel(service, source) {
	            var self = this;
	            self._lastNonNullRow = 0;
	            self._lastNonNullColumn = 0;
	            self._volatitleCells = [];
	            self.dataTable = {};
	            self.dataTableByName = {};
	            self._rowDataArray = [];
	            self._columnDataArray = [];
	            self._defaultDataNode = keyword_null;
	            self._source = source;
	            self._service = service;
	            self._removedVolatileCount = 0;
	        }
	
	        return CalcSourceModel;
	    })();
	
	    CalcSourceModel.prototype = {
	        getNode: function (row, col, create) {
	            var self = this;
	            var node = keyword_null;
	            if (row >= 0 && col >= 0) {
	                var dr = self.dataTable[row];
	                if (create && !dr) {
	                    dr = self.dataTable[row] = {};
	                    if (row > self._lastNonNullRow) {
	                        self._lastNonNullRow = row;
	                    }
	                }
	                if (dr) {
	                    node = dr[col];
	                    if (create && !node) {
	                        node = dr[col] = {};
	                        if (col > self._lastNonNullColumn) {
	                            self._lastNonNullColumn = col;
	                        }
	                    }
	                }
	            } else if (row === -1 && col >= 0) {
	                node = self._columnDataArray[col];
	                if (create && !node) {
	                    node = self._columnDataArray[col] = {};
	                    if (col > self._lastNonNullColumn) {
	                        self._lastNonNullColumn = col;
	                    }
	                }
	            } else if (row >= 0 && col === -1) {
	                node = self._rowDataArray[row];
	                if (create && !node) {
	                    node = self._rowDataArray[row] = {};
	                    if (col > self._lastNonNullColumn) {
	                        self._lastNonNullColumn = col;
	                    }
	                }
	            } else if (row === -1 && col === -1) {
	                node = self._defaultDataNode;
	                if (create && !node) {
	                    node = self._defaultDataNode = {};
	                }
	            }
	            return node;
	        },
	        getNodeByName: function (name, create) {
	            var self = this;
	            var node = self.dataTableByName[name];
	            if (create && !node) {
	                node = self.dataTableByName[name] = {};
	            }
	            return node;
	        },
	        _getExpr: function (row, col) {
	            var node = this.getNode(row, col);
	            return (node && node._expr);
	        },
	        _getWorkingExpr: function (row, col) {
	            var node = this.getNode(row, col);
	            return (node && node._workingExpr);
	        },
	        _getArrayInfo: function (row, col) {
	            return this.getWorkingNodeInfo(row, col, 2 );
	        },
	        _getWorkingExpressionWithRowColumn: function (row, col) {
	            return this.getWorkingNodeInfo(row, col, 1 );
	        },
	        _getExpressionWithRowColumn: function (row, col) {
	            return this.getWorkingNodeInfo(row, col, 0 );
	        },
	        _getWorkingExpressionWithRowColumnByName: function (name) {
	            var node = this.getNodeByName(name);
	            return node && node._workingExpr;
	        },
	        _getExpressionWithRowColumnByName: function (name) {
	            var node = this.getNodeByName(name);
	            return node && node._expr;
	        },
	        clearAll: function () {
	            var self = this;
	            self.clear(-1, -1, -1, -1);
	            self.dataTable = {};
	            self.dataTableByName = {};
	            self._rowDataArray = [];
	            self._columnDataArray = [];
	            self._defaultDataNode = keyword_null;
	        },
	        clear: function (row, column, rowCount, columnCount, changeInfo) {
	            this._clear(row, column, rowCount, columnCount, changeInfo);
	        },
	        addRows: function (row, count) {
	            var self = this;
	            var rowCount = self.rC();
	            if (row < 0 || row > rowCount || count < 0) {
	                return;
	            }
	            addElements(self.dataTable, rowCount, row, count);
	            addElements(self._rowDataArray, rowCount, row, count);
	            for (var i = 0; i < count; i++) {
	                if (self.dataTable[row + i]) {
	                    self.dataTable[row + i] = { rs: 'n' };
	                }
	            }
	        },
	        deleteRows: function (row, count) {
	            var self = this;
	            var n = self.rC();
	            if (row < 0 || row >= n || count <= 0) {
	                return;
	            }
	            if (row + count > n) {
	                count = n - row;
	            }
	            deleteElements(self.dataTable, n, row, count);
	            deleteElements(self._rowDataArray, n, row, count);
	        },
	        addColumns: function (col, count) {
	            var self = this;
	            var rowCount = self.rC(), colCount = self.cC();
	            if (col < 0 || col > colCount || count < 0) {
	                return;
	            }
	            for (var i = 0; i < rowCount; i++) {
	                var tr = self.dataTable[i];
	                if (tr && col < colCount) {
	                    addElements(tr, colCount, col, count);
	                }
	            }
	            addElements(this._columnDataArray, colCount, col, count);
	        },
	        deleteColumns: function (col, count) {
	            var self = this;
	            var rowCount = self.rC(), colCount = self.cC();
	            if (col < 0 || col >= colCount || count < 0) {
	                return;
	            }
	            for (var i = 0; i < rowCount; i++) {
	                var tr = this.dataTable[i];
	                if (tr) {
	                    deleteElements(tr, colCount, col, count);
	                }
	            }
	            deleteElements(this._columnDataArray, colCount, col, count);
	        },
	        _getNodeInfo: function (row, col) {
	            var result = [row, col];
	            var node = this.getNode(row, col);
	            if (node) {
	                result.push(node._expr, node._workingExpr, node._arrayInfo);
	            }
	            return result;
	        },
	        _backupNodeItem: function (changeInfo, row, col) {
	            if (changeInfo) {
	                changeInfo.push(this._getNodeInfo(row, col));
	            }
	        },
	        _getChangesForCalcEngine: function () {
	            return this.getSource().getSheet()._modelManager._getChangesForCalcEngine();
	        },
	        _restoreNodeItem: function (row, col, expr, workingExpr, arrayInfo) {
	            var self = this;
	            if (row === -1) {
	                self._setColumnExpression(col, expr, workingExpr);
	            } else if (col === -1) {
	                self._setRowExpression(row, expr, workingExpr);
	            } else {
	                self._setCellExpression(row, col, expr, workingExpr, arrayInfo);
	            }
	        },
	        _setExpr: function (row, col, expr, changeInfo) {
	            var node = this.getNode(row, col, !!expr);
	            if (node) {
	                if (changeInfo) {
	                    changeInfo.push([row, col, node._expr]);
	                   
	                }
	                node._expr = expr;
	            }
	        },
	        _setNodeInfo: function (row, col, expr, workingExpr, arrayInfo, isVolatile, changeInfo) {
	            var node = this.getNode(row, col, !!expr);
	            if (node) {
	                this._backupNodeItem(changeInfo, row, col);
	                node._expr = expr;
	                if (node._workingExpr || workingExpr) {
	                    node._workingExpr = workingExpr;
	                }
	                if (node._arrayInfo || arrayInfo) {
	                    node._arrayInfo = arrayInfo;
	                }
	                if (node.isVolatile && !expr) {
	                    this._removeVolatile(node);
	                } else if (isVolatile || node.isVolatile) {
	                    node.isVolatile = isVolatile;
	                }
	            }
	        },
	        _clearAllExpr: function (row, col, changeInfo) {
	            this._setNodeInfo(row, col, keyword_undefined , keyword_undefined , keyword_undefined , false , changeInfo);
	        },
	        _copyExpr: function (dest, row, col, desRow, desCol, changeInfo) {
	            var node = this.getNode(row, col);
	            if (node && node._expr) {
	                dest._setNodeInfo(desRow, desCol, node._expr, node._workingExpr, node._arrayInfo, node.isVolatile, changeInfo);
	               
	               
	               
	               
	               
	               
	               
	               
	            }
	           
	           
	           
	        },
	        _containsNode: function (row, col) {
	            var dr = this.dataTable[row];
	            return dr && dr[col];
	        },
	        _setWorkingExpr: function (row, col, expr) {
	            var node = this.getNode(row, col, !!expr);
	            if (node) {
	                node._workingExpr = expr;
	            }
	        },
	        _setArrayInfo: function (row, col, arrayInfo) {
	            var node = this.getNode(row, col, !!arrayInfo);
	            if (node) {
	                node._arrayInfo = arrayInfo;
	            }
	        },
	        _getCalc: function (row, col) {
	            var node = this.getNode(row, col);
	            return (node && node.calc);
	        },
	        _setCalc: function (row, col, calc) {
	            var node = this.getNode(row, col, true);
	            if (node) {
	                if (node.calc && node.calc.isVolatile) {
	                    this._removeVolatile(node);
	                }
	                node.calc = calc;
	                if (calc) {
	                    calc.node = node;
	                }
	            }
	        },
	        _removeCalc: function (row, col, type) {
	            var node = this.getNode(row, col, true);
	            if (node && node.calc) {
	                if (node.calc.isVolatile) {
	                    this._removeVolatile(node);
	                }
	                this._service._removeDirty(node.calc, type);
	                node.calc = keyword_undefined;
	            }
	        },
	        _setNode4Swap: function (or, oc, row, col, node) {
	            var self = this;
	            if (row >= 0 && col >= 0) {
	                var dr = self.dataTable[row];
	                if (!dr) {
	                    dr = self.dataTable[row] = {};
	                }
	                dr[col] = node;
	                if (node && node.calc) {
	                    delete node.calc;
	                }
	            } else if (row >= 0 && col === -1 && or >= 0 && oc === -1) {
	                self._rowDataArray[row] = node;
	            } else if (col >= 0 && row === -1 && oc >= 0 && or === -1) {
	                self._columnDataArray[col] = node;
	            }
	        },
	        _swapNode: function (row, col, row2, col2) {
	            var self = this;
	            var node = self.getNode(row, col);
	            var node2 = self.getNode(row2, col2);
	            if (node && node._expr) {
	                self._setNode4Swap(row, col, row2, col2, node);
	            } else if (node2 && node2._expr) {
	                self._setNode4Swap(row, col, row2, col2, keyword_null);
	            }
	            if (node2 && node2._expr) {
	                self._setNode4Swap(row2, col2, row, col, node2);
	            } else if (node && node._expr) {
	                self._setNode4Swap(row2, col2, row, col, keyword_null);
	            }
	        },
	        _getAllVolatiles: function () {
	            return this._volatitleCells;
	        },
	        _setVolatile: function (calc) {
	            if (!calc.isVolatile) {
	                calc.isVolatile = true;
	                this._volatitleCells.push(calc);
	            }
	        },
	        _removeVolatile: function (calc) {
	            calc.isVolatile = keyword_undefined;
	            var self = this;
	            self._removedVolatileCount++;
	            if (self._removedVolatileCount > 100) {
	                self._removedVolatileCount = 0;
	                var newArray = [];
	                var caches = self._volatitleCells, length = self._volatitleCells.length;
	                for (var i = 0; i < length; i++) {
	                    if (caches[i].isVolatile) {
	                        newArray.push(caches[i]);
	                    }
	                }
	                self._volatitleCells = newArray;
	            }
	        },
	        
	        getCalcService: function () {
	            return this._service;
	        },
	        setCalcService: function (service) {
	            this._service = service;
	        },
	        _getCalcServiceInternal: function () {
	            return this._service;
	        },
	        
	        getSource: function () {
	            return this._source;
	        },
	        hasFormula: function (row, col) {
	            row = row !== keyword_undefined ? row : -1;
	            col = col !== keyword_undefined ? col : -1;
	            return !!this._getExpressionWithRowColumn(row, col);
	        },
	        
	        setFormula: function (row, col, formula, expression, ignoreError, force, changeInfo) {
	            var self = this;
	            if (formula && formula.length === 0) {
	                formula = keyword_null;
	            }
	            if (!ignoreError && self._intersectWithArrayFormula(row, col, 1, 1)) {
	                self._throwArrayPartException();
	            }
	
	            var oldFormula = self.getFormula(row, col);
	            if (force || (oldFormula !== formula) && !((oldFormula === '' && !formula) || (!oldFormula && formula === ''))) {
	                var svc = self._getCalcServiceInternal();
	                var expr = keyword_null;
	                if (svc) {
	                    try {
	                        var fixedRow = row >= 0 ? row : 0;
	                        var fixedCol = col >= 0 ? col : 0;
	                        expr = expression || (formula ? svc.parse(self._source, formula, fixedRow, fixedCol, false, ignoreError, ignoreError) : keyword_null);
	                        self._setExpression(row, col, expr, keyword_undefined, false, changeInfo);
	                    } catch (ex) {
	                        if (!ignoreError) {
	                            throw ex;
	                        }
	                    }
	                }
	               
	                if (row >= 0 && col >= 0) {
	                   
	                   
	                    self._source.setFormula(row, col, formula);
	                }
	            }
	        },
	        
	        getFormula: function (row, col, culture) {
	            var svc = this._getCalcServiceInternal();
	            if (svc) {
	                var expr = this._getExpressionWithRowColumn(row, col);
	                if (expr) {
	                    var arrayInfo = this._getArrayInfo(row, col);
	                    row = arrayInfo ? arrayInfo.row : row;
	                    col = arrayInfo ? arrayInfo.col : col;
	                    return svc.unparse(this._source, expr, row, col, culture);
	                }
	            }
	            return keyword_null;
	        },
	        
	        setFormulaByName: function (name, formula, ignoreError, syncOnly) {
	            if (!name) {
	                return;
	            }
	            name = toUpperCase(name);
	            var self = this;
	            if (formula && formula.length === 0) {
	                formula = keyword_null;
	            }
	            var oldFormula = self.getFormulaByName(name);
	            if ((oldFormula !== formula) && !((oldFormula === '' && !formula) || (!oldFormula && formula === ''))) {
	                var svc = self._getCalcServiceInternal();
	                var expr = keyword_null;
	                if (svc) {
	                    try {
	                        expr = formula ? svc.parse(self._source, formula, 0, 0, false, ignoreError) : keyword_null;
	                        self._setExpressionByName(name, expr, keyword_undefined, false, syncOnly);
	                    } catch (ex) {
	                        if (!ignoreError) {
	                            throw ex;
	                        }
	                    }
	                }
	               
	               
	               
	                self._source.setFormula({ name: name }, formula);
	            }
	        },
	        
	        getFormulaByName: function (name) {
	            var svc = this._getCalcServiceInternal();
	            if (svc && name) {
	                var expr = this._getExpressionWithRowColumnByName(toUpperCase(name));
	                if (expr) {
	                    return svc.unparse(this._source, expr, 0, 0);
	                }
	            }
	            return keyword_null;
	        },
	        _throwArrayPartException: function () {
	            throw sR().Exp_ArrayFromulaPart;
	        },
	       
	        rC: function () {
	            return Math_min(this._source.getRowCount());
	        },
	       
	        cC: function () {
	            return Math_min(this._source.getColumnCount());
	        },
	        
	        setArrayFormula: function (row, col, rowCount, colCount, formula, ignoreError, changeInfo) {
	            var self = this, expr;
	            if (formula && formula.length === 0) {
	                formula = keyword_null;
	            }
	            if (self._intersectWithArrayFormula(row, col, rowCount, colCount)) {
	                self._throwArrayPartException();
	            }
	            row = row < 0 ? 0 : row;
	            col = col < 0 ? 0 : col;
	            var svc = self._getCalcServiceInternal();
	            if (!svc) {
	                return;
	            }
	            self._clear(row, col, rowCount, colCount, changeInfo);
	            if (!formula) {
	                return;
	            }
	            try {
	                expr = formula ? svc.parse(self._source, formula, row, col, false, ignoreError, ignoreError) : keyword_null;
	            } catch (ex) {
	                if (!ignoreError) {
	                    throw ex;
	                }
	                return;
	            }
	            for (var rowIndex = row; rowIndex < row + rowCount; rowIndex++) {
	                for (var colIndex = col; colIndex < col + colCount; colIndex++) {
	                    self._setExpression(rowIndex, colIndex, expr, createRange(row, col, rowCount, colCount), false, changeInfo);
	                }
	            }
	            if (row >= 0 && col >= 0) {
	                self._source.setArrayFormula(row, col, rowCount, colCount, svc.unparse(self._source, expr, row, col));
	            }
	        },
	        getWorkingNodeInfo: function (row, col, infoType) {
	            var self = this;
	            var node, source = self._source;
	            if (row >= source.getRowCount() || col >= source.getColumnCount()) {
	                return node;
	            }
	            if (row >= 0 && col >= 0) {
	                node = self.getNode(row, col);
	                if (!node || infoType === 0 && !node._expr
	                    || infoType === 1 && !node._workingExpr
	                    || infoType === 2 && !node._arrayInfo) {
	                    node = self.getNode(row, -1);
	                }
	                if (!node || infoType === 0 && !node._expr
	                    || infoType === 1 && !node._workingExpr
	                    || infoType === 2 && !node._arrayInfo) {
	                    node = self.getNode(-1, col);
	                }
	            } else if (row >= 0 && col === -1) {
	                node = self.getNode(row, -1);
	            } else if (row === -1 && col >= 0) {
	                node = self.getNode(-1, col);
	            } else {
	                node = self.getNode(-1, -1);
	            }
	            return node && (infoType === 0 && node._expr
	                || infoType === 1 && node._workingExpr
	                || infoType === 2 && node._arrayInfo);
	        },
	        _setExpression: function (row, col, expr, baseRange, updateModel, changeInfo) {
	            var self = this;
	            var svc = self._getCalcServiceInternal();
	            svc._hasAsync && svc._evaluator.asyncManager.endCalcCell();
	            var isArrayFormula = baseRange !== keyword_undefined && baseRange !== null;
	            var context = new Calc.EvaluateContext(self._source, createCellIdentity(isArrayFormula ? baseRange.row : row, isArrayFormula ? baseRange.col : col), isArrayFormula);
	            var workingExpr = _mappingArray(context, expr, isArrayFormula, isArrayFormula ? row - baseRange.row : 0, isArrayFormula ? col - baseRange.col : 0);
	            workingExpr = workingExpr === expr ? keyword_undefined : workingExpr;
	            var arrayInfo;
	            if (baseRange !== keyword_undefined) {
	                arrayInfo = baseRange;
	            }
	            if (row >= 0 && col >= 0) {
	                if (updateModel === keyword_undefined || updateModel) {
	                    var fixedRow = row >= 0 ? row : 0;
	                    var fixedCol = col >= 0 ? col : 0;
	                    var formula = expr ? svc.unparse(self._source, expr, fixedRow, fixedCol) : keyword_undefined;
	                    self._source.setFormula(row, col, formula);
	                }
	                self._setCellExpression(row, col, expr, workingExpr, arrayInfo, changeInfo);
	            } else if (row >= 0 && col === -1) {
	                self._setRowExpression(row, expr, workingExpr, changeInfo);
	            } else if (row === -1 && col >= 0) {
	                self._setColumnExpression(col, expr, workingExpr, changeInfo);
	            }
	            if (svc.autoCalculation && !svc.IsSuspended()) {
	                svc.recalculateAll(false);
	            }
	        },
	        _setExpressionByName: function (name, expr, baseRange, updateModel, syncOnly) {
	            var self = this;
	            var svc = self._getCalcServiceInternal();
	            var context = new Calc.EvaluateContext(self._source, createCellIdentity(0, 0), false);
	            var workingExpr = _mappingArray(context, expr, false, 0, 0);
	            workingExpr = workingExpr === expr ? keyword_undefined : workingExpr;
	            if ((updateModel === keyword_undefined || updateModel) && !syncOnly) {
	                var formula = expr ? svc.unparse(self._source, expr, 0, 0) : keyword_undefined;
	                self._source.setFormulaByName(name, formula);
	            }
	            self._setNameExpression(name, expr, workingExpr);
	            if (svc.autoCalculation && !svc.IsSuspended()) {
	                !syncOnly && svc.recalculateAll(false);
	            }
	        },
	        getRowExpression: function (row) {
	            return this._getExpr(row, -1);
	        },
	        getColumnExpression: function (column) {
	            return this._getExpr(-1, column);
	        },
	        _setNameExpression: function (name, value, workingExpr, changeInfo) {
	            var self = this;
	            var nameIdCalc = self._getNameIDCalc(name, true);
	            if (nameIdCalc) {
	                nameIdCalc._stopListening();
	                var node = this.getNodeByName(name, true);
	                node._expr = value;
	                if (changeInfo) {
	                    changeInfo[0].push('dataTable', name);
	                    changeInfo[1] = node._expr;
	                }
	                workingExpr = value && workingExpr ? workingExpr : keyword_undefined;
	                node._workingExpr = workingExpr;
	                nameIdCalc._startListening();
	                self._service._addDirty(nameIdCalc, 3 );
	            }
	        },
	        _setCellExpression: function (row, col, value, workingExpr, arrayInfo, changeInfo) {
	            var self = this;
	            var cellCalc = self._getCellCalc(row, col, true);
	            if (cellCalc) {
	                self._backupNodeItem(changeInfo, row, col);
	                self._service.onClearExpr(self._source, createCellIdentity(row, col));
	                cellCalc._stopListening();
	                self._setExpr(row, col, value);
	                if (value) {
	                    if (workingExpr || self._getWorkingExpr(row, col)) {
	                        self._setWorkingExpr(row, col, workingExpr);
	                    }
	                    if (arrayInfo || self._getArrayInfo(row, col)) {
	                        self._setArrayInfo(row, col, arrayInfo);
	                    }
	                } else {
	                    self._setWorkingExpr(row, col, keyword_undefined);
	                    self._setArrayInfo(row, col, keyword_undefined);
	                }
	                cellCalc._startListening();
	                self._service._addDirty(cellCalc, 0 );
	            }
	        },
	        _setRowExpression: function (row, value, workingExpr, changeInfo) {
	            var self = this;
	            var rowCalc = self._getRowCalc(row, true);
	            if (rowCalc) {
	                self._backupNodeItem(changeInfo, row, -1);
	                rowCalc._stopListening();
	                self._setExpr(row, -1, value);
	                if (workingExpr || self._getWorkingExpr(row, -1)) {
	                    self._setWorkingExpr(row, -1, workingExpr);
	                }
	                rowCalc._startListening();
	                self._service._addDirty(rowCalc, 1 );
	            }
	        },
	        _setColumnExpression: function (column, value, workingExpr, changeInfo) {
	            var self = this;
	            var columnCalc = self._getColumnCalc(column, true);
	            if (columnCalc) {
	                self._backupNodeItem(changeInfo, -1, column);
	                columnCalc._stopListening();
	                self._setExpr(-1, column, value);
	                if (workingExpr || self._getWorkingExpr(-1, column)) {
	                    self._setWorkingExpr(-1, column, workingExpr);
	                }
	                columnCalc._startListening();
	                self._service._addDirty(columnCalc, 2 );
	            }
	        },
	        _clear: function (row, col, rowCount, colCount, changeInfo) {
	            var self = this;
	            var row1 = row < 0 ? 0 : row;
	            var col1 = col < 0 ? 0 : col;
	            var rowCount1 = row < 0 ? self.rC() : rowCount;
	            var colCount1 = col < 0 ? self.cC() : colCount;
	            var row2 = row1 + rowCount1 - 1;
	            var col2 = col1 + colCount1 - 1;
	            var workingExpr, expr, arrayInfo;
	            var clearOne = function (rowIndex, colIndex) {
	                workingExpr = self._getWorkingExpr(rowIndex, colIndex);
	                expr = self._getExpr(rowIndex, colIndex);
	                if (workingExpr || expr) {
	                    arrayInfo = self._getArrayInfo(rowIndex, colIndex);
	                    var baseRange = arrayInfo ? createRange(arrayInfo.row, arrayInfo.col, arrayInfo.rowCount, arrayInfo.colCount) : keyword_undefined;
	                    self._setExpression(rowIndex, colIndex, keyword_null, baseRange, true, changeInfo);
	                }
	            };
	            for (var r = row1; r <= row2 && r >= 0; r++) {
	                if (col < 0) {
	                    clearOne(r, -1);
	                }
	                for (var c = col1; c <= col2 && c >= 0; c++) {
	                    if (r === row1 && row < 0) {
	                        clearOne(-1, c);
	                    }
	                    clearOne(r, c);
	                }
	            }
	            if (row < 0 && col < 0) {
	                clearOne(row, col);
	            }
	        },
	        _intersectWithArrayFormula: function (row, col, rowCount, colCount) {
	            return this._getFormulaExps(row, col, rowCount, colCount, true, true);
	        },
	        _getFormulaExps: function (row, col, rowCount, colCount, testIntersect, onlyArrayFormula) {
	            var self = this;
	            var row1 = row < 0 ? 0 : row;
	            var col1 = col < 0 ? 0 : col;
	            var rowCount1 = row < 0 ? self.rC() : rowCount;
	            var colCount1 = col < 0 ? self.cC() : colCount;
	            var row2 = row1 + (rowCount1 === 0 ? 1 : rowCount1) - 1;
	            var col2 = col1 + (colCount1 === 0 ? 1 : colCount1) - 1;
	            var hasPart = false;
	            var ranges = [], formulas = [], node, dr, dataTable = self.dataTable;
	            for (var r = row1; r <= row2 && r >= 0; r++) {
	                if (r > self._lastNonNullRow) {
	                    break;
	                }
	                dr = dataTable[r];
	                if (!dr) {
	                    continue;
	                }
	                for (var c = col1; c <= col2 && c >= 0; c++) {
	                    if (c > self._lastNonNullColumn) {
	                        break;
	                    }
	                    node = dr[c];
	                    if (node) {
	                        var array = node._arrayInfo, expr;
	                        if (array) {
	                            if (array.row < row1 || array.row + array.rowCount - 1 > row2 || array.col < col1 || array.col + array.colCount - 1 > col2) {
	                                if (testIntersect) {
	                                    return true;
	                                }
	                                hasPart = true;
	                            }
	                           
	                            if (r !== array.row && r !== row1) {
	                                continue;
	                            }
	                            ranges.push(createRange(array.row, array.col, array.rowCount, array.colCount));
	                            expr = node._expr;
	                            formulas.push(expr);
	                           
	                            c = array.col + array.colCount - 1;
	                        } else if (!onlyArrayFormula) {
	                            expr = node._expr;
	                            if (expr) {
	                                ranges.push({ row: r, col: c });
	                                formulas.push(expr);
	                            }
	                        }
	                    }
	                }
	            }
	            if (testIntersect) {
	                return false;
	            }
	            return { hasPart: hasPart, ranges: ranges, formulas: formulas };
	        },
	        getCalcObj: function (identity, create) {
	            var self = this;
	            var row = identity.row, col = identity.column;
	            var t = null;
	            if (!isNaN(row) && !isNaN(col)) {
	                if (row >= 0 && col >= 0) {
	                    if (identity._isCell()) {
	                        t = self._getCellCalc(row, col, create);
	                    } else {
	                        var endRow = identity.endRow, endColumn = identity.endColumn;
	                        t = [];
	                        for (var r = row; r <= endRow; r++) {
	                            for (var c = col; c <= endColumn; c++) {
	                                t.push(self._getCellCalc(r, c, create));
	                            }
	                        }
	                    }
	                } else if (row >= 0) {
	                    t = self._getRowCalc(row, create);
	                } else if (col >= 0) {
	                    t = self._getColumnCalc(col, create);
	                }
	            } else if (identity.name) {
	                t = self._getNameIDCalc(identity.name, create);
	            }
	            return t;
	        },
	        _getNameIDCalc: function (name, create) {
	            var self = this;
	            var cell = keyword_null;
	            var node = self.getNodeByName(name, create);
	            if (node) {
	                cell = node.calc;
	                if (!cell && create) {
	                    cell = new Calc.NameIDCalc(self, name);
	                    node.calc = cell;
	                    cell.node = node;
	                }
	            }
	            return cell;
	        },
	        _getCellCalc: function (row, col, create) {
	            var self = this;
	            var cell = keyword_null;
	            if (row >= 0 && col >= 0) {
	                var dataTable = self.dataTable;
	                var dr = dataTable[row];
	                if (!dr) {
	                    if (create) {
	                        dr = dataTable[row] = {};
	                        if (row > self._lastNonNullRow) {
	                            self._lastNonNullRow = row;
	                        }
	                    } else {
	                        return cell;
	                    }
	                }
	                var dc = dr[col];
	                if (!dc) {
	                    if (create) {
	                        dc = dr[col] = {};
	                        cell = new CellCalc(self, row, col);
	                        dc.calc = cell;
	                        cell.node = dc;
	                        if (col > self._lastNonNullColumn) {
	                            self._lastNonNullColumn = col;
	                        }
	                    }
	                    return cell;
	                }
	                cell = dc.calc;
	                if (!cell && create) {
	                    cell = new CellCalc(self, row, col);
	                    dc.calc = cell;
	                    cell.node = dc;
	                    if (row > self._lastNonNullRow) {
	                        self._lastNonNullRow = row;
	                    }
	                    if (col > self._lastNonNullColumn) {
	                        self._lastNonNullColumn = col;
	                    }
	                }
	            }
	            return cell;
	        },
	        _getRowCalc: function (row, create) {
	            var self = this;
	            var calc = keyword_null;
	            if (row >= 0) {
	                calc = self._getCalc(row, -1);
	                if (!calc && create) {
	                    calc = new RowCalc(self, row);
	                    self._setCalc(row, -1, calc);
	                    if (row > self._lastNonNullRow) {
	                        self._lastNonNullRow = row;
	                    }
	                }
	            }
	            return calc;
	        },
	        _getColumnCalc: function (column, create) {
	            var self = this;
	            var calc = keyword_null;
	            if (column >= 0) {
	                calc = self._getCalc(-1, column);
	                if (!calc && create) {
	                    calc = new ColumnCalc(self, column);
	                    self._setCalc(-1, column, calc);
	                    if (column > self._lastNonNullColumn) {
	                        self._lastNonNullColumn = column;
	                    }
	                }
	            }
	            return calc;
	        },
	        _getRangeCalc: function (create) {
	            var self = this;
	            if (!self._rangeCalc && create) {
	                self._rangeCalc = new RangeCalc(self);
	            }
	            return self._rangeCalc;
	        },
	        _getNameCalc: function (name, create) {
	            var self = this;
	            var nameCalc;
	            name = toUpperCase(name);
	            if (!self._nameCalcs) {
	                self._nameCalcs = {};
	            }
	            nameCalc = self._nameCalcs[name];
	            if (!nameCalc && create) {
	                nameCalc = self._nameCalcs[name] = new NameCalc(self, name);
	            }
	            return nameCalc;
	        },
	        updateNameCalc: function (name, start) {
	            var nameCalc = this._getNameCalc(toUpperCase(name));
	            if (nameCalc) {
	                nameCalc.updateListening(true, start);
	                nameCalc._addToDirty();
	            }
	        },
	        _addColumnsToDirty: function (col, colCount) {
	            var self = this, maxCol = Math_min(self._lastNonNullColumn, col + colCount - 1);
	            for (var c = col; c !== -1 && c <= maxCol; c++) {
	                if (!self.isDirty(-1, c)) {
	                    continue;
	                }
	                var columnCalc = self._getColumnCalc(c, true);
	                self._service._addDirty(columnCalc, 2 );
	            }
	        },
	        _addRowsToDirty: function (row, rowCount) {
	            var self = this, maxRow = Math_min(self._lastNonNullRow, row + rowCount - 1);
	            for (var r = row; r !== -1 && r <= maxRow; r++) {
	                if (!self.isDirty(r, -1)) {
	                    continue;
	                }
	                var rowCalc = self._getRowCalc(r, true);
	                self._service._addDirty(rowCalc, 1 );
	            }
	        },
	        _addCellsToDirty: function (row, col, rowCount, colCount) {
	            var self = this;
	            var maxRow = Math_min(self._lastNonNullRow, row + rowCount - 1),
	                maxCol = Math_min(self._lastNonNullColumn, col + colCount - 1);
	            for (var r = row; r <= maxRow; r++) {
	                for (var c = col; c <= maxCol; c++) {
	                    if (!self._containsNode(r, c)) {
	                        continue;
	                    }
	                    var cellCalc = self._getCellCalc(r, c, true);
	                    self._service._addDirty(cellCalc, 0 );
	                }
	            }
	            self._addRowsToDirty(row, rowCount);
	            self._addColumnsToDirty(col, colCount);
	            var rangesCalc = self._getRangeCalc(false);
	            if (rangesCalc) {
	                rangesCalc._addListenersToDirty(row, col, rowCount, colCount);
	            }
	        },
	        _addVolatitlesToDirty: function () {
	            var self = this, volatiles = self._getAllVolatiles(), rowCalc, colCalc;
	            for (var volatileIndex = 0; volatileIndex < volatiles.length; volatileIndex++) {
	                var volatiCalc = volatiles[volatileIndex];
	                if (volatiCalc && volatiCalc.isVolatile && (volatiCalc instanceof CellCalc) && !self._isDirtyCell(volatiCalc)) {
	                    var cellCalc = self._getCellCalc(volatiCalc.row, volatiCalc.column, true);
	                    self._service._addDirty(cellCalc, 0 );
	                    rowCalc = self._getRowCalc(volatiCalc.row, false);
	                    if (rowCalc && !self._isDirtyRow(rowCalc)) {
	                        self._addRowsToDirty(volatiCalc.row, 1);
	                    }
	                    colCalc = self._getColumnCalc(volatiCalc.column, false);
	                    if (colCalc && !self._isDirtyRow(colCalc)) {
	                        self._addColumnsToDirty(volatiCalc.column, 1);
	                    }
	                }
	            }
	        },
	        _checkAndUpdateVolatitles: function () {
	            var self = this, volatiles = self._getAllVolatiles(), rowCalc, colCalc;
	            var needUpdate = true, maxCount = 5;
	            var service = self._service;
	            while (needUpdate && maxCount) {
	                needUpdate = false;
	                maxCount--;
	                for (var volatileIndex = 0, length = volatiles.length; volatileIndex < length; volatileIndex++) {
	                    var volatiCalc = volatiles[volatileIndex];
	                    if (volatiCalc && volatiCalc.isVolatile && (volatiCalc instanceof CellCalc) && !self._isDirtyCell(volatiCalc)) {
	                        var row = volatiCalc.row, column = volatiCalc.column;
	                        if (self.recalculateCell(row, column)) {
	                            needUpdate = true;
	                            var cellCalc = self._getCellCalc(row, column, true);
	                            service._addDirty(cellCalc, 0 );
	                            rowCalc = self._getRowCalc(row, false);
	                            if (rowCalc && !self._isDirtyRow(rowCalc)) {
	                                self._addRowsToDirty(row, 1);
	                            }
	                            colCalc = self._getColumnCalc(column, false);
	                            if (colCalc && !self._isDirtyRow(colCalc)) {
	                                self._addColumnsToDirty(column, 1);
	                            }
	                        }
	                    }
	                }
	                if (needUpdate) {
	                    service._recalculateImp(true);
	                }
	            }
	        },
	        _isDirtyCell: function (cell) {
	            var heads = this.getCalcService()._heads;
	            return !!cell._preDirty || cell === (heads && heads[0]);
	        },
	        _isDirtyRow: function (row) {
	            var heads = this.getCalcService()._heads;
	            return row._preDirty || row === (heads && heads[1]);
	        },
	        isDirtyColumn: function (column) {
	            var heads = this.getCalcService()._heads;
	            return column._preDirty || column === (heads && heads[2]);
	        },
	        isDirty: function (row, col) {
	            return !!(this._getCalc(row, col) || this._getExpr(row, col));
	        },
	        recalculateForContext: function (source, context, isAyncEvaluate) {
	            var service = this._service;
	            var model = service.getSourceModel(source);
	            var row = context.row, column = context.col;
	            if (column === -1) {
	                model._addCellsToDirty(row, 0, 1, model.cC());
	            } else if (row === -1) {
	                model._addCellsToDirty(0, column, model.rC(), 1);
	            } else {
	                model._addCellsToDirty(row, column, 1, 1);
	            }
	            if (!service.IsSuspended()) {
	                service.recalculateAll(false, isAyncEvaluate);
	            }
	        },
	        recalculateCell: function (row, column) {
	            var self = this, source = self._source;
	            var expr = (self._getWorkingExpressionWithRowColumn(row, column) || self._getExpressionWithRowColumn(row, column));
	            if (expr) {
	                var identity = createCellIdentity(row, column);
	                var oldValue = source.getValue(row, column);
	                var isArrayFormula = false, baseRow, baseCol, rowCount, colCount;
	                var arrayInfo = self._getArrayInfo(row, column);
	                if (arrayInfo) {
	                    isArrayFormula = true;
	                    baseRow = arrayInfo.row;
	                    baseCol = arrayInfo.col;
	                    rowCount = arrayInfo.rowCount;
	                    colCount = arrayInfo.colCount;
	                }
	                self._service._hasAsync && self._service._evaluator.asyncManager.startCalcCell(self._source, identity);
	                var value = self._service._evaluateParsedFormula(self._source, expr, identity, isArrayFormula, true, arrayInfo && createRangeIdentity(baseRow, baseCol, rowCount, colCount));
	                if (oldValue === value) {
	                    return false;
	                } else if (oldValue instanceof Date) {
	                    if ((value instanceof Date) && oldValue.valueOf() === value.valueOf()) {
	                        return false;
	                    } else if (typeof value === 'number') {
	                        var numberValue = _DateTimeHelper._toOADate(oldValue);
	                        if (numberValue === value) {
	                            return false;  
	                        }
	                        value = _DateTimeHelper._fromOADate(value);
	                    }
	                }
	                source.setValue(row, column, value, oldValue);
	                self._service._hasAsync && self._service._evaluator.asyncManager.endCalcCell(self._source, identity);
	                source._removeDirtyCachedArrayItem && source._removeDirtyCachedArrayItem(row, column);   
	                return true;
	            }
	            return false;
	        },
	        recalculateNameID: function (name) {
	            var self = this, source = self._source;
	            var expr = (self._getWorkingExpressionWithRowColumnByName(name) || self._getExpressionWithRowColumnByName(name));
	            if (expr) {
	                var oldValue = source.getValueByName ? source.getValueByName(name) : source.getValue({ name: name });
	                var value = self._service._evaluateParsedFormula(self._source, expr, { name: name }, false, true);
	                if (oldValue === value) {
	                    return;
	                } else if ((oldValue instanceof Date) && (value instanceof Date) && oldValue.valueOf() === value.valueOf()) {
	                    return;
	                }
	                source.setValueByName ? source.setValueByName(name, value) : source.setValue({ name: name }, value);
	            }
	        },
	
	       
	        addDirtyNodesForCalc: function (dirtyAll, isAyncEvaluate) {
	            var self = this;
	            if (dirtyAll !== false) {
	                var colCount = self.cC();
	                var rowCount = self.rC();
	                self._addColumnsToDirty(0, colCount);
	                self._addRowsToDirty(0, rowCount);
	                self._addCellsToDirty(0, 0, rowCount, colCount);
	            } else if (!isAyncEvaluate) {
	                self._addVolatitlesToDirty();
	            }
	        },
	        addListenersToDirtyForRow: function (calcService) {
	            while (calcService._heads[1]) {
	                var head = calcService._heads[1];
	                var sheetSource = head._sourceModel;
	                var columnCount = sheetSource.cC();
	                for (var c = 0; c < columnCount; c++) {
	                    calcService._addDirty(sheetSource._getCellCalc(head.row, c, true), 0 );
	                }
	                calcService._removeDirty(head, 1 );
	            }
	        },
	        addListenersToDirtyForCol: function (calcService) {
	            while (calcService._heads[2]) {
	                var head = calcService._heads[2];
	                var sheetSource = head._sourceModel;
	                var rowCount = sheetSource.rC();
	                if (rowCount > 0) {
	                    for (var r = 0; r < rowCount; r++) {
	                        calcService._addDirty(sheetSource._getCellCalc(r, head.column, true), 0 );
	                    }
	                } else {
	                    head._addListenersToDirty();
	                }
	                calcService._removeDirty(head, 2 );
	            }
	        },
	        _cacheHeadDirtyColumns: function (cachedDirtyColumns, currentHeadDirtyColumns) {
	            var index = cachedDirtyColumns.length;
	            var dirtyColumn = currentHeadDirtyColumns;
	            while (dirtyColumn) {
	                cachedDirtyColumns[index] = dirtyColumn;
	                index++;
	                dirtyColumn = dirtyColumn._nextDirty;
	            }
	        },
	        addListenersToDirty: function (calcService, type) {
	            if (type === 1) {
	                this.addListenersToDirtyForRow(calcService);
	            } else if (type === 2) {
	                this.addListenersToDirtyForCol(calcService);
	            } else if (type === 0) {
	                var cachedHeadDirtyColumns = [];
	                if (calcService._heads[2]) {
	                    this._cacheHeadDirtyColumns(cachedHeadDirtyColumns, calcService._heads[2]);
	                }
	
	                for (var cell = calcService._heads[0]; cell; cell = cell._nextDirty) {
	                    var sheetSource = cell._sourceModel;
	                    var row = cell.row;
	                    var col = cell.column;
	                    var rowCalc = sheetSource._getRowCalc(row, false);
	                    var columnCalc = sheetSource._getColumnCalc(col, false);
	                    var rangesCalc = sheetSource._getRangeCalc(false);
	                    cell._addListenersToDirty();
	                    if (rowCalc) {
	                        rowCalc._addListenersToDirty();
	                    }
	                    if (columnCalc) {
	                        columnCalc._addListenersToDirty();
	                    }
	                    if (rangesCalc) {
	                        rangesCalc._addListenersToDirty(row, col, 1, 1);
	                    }
	                    this.addListenersToDirtyForRow(calcService);
	
	                    while (calcService._heads[2]) {
	                        var head = calcService._heads[2];
	                       
	                        var reapted = false;
	                        for (var i = 0; i < cachedHeadDirtyColumns.length; i++) {
	                            if (cachedHeadDirtyColumns[i] === head) {
	                                reapted = true;
	                                break;
	                            }
	                        }
	                        if (reapted) {
	                            calcService._removeDirty(head, 2 );
	                            continue;
	                        } else {
	                            cachedHeadDirtyColumns[cachedHeadDirtyColumns.length] = head;
	                        }
	                       
	
	                        sheetSource = head._sourceModel;
	                        var rowCount = sheetSource.rC();
	                        for (var r = 0; r < rowCount; r++) {
	                            calcService._addDirty(sheetSource._getCellCalc(r, head.column, true), 0 );
	                        }
	                        calcService._removeDirty(head, 2 );
	                    }
	                }
	            } else if (type === 3) {
	                for (var nameID = calcService._heads[3]; nameID; nameID = nameID._nextDirty) {
	                    nameID._addListenersToDirty();
	                }
	            }
	        },
	        initDelay: function (calcService, type) {
	            if (type === 0) {
	                var nextDirty = null;
	                for (var cell = calcService._heads[0]; cell; cell = nextDirty) {
	                    nextDirty = cell._nextDirty;
	                    var sheetSource = cell._sourceModel;
	                    var maxRowCount = sheetSource.rC();
	                    var maxColCount = sheetSource.cC();
	
	                    if (cell.row < maxRowCount && cell.column < maxColCount) {
	                        if (Calc.supportRowColumnFormula) {
	                            var columnCalc = sheetSource._getColumnCalc(cell.column, false);
	                            if (columnCalc) {
	                                columnCalc.delay = 0;
	                            }
	                        }
	                        cell.delay = 0;
	                    } else {
	                        calcService._removeDirty(cell, 0 );
	                    }
	                }
	            } else if (type === 3) {
	                for (var nameID = calcService._heads[3]; nameID; nameID = nameID._nextDirty) {
	                    nameID.delay = 0;
	                }
	            }
	        },
	        adjustDelayOfListeners: function (calcService, type, isIncrement) {
	            if (type === 0) {
	                for (var cell = calcService._heads[type]; cell; cell = cell._nextDirty) {
	                    var sheetSource = cell._sourceModel;
	                    var r = cell.row;
	                    var c = cell.column;
	                    var rowCalc = sheetSource._getRowCalc(r, false);
	                    var columnCalc = sheetSource._getColumnCalc(c, false);
	                    var rangesCalc = sheetSource._getRangeCalc(false);
	                    cell._adjustDelayOfListeners(isIncrement);
	                    if (rowCalc) {
	                        rowCalc._adjustDelayOfListeners(isIncrement);
	                    }
	                    if (columnCalc) {
	                        columnCalc._adjustDelayOfListeners(isIncrement);
	                    }
	                    if (rangesCalc) {
	                        rangesCalc._adjustDelayOfListeners(r, c, isIncrement);
	                    }
	                }
	            } else if (type === 3) {
	                for (var nameID = calcService._heads[3]; nameID; nameID = nameID._nextDirty) {
	                    nameID._adjustDelayOfListeners(isIncrement);
	                }
	            }
	        },
	        calculateDirtyNodes: function (calcService, type) {
	            var progress = false;
	            var sheetSource = null;
	            var nextDirty;
	            if (type === 0) {
	                for (var cell = calcService._heads[type]; cell; cell = nextDirty) {
	                    nextDirty = cell._nextDirty;
	                    if (cell.delay === 0) {
	                        sheetSource = cell._sourceModel;
	                        var r = cell.row;
	                        var c = cell.column;
	                        var rowCalc = sheetSource._getRowCalc(r, false);
	                        var columnCalc = sheetSource._getColumnCalc(c, false);
	                        if (columnCalc && columnCalc.delay) {
	                            continue;
	                        }
	                        var rangesCalc = sheetSource._getRangeCalc(false);
	                        sheetSource.recalculateCell(r, c);
	                        calcService._removeDirty(cell, 0 );
	                        cell._adjustDelayOfListeners(false);
	                        if (rowCalc) {
	                            rowCalc._adjustDelayOfListeners(false);
	                        }
	                        if (columnCalc) {
	                            columnCalc._adjustDelayOfListeners(false);
	                        }
	                        if (rangesCalc) {
	                            rangesCalc._adjustDelayOfListeners(r, c, false);
	                        }
	                        progress = true;
	                    }
	                }
	            } else if (type === 3) {
	                for (var nameID = calcService._heads[type]; nameID; nameID = nextDirty) {
	                    nextDirty = nameID._nextDirty;
	                    if (nameID.delay === 0) {
	                        sheetSource = nameID._sourceModel;
	                        sheetSource.recalculateNameID(nameID.name);
	                        calcService._removeDirty(nameID, 3 );
	                        nameID._adjustDelayOfListeners(false);
	                        progress = true;
	                    }
	                }
	            }
	            return progress;
	        },
	
	        calculateIterations: function (calcService, type) {
	            if (type === 0) {
	                var head = calcService._heads[type];
	                if (head) {
	                    var cell = null;
	                    var moreIterations = true;
	                    for (var sourceName in calcService._sourceModels) { 
	                        if (calcService._sourceModels.hasOwnProperty(sourceName)) {
	                            var src = calcService._sourceModels[sourceName].getSource();
	                            src.clearValueCache && src.clearValueCache();
	                        }
	                    }
	
	                    for (var i = 0; moreIterations && i < calcService.maximumIterations; i++) {
	                        moreIterations = false;
	                        for (cell = head; cell; cell = cell._nextDirty) {
	                            var formulaContext = cell._sourceModel;
	                            var r = cell.row;
	                            var c = cell.column;
	                            var oldValue = formulaContext.getSource().getValue(r, c);
	                            formulaContext.recalculateCell(r, c);
	                            var newValue = formulaContext.getSource().getValue(r, c);
	                            if (calcService._iterationChange(oldValue, newValue) >= calcService.maximumChange) {
	                                moreIterations = true;
	                            }
	                        }
	                    }
	                    var nextDirty = null;
	                    for (cell = head; cell; cell = nextDirty) {
	                        nextDirty = cell._nextDirty;
	                        cell._nextDirty = keyword_undefined;
	                        if (nextDirty) {
	                            nextDirty._preDirty = keyword_undefined;
	                        }
	                    }
	                }
	            }
	        },
	
	       
	        _dealWithExpression: function (exprCalc, row, column, expr, orgExpr, isAdd, contextSource) {
	            var self = this, i, name, nameExpr, sheetNameCalc, refNameCalc;
	            while (expr.type === 12 ) {
	                expr = expr.value;
	            }
	            while (expr.type === 10 ) {
	                expr = expr.value;
	            }
	            while (expr.type === 12 ) {
	                expr = expr.value;
	            }
	            if (orgExpr) {
	                while (orgExpr.type === 12 ) {
	                    orgExpr = orgExpr.value;
	                }
	                while (orgExpr.type === 10 ) {
	                    orgExpr = orgExpr.value;
	                }
	                while (orgExpr.type === 12 ) {
	                    orgExpr = orgExpr.value;
	                }
	            }
	           
	            if (expr.type === 13 ) {
	                var cellRange = expr.getRange(row, column, true);
	                if (cellRange === keyword_null) {
	                    return;
	                }
	                if (cellRange.rowCount === 1 && cellRange.colCount === 1) {
	                    expr = createCellExpression(keyword_null, keyword_null, cellRange.row, cellRange.col, false, false);
	                } else {
	                    expr = createRangeExpression(keyword_null, keyword_null, cellRange.row, cellRange.col, cellRange.row + cellRange.rowCount - 1, cellRange.col + cellRange.colCount - 1, false, false, false, false);
	                }
	            }
	            var refRow, refColumn, refStartRow, refEndRow, refStartColumn, refEndColumn, refRowCount, refColumnCount,
	                refCellCalc, refRowCalc, refColumnCalc, r, c, sheetSource, calcModel;
	            if (orgExpr && orgExpr !== expr && (orgExpr.type === 8 )) {
	               
	                if (orgExpr.source instanceof Calc.ErrorSource) {
	                    return;
	                }
	               
	               
	               
	                name = orgExpr.value;
	               
	                sheetSource = expr.source || orgExpr.source || contextSource || self._source;
	               
	                nameExpr = sheetSource.getCustomName(name);
	                if (nameExpr) {
	                    calcModel = sheetSource.getCalcSourceModel();
	                } else {
	                    calcModel = self._service.getGlobalSourceModel() || sheetSource.getCalcSourceModel();
	                    nameExpr = calcModel.getSource().getCustomName(name);
	                    if (!nameExpr) {
	                        sheetNameCalc = sheetSource.getCalcSourceModel()._getNameCalc(name, true);
	                       
	                        sheetNameCalc._processListener(cellListeners, exprCalc, isAdd);
	                    }
	                }
	                refNameCalc = calcModel._getNameCalc(name, true);
	               
	                refNameCalc._processListener(cellListeners, exprCalc, isAdd);
	                orgExpr = null;
	                nameExpr && self._dealWithExpression(exprCalc, row, column, nameExpr, keyword_null, isAdd, calcModel.getSource());
	            }
	            if (expr.type === 1  && expr.endSource) {
	                var sheetRangeExpr = expr;
	                var sources = sheetRangeExpr.source.getSources(sheetRangeExpr.endSource);
	                for (i = 0; i < sources.length; i++) {
	                    var subExpr = createRangeExpression(sources[i], keyword_null, sheetRangeExpr.row, sheetRangeExpr.column, sheetRangeExpr.endRow, sheetRangeExpr.endColumn, sheetRangeExpr.rowRelative, sheetRangeExpr.columnRelative, sheetRangeExpr.endRowRelative, sheetRangeExpr.endColumnRelative);
	                    subExpr.isFullRow = sheetRangeExpr.isFullRow;
	                    subExpr.isFullColumn = sheetRangeExpr.isFullColumn;
	                    self._dealWithExpression(exprCalc, row, column, subExpr, keyword_null, isAdd);
	                }
	            } else if (expr.type === 1 ) {
	                sheetSource = expr.source !== Calc.BangSource && expr.source || self._source;
	                calcModel = sheetSource.getCalcSourceModel();
	                if (!calcModel) {
	                    return;
	                }
	                var rangeExpr = expr;
	                var isNotCellOrRange = exprCalc.row === keyword_undefined || exprCalc.column === keyword_undefined;
	                var refRangeType = rangeExpr._getRangeType();
	                var refRange = getRangeForReference(expr, row, column);
	                refStartRow = refRange.row;
	                refStartColumn = refRange.col;
	                refRowCount = refRange.rowCount;
	                refColumnCount = refRange.colCount;
	                refEndRow = refStartRow + refRowCount - 1;
	                refEndColumn = refStartColumn + refColumnCount - 1;
	                if (refRangeType === 0 ) {
	                    if (0 <= row && 0 <= column) {
	                       
	                        if (shouldUseRange(refRow, refColumn, refRowCount, refColumnCount)) {
	                            var rangeCalc = calcModel._getRangeCalc(true);
	                            if (isNotCellOrRange) {
	                                rangeCalc._processIDListerner(refStartRow, refStartColumn, refRowCount, refColumnCount, exprCalc, isAdd);
	                            } else {
	                                rangeCalc._processCellListener(refStartRow, refStartColumn, refRowCount, refColumnCount, exprCalc, isAdd);
	                            }
	                        } else {
	                            for (r = refStartRow; r <= refEndRow; r++) {
	                                for (c = refStartColumn; c <= refEndColumn; c++) {
	                                    refCellCalc = calcModel._getCellCalc(r, c, true);
	                                    if (isNotCellOrRange) {
	                                       
	                                        refCellCalc && refCellCalc._processListener(nameIDListeners, exprCalc, isAdd);
	                                    } else {
	                                        refCellCalc && refCellCalc._processListener(cellListeners, exprCalc, isAdd);
	                                       
	                                    }
	                                }
	                            }
	                        }
	                    } else if (0 <= row && column === -1) {
	                        for (r = refStartRow; r <= refEndRow; r++) {
	                            for (c = refStartColumn; c <= refEndColumn; c++) {
	                                if (rangeExpr.columnRelative || rangeExpr.endColumnRelative) {
	                                    refRowCalc = calcModel._getRowCalc(r, true);
	                                    if (refRowCalc) {
	                                        refRowCalc._processRowListener2(exprCalc, -c, isAdd);
	                                    }
	                                } else {
	                                    refCellCalc = calcModel._getCellCalc(r, c, true);
	                                    refCellCalc && refCellCalc._processListener(rowListeners, exprCalc, isAdd);
	                                   
	                                }
	                            }
	                        }
	                    } else if (0 <= column && row === -1) {
	                        for (r = refStartRow; r <= refEndRow; r++) {
	                            for (c = refStartColumn; c <= refEndColumn; c++) {
	                                if (rangeExpr.rowRelative || rangeExpr.endRowRelative) {
	                                    refColumnCalc = calcModel._getColumnCalc(c, true);
	                                    refColumnCalc && refColumnCalc._processColumnListener2(exprCalc, -r, isAdd);
	                                } else {
	                                    refCellCalc = calcModel._getCellCalc(r, c, true);
	                                   
	                                    refCellCalc && refCellCalc._processListener(columnListeners, exprCalc, isAdd);
	                                }
	                            }
	                        }
	                    }
	                } else if (refRangeType === 1 ) {
	                    if (0 <= row && 0 <= column) {
	                       
	                       
	                        rangeCalc = calcModel._getRangeCalc(true);
	                        if (isNotCellOrRange) {
	                            rangeCalc._processIDListerner(refStartRow, refStartColumn, refRowCount, refColumnCount, exprCalc, isAdd);
	                        } else {
	                            rangeCalc._processCellListener(refStartRow, refStartColumn, refRowCount, refColumnCount, exprCalc, isAdd);
	                        }
	
	                       
	                       
	                       
	                       
	                       
	                       
	                       
	                       
	                    } else if (0 <= row && column === -1) {
	                    } else if (row === -1 && 0 <= column) {
	                        if (rangeExpr.rowRelative || rangeExpr.endRowRelative) {
	                        } else {
	                            refStartRow = rangeExpr.row;
	                            refEndRow = rangeExpr.endRow;
	                            for (r = refStartRow; r <= refEndRow; r++) {
	                                refRowCalc = calcModel._getRowCalc(r, true);
	                               
	                                refRowCalc && refRowCalc._processListener(columnListeners, exprCalc, isAdd);
	                            }
	                        }
	                    }
	                } else if (refRangeType === 2 ) {
	                    if (0 <= row && 0 <= column) {
	                       
	                       
	                        rangeCalc = calcModel._getRangeCalc(true);
	                        if (isNotCellOrRange) {
	                            rangeCalc._processIDListerner(refStartRow, refStartColumn, refRowCount, refColumnCount, exprCalc, isAdd);
	                        } else {
	                            rangeCalc._processCellListener(refStartRow, refStartColumn, refRowCount, refColumnCount, exprCalc, isAdd);
	                        }
	
	                       
	                       
	                       
	                       
	                       
	                       
	                       
	                       
	                    } else if (0 <= row && column === -1) {
	                    } else if (row === -1 && 0 <= column) {
	                        for (c = refStartColumn; c <= refEndColumn; c++) {
	                            refColumnCalc = calcModel._getColumnCalc(c, true);
	                           
	                            refColumnCalc && refColumnCalc._processListener(columnListeners, exprCalc, isAdd);
	                        }
	                    }
	                }
	               
	               
	               
	               
	               
	               
	               
	               
	            } else if (expr.type === 9 ) {
	                self._dealWithExpression(exprCalc, row, column, expr.value, orgExpr && orgExpr.type === 9  && orgExpr.value, isAdd);
	                if (expr.value2) {
	                    self._dealWithExpression(exprCalc, row, column, expr.value2, orgExpr && orgExpr.type === 9  && orgExpr.value2, isAdd);
	                }
	            } else if (expr.type === 8 ) {
	                sheetSource = expr.source || contextSource || self._source;
	                name = toUpperCase(expr.value);
	                nameExpr = sheetSource.getCustomName(name);
	                if (nameExpr) {
	                    calcModel = sheetSource.getCalcSourceModel();
	                } else {
	                    calcModel = self._service.getGlobalSourceModel() || sheetSource.getCalcSourceModel();
	                    nameExpr = calcModel.getSource().getCustomName(name);
	                    if (!nameExpr) {
	                        sheetNameCalc = sheetSource.getCalcSourceModel()._getNameCalc(name, true);
	                       
	                        sheetNameCalc._processListener(cellListeners, exprCalc, isAdd);
	                    }
	                }
	                refNameCalc = calcModel._getNameCalc(name, true);
	                if (!refNameCalc) {
	                    return;
	                }
	               
	                refNameCalc._processListener(cellListeners, exprCalc, isAdd);
	               
	                nameExpr && self._dealWithExpression(exprCalc, row, column, nameExpr, keyword_null, isAdd, calcModel.getSource());
	            } else if (expr.type === 7 ) {
	                var func = expr.function;
	                if (func) {
	                    if (func.isVolatile()) {
	                        if (isAdd) {
	                            self._setVolatile(exprCalc);
	                        } else {
	                            self._removeVolatile(exprCalc);
	                        }
	                    }
	                    if (!func.precedentReference()) {
	                        return;
	                    }
	                    if (func instanceof Calc.Functions.AsyncFunction) {
	                        self._service._hasAsync = true;
	                    }
	                }
	                var argCount = expr.arguments.length;
	                for (i = 0; i < argCount; i++) {
	                    self._dealWithExpression(exprCalc, row, column, expr.arguments[i], orgExpr && orgExpr.type === 7  && orgExpr.arguments[i], isAdd);
	                }
	            } else if (expr.type === 25  || expr.type === 26 ) {
	                var nameIDExpr = expr;
	                sheetSource = expr.source || self._source;
	                calcModel = sheetSource.getCalcSourceModel();
	                var refNameIDCalc = calcModel._getNameIDCalc(nameIDExpr.value, true);
	                if (!refNameIDCalc) {
	                    return;
	                }
	                refNameIDCalc._processListener(cellListeners, exprCalc, isAdd);
	               
	            }
	        },
	        _dealWithNameIDExpression: function (name, isAdd) {
	            var node = this.getNodeByName(name);
	            if (node && (node._workingExpr || node._expr)) {
	                this._dealWithExpression(this._getNameIDCalc(name), 0, 0, node._workingExpr || node._expr, node._expr, isAdd);
	            }
	        },
	        _dealWithCellExpression: function (row, column, rowCount, columnCount, isAdd) {
	            var self = this;
	            var endRow = row + rowCount, endCol = column + columnCount;
	            var workingExpr, expr, arrayInfo;
	            for (var r = row; r < endRow; r++) {
	                for (var c = column; c < endCol; c++) {
	                    workingExpr = self._getWorkingExpr(r, c);
	                    expr = self._getExpr(r, c);
	                    if (workingExpr || expr) {
	                        arrayInfo = self._getArrayInfo(r, c);
	                        if (arrayInfo) {
	                            self._dealWithExpression(self._getCellCalc(r, c), arrayInfo.row, arrayInfo.col, workingExpr || expr, expr, isAdd);
	                        } else {
	                            self._dealWithExpression(self._getCellCalc(r, c), r, c, workingExpr || expr, expr, isAdd);
	                        }
	                    }
	                }
	            }
	        },
	        _dealWithColumnExpression: function (col, colCount, isAdd) {
	            var endCol = col + colCount;
	            for (var c = col; c !== -1 && c < endCol; c++) {
	                var expr = this.getColumnExpression(c);
	                if (expr) {
	                    this._dealWithExpression(this._getColumnCalc(c, false), -1, c, expr, expr, isAdd);
	                }
	            }
	        },
	        _linkCellExpression: function (row, column, rowCount, columnCount) {
	            this._dealWithCellExpression(row, column, rowCount, columnCount, true);
	        },
	        _unlinkCellExpression: function (row, column, rowCount, columnCount) {
	            this._dealWithCellExpression(row, column, rowCount, columnCount, false);
	        },
	        _linkRowExpression: function (row, rowCount) {
	        },
	        _unlinkRowExpression: function (row, rowCount) {
	        },
	        _linkColumnExpression: function (col, colCount) {
	            this._dealWithColumnExpression(col, colCount, true);
	        },
	        _unlinkColumnExpression: function (col, colCount) {
	            this._dealWithColumnExpression(col, colCount, false);
	        },
	        _iterateEachCell: function (row, column, rowCount, columnCount, setAdjust, setDirty, changeInfo) {
	            var endRow = row + rowCount, endCol = column + columnCount;
	            var self = this;
	            for (var r = row; r < endRow; r++) {
	                for (var c = column; c < endCol; c++) {
	                    var cellCalc = this._getCellCalc(r, c, false);
	                    if (cellCalc) {
	                        self._backupNodeItem(changeInfo, r, c);
	                        if (setAdjust) {
	                            cellCalc._addListenersToAdjust();
	                        }
	                        if (setDirty) {
	                            cellCalc._addListenersToDirty();
	                        }
	                    }
	                }
	            }
	        },
	        _iterateEachRow: function (row, rowCount, setAdjust, setDirty, changeInfo) {
	            var self = this;
	            var rowData = self._rowDataArray;
	            if (row !== -1 && rowData) {
	                var maxRow = Math_min(row + rowCount, rowData.length);
	                for (var r = row; r < maxRow; r++) {
	                    var node = rowData[r];
	                    if (!node || !node.calc) {
	                        continue;
	                    }
	                    self._backupNodeItem(changeInfo, r, -1);
	                    var rowCalc = node.calc;
	                    if (setAdjust) {
	                        rowCalc._addListenersToAdjust();
	                    }
	                    if (setDirty) {
	                        rowCalc._addListenersToDirty();
	                    }
	                }
	            }
	        },
	        _iterateEachColumn: function (column, columnCount, setAdjust, setDirty, changeInfo) {
	            var self = this;
	            var columnData = self._columnDataArray;
	            if (column !== -1 && columnData) {
	                var maxCol = Math_min(column + columnCount, columnData.length);
	                for (var c = column; c < maxCol; c++) {
	                    var node = columnData[c];
	                    if (!node || !node.calc) {
	                        continue;
	                    }
	                    self._backupNodeItem(changeInfo, -1, c);
	                    var columnCalc = node.calc;
	                    if (setAdjust) {
	                        columnCalc._addListenersToAdjust();
	                    }
	                    if (setDirty) {
	                        columnCalc._addListenersToDirty();
	                    }
	                }
	            }
	        },
	        _addDependents: function (row, column, rowCount, columnCount, setAdjust, setDirty, needSaveChanges) {
	            if (setAdjust || setDirty) {
	                var self = this;
	                var calcChangInfo;
	                if (needSaveChanges) {
	                    calcChangInfo = self._getChangesForCalcEngine();
	                }
	                if (0 <= row && 0 <= column) {
	                    self._iterateEachCell(row, column, rowCount, columnCount, setAdjust, setDirty, calcChangInfo);
	                    self._iterateEachRow(row, rowCount, setAdjust, setDirty, calcChangInfo);
	                    self._iterateEachColumn(column, columnCount, setAdjust, setDirty, calcChangInfo);
	                    if (self._rangeCalc) {
	                        if (setAdjust) {
	                            self._rangeCalc._addListenersToAdjust(row, column, rowCount, columnCount);
	                        }
	                        if (setDirty) {
	                            self._rangeCalc._addListenersToDirty(row, column, rowCount, columnCount);
	                        }
	                    }
	                } else if (0 <= row && column === -1) {
	                    self._iterateEachCell(row, 0, rowCount, self.cC(), setAdjust, setDirty, calcChangInfo);
	                    self._iterateEachRow(row, rowCount, setAdjust, setDirty, calcChangInfo);
	                    if (self._rangeCalc) {
	                        if (setAdjust) {
	                            self._rangeCalc._addListenersToAdjust(row, column, rowCount, columnCount);
	                        }
	                        if (setDirty) {
	                            self._rangeCalc._addListenersToDirty(row, column, rowCount, columnCount);
	                        }
	                    }
	                } else if (row === -1 && 0 <= column) {
	                    self._iterateEachCell(0, column, self.rC(), columnCount, setAdjust, setDirty, calcChangInfo);
	                    self._iterateEachColumn(column, columnCount, setAdjust, setDirty, calcChangInfo);
	                   
	                    if (self._rangeCalc) {
	                        if (setAdjust) {
	                            self._rangeCalc._addListenersToAdjust(row, column, rowCount, columnCount);
	                        }
	                        if (setDirty) {
	                            self._rangeCalc._addListenersToDirty(row, column, rowCount, columnCount);
	                        }
	                    }
	                } else if (row === -1 && column === -1) {
	                    var rc = self.rC(), cc = self.cC();
	                    self._iterateEachCell(0, 0, rc, cc, setAdjust, setDirty, calcChangInfo);
	                    self._iterateEachRow(0, rc, setAdjust, setDirty, calcChangInfo);
	                    self._iterateEachColumn(0, cc, setAdjust, setDirty, calcChangInfo);
	                   
	                    if (self._rangeCalc) {
	                        if (setAdjust) {
	                            self._rangeCalc._addListenersToAdjust(row, column, rowCount, columnCount);
	                        }
	                        if (setDirty) {
	                            self._rangeCalc._addListenersToDirty(row, column, rowCount, columnCount);
	                        }
	                    }
	                }
	            }
	        },
	        getAllNodes: function () {
	            var nodes = [], cells = this.dataTable, rows = this._rowDataArray, cols = this._columnDataArray,
	                sheet = this._defaultDataNode, node, key;
	            if (sheet) {
	                nodes.push(sheet);
	            }
	            for (key in rows) { 
	                if (rows.hasOwnProperty(key)) {
	                    node = rows[key];
	                    if (node) {
	                        nodes.push(node);
	                    }
	                }
	            }
	            for (key in cols) { 
	                if (cols.hasOwnProperty(key)) {
	                    node = cols[key];
	                    if (node) {
	                        nodes.push(node);
	                    }
	                }
	            }
	            for (var rowKey in cells) { 
	                if (cells.hasOwnProperty(rowKey)) {
	                    var rowNode = cells[rowKey];
	                    if (rowNode) {
	                        for (key in rowNode) { 
	                            if (rowNode.hasOwnProperty(key)) {
	                                node = rowNode[key];
	                                if (node) {
	                                    nodes.push(node);
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            return nodes;
	        },
	        toJSON: function (data) {
	            this._source.toJSON(data, this.dataTable, this._lastNonNullRow, this._lastNonNullColumn);
	        }
	    };
	
	    var BaseCalc = Calc.BaseCalc;
	    var CellCalc = Calc.CellCalc = (function (_super) {
	        inherit(CellCalc, _super);
	        function CellCalc(sourceModel, row, column) {
	            _super.call(this, sourceModel);
	            var self = this;
	            self.row = row;
	            self.column = column;
	            self.delay = 0;
	        }
	
	        return CellCalc;
	    })(BaseCalc);
	    extend(CellCalc.prototype, {
	        getKey: function () {
	            var self = this;
	            var sourceModel = self._sourceModel;
	            var sourceName = sourceModel === null ? '' : sourceModel._source.id + ',';
	            return sourceName + self.row + ',' + self.column;
	        },
	        _startListening: function () {
	            var self = this;
	            self._sourceModel._linkCellExpression(self.row, self.column, 1, 1);
	        },
	        _stopListening: function () {
	            var self = this;
	            self._sourceModel._unlinkCellExpression(self.row, self.column, 1, 1);
	        },
	        _addToAdjust: function () {
	            this._sourceModel._getCalcServiceInternal()._getOperatorAdjustor()._addAdjust(this, 0 );
	        },
	        _addToDirty: function () {
	            this._sourceModel._getCalcServiceInternal()._addDirty(this, 0 );
	        },
	        _setAsyncFunctionNodeNeedRecalculate: function () {
	            var self = this;
	            var sourceModel = self._sourceModel, calcService = sourceModel.getCalcService();
	            if (calcService && calcService._hasAsync) {
	                var hasAsync = self._hasAsync, asyncFunctionNode = hasAsync && self._asyncNode;
	                if (!asyncFunctionNode && isNullOrUndefined(hasAsync)) {
	                    var sheetSource = sourceModel.getSource();
	                    if (sheetSource) {
	                        var sheetName = sheetSource.getName();
	                        var asyncManager = calcService._evaluator.asyncManager;
	
	                        var nodes = asyncManager._nodes[sheetName];
	                       
	                       
	                       
	                        if (nodes) {   
	                            var rowNode = nodes[self.row];
	                            if (rowNode) {
	                                var colItem = rowNode[self.column];
	                                if (colItem) {
	                                    asyncFunctionNode = colItem[0];
	                                    if (asyncFunctionNode) {
	                                        self._hasAsync = true;
	                                        self._asyncNode = asyncFunctionNode;
	                                        asyncFunctionNode._calc = self;
	                                    } else {
	                                        self._hasAsync = false;
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	                if (asyncFunctionNode && asyncFunctionNode.evaluateMode === 0 ) {
	                    asyncFunctionNode._hasResult = false;   
	                }
	            }
	        }
	    });
	
	    function addListenerImp(obj, prop, item) {
	        if (!obj[prop]) {
	            obj[prop] = [];
	        }
	        obj[prop].push(item);
	    }
	
	    function removeListenerImp(obj, prop, item) {
	        var collection = obj[prop];
	        if (collection) {
	            for (var i = 0; i < collection.length; i++) {
	                if (collection[i] === item) {
	                    collection.splice(i, 1);
	                    return;
	                }
	            }
	        }
	    }
	
	    var RowCalc = Calc.RowCalc = (function (_super) {
	        inherit(RowCalc, _super);
	        function RowCalc(sourceModel, row) {
	            _super.call(this, sourceModel);
	            var self = this;
	            self.row = row;
	        }
	
	        return RowCalc;
	    })(BaseCalc);
	    extend(RowCalc.prototype, {
	        getKey: function () {
	            var self = this;
	            var sourceModel = self._sourceModel;
	            var sourceName = sourceModel === null ? '' : sourceModel._source.id + ',';
	            return sourceName + self.row + ',-1';
	        },
	        incrementDelay2: function (column, columnCount) {
	           
	        },
	        decrementDelay2: function (column, columnCount) {
	           
	        },
	        _startListening: function () {
	            this._sourceModel._linkRowExpression(this.row, 1);
	        },
	        _stopListening: function () {
	            this._sourceModel._unlinkRowExpression(this.row, 1);
	        },
	        _processRowListener2: function (row, columnOffset, isAdd) {
	            if (isAdd) {
	                addListenerImp(this, rowSliceListeners, { row: row, columnOffset: columnOffset, columnCount: 1 });
	            } else {
	                removeListenerImp(this, rowSliceListeners, { row: row, columnOffset: columnOffset, columnCount: 1 });
	            }
	        },
	        _addToAdjust: function () {
	            this._sourceModel._getCalcServiceInternal()._getOperatorAdjustor()._addAdjust(this, 1 );
	        },
	        _addToDirty: function () {
	            this._sourceModel._getCalcServiceInternal()._addDirty(this, 1 );
	        }
	    });
	
	    var ColumnCalc = Calc.ColumnCalc = (function (_super) {
	        inherit(ColumnCalc, _super);
	        function ColumnCalc(sourceModel, column) {
	            _super.call(this, sourceModel);
	            var self = this;
	            self.column = column;
	        }
	
	        return ColumnCalc;
	    })(BaseCalc);
	    extend(ColumnCalc.prototype, {
	        getKey: function () {
	            var self = this;
	            var sourceModel = self._sourceModel;
	            var sourceName = sourceModel === null ? '' : sourceModel._source.id + ',';
	            return sourceName + '-1,' + self.column;
	        },
	        incrementDelay2: function (row, rowCount) {
	           
	        },
	        decrementDelay2: function (row, rowCount) {
	           
	        },
	        _startListening: function () {
	            this._sourceModel._linkColumnExpression(this.column, 1);
	        },
	        _stopListening: function () {
	            this._sourceModel._unlinkColumnExpression(this.column, 1);
	        },
	        _processColumnListener2: function (column, rowOffset, isAdd) {
	           
	           
	           
	           
	           
	           
	            this._processListener(columnListeners, column, isAdd);
	        },
	        _addToAdjust: function () {
	            this._sourceModel._getCalcServiceInternal()._getOperatorAdjustor()._addAdjust(this, 2 );
	        },
	        _addToDirty: function () {
	            this._sourceModel._getCalcServiceInternal()._addDirty(this, 2 );
	        }
	    });
	
	   
	    var NameCalc = Calc.NameCalc = (function (_super) {
	        inherit(NameCalc, _super);
	        function NameCalc(sourceModel, name) {
	            _super.call(this, sourceModel);
	            this.name = name;
	        }
	
	        return NameCalc;
	    })(BaseCalc);
	    extend(NameCalc.prototype, {
	        getKey: function () {
	            var self = this;
	            var sourceModel = self._sourceModel;
	            var sourceName = sourceModel === null ? '' : sourceModel._source.id + ',';
	            return sourceName + self.name;
	        },
	        updateListening: function (stop, start) {
	            var self = this;
	            var listeners = self._listeners, calc, node;
	            for (var lIndex = 0; lIndex < listeners.length; lIndex++) {
	                var cls = self[listeners[lIndex]];
	                if (cls) {
	                    var clsArray = [];
	                    for (var key in cls) { 
	                        if (cls.hasOwnProperty(key)) {
	                            calc = cls[key];
	                            calc && (clsArray.push(calc));
	                        }
	                    }
	                    var cLength = clsArray.length;
	                    for (var i = 0; i < cLength; i++) {
	                        calc = clsArray[i];
	                       
	                       
	                       
	                       
	                       
	                       
	                       
	                       
	                       
	                       
	                       
	                        node = calc.node;
	                        calc._stopListening();
	                        if (node && (!node._arrayInfo || node._arrayInfo.row === calc.row && node._arrayInfo.col === calc.column)) {
	                            calc._sourceModel._setExpression(calc.row, calc.column, node._expr, node._arrayInfo, true);
	                        }
	                    }
	                }
	            }
	        },
	        updateListeningOnRemoved: function () {
	            var self = this;
	            var listeners = self._listeners, calc, depModel, row, col, expr, baseModel = self._sourceModel,
	                service = baseModel._getCalcServiceInternal();
	            for (var lIndex = 0; lIndex < listeners.length; lIndex++) {
	                var cls = self[listeners[lIndex]];
	                if (cls) {
	                    for (var key in cls) { 
	                        if (cls.hasOwnProperty(key)) {
	                            calc = cls[key];
	                            if (calc) {
	                                depModel = calc._sourceModel;
	                                row = calc.row;
	                                col = calc.col;
	                                row = row === keyword_undefined ? -1 : row;
	                                col = col === keyword_undefined ? -1 : col;
	                                expr = depModel._getExpr(row, col);
	                                var baseRange = depModel._getArrayInfo(row, col);
	                                if (expr) {
	                                    var newExpr = service._getOperatorAdjustor().adjustFormulaOnRemoveName(baseModel, expr, self.name);
	                                    if (newExpr !== expr) {
	                                        depModel._setExpression(row, col, newExpr, baseRange, true);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        },
	        _addToDirty: function () {
	            var listeners = this._listeners, calc;
	            for (var lIndex = 0; lIndex < listeners.length; lIndex++) {
	                var cls = this[listeners[lIndex]];
	                if (cls) {
	                    for (var key in cls) { 
	                        if (cls.hasOwnProperty(key)) {
	                            calc = cls[key];
	                            calc && calc._addToDirty();
	                        }
	                    }
	                }
	            }
	        }
	    });
	
	    var RangeCalc = Calc.RangeCalc = (function () {
	        function RangeCalc(sourceModel) {
	            this._sourceModel = sourceModel;
	            this._listeners = [];
	        }
	
	        return RangeCalc;
	    })();
	    extend(RangeCalc.prototype, {
	        processListener: function (listenerType, row, column, rowCount, columnCount, listener, isAdd) {
	            var self = this, caches = self[listenerType], key = row + ',' + column + ',' + rowCount + ',' + columnCount,
	                list, i;
	            if (listenerType === nameIDListeners && !(listener instanceof Calc.NameIDCalc)) {
	                return;
	            }
	            if (!caches) {
	                self._listeners.push(listenerType);
	                self[listenerType] = caches = {};
	            }
	            list = caches[key];
	            if (!list) {
	                if (!isAdd) {
	                    return;
	                }
	                list = caches[key] = [];
	                list.row = row;
	                list.col = column;
	                list.rowCount = rowCount;
	                list.colCount = columnCount;
	            }
	            if (isAdd) {
	                for (i = 0; i < list.length; i++) {
	                    if (list[i] === listener) {
	                        return;
	                    }
	                }
	                list.push(listener);
	            } else {
	                for (i = 0; i < list.length; i++) {
	                    if (list[i] === listener) {
	                        list.splice(i, 1);
	                    }
	                }
	            }
	        },
	        _processCellListener: function (row, column, rowCount, columnCount, listener, isAdd) {
	            this.processListener(cellListeners, row, column, rowCount, columnCount, listener, isAdd);
	        },
	        _processRowListener: function (row, column, rowCount, columnCount, listener, all, sliceOffset, sliceCount, isAdd) {
	            this.processListener(rowListeners, row, column, rowCount, columnCount, listener, isAdd);
	        },
	        _processColumnListener: function (row, column, rowCount, columnCount, listener, all, sliceOffset, sliceCount, isAdd) {
	            this.processListener(columnListeners, row, column, rowCount, columnCount, listener, isAdd);
	        },
	        _processIDListerner: function (row, column, rowCount, columnCount, listener, isAdd) {
	            this.processListener(nameIDListeners, row, column, rowCount, columnCount, listener, isAdd);
	        },
	        _addListenersToAdjust: function (row, column, rowCount, columnCount) {
	            this.visit(0 , row, column, rowCount, columnCount);
	        },
	        clearListenersCache: function () {
	            var listeners = this._listeners;
	            for (var lIndex = 0; lIndex < listeners.length; lIndex++) {
	                delete this[listeners[lIndex] + 'cached'];
	            }
	        },
	        getListeners: function (listeners, lIndex) {
	            var cls = this[listeners[lIndex]], cached;
	            if (cls) {
	                cached = this[listeners[lIndex] + 'cached'];
	                if (!cached) {
	                    cached = this[listeners[lIndex] + 'cached'] = [];
	                    for (var rangeKey in cls) {
	                        if (cls.hasOwnProperty(rangeKey)) {
	                            var list = cls[rangeKey];
	                            if (list) {
	                                cached.push(list);
	                            }
	                        }
	                    }
	                }
	            }
	            return cached;
	        },
	        visit: function (action, row, column, rowCount, columnCount) {
	            var listeners = this._listeners, calc;
	            for (var lIndex = 0; lIndex < listeners.length; lIndex++) {
	                var cls = this[listeners[lIndex]];
	                if (cls) {
	                    var cachedListeners = this.getListeners(listeners, lIndex);
	                    for (var i = 0; i < cachedListeners.length; i++) {
	                        var list = cachedListeners[i];
	                        var r = list.row;
	                        var c = list.col;
	                        var rc = list.rowCount;
	                        var cc = list.colCount;
	                       
	                        if ((r === -1 || row === -1 || r < row + rowCount && row < r + rc) && (c === -1 || column === -1 || c < column + columnCount && column < c + cc)) {
	                            var listenerLength = list.length;
	                            for (var listenerIndex = 0; listenerIndex < listenerLength; listenerIndex++) {
	                                calc = list[listenerIndex];
	                                if (action === 0 ) {
	                                    calc._addToAdjust();
	                                } else {
	                                    calc._addToDirty();
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        },
	        _addListenersToDirty: function (row, column, rowCount, columnCount) {
	            this.visit(1 , row, column, rowCount, columnCount);
	        },
	        _adjustDelayOfListeners: function (row, column, isIncrement) {
	            var listeners = this._listeners, range, increment = isIncrement ? 1 : -1;
	            for (var lIndex = 0; lIndex < listeners.length; lIndex++) {
	                var cls = this[listeners[lIndex]];
	                if (cls) {
	                    var cachedListeners = this.getListeners(listeners, lIndex);
	                    for (var i = 0; i < cachedListeners.length; i++) {
	                        var list = cachedListeners[i];
	                        range = list;
	                       
	                        if (range && (range.row === -1 || range.row <= row && row < range.row + range.rowCount) && (range.col === -1 || range.col <= column && column < range.col + range.colCount)) {
	                            var listenerLength = list.length;
	                            for (var listenerIndex = 0; listenerIndex < listenerLength; listenerIndex++) {
	                                list[listenerIndex].delay += increment;
	                            }
	                        }
	                    }
	                }
	            }
	        },
	        _startListening: function () {
	        },
	        _stopListening: function () {
	        }
	    });
	
	    function createMappingNode(expr, acceptsArray, acceptsRef, index, context) {
	        return { expr: expr, acceptsArray: acceptsArray, acceptsRef: acceptsRef, index: index, context: context };
	    }
	
	    var _mappingArray = Calc._mappingArray = function (context, expr, isArrayFormula, offsetRow, offsetCol, resultArray, resultReference) {
	        var baseRow = context.row, baseColumn = context.column, stack = [], stackIndex = 0;
	        var activeRow = context.arrayIdentity ? context.arrayIdentity.row : baseRow,
	            activeCol = context.arrayIdentity ? context.arrayIdentity.col : baseColumn;
	        stack[stackIndex] = {
	            expr: expr,
	            acceptsArray: resultArray || false,
	            acceptsRef: resultReference || false,
	            index: -1
	        };
	        var expendCount = 0;
	        var nameCount = 0;
	        var _currentIndexneedExpend = false;
	        var _rowOffset = offsetRow;
	        var _colOffset = offsetCol;
	        var _arrayArgumentEvaluateMode = false;
	        var currentNode, acceptsArray, acceptsReference, newExpr, argExpr, range, source, maxRowCount, maxColCount, row, col, neeedExpendindexs;
	        while (stackIndex >= 0) {
	            currentNode = stack[stackIndex--];
	            acceptsArray = currentNode.acceptsArray;
	            acceptsReference = currentNode.acceptsRef;
	            expr = currentNode.expr;
	            newExpr = keyword_null;
	            if (!expr) {
	            } else if (expr.type === 7 ) {
	                var funcExpr = expr;
	                var func;
	                var argCount = funcExpr.arguments.length;
	                if (!funcExpr.function) {
	                    if (!context) {
	                        newExpr = createErrorExpression(CalcErrorsName);
	                        continue;
	                    } else {
	                        funcExpr.function = context.getFunction(funcExpr.functionName);
	                    }
	                }
	                func = funcExpr.function;
	                var argIndex = currentNode.index;
	                neeedExpendindexs = currentNode.neeedExpendindexs;
	                if (argIndex < 0) {
	                    currentNode.arrayArgumentEvaluateMode = _arrayArgumentEvaluateMode;
	                    currentNode.arrayFormulaCatchValue = isArrayFormula;
	                    if (func && func.arrayArgumentEvaluateMode) {
	                        _arrayArgumentEvaluateMode = func.arrayArgumentEvaluateMode;
	                    }
	                    currentNode.args = [];
	                } else {
	                    if (func && func.acceptsArray(argIndex)) {
	                        expendCount--;
	                    } else if (_currentIndexneedExpend) {
	                        if (!neeedExpendindexs) {
	                            neeedExpendindexs = [];
	                            currentNode.neeedExpendindexs = neeedExpendindexs;
	                        }
	                        if (funcExpr.arguments[argIndex] !== argExpr) {
	                        }
	                        neeedExpendindexs.push(argIndex);
	                    }
	                    currentNode.args.push(argExpr);
	                }
	                if (argIndex === argCount - 1) {
	                    _arrayArgumentEvaluateMode = currentNode.arrayArgumentEvaluateMode;
	                    isArrayFormula = currentNode.arrayFormulaCatchValue;
	                    var args = currentNode.args;
	                    var argsChanged = false;
	                    if (args && args.length > 0) {
	                        for (var argI = 0; argI < args.length; argI++) {
	                            if (args[argI] !== funcExpr.arguments[argI]) {
	                                argsChanged = true;
	                                break;
	                            }
	                        }
	                    }
	                    if (argsChanged) {
	                        newExpr = createFunctionExpression(funcExpr, args);
	                    } else {
	                        newExpr = expr;
	                    }
	                    if (neeedExpendindexs && neeedExpendindexs.length > 0) {
	                        newExpr = createExpandExpression(newExpr, neeedExpendindexs);
	                        _currentIndexneedExpend = true;
	                    }
	                    if ((!acceptsReference || !acceptsArray) && func && func.returnReference && func.returnReference()) {
	                        _currentIndexneedExpend = true;
	                    }
	                } else {
	                    if (argIndex === 0 && func && func.arrayArgumentEvaluateMode === 3 && _arrayArgumentEvaluateMode === 3 ) {
	                        _arrayArgumentEvaluateMode = 0;
	                    }
	                    _currentIndexneedExpend = false;
	                    argIndex++;
	                    currentNode.index = argIndex;
	                    if (func && func.acceptsArray(argIndex)) {
	                        expendCount++;
	                    }
	                    stack[++stackIndex] = currentNode;
	                    stack[++stackIndex] = {
	                        expr: funcExpr.arguments[argIndex],
	                        acceptsArray: !!func && func.acceptsArray(argIndex),
	                        acceptsRef: !!func && func.acceptsReference(argIndex),
	                        index: -1
	                    };
	                }
	            } else if (expr.type === 1  && expr._isCell()) {
	                if (nameCount) {
	                    source = expr.source !== Calc.BangSource && expr.source || context.source;
	                    maxRowCount = source.getRowCount();
	                    maxColCount = source.getColumnCount();
	                    row = expr.rowRelative ? (expr.row + activeRow) % MAX_ROW_COUNT % maxRowCount : expr.row;
	                    col = expr.columnRelative ? (expr.column + activeCol) % MAX_COLUMN_COUNT % maxColCount : expr.column;
	                    row = row < 0 ? row + maxRowCount : row;
	                    col = col < 0 ? col + maxColCount : col;
	                    expr = createCellExpression(expr.source && source, keyword_null, row, col, false, false);
	                }
	            } else if (expr.type === 1  || expr.type === 13 ) {
	                if (expr.type === 13 ) {
	                    var tableExpr = expr;
	                    range = tableExpr.getRange(baseRow, baseColumn);
	                    if (!range) {
	                        newExpr = expr;
	                        argExpr = expr;
	                        continue;
	                    }
	                    expr = createRangeExpression(tableExpr.source() === context.source ? keyword_null : tableExpr.source(),
	                        keyword_null, range.row, range.col, range.row + range.rowCount - 1, range.col + range.colCount - 1);
	                }
	                var actualSource = expr.source !== Calc.BangSource && expr.source;
	                var rangeExpr = expr;
	                if (nameCount) {
	                    source = actualSource || context.source;
	                    maxRowCount = MAX_ROW_COUNT;
	                    maxColCount = MAX_COLUMN_COUNT;
	                    var startRow = rangeExpr.rowRelative ? (rangeExpr.row + activeRow) % maxRowCount : rangeExpr.row;
	                    var startCol = rangeExpr.columnRelative ? (rangeExpr.column + activeCol) % maxColCount : rangeExpr.column;
	                    var endRow = rangeExpr.endRowRelative ? (rangeExpr.endRow + activeRow) % maxRowCount : rangeExpr.endRow;
	                    var endCol = rangeExpr.endColumnRelative ? (rangeExpr.endColumn + activeCol) % maxColCount : rangeExpr.endColumn;
	                    startRow = startRow < 0 ? startRow + maxRowCount : startRow;
	                    startCol = startCol < 0 ? startCol + maxColCount : startCol;
	                    endRow = endRow < 0 ? endRow + maxRowCount : endRow;
	                    endCol = endCol < 0 ? endCol + maxColCount : endCol;
	                    var tmp;
	                    if (startRow > endRow) {
	                        tmp = startRow;
	                        startRow = endRow;
	                        endRow = tmp;
	                    }
	                    if (startCol > endCol) {
	                        tmp = startCol;
	                        startCol = endCol;
	                        endCol = tmp;
	                    }
	                    maxRowCount = source.getRowCount();
	                    maxColCount = source.getColumnCount();
	                    if (startRow >= maxRowCount) {
	                        startRow = startRow % maxRowCount;
	                        endRow = endRow % maxRowCount;
	                    } else if (endRow >= maxRowCount) {
	                        endRow = maxRowCount - 1;
	                    }
	                    if (startCol >= maxColCount) {
	                        startCol = startCol % maxColCount;
	                        endCol = endCol % maxColCount;
	                    } else if (endCol >= maxColCount) {
	                        endCol = maxColCount - 1;
	                    }
	                    if (expr.row === BAND_INDEX_CONST) {
	                        startRow = endRow = BAND_INDEX_CONST;
	                    }
	                    if (expr.column === BAND_INDEX_CONST) {
	                        startCol = endCol = BAND_INDEX_CONST;
	                    }
	                    expr = createRangeExpression(actualSource, expr.endSource, startRow, startCol, endRow, endCol, false, false, false, false);
	                }
	                if (acceptsReference && (acceptsArray || !isArrayFormula && _arrayArgumentEvaluateMode !== 1  && _arrayArgumentEvaluateMode !== 3)
	                    || baseRow < 0 || baseColumn < 0) {
	                } else if (expendCount > 0 && !isArrayFormula && _arrayArgumentEvaluateMode !== 1  && _arrayArgumentEvaluateMode !== 3 
	                    || expendCount === 0 || _arrayArgumentEvaluateMode === 2 ) {
	                    range = rangeExpr.getRange(baseRow, baseColumn);
	                    if (isArrayFormula || (acceptsReference || acceptsArray) && _arrayArgumentEvaluateMode === 1 ) {
	                        if (!rangeExpr.isFullColumn && range.rowCount !== 1 && _rowOffset >= range.rowCount || !rangeExpr.isFullRow && range.colCount !== 1 && _colOffset >= range.colCount) {
	                            newExpr = createErrorExpression(CalcErrorsNotAvailable);
	                        } else {
	                            row = (rangeExpr.isFullColumn ? 0 : range.row) + (range.rowCount === 1 ? 0 : _rowOffset);
	                            col = (rangeExpr.isFullRow ? 0 : range.col) + (range.colCount === 1 ? 0 : _colOffset);
	                            newExpr = createCellExpression(actualSource, expr.endSource, row, col, false, false);
	                        }
	                    } else if (range.rowCount > 1 && range.colCount > 1 || range.rowCount > 1 && !rangeExpr.isFullColumn && (baseRow < range.row || baseRow >= range.row + range.rowCount) || range.colCount > 1 && !rangeExpr.isFullRow && (baseColumn < range.col || baseColumn >= range.col + range.colCount)) {
	                        newExpr = createErrorExpression(CalcErrorsValue);
	                    } else {
	                        row = (rangeExpr.isFullColumn || range.rowCount > 1) ? baseRow : range.row;
	                        col = (rangeExpr.isFullRow || range.colCount > 1) ? baseColumn : range.col;
	                        newExpr = createCellExpression(actualSource, expr.endSource, row, col, false, false);
	                    }
	                } else {
	                    _currentIndexneedExpend = true;
	                }
	            } else if (expr.type === 9 ) {
	                var acceptsRef = expr.operatorType >= 15 ;
	                if (currentNode.index === -1) {
	                    currentNode.index = expr.value2 ? 0 : 1;
	                    stack[++stackIndex] = currentNode;
	                    stack[++stackIndex] = createMappingNode(expr.value, acceptsRef, acceptsRef, -1);
	                } else if (currentNode.index === 0) {
	                    if (argExpr !== expr.value) {
	                        newExpr = createOperatorExpression(expr.operatorType, argExpr, expr.value2);
	                        currentNode.expr = newExpr;
	                    }
	                    if (_currentIndexneedExpend) {
	                        neeedExpendindexs = [];
	                        neeedExpendindexs.push(0);
	                        currentNode.neeedExpendindexs = neeedExpendindexs;
	                        _currentIndexneedExpend = false;
	                    }
	                    currentNode.index = 1;
	                    stack[++stackIndex] = currentNode;
	                    stack[++stackIndex] = createMappingNode(expr.value2, acceptsRef, acceptsRef, -1);
	                } else {
	                    if (expr.value2 && argExpr !== expr.value2) {
	                        newExpr = createOperatorExpression(expr.operatorType, expr.value, argExpr);
	                    } else {
	                        newExpr = expr;
	                    }
	                    neeedExpendindexs = currentNode.neeedExpendindexs;
	                    if (_currentIndexneedExpend) {
	                        if (!neeedExpendindexs) {
	                            neeedExpendindexs = [];
	                        }
	                        neeedExpendindexs.push(1);
	                    }
	                    if (neeedExpendindexs) {
	                        newExpr = createExpandExpression(newExpr, neeedExpendindexs);
	                        _currentIndexneedExpend = true;
	                    }
	                }
	            } else if (expr.type === 10 ) {
	                if (currentNode.index === -1) {
	                    currentNode.index = 0;
	                    stack[++stackIndex] = currentNode;
	                    stack[++stackIndex] = createMappingNode(expr.value, acceptsArray, acceptsReference, -1);
	                } else if (expr.value !== argExpr) {
	                    newExpr = createParenthesesExpression(argExpr);
	                }
	            } else if (expr.type === 8 ) {
	                if (currentNode.index === 1) {
	                    nameCount--;
	                    newExpr = argExpr;
	                    if (currentNode.context) {
	                        context = currentNode.context;
	                    }
	                } else {
	                    nameCount++;
	                    stack[++stackIndex] = createMappingNode(expr, acceptsArray, acceptsReference, 1, context);
	                    var rExpr, extContext = context, extSource;
	                    if (expr.source) {
	                        extSource = expr.source === Calc.BangSource ? context.source : expr.source;
	                        extContext = new Calc.EvaluateContext(extSource);
	                        extContext.cloneFrom(context);
	                        rExpr = extSource.getCustomName(expr.value);
	                    } else {
	                        rExpr = context.getName(expr.value);
	                        if (!context.source.getCustomName(expr.value)) {
	                            extContext = new Calc.GloableEvaluateContext(context.source);
	                            extContext.cloneFrom(context);
	                        }
	                    }
	                    if (!rExpr) {
	                        rExpr = createErrorExpression(CalcErrorsName);
	                    }
	                    context = extContext || context;
	                    stack[++stackIndex] = createMappingNode(rExpr, acceptsArray, acceptsReference, -1, context);
	                }
	            } else if (expr.type === 6 ) {
	                var arrayExpression = expr;
	                if (!acceptsArray && (expendCount > 0 || isArrayFormula || _arrayArgumentEvaluateMode === 1  || _arrayArgumentEvaluateMode === 3 )) {
	                    _currentIndexneedExpend = true;
	                } else if (!acceptsArray && expendCount === 0) {
	                    if ((_rowOffset >= arrayExpression.value.RowCount && arrayExpression.value.RowCount > 1) || (_colOffset >= arrayExpression.value.colCount && arrayExpression.value.colCount > 1)) {
	                        newExpr = createErrorExpression(CalcErrorsNotAvailable);
	                    } else {
	                        try {
	                            if (arrayExpression.value.RowCount === 1) {
	                                _rowOffset = 0;
	                            }
	                            if (arrayExpression.value.colCount === 1) {
	                                _colOffset = 0;
	                            }
	                            var cValue = arrayExpression.value.getValue(_rowOffset, _colOffset);
	                            if (typeof cValue === 'string') {
	                                newExpr = createStringExpression(cValue);
	                            } else if (typeof cValue === 'number') {
	                                newExpr = createNumberExpression(cValue);
	                            }
	                            var parser = new Calc.Parser();
	
	                            newExpr = parser.parse(context.source.getParserContext(context.useR1C1, createCellIdentity(0, 0)), arrayExpression.value.getValue(_rowOffset, _colOffset).toString());
	                        } catch (ex) {
	                            newExpr = createErrorExpression(CalcErrorsNotAvailable);
	                        }
	                    }
	                }
	            }
	            if (newExpr === keyword_null) {
	                newExpr = expr;
	            } else if (newExpr !== expr) {
	               
	            }
	            argExpr = newExpr;
	        }
	        return newExpr;
	    };
	
	
	
	   
	
	
	    var SheetSource = SheetsCalc.SheetSource = (function (_super) {
	        inherit(SheetSource, _super);
	        function SheetSource(sheet) {
	            _super.call(this, keyword_null);
	            this._sheet = sheet;
	        }
	
	        return SheetSource;
	    })(Calc.CalcSource);
	    extend(SheetSource.prototype, {
	        createSourceModel: function (calcService) {
	            return new CalcSourceModel(calcService, this);
	        },
	        startCalculation: function () {
	            if (this._valueCaches) {
	                return;
	            }
	            var rowCount = this.getRowCount(), colCount = this.getColumnCount();
	            this._valueCaches = {rowCount: rowCount, colCount: colCount, arrayInfo: []};
	            this._changedCells = [];
	        },
	        endCalculation: function () {
	            this._valueCaches = keyword_null;
	            var changedCells = this._changedCells;
	            if (changedCells && changedCells.length > 0) {
	                this._sheet._trigger(__webpack_require__(17).Events.RangeChanged, {
	                    sheet: this._sheet,
	                    sheetName: this._sheet.name(),
	                    row: 0,
	                    col: 0,
	                    rowCount: this._sheet.getRowCount(),
	                    colCount: this._sheet.getColumnCount(),
	                    changedCells: changedCells,
	                    action: 6 
	                });
	            }
	            this._changedCells = keyword_null;
	            var rangeCalc = this._calcSourceModel._getRangeCalc(false);
	            if (rangeCalc) {
	                rangeCalc.clearListenersCache();
	            }
	        },
	        clearValueCache: function () {
	            this._valueCaches = keyword_null;
	        },
	        getValue: function (identity, valueType) { 
	            var self = this, sheet = self._sheet, row, column;
	            if (identity.row !== keyword_undefined) {
	                row = identity.row;
	                column = identity.col;
	            } else if (identity.name) {
	                return null;
	            } else {
	                row = arguments[0];
	                column = arguments[1];
	                valueType = arguments[2];
	            }
	            valueType = valueType || 0 ;
	           
	            if (row < 0 || column < 0) {
	                return CalcErrorsValue;
	            }
	            if (sheet._isValidatingCell && sheet._validatingRow === row && sheet._validatingColumn === column) {
	                return sheet._validatingValue;
	            }
	            var cache = self._valueCaches, typeString = CalcValueTypeStrings[valueType];
	            if (cache) {
	                var rowCount = cache.rowCount, colCount = cache.colCount, rowCache, cellCache, value;
	                if (row >= rowCount) {
	                    return keyword_null;
	                }
	                if (column >= colCount) {
	                    return keyword_null;
	                }
	                rowCache = cache[row];
	                if (!rowCache) {
	                    rowCache = cache[row] = {};
	                }
	                cellCache = rowCache[column];
	                if (!cellCache) {
	                    cellCache = rowCache[column] = {v: sheet.getValue(row, column)};
	                }
	                value = cellCache[typeString];
	                if (value === keyword_undefined) {
	                    value = Calc.Convert._convertValue(cellCache.v, valueType, true);
	                    cellCache[typeString] = value;
	                }
	                value = util_common._tryConvertOADateToDate(value);
	                return value;
	            } else if (row >= self.getRowCount()) {
	                return keyword_null;
	            }
	            if (column >= self.getColumnCount()) {
	                return keyword_null;
	            }
	            return self._sheet.getValue(row, column);
	        },
	        getIdentity: function (context, ref) {
	            var self = this;
	
	            var row = ref.row, rowCount = ref.rowCount || 1, col = ref.column, colCount = ref.columnCount || 1;
	            if (row === -1) {
	                row = 0;
	                rowCount = self.getRowCount();
	            }
	            if (col === -1) {
	                col = 0;
	                colCount = self.getColumnCount();
	            }
	            return self.getName() + "." + row + "." + rowCount + "." + col + "." + colCount;
	        },
	        getReference: function (identity) {
	            var self = this;
	            if (identity.row === -1) {
	                identity.row = 0;
	                identity.rowCount = self.getRowCount();
	            }
	            if (identity.col === -1) {
	                identity.col = 0;
	                identity.colCount = self.getColumnCount();
	            }
	            return new Calc.CalcReference(self, [identity]);
	        },
	        getSheetRangeReference: function (identity) {
	            var parent = this._sheet && this._sheet.parent;
	            if (identity.endSource && parent && parent.sheets && (identity.endSource instanceof SheetSource)) {
	                var sheets = parent.sheets, searched = false, source, references = [];
	                for (var i = 0; i < sheets.length; i++) {
	                    source = sheets[i]._getSheetSource();
	                    if (source === this) {
	                        searched = true;
	                    } else if (source === identity.endSource) {
	                        references.push(source.getReference(identity));
	                        break;
	                    }
	                    if (searched) {
	                        references.push(source.getReference(identity));
	                    }
	                }
	                return new SheetRangeReference(references);
	            }
	        },
	        getSources: function (endSource) {
	            if (this._sheet && this._sheet.parent && this._sheet.parent.sheets && (endSource instanceof SheetSource)) {
	                var sheets = this._sheet.parent.sheets, searched = false, source, sources = [];
	                for (var i = 0; i < sheets.length; i++) {
	                    source = sheets[i]._getSheetSource();
	                    if (source === this) {
	                        searched = true;
	                    }
	                    if (source === endSource) {
	                        sources.push(source);
	                        break;
	                    }
	                    if (searched) {
	                        sources.push(source);
	                    }
	                }
	                return sources;
	            }
	        },
	        _removeDirtyCachedArrayItem: function (row, column) {
	            var self = this;
	            var valueCaches = self._valueCaches, keys = valueCaches && valueCaches.arrayInfo;
	            if (keys) {
	                keys.forEach(function (item, index) {
	                    if (item) {
	                        var reference = item.reference, key = item.key;
	                        if (range_contains.call(reference._identities[0], row, column)) {
	                            delete valueCaches[key];   
	                            delete keys[index];        
	                        }
	                    }
	                });
	            }
	        },
	        referenceToArray: function (reference, valueType, toOneDimension, breakOnError, breakOnConvertError, ignoreBlank, followFormatter, ignoreBoolean) { 
	            var self = this, row, col, rowCount = 1, colCount = 1, startRow, startCol, rangeCount, result = [], value,
	                rowValues, sheet = self._sheet, valueCaches = self._valueCaches, rowCaches, cacheKey,
	                typeString = CalcValueTypeStrings[valueType];
	            rangeCount = reference.getRangeCount();
	            if (rangeCount === 0) {
	                result.isError = true;
	                return result;
	            }
	            if (valueCaches) {
	                cacheKey = reference.getRangeCount() + '_' + reference.getRow(0) + '_' + reference.getColumn(0) + '_' + reference.getRowCount(0) + '_' + reference.getColumnCount(0) + '_' + valueType + '_' + toOneDimension;
	                value = valueCaches[cacheKey];
	                if (value) {
	                    return value;
	                }
	            }
	            var maxRowCount = this.getRowCount(), maxColCount = this.getColumnCount();
	            toOneDimension = toOneDimension === keyword_undefined ? true : toOneDimension;
	            for (var rangeIndex = 0; rangeIndex < rangeCount; rangeIndex++) {
	                if (!toOneDimension) {
	                    rowValues = [];
	                    result.push(rowValues);
	                }
	                rowCount = reference.getRowCount(rangeIndex);
	                if (rowCount === 0) {
	                    result.isError = true;
	                    return result;
	                }
	                colCount = reference.getColumnCount(rangeIndex);
	                if (colCount === 0) {
	                    result.isError = true;
	                    return result;
	                }
	                startRow = reference.getRow(rangeIndex);
	                startCol = reference.getColumn(rangeIndex);
	                if (startRow >= maxRowCount || startCol >= maxColCount) {
	                    result = [keyword_null];
	                    result.rowCount = 1;
	                    result.colCount = 1;
	                    result.rangeCount = 1;
	                    return result;
	                }
	                if (startRow + rowCount > maxRowCount) {
	                    rowCount = maxRowCount - startRow;
	                }
	                if (startCol + colCount > maxColCount) {
	                    colCount = maxColCount - startCol;
	                }
	                var colValues, t, needConsideValidating = sheet._isValidatingCell;
	                for (var i = 0; i < rowCount; i++) {
	                    row = startRow + i;
	                    if (!toOneDimension) {
	                        colValues = [];
	                        rowValues.push(colValues);
	                    }
	                    if (valueCaches) {
	                        if (!valueCaches[row]) {
	                            valueCaches[row] = {};
	                        }
	                        rowCaches = valueCaches[row];
	                    }
	                    for (var j = 0; j < colCount; j++) {
	                        col = startCol + j;
	                        if (needConsideValidating && sheet._validatingRow === row && sheet._validatingColumn === col) { 
	                            value = sheet._validatingValue;
	                            needConsideValidating = false;
	                        } else {
	                            if (valueCaches) {
	                                t = rowCaches[col];
	                                if (t) {
	                                    value = t.v;
	                                } else {
	                                    value = sheet.getValue(row, col);
	                                    t = rowCaches[col] = {v: value};
	                                }
	                            } else {
	                                value = sheet.getValue(row, col);
	                            }
	                            if(followFormatter) {
	                                var formatter = sheet.getFormatter(), formatterString;
	                                if(formatter instanceof GeneralFormatter) {
	                                    formatterString = formatter.formatString();
	                                } else {
	                                    formatterString = formatter;
	                                }
	                                if(formatterString === '@') {
	                                    value = sheet.getText(row, col);
	                                } else if(value instanceof Date) {
	                                    value = Types._toDouble(value);
	                                }
	                                if(!isEmptyObject(t)) {
	                                    t = rowCaches[col] = {v: value};
	                                }
	                            }
	                            if (breakOnError && Calc.Convert._isError(value)) {
	                                result = [value];
	                                result.isError = true;
	                                return result;
	                            }
	                            if (t && t[typeString] !== keyword_undefined) {
	                                value = t[typeString];
	                            } else {
	                                value = Calc.Convert._convertValue(value, valueType, true, ignoreBlank, ignoreBoolean);
	                                if (t) {
	                                    t[typeString] = value;
	                                }
	                                if (breakOnConvertError && t === value) {
	                                    result = [CalcErrorsValue];
	                                    result.isError = true;
	                                    return result;
	                                }
	                            }
	                        }
	                        if (Calc.Convert._judgeBlankChar(value, ignoreBlank)) { 
	                        } else if (toOneDimension) {
	                            result.push(value);
	                        } else {
	                            colValues.push(value);
	                        }
	                    }
	                }
	            }
	            if (!toOneDimension && rangeCount === 1) {
	                result = result[0];
	            }
	            result.rowCount = rowCount;
	            result.colCount = colCount;
	            result.rangeCount = rangeCount;
	            if (valueCaches) {
	                valueCaches[cacheKey] = result;
	                valueCaches[cacheKey].rowCount = rowCount;
	                valueCaches[cacheKey].colCount = colCount;
	                valueCaches[cacheKey].rangeCount = rangeCount;
	                valueCaches.arrayInfo.push({ reference: reference, key: cacheKey });
	            }
	            return result;
	        },
	        getColumnCount: function () {
	            return this._sheet.getColumnCount();
	        },
	        getRowCount: function () {
	            return this._sheet.getRowCount();
	        },
	        isHiddenRow: function (row, onlyFiltered) {
	            var sheet = this._sheet, hasFilter = sheet._hasRowFilterOut && sheet._hasRowFilterOut();
	            if (hasFilter || !onlyFiltered) {
	                return sheet.getRowHeight(row) === 0;
	            }
	            return false;
	        },
	        getName: function () {
	            return this._sheet.name();
	        },
	        setValue: function (identity, value, oldValue) { 
	            var self = this, sheet = self._sheet, row, column;
	            if (identity.row !== keyword_undefined) {
	                row = identity.row;
	                column = identity.col;
	            } else if (identity.name) {
	                return;
	            } else {
	                row = arguments[0];
	                column = arguments[1];
	                value = arguments[2];
	            }
	            var caches = self._valueCaches;
	            if (caches) {
	                var rowCaches = caches[row];
	                if (rowCaches) {
	                    var cellCache = rowCaches[column];
	                    if (cellCache) {
	                        cellCache.v = value;
	                        if (cellCache.b !== keyword_undefined) { 
	                            cellCache.b = keyword_undefined;
	                        }
	                        if (cellCache.d !== keyword_undefined) { 
	                            cellCache.d = keyword_undefined;
	                        }
	                        if (cellCache.n !== keyword_undefined) { 
	                            cellCache.n = keyword_undefined;
	                        }
	                        if (cellCache.s !== keyword_undefined) { 
	                            cellCache.s = keyword_undefined;
	                        }
	                    }
	                }
	            }
	           
	            var OAValue = util_common._tryConvertDateToOADate(value);
	            var modelManager = sheet._modelManager;
	            var valueSet = false;
	            var tm = sheet.tables;
	            var table = tm && tm.find(row, column);
	            if (table) {
	                var isHeaderRow = table.showHeader() && row === table.headerIndex(),
	                    isFooterRow = table.showFooter() && row === table.footerIndex();
	                if (!isHeaderRow && !isFooterRow) {
	                    valueSet = table._setValue(row, column, OAValue);
	                }
	            }
	            var bm = sheet._bindingManager;
	            if (!valueSet && bm && bm._dataSource) {
	                var bdValue = bm.getValue(row, column);
	                if (bdValue.hasBinding) {
	                    var oldItem;
	                    if (caches) {
	                        var bindingRows = caches.bindingRows = caches.bindingRows || {};
	                        oldItem = bindingRows[row];
	                        if (!oldItem) {
	                            oldItem = bindingRows[row] = extend({}, sheet.getDataItem(row));
	                        }
	                    } else {
	                        oldItem = extend({}, sheet.getDataItem(row));
	                    }
	                    modelManager._updateDirty(row, column, {_originalItem: oldItem, _oldValue: bdValue.value});
	                    bm.setValue(row, column, OAValue);
	                }
	                valueSet = bdValue.hasBinding;
	            }
	            if (!valueSet) {
	                modelManager.do('setValue', row, column, OAValue, keyword_undefined, true, true);
	            }
	            if (this._changedCells) {
	                this._changedCells.push({row: row, col: column});
	            } else {
	                this._sheet._trigger(__webpack_require__(17).Events.CellChanged, {
	                    sheet: this._sheet,
	                    sheetName: this._sheet.name(),
	                    row: row,
	                    col: column,
	                    sheetArea: 3 ,
	                    propertyName: 'value',
	                    oldValue: oldValue,
	                    newValue: value
	                });
	            }
	        },
	        getCustomFunction: function (name) {
	            return this._sheet ? this._sheet._findCustomFunction(name) : keyword_null;
	        },
	        getCustomName: function (name) {
	            name = toUpperCase(name);
	            var nameInfo = this._sheet ? this._sheet.getCustomName(name) : keyword_null;
	            if (nameInfo) {
	                return nameInfo.getExpression();
	            }
	            return keyword_null;
	        },
	        getSheet: function () {
	            return this._sheet;
	        },
	        getParserContext: function (useR1C1, identity, option) {
	            identity = identity || Calc._createCellIdentity(0, 0);
	            return new SheetParserContext(this._sheet, useR1C1, identity, option);
	        },
	        setFormula: function (row, column, formula) { 
	        },
	        setArrayFormula: function (row, column, rowCount, columnCount, formula) { 
	        },
	        setFormulaByName: function (name, formula) { 
	        },
	        refresh: function () {
	            this._sheet.repaint();
	        },
	        toJSON: function (jsonData, calcData, lastRow, lastColumn) { 
	            var sheetNodes, sheetCalcNodes = calcData, rowCalcNodes, cellCalcNode, rowNode, cellNode;
	            var data = jsonData.data || {}, rowIsEmpty = true;
	            for (var row = 0; row <= lastRow; row++) {
	                sheetNodes = data.dataTable || {};
	                rowCalcNodes = sheetCalcNodes[row];
	                if (!rowCalcNodes) {
	                    continue;
	                }
	                rowNode = sheetNodes[row];
	                rowIsEmpty = !rowNode;
	                rowNode = rowNode || {};
	                for (var col = 0; col <= lastColumn; col++) {
	                    cellCalcNode = rowCalcNodes[col];
	                    if (cellCalcNode && cellCalcNode._expr) {
	                        cellNode = rowNode[col] || {};
	                        try { 
	                            var formula = this._getCalcServiceInternal().unparse(this, cellCalcNode._expr, row, col, false, true);
	                            if (cellCalcNode._arrayInfo) {
	                                if (cellCalcNode._arrayInfo.row === row && cellCalcNode._arrayInfo.col === col) {
	                                    cellNode.arrayInfo = cellCalcNode._arrayInfo;
	                                    cellNode.formula = formula;
	                                }
	                            } else {
	                                cellNode.formula = formula;
	                            }
	                            rowIsEmpty = false;
	                            rowNode[col] = cellNode;
	                        } catch (ex) {
	                           
	                        }
	                    }
	                }
	                if (!rowIsEmpty) {
	                    sheetNodes[row] = rowNode;
	                }
	                if (!isEmptyObject(sheetNodes)) {
	                    data.dataTable = sheetNodes;
	                }
	            }
	            if (!isEmptyObject(data)) {
	                jsonData.data = data;
	            }
	        }
	    });
	
	    SheetsCalc.SpreadSource = (function (_super) {
	        inherit(SpreadSource, _super);
	        function SpreadSource(spread) {
	            _super.call(this, keyword_null);
	            this._spread = spread;
	        }
	
	        SpreadSource.prototype.getCustomFunction = function (name) {
	            return this._spread ? this._spread.getCustomFunction(name) : keyword_null;
	        };
	        SpreadSource.prototype.getCustomName = function (name) {
	            var nameInfo = this._spread ? this._spread.getCustomName(name) : keyword_null;
	            if (nameInfo) {
	                return nameInfo.getExpression();
	            }
	            return keyword_null;
	        };
	        SpreadSource.prototype.createSourceModel = function (calcService) {
	            return new CalcSourceModel(calcService, this);
	        };
	
	        return SpreadSource;
	    })(Calc.CalcSource);
	
	   
	    
	    function formulaToExpression(context, formula, baseRow, baseColumn, useR1C1, considerCurrentCulture) {
	        var sheet = context && (context instanceof Worksheet) && context;
	        var parser = new Calc.Parser();
	        baseRow = baseRow === keyword_undefined ? 0 : baseRow;
	        baseColumn = baseColumn === keyword_undefined ? 0 : baseColumn;
	        var parserContext = new SheetParserContext(sheet, !!useR1C1, Calc._createCellIdentity(baseRow, baseColumn));
	        if (considerCurrentCulture) {
	            parserContext.culture = true;  
	        }
	        return parser.parse(parserContext, formula);
	    }
	
	    SheetsCalc.formulaToExpression = formulaToExpression;
	
	   
	    
	    function expressionToFormula(context, expression, baseRow, baseColumn, useR1C1, structureToRange) {
	        var sheet = context && (context instanceof Worksheet) && context;
	        var parser = new Calc.Parser();
	        baseRow = baseRow === keyword_undefined ? 0 : baseRow;
	        baseColumn = baseColumn === keyword_undefined ? 0 : baseColumn;
	        var parserContext = new SheetParserContext(sheet, !!useR1C1, Calc._createCellIdentity(baseRow, baseColumn));
	        parserContext._structureToRange = structureToRange;
	        return parser.unparse(parserContext, expression);
	    }
	
	    SheetsCalc.expressionToFormula = expressionToFormula;
	
	   
	    
	    function evaluateFormula(context, formula, baseRow, baseColumn, useR1C1) {
	       
	       
	        if (baseRow === keyword_undefined) {
	            baseRow = 0;
	        }
	        if (baseColumn === keyword_undefined) {
	            baseColumn = 0;
	        }
	       
	        var expression = formulaToExpression(context, formula, baseRow, baseColumn, useR1C1, true);
	        return SheetsCalc.evaluateExpression(context, expression, baseRow, baseColumn);
	    }
	
	    SheetsCalc.evaluateFormula = evaluateFormula;
	    function evaluateExpression(context, expression, baseRow, baseColumn, options) {
	        var calcService = context._getCalcServiceInternal();
	        if (baseRow === keyword_undefined) {
	            baseRow = context.getActiveRowIndex();
	        }
	        if (baseColumn === keyword_undefined) {
	            baseColumn = context.getActiveColumnIndex();
	        }
	        var convertNullToZero = true;
	        if (options && options.convertNullToZero !== keyword_undefined) {
	            convertNullToZero = options.convertNullToZero;
	        }
	        var sheetSource = context._getSheetSource();
	        return calcService._evaluateParsedFormula(sheetSource, expression, Calc._createCellIdentity(baseRow, baseColumn), false, convertNullToZero);
	    }
	
	    SheetsCalc.evaluateExpression = evaluateExpression;
	    function rangeToExpression(range, baseRow, baseCol, rangeReferenceRelative, table) {
	        var row = range.row, col = range.col, endRow = range.row + range.rowCount - 1,
	            endCol = range.col + range.colCount - 1;
	        var startRowRelative = false, endRowRelative = false, startColRelative = false, endColRelative = false;
	        if (arguments.length >= 4) {
	            startRowRelative = (rangeReferenceRelative & 1 ) !== 0;
	            endRowRelative = (rangeReferenceRelative & 4 ) !== 0;
	            startColRelative = (rangeReferenceRelative & 2 ) !== 0;
	            endColRelative = (rangeReferenceRelative & 8 ) !== 0;
	            row -= startRowRelative ? baseRow : 0;
	            endRow -= endRowRelative ? baseRow : 0;
	            col -= startColRelative ? baseCol : 0;
	            endCol -= endColRelative ? baseCol : 0;
	        }
	        var expression;
	        if (table) {
	            var structReferencePortions = getReferencePortions(range, table, baseRow);
	            var structReferenceColumnSpecifier = getReferenceColumnSpecifier(range, table, baseRow);
	            if (structReferencePortions && structReferenceColumnSpecifier) {
	                expression = SheetsCalc.StructureReferenceResolver.create(table, structReferencePortions, structReferenceColumnSpecifier, range.col - table.dataRange().col, range.col + range.colCount - table.dataRange().col - 1);
	                return expression;
	            }
	        }
	        if (range.rowCount === 1 && range.colCount === 1) {
	            expression = Calc._createCellExpression(keyword_null, keyword_null, row, col, startRowRelative, startColRelative);
	        } else {
	            if (range.row < 0) {
	                row = endRow = Calc.BAND_INDEX_CONST;
	            }
	            if (range.col < 0) {
	                col = endCol = Calc.BAND_INDEX_CONST;
	            }
	            expression = Calc._createRangeExpression(keyword_null, keyword_null, row, col, endRow, endCol, startRowRelative, startColRelative, endRowRelative, endColRelative);
	        }
	        return expression;
	    }
	
	    SheetsCalc.rangeToExpression = rangeToExpression;
	    function getReferencePortions(range, table, baseRow) {
	        if (range.rowCount === 1) {
	           
	            if (table.hasHeadersRow() && range.row === table.startRow()) {
	                return 2 ;
	            }
	           
	            if (table.hasTotalsRow() && range.row === table.endRow()) {
	                return 8 ;
	            }
	           
	            if (baseRow === range.row) {
	                return 1 ;
	            }
	        } else {
	           
	            if (table.hasHeadersRow() && range.row === table.startRow()) {
	               
	                if (range.rowCount === table.dataRange().rowCount + 1) {
	                    return 6 ;
	                }
	               
	                if (table.hasTotalsRow() && range.rowCount === table.dataRange().rowCount + 1 + 1) {
	                    return 14 ;
	                }
	            }
	           
	            if (range.row === table.dataRange().row) {
	               
	                if (range.rowCount === table.dataRange().rowCount) {
	                    return 3 ;
	                }
	               
	                if (table.hasTotalsRow() && range.rowCount === table.dataRange().rowCount + 1) {
	                    return 12 ;
	                }
	            }
	        }
	        return keyword_undefined;
	    }
	
	    function getReferenceColumnSpecifier(range, table, baseRow) { 
	        if (range.col === table.startColumn() && range.colCount === table.dataRange().colCount) {
	            return 1 ;
	        }
	        if (range.colCount === 1) {
	            return 2 ;
	        }
	        if (range.col >= table.startColumn() && (range.col + range.colCount - 1) <= table.endColumn()) {
	            return 4 ;
	        }
	        return keyword_undefined;
	    }
	
	   
	    
	    function rangeToFormula(range, baseRow, baseCol, rangeReferenceRelative, useR1C1) {
	        var expression = SheetsCalc.rangeToExpression(range, baseRow, baseCol, rangeReferenceRelative);
	        var context = new SheetParserContext(keyword_null, !!useR1C1, Calc._createCellIdentity(baseRow, baseCol));
	        var parser = new Calc.Parser();
	        return parser.unparse(context, expression);
	    }
	
	    SheetsCalc.rangeToFormula = rangeToFormula;
	    function rangeToFormulaWithStructReference(source, range, baseRow, baseCol, rangeReferenceRelative, useR1C1, table) {
	        var expression = SheetsCalc.rangeToExpression(range, baseRow, baseCol, rangeReferenceRelative, table);
	        var context = new SheetParserContext(source, !!useR1C1, Calc._createCellIdentity(baseRow, baseCol));
	        var parser = new Calc.Parser();
	        return parser.unparse(context, expression);
	    }
	
	    SheetsCalc.rangeToFormulaWithStructReference = rangeToFormulaWithStructReference;
	    function formulaToRange(sheet, formula, baseRow, baseCol) {
	        if (!formula) {
	            return null;
	        }
	        baseRow = !baseRow ? 0 : baseRow;
	        baseCol = !baseCol ? 0 : baseCol;
	        var service = sheet._getCalcServiceInternal();
	        var expr = service.parse(sheet._getSheetSource(), formula, baseRow, baseCol, true, true), source;
	        if (expr) {
	            source = expr.source;
	            if (source && expr.type === 13 ) {
	                source = expr.source();
	            } else if (expr.type === 1 && expr.endSource ) {
	                var startSource = expr.source, endSource = expr.endSource;
	                var sources = startSource.getSources(endSource), isInSheetRange = false;
	                for (var i = 0; i < sources.length; i++) {
	                    if (sources[i] === sheet._getSheetSource()) {
	                        isInSheetRange = true;
	                        break;
	                    }
	                }
	                expr = isInSheetRange && expr;
	            }
	        }
	        if (expr && expr.getRange && (!source || source === sheet._getSheetSource())) {
	            var cellRange = expr.getRange(baseRow, baseCol);
	            if (!cellRange) {
	                return null;
	            }
	            return new Core.Range(cellRange.row, cellRange.col, cellRange.rowCount, cellRange.colCount);
	        }
	        return null;
	    }
	
	    SheetsCalc.formulaToRange = formulaToRange;
	
	   
	    
	    function formulaToRanges(sheet, formula, baseRow, baseCol, forceA1) {
	        var result = [];
	        var ranges = [];
	        if (!formula) {
	            return result;
	        }
	        var names = {};
	        baseRow = baseRow || 0;
	        baseCol = baseCol || 0;
	
	        var parser = new Calc.Parser();
	        var infos = parser.parseReferenceExpressionInfos(formula, sheet, baseRow, baseCol, keyword_undefined , forceA1);
	        for (var i = 0; i < infos.length; i++) {
	            var sheetRanges = infos[i].sheetRanges;
	            for (var sheetIndex = 0; sheetRanges && sheetIndex < sheetRanges.sheets.length; sheetIndex++) {
	                var sheetName = sheetRanges.sheets[sheetIndex];
	                ranges = names[sheetName];
	                if (!ranges) {
	                    names[sheetName] = ranges = [];
	                    result.push({sheetName: sheetName, ranges: ranges});
	                }
	                var infoSheetRanges = sheetRanges[sheetName];
	                for (var rangeIndex = 0; rangeIndex < infoSheetRanges.length; rangeIndex++) {
	                    var range = infoSheetRanges[rangeIndex];
	                    ranges.push(new Core.Range(range.row, range.col, range.rowCount, range.colCount));
	                }
	            }
	        }
	        return result;
	    }
	
	    SheetsCalc.formulaToRanges = formulaToRanges;
	   
	    
	    function rangesToFormula(ranges, baseRow, baseCol, rangeReferenceRelative, useR1C1) {
	        var formula = '';
	        var parser = new Calc.Parser();
	        var context = new SheetParserContext(keyword_null, !!useR1C1, Calc._createCellIdentity(baseRow, baseCol));
	        for (var i = 0; i < ranges.length; i++) {
	            var expression = SheetsCalc.rangeToExpression(ranges[i], baseRow, baseCol, rangeReferenceRelative);
	            var rangeFormula = parser.unparse(context, expression);
	            if (i > 0) {
	                formula += ', ' + rangeFormula;
	            } else {
	                formula += rangeFormula;
	            }
	        }
	        return formula;
	    }
	
	    SheetsCalc.rangesToFormula = rangesToFormula;
	   
	    
	    SheetsCalc.RangeReferenceRelative = {
	        
	        allAbsolute: 0,
	        
	        startRowRelative: 1,
	        
	        startColRelative: 2,
	        
	        endRowRelative: 4,
	        
	        endColRelative: 8,
	        
	        rowRelative: 5,
	        
	        colRelative: 10,
	        
	        allRelative: 15
	    };
	
	   
	    
	    function goalSeek(changingSheet, changingRow, changingColumn, formulaSheet, formulaRow, formulaColumn, desiredResult) { 
	        var initialValue = formulaSheet.getValue(changingRow, changingColumn);
	        var obj;
	        var x0, x1;
	        var f0, f1;
	        var found = false;
	        var maxIterations = 100;
	        var maxChange = 0.001;
	        var epsilon = 0.01;
	        x0 = (isNumeric(initialValue) ? +initialValue : 0.0) - desiredResult;
	        obj = formulaSheet.getValue(formulaRow, formulaColumn);
	        f0 = (isNumeric(obj) ? +obj : 0.0) - desiredResult;
	        if (isNumeric(obj) && (Math.abs(f0) < maxChange)) {
	            found = true;
	        } else if (isError(obj)) {
	            found = false;
	        } else {
	            x1 = x0 + ((x0 === 0.0) ? epsilon : epsilon * x0);
	            for (var i = 0; !found && i < maxIterations; i++) {
	                x1 = Common._NumberHelper._fixNumber(x1, 13);
	                changingSheet.setValue(changingRow, changingColumn, x1);
	                obj = formulaSheet.getValue(formulaRow, formulaColumn);
	                f1 = (isNumeric(obj) ? +obj : 0.0) - desiredResult;
	                if (isNumeric(obj) && Math.abs(f1) < maxChange) {
	                    found = true;
	                } else if (isError(obj)) {
	                   
	                    x1 = (x0 + x1) / 2.0;
	                } else if ((x0 - x1) === 0.0) {
	                   
	                    x1 = x0 + ((x0 === 0.0) ? epsilon : epsilon * x0);
	                } else if ((f0 - f1) === 0.0) {
	                   
	                    x1 = x0 + (x1 - x0) * 2.0;
	                } else {
	                   
	                    var x2 = x1 - f1 * (x0 - x1) / (f0 - f1);
	                    x0 = x1;
	                    f0 = f1;
	                    x1 = x2;
	                }
	            }
	        }
	        if (!found) {
	            changingSheet.setValue(changingRow, changingColumn, initialValue);
	        }
	        return found;
	    }
	
	    SheetsCalc.goalSeek = goalSeek;
	    module.exports = SheetsCalc;
	
	}());

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var Calc = __webpack_require__(2);
	    var Errors = Calc.Errors, Math_min = Math.min, Math_max = Math.max, createRange = Calc._createRange,
	        keyword_undefined = void 0,
	        keyword_null = null, Convert = Calc.Convert, _isError = Convert._isError,
	        createCellExpression = Calc._createCellExpression,
	        createRangeExpression = Calc._createRangeExpression, createErrorExpression = Calc._createErrorExpression,
	        createParenthesesExpression = Calc._createParenthesesExpression,
	        createOperatorExpression = Calc._createOperatorExpression,
	        createFunctionExpression = Calc._createFunctionExpression, CalcErrorsReference = Errors.Reference,
	        ReferenceErrorExpr = Calc._referenceErrorExpr, BAND_INDEX_CONST = Calc.BAND_INDEX_CONST;
	
	    var util = __webpack_require__(3)._util;
	    var getBaseRowBaseCol = util._getBaseRowBaseCol;
	
	    function fnIntersectWith(current, range) {
	        if (!range) {
	            range = this;
	        }
	        var top = Math_max(current.row, range.row);
	        var left = Math_max(current.column, range.col);
	        var bottom = Math_min(current.row + current.rowCount, range.row + range.rowCount);
	        var right = Math_min(current.column + current.colCount, range.col + range.colCount);
	        if (top >= bottom || left >= right) {
	            return keyword_null;
	        }
	        return {
	            row: top,
	            col: left,
	            rowCount: bottom - top,
	            colCount: right - left,
	            intersectWith: fnIntersectWith
	        };
	    }
	
	    var MoveSwapInfo = (function () {
	        function MoveSwapInfo(fromModel, fromRow, fromColumn, toModel, toRow, toColumn, rowCount, columnCount) {
	            var self = this;
	            self._fromModel = fromModel;
	            self._fromRow = fromRow;
	            self._fromColumn = fromColumn;
	            self._toModel = toModel;
	            self._toRow = toRow;
	            self._toColumn = toColumn;
	            self._rowCount = rowCount;
	            self._columnCount = columnCount;
	        }
	
	        return MoveSwapInfo;
	    })();
	
	    MoveSwapInfo.prototype = {
	        _rowOffset: function () {
	            return this._toRow - this._fromRow;
	        },
	        _colOffset: function () {
	            return this._toColumn - this._fromColumn;
	        },
	        _sourceContains: function (model, row, column, rowCount, columnCount) {
	            var self = this;
	            return (self._fromModel === model) && ((self._fromRow === -1) || (self._fromRow <= row && row + rowCount <= self._fromRow + self._rowCount)) && ((self._fromColumn === -1) || (self._fromColumn <= column && column + columnCount <= self._fromColumn + self._columnCount));
	        },
	        _destinationContains: function (model, row, column, rowCount, columnCount) {
	            var self = this;
	            return (self._toModel === model) && 
	                ((self._toRow === -1) || (self._toRow <= row && row + rowCount <= self._toRow + self._rowCount)) && 
	                ((self._toColumn === -1) || (self._toColumn <= column && column + columnCount <= self._toColumn + self._columnCount)) && 
	                !(row === 0 && column === 0 && self._toRow === 0 && self._toColumn === 0 && (self._fromRow || self._fromColumn));  
	        },
	        intersectWith: function (model, row, column, rowCount, columnCount) {
	            var self = this;
	            if (self._toModel !== model) {
	                return keyword_null;
	            }
	            var range = self._createValidCellRange(model, row, column, rowCount, columnCount);
	            var sourceRange = self._createValidCellRange(model, self._fromRow, self._fromColumn, rowCount, columnCount);
	            return sourceRange.intersectWith(range);
	        },
	        _createValidCellRange: function (model, row, column, rowCount, columnCount) {
	            var validFromRow = (row === -1 ? 0 : row);
	            var validFromRowCount = ((row === -1 || rowCount === -1) ? model.rowCount : rowCount);
	            var validFromColumn = (column === -1 ? 0 : column);
	            var validFromColumnCount = ((column === -1 || columnCount === -1) ? model.colCount : columnCount);
	            return {
	                row: validFromRow,
	                column: validFromColumn,
	                rowCount: validFromRowCount,
	                columnCount: validFromColumnCount,
	                intersectWith: fnIntersectWith
	            };
	        }
	    };
	
	    var CalcOperatorAdjustor = Calc.CalcOperatorAdjustor = (function () {
	        function CalcOperatorAdjustor() {
	        }
	
	        CalcOperatorAdjustor._copyExpression = function (fromSource, destSource, expr, row, column, offsetRow, offsetColumn, destRow, destColumn, rowCount, columnCount) {
	            var newExpr = expr, self = CalcOperatorAdjustor, selfFunction = self._copyExpression;
	            if (!expr) {
	                return newExpr;
	            }
	            var maxRowCount, maxColCount;
	            if (expr.type === 10 ) {
	                newExpr = Calc._createParenthesesExpression(selfFunction.call(self, fromSource, destSource, expr.value, row, column, offsetRow, offsetColumn, destRow, destColumn, rowCount, columnCount));
	            } else if (expr.type === 1  && expr._isCell()) {
	                maxRowCount = Math_min((expr.source || destSource).getRowCount(), Calc.MAX_ROW_COUNT);
	                maxColCount = Math_min((expr.source || destSource).getColumnCount(), Calc.MAX_COLUMN_COUNT);
	                if (expr.rowRelative && ((expr.row + row < 0) || (expr.row + row >= maxRowCount)) || expr.columnRelative && ((expr.column + column < 0) || (expr.column + column >= maxColCount))) {
	                    return createErrorExpression(CalcErrorsReference, expr.source);
	                }
	                newExpr = expr.offset(0, 0, false);
	            } else if (expr.type === 1 ) {
	                maxRowCount = Math_min((expr.source || destSource).getRowCount(), Calc.MAX_ROW_COUNT);
	                maxColCount = Math_min((expr.source || destSource).getColumnCount(), Calc.MAX_COLUMN_COUNT);
	                var rangeExpr = expr;
	                if (rangeExpr.rowRelative && !expr.isFullColumn && ((rangeExpr.row + row < 0) || (rangeExpr.row + row > maxRowCount))
	                    || rangeExpr.columnRelative && !expr.isFullRow && ((rangeExpr.column + column < 0) || (rangeExpr.column + column > maxColCount))
	                    || rangeExpr.endRowRelative && !expr.isFullColumn && ((rangeExpr.endRow + row < 0) || (rangeExpr.endRow + row > maxRowCount))
	                    || rangeExpr.endColumnRelative && !expr.isFullRow && ((rangeExpr.endColumn + column < 0) || (rangeExpr.endColumn + column > maxColCount))) {
	                    return createErrorExpression(CalcErrorsReference, expr.source, expr.endSource);
	                }
	                newExpr = expr.offset(0, 0, false);
	            } else if (expr.type === 9 ) {
	                newExpr = Calc._createOperatorExpression(expr.operatorType,
	                    selfFunction.call(self, fromSource, destSource, expr.value, row, column, offsetRow, offsetColumn, destRow, destColumn, rowCount, columnCount),
	                    expr.value2 && selfFunction.call(self, fromSource, destSource, expr.value2, row, column, offsetRow, offsetColumn, destRow, destColumn, rowCount, columnCount));
	            } else if (expr.type === 7 ) {
	                var newArgs = [];
	                if (expr.arguments && expr.arguments.length > 0) {
	                    for (var i = 0; i < expr.arguments.length; i++) {
	                        newArgs[i] = selfFunction.call(self, fromSource, destSource, expr.arguments[i], row, column, offsetRow, offsetColumn, destRow, destColumn, rowCount, columnCount);
	                    }
	                }
	                newExpr = Calc._createFunctionExpression(expr, newArgs);
	            } else if (expr.type === 13 ) {
	                newExpr = expr.offsetWhenCopy(fromSource, destSource, row, column, offsetRow, offsetColumn, destRow, destColumn, rowCount, columnCount);
	            }
	            return newExpr;
	        };
	        CalcOperatorAdjustor.copyFormula = function (src, srcRow, srcColumn, dest, destRow, destColumn, copyRowCount, copyColumnCount, ignoreFilteredOutRow) {
	            var srcCalcModel = src, destCalcModel = dest, srcSheetSource = src.getSource(),
	                destSheetSource = dest.getSource(), self = CalcOperatorAdjustor;
	            if (!srcCalcModel || !destCalcModel) {
	                return;
	            }
	            var destChangeInfo = destSheetSource && destSheetSource.getSheet()._modelManager._getChangesForCalcEngine();
	            var fromRow = srcRow;
	            var fromColumn = srcColumn;
	            var toRow = destRow;
	            var toColumn = destColumn;
	            var rowCount = copyRowCount;
	            var columnCount = copyColumnCount;
	            if (srcRow < 0) {
	                fromRow = 0;
	                rowCount = Math_min(src.rC(), dest.rC());
	            }
	            if (srcColumn < 0) {
	                fromColumn = 0;
	                columnCount = Math_min(src.cC(), dest.cC());
	            }
	            if (destRow < 0) {
	                toRow = 0;
	            }
	            if (destColumn < 0) {
	                toColumn = 0;
	            }
	            if (srcCalcModel) {
	                srcCalcModel._unlinkCellExpression(toRow, toColumn, rowCount, columnCount);
	            }
	            var mc = new Calc.CalcSourceModel(src._getCalcServiceInternal(), srcSheetSource);
	            var r, c;
	            for (r = 0; r < rowCount; r++) {
	                for (c = 0; c < columnCount; c++) {
	                   
	                    srcCalcModel._copyExpr(mc, r + fromRow, c + fromColumn, r, c);
	                }
	            }
	            var exprSettedObj = {};
	            var calcSvc = dest._getCalcServiceInternal();
	            for (r = 0; r < rowCount; r++) {
	                if (ignoreFilteredOutRow && destSheetSource.isHiddenRow(r + toRow)) {
	                    continue;
	                }
	                var toR = r + toRow;
	                for (c = 0; c < columnCount; c++) {
	                    var toC = c + toColumn;
	                    var expr = mc._getExpr(r, c);
	                    if (expr) {
	                        if (expr === exprSettedObj) {
	                            continue;
	                        }
	                        expr = self._copyExpression(srcSheetSource, destSheetSource, mc._getExpr(r, c), toR, toC, destRow - srcRow, destColumn - srcColumn, destRow, destColumn, rowCount, columnCount);
	                        var arrayInfo = mc._getArrayInfo(r, c);
	                        if (destSheetSource) {
	                            if (arrayInfo) {
	                                var arrayRowCount = rowCount - r < arrayInfo.rowCount ? rowCount - r : arrayInfo.rowCount;
	                                var arrayColCount = columnCount - c < arrayInfo.colCount ? columnCount - c : arrayInfo.colCount;
	                                for (var i = 0; i < arrayRowCount; i++) {
	                                    for (var j = 0; j < arrayColCount; j++) {
	                                        mc._setExpr(r + i, c + j, expr);
	                                    }
	                                }
	                                dest.setArrayFormula(toR, toC, arrayRowCount, arrayColCount, calcSvc.unparse(destSheetSource, expr, toR, toC), keyword_undefined , destChangeInfo);
	                            } else {
	                                var formula = expr ? calcSvc.unparse(destSheetSource, expr, toR, toC) : keyword_undefined;
	                                destSheetSource.setFormula(toR, toC, formula);
	                                var workingExpr = mc._getWorkingExpr(r, c);
	                                if (workingExpr) {
	                                    var context = new Calc.EvaluateContext(destSheetSource, Calc._createCellIdentity(toR, toC), false);
	                                    workingExpr = Calc._mappingArray(context, expr, false, 0, 0);
	                                    workingExpr = workingExpr === expr ? keyword_undefined : workingExpr;
	                                }
	                                destCalcModel._setCellExpression(toR, toC, expr, workingExpr, arrayInfo, destChangeInfo);
	                            }
	                        } else {
	                            destCalcModel._setExpr(r + toRow, c + toColumn, expr);
	                            destCalcModel._setArrayInfo(r + toRow, c + toColumn, arrayInfo);
	                        }
	                    } else if (destCalcModel && destCalcModel._getExpr(toR, toC)) {
	                        destCalcModel._clearAllExpr(toR, toC, destChangeInfo);
	                    }
	                }
	            }
	        };
	        CalcOperatorAdjustor.moveFormula = function (src, fromRow, fromColumn, dest, toRow, toColumn, rowCount, columnCount) {
	            var srcCalcModel = src._getCalcModel(), destCalcModel = dest._getCalcModel();
	            var calcSvc = srcCalcModel._getCalcServiceInternal();
	            if (!srcCalcModel || !destCalcModel) {
	                return;
	            }
	            var srcChangeInfo = srcCalcModel._getChangesForCalcEngine();
	            var destChangeInfo = destCalcModel._getChangesForCalcEngine();
	            var operatorAdjustor = calcSvc._getOperatorAdjustor();
	
	            if (fromRow < 0) {
	                fromRow = 0;
	                rowCount = Math_min(src.getRowCount(), dest.getRowCount());
	            }
	            if (toRow < 0) {
	                toRow = 0;
	            }
	            if (fromColumn < 0) {
	                fromColumn = 0;
	                columnCount = Math_min(src.getColumnCount(), dest.getColumnCount());
	            }
	            if (toColumn < 0) {
	                toColumn = 0;
	            }
	            var crossSheet = !(src === dest && src.name() === dest.name());
	            srcCalcModel._unlinkCellExpression(fromRow, fromColumn, rowCount, columnCount);
	            addDependentsToAdjust(srcCalcModel, fromRow, fromColumn, rowCount, columnCount);
	            destCalcModel._unlinkCellExpression(toRow, toColumn, rowCount, columnCount);
	            addDependentsToAdjust(destCalcModel, toRow, toColumn, rowCount, columnCount);
	            var nodes = [], r, c, expr, arrayInfo, workingExpr;
	            for (r = 0; r < rowCount; r++) {
	                for (c = 0; c < columnCount; c++) {
	                    expr = srcCalcModel._getExpr(r + fromRow, c + fromColumn);
	                    arrayInfo = srcCalcModel._getArrayInfo(r + fromRow, c + fromColumn);
	                    workingExpr = srcCalcModel._getWorkingExpr(r + fromRow, c + fromColumn);
	                    if (expr) {
	                        nodes.push({_expr: expr, _arrayInfo: arrayInfo, _workingExpr: workingExpr});
	                        srcCalcModel._clearAllExpr(r + fromRow, c + fromColumn, srcChangeInfo);
	                    } else {
	                        nodes.push(keyword_null);
	                    }
	                }
	            }
	            var toArrayInfo, sourceChangedExprInfos = crossSheet ? {} : null;
	            for (r = 0; r < rowCount; r++) {
	                var destRow = r + toRow;
	                for (c = 0; c < columnCount; c++) {
	                    var exprInfo = nodes.shift(), destColumn = c + toColumn;
	                    if (exprInfo) {
	                        expr = exprInfo._expr;
	                        arrayInfo = exprInfo._arrayInfo;
	                        if (calcSvc && arrayInfo && arrayInfo.row === fromRow + r && arrayInfo.col === fromColumn + c) {
	                            toArrayInfo = createRange(destRow, destColumn, arrayInfo.rowCount, arrayInfo.colCount);
	                        }
	                        if (arrayInfo) {
	                            arrayInfo.row = destRow;
	                            arrayInfo.col = destColumn;
	                        }
	                        var _arrayInfo = arrayInfo ? toArrayInfo : keyword_undefined;
	                        workingExpr = exprInfo._workingExpr;
	                        destCalcModel._backupNodeItem(destChangeInfo, destRow, destColumn);
	                        destCalcModel._setExpr(destRow, destColumn, expr);
	                        destCalcModel._setArrayInfo(destRow, destColumn, _arrayInfo);
	                        destCalcModel._setWorkingExpr(destRow, destColumn, workingExpr);
	                        if (crossSheet) {
	                            sourceChangedExprInfos[destRow + ', ' + destColumn] = expr;
	                        }
	                    } else {
	                        destCalcModel._backupNodeItem(destChangeInfo, destRow, destColumn);
	                        destCalcModel._setExpr(destRow, destColumn, keyword_undefined);
	                        destCalcModel._setArrayInfo(destRow, destColumn, keyword_undefined);
	                    }
	                }
	            }
	            operatorAdjustor._addCellsToAdjust(srcCalcModel, fromRow, fromColumn, rowCount, columnCount);
	            operatorAdjustor._addCellsToAdjust(destCalcModel, toRow, toColumn, rowCount, columnCount);
	            var sheet = srcCalcModel.getSource().getSheet(),
	                validators = sheet._validations && (sheet.parent || sheet)._getValidatorsWithFormula();
	            operatorAdjustor._adjustFormulasOnMoveSwap(validators, srcCalcModel.getSource(), fromRow, fromColumn, destCalcModel.getSource(), toRow, toColumn, rowCount, columnCount, true, sourceChangedExprInfos);
	            if (crossSheet === true) {
	                operatorAdjustor._adjustFormulasOnMoveSwap(validators, srcCalcModel.getSource(), fromRow, fromColumn, destCalcModel.getSource(), toRow, toColumn, rowCount, columnCount, true, sourceChangedExprInfos);
	            }
	        };
	        return CalcOperatorAdjustor;
	    })();
	
	    CalcOperatorAdjustor.prototype = {
	
	        isAdjustCell: function (cell) {
	            return cell.preAdj || (this._heads && cell === this._heads[0]);
	        },
	        isAdjust: function (cell) {
	            return cell.preAdj || (this._heads && cell === this._heads[0]);
	        },
	        _addAdjust: function (node, type) {
	            var self = this, head, tail;
	            if (isNaN(type)) {
	                return;
	            }
	
	            if (!self._heads) {
	                self._heads = {};
	                self._tails = {};
	            }
	
	            head = self._heads[type];
	            tail = self._tails[type];
	
	            if (node && !node.preAdj && node !== head) {
	                if (head) {
	                    tail.nextAdj = node;
	                } else {
	                    self._heads[type] = node;
	                }
	                node.preAdj = tail;
	                node.nextAdj = keyword_null;
	
	                self._tails[type] = node;
	            }
	        },
	        _removeAdjust: function (node, type) {
	            var self = this, head;
	            if (isNaN(type)) {
	                return;
	            }
	
	            head = self._heads && self._heads[type];
	
	            if (node && (node.preAdj || node === head)) {
	                var prevAdjust = node.preAdj;
	                var nextAdj = node.nextAdj;
	                if (prevAdjust) {
	                    prevAdjust.nextAdj = nextAdj;
	                } else {
	                    self._heads[type] = nextAdj;
	                }
	
	                if (nextAdj) {
	                    nextAdj.preAdj = prevAdjust;
	                } else {
	                    self._tails[type] = prevAdjust;
	                }
	                node.preAdj = keyword_null;
	                node.nextAdj = keyword_null;
	            }
	        },
	        _adjustFormulasOnAddRemove: function (addModel, index, count, isRow, isAdd) {
	            this._adjustFormulasOnOperator(addModel, adjustFormulaOnAddRemove, index, count, isRow, isAdd);
	            var row1 = 0, col1 = 0, row2 = 0, col2 = 0;
	            if (index === 0) {
	                if (isRow && isAdd) {
	                    row2 = count;
	                } else if (isRow) {
	                    row1 = count;
	                } else if (isAdd) {
	                    col2 = count;
	                } else {
	                    col1 = count;
	                }
	            }
	            adjustValidatorFormulasOnOperator(addModel, adjustFormulaOnAddRemove, index, count, row1, col1, row2, col2, isRow, isAdd);
	        },
	        _adjustFormulasOnOperator: function (model, expressionAdjustor, index, count, isRow, isAdd) {
	            var self = this;
	            var heads = self._heads;
	            if (!heads) {
	                return;
	            }
	
	            var calcModel, row, column, expr, head, source;
	            var settedMap = {};
	            while (heads[0]) {
	                head = heads[0];
	                calcModel = head._sourceModel;
	                source = calcModel.getSource();
	                row = head.row;
	                column = head.column;
	                if (settedMap[row] && settedMap[row][column]) {
	                    self._removeAdjust(head, 0 );
	                    continue;
	                }
	                expr = calcModel._getExpr(row, column);
	                if (expr) {
	                    expr = expressionAdjustor.call(self, source, row, column, expr, model, index, count, isRow, isAdd);
	                    var arrayInfo = calcModel._getArrayInfo(row, column);
	                    if (arrayInfo) {
	                        arrayInfo = createRange(row, column, arrayInfo.rowCount, arrayInfo.colCount);
	                        for (var r = row; r < row + arrayInfo.rowCount; r++) {
	                            if (!settedMap[r]) {
	                                settedMap[r] = {};
	                            }
	                            for (var c = column; c < column + arrayInfo.colCount; c++) {
	                                calcModel._setExpression(r, c, expr, arrayInfo, r === row && c === column);
	                                settedMap[r][c] = true;
	                            }
	                        }
	                    } else {
	                        calcModel._setExpression(row, column, expr, arrayInfo, true);
	                    }
	                } else if ((calcModel.getRowExpression && calcModel.getRowExpression(row)) || (calcModel.getColumnExpression && calcModel.getColumnExpression(column))) {
	                    calcModel._addCellsToDirty(row, column, 1, 1);
	                }
	                self._removeAdjust(head, 0 );
	            }
	            while (heads[1]) {
	                head = heads[1];
	                calcModel = head._sourceModel;
	                row = head.row;
	                if (calcModel.getRowExpression) {
	                    expr = calcModel.getRowExpression(row);
	                    if (expr && calcModel._setExpression) {
	                        source = calcModel.getSource();
	                        calcModel._setExpression(row, -1, expressionAdjustor.call(self, source, row, -1, expr, model, index, count, isRow, isAdd), keyword_undefined, true);
	                    }
	                }
	                self._removeAdjust(head, 1 );
	            }
	            while (heads[2]) {
	                head = heads[2];
	                calcModel = head._sourceModel;
	                column = head.column;
	                if (calcModel.getColumnExpression) {
	                    expr = calcModel.getColumnExpression(column);
	                    if (expr && calcModel._setExpression) {
	                        source = calcModel.getSource();
	                        calcModel._setExpression(-1, column, expressionAdjustor.call(self, source, -1, column, expr, model, index, count, isRow, isAdd), keyword_undefined, true);
	                    }
	                }
	                self._removeAdjust(head, 2 );
	            }
	            while (heads[3]) {
	                var nameIDs = heads[3], nameID = nameIDs.name;
	                calcModel = nameIDs._sourceModel;
	                expr = calcModel._getExpressionWithRowColumnByName(nameID);
	                var newExpr = expressionAdjustor.call(self, calcModel.getSource(), 0, 0, expr, model, index, count, isRow, isAdd);
	                calcModel._setExpressionByName(nameID, newExpr);
	                self._removeAdjust(nameIDs, 3 );
	            }
	            for (var p in heads) {
	                if (parseInt(p) > 3 && heads.hasOwnProperty(p)) {
	                    while (heads[p]) {
	                        var node = heads[p];
	                        calcModel = node._sourceModel;
	                        expr = expressionAdjustor.call(self, calcModel, 0, 0, node.expression, model, index, count, isRow, isAdd);
	                        calcModel.setExpression(node.id, node.name, expr);
	                        self._removeAdjust(node, p );
	                    }
	                }
	            }
	        },
	        _adjustFormulasOnRemoveSheet: function (removeSource) {
	            var self = this, model = removeSource.getCalcSourceModel(), rowCount = removeSource.getRowCount(),
	                colCount = removeSource.getColumnCount();
	            addDependentsToAdjust(model, 0, 0, rowCount, colCount);
	            self._adjustFormulasOnOperator(removeSource, adjustFormulaOnRemoveSheet2);
	            adjustValidatorFormulasOnOperator(removeSource, adjustFormulaOnRemoveSheet2, 0, 0, 0, 0, 0, 0, true, false);
	        },
	        _adjustFormulasOnMoveSwap: function (validators, fromModel, fromRow, fromColumn, toModel, toRow, toColumn, rowCount, columnCount, isMove, sourceChangedExprInfos) {
	            var self = this, adjustor = adjustFormulaOnMoveSwap;            
	            var info = new MoveSwapInfo(fromModel, fromRow, fromColumn, toModel, toRow, toColumn, rowCount, columnCount);
	            var calcModel, head, row, column, expr, settedMap = {}, calcChangInfo;
	            validators && adjustDataValidatorFormulasOnMoveSwap(validators, info, isMove);
	
	            var heads = self._heads;
	            if (!heads) {
	                return;
	            }
	
	            while (heads[0]) {
	                head = heads[0];
	                calcModel = head._sourceModel;
	                row = head.row;
	                column = head.column;
	                calcChangInfo = calcModel._getChangesForCalcEngine();
	                if (settedMap[row] && settedMap[row][column]) {
	                    self._removeAdjust(head, 0 );
	                    continue;
	                }
	                expr = calcModel._getExpr(row, column);
	                var exprSource = calcModel.getSource();
	                if (expr) {
	                    if (sourceChangedExprInfos && sourceChangedExprInfos[row + ', ' + column]) {
	                        exprSource = fromModel;
	                    }
	                    expr = adjustor.call(self, exprSource, row, column, expr, info, isMove);
	                    var arrayInfo = calcModel._getArrayInfo(row, column);
	                    if (arrayInfo) {
	                        arrayInfo = createRange(row, column, arrayInfo.rowCount, arrayInfo.colCount);
	                        for (var r = row; r < row + arrayInfo.rowCount; r++) {
	                            if (!settedMap[r]) {
	                                settedMap[r] = {};
	                            }
	                            for (var c = column; c < column + arrayInfo.colCount; c++) {
	                                calcModel._setExpression(r, c, expr, arrayInfo, r === row && c === column, calcChangInfo);
	                                settedMap[r][c] = true;
	                            }
	                        }
	                    } else {
	                        calcModel._setExpression(row, column, expr, arrayInfo, true, calcChangInfo);
	                    }
	                } else if ((calcModel.getRowExpression && calcModel.getRowExpression(row)) || (calcModel.getColumnExpression && calcModel.getColumnExpression(column))) {
	                    calcModel._addCellsToDirty(row, column, 1, 1);
	                }
	                self._removeAdjust(head, 0 );
	            }
	            while (heads[1]) {
	                head = heads[1];
	                calcModel = head._sourceModel;
	                row = head.row;
	                calcChangInfo = calcModel._getChangesForCalcEngine();
	                if (calcModel.getRowExpression) {
	                    expr = calcModel.getRowExpression(row);
	                    if (expr && calcModel._setRowExpression) {
	                        calcModel._setRowExpression(row, adjustor.call(self, exprSource, row, -1, expr, info, isMove), keyword_undefined, calcChangInfo);
	                    }
	                }
	                self._removeAdjust(head, 1 );
	            }
	            while (heads[2]) {
	                head = heads[2];
	                calcModel = head._sourceModel;
	                column = head.column;
	                calcChangInfo = calcModel._getChangesForCalcEngine();
	                if (calcModel.getColumnExpression) {
	                    expr = calcModel.getColumnExpression(column);
	                    if (expr && calcModel._setColumnExpression) {
	                        calcModel._setColumnExpression(column, adjustor.call(self, exprSource, -1, column, expr, info, isMove), keyword_undefined, calcChangInfo);
	                    }
	                }
	                self._removeAdjust(head, 2 );
	            }
	            while (heads[3]) {
	                var nameIDs = heads[3], nameID = nameIDs.name;
	                calcModel = nameIDs._sourceModel;
	                expr = calcModel._getExpressionWithRowColumnByName(nameID);
	                var newExpr = adjustor.call(self, exprSource, 0, 0, expr, info, isMove);
	                calcModel._setExpressionByName(nameID, newExpr);
	                self._removeAdjust(nameIDs, 3 );
	            }
	            for (var p in heads) {
	                if (parseInt(p) > 3 && heads.hasOwnProperty(p)) {
	                    while (heads[p]) {
	                        var node = heads[p];
	                        calcModel = node._sourceModel;
	                        var source = calcModel.getSource();
	                        expr = adjustor.call(self, source, 0, 0, node.expression, info, isMove);
	                        calcModel.setExpression(node.id, node.name, expr);
	                        self._removeAdjust(node, p );
	                    }
	                }
	            }
	        },
	
	        _addCellsToAdjust: function (sourceModel, row, column, rowCount, columnCount) {
	            var self = this;
	            var endRow = row + rowCount, endCol = column + columnCount;
	            var calc, expr;
	            for (var r = row; r < endRow; r++) {
	                for (var c = column; c < endCol; c++) {
	                    calc = sourceModel._getCalc(r, c);
	                    expr = sourceModel._getExpr(r, c);
	                    if (!calc && !expr) {
	                        continue;
	                    }
	                    self._removeAdjust(calc, 0 );
	                    sourceModel._removeCalc(r, c, 0);
	                    var cellCalc = sourceModel._getCellCalc(r, c, true);
	                    self._addAdjust(cellCalc, 0 );
	                }
	            }
	        },
	        _addColumnsToAdjust: function (sourceModel, col, colCount) {
	            var self = this;
	            for (var c = col; c !== -1 && c < col + colCount; c++) {
	                if (!sourceModel._getCalc(-1, c) && !sourceModel._getExpr(-1, c)) {
	                    continue;
	                }
	                sourceModel._removeCalc(-1, c, 2);
	                var columnCalc = sourceModel._getColumnCalc(c, true);
	                self._addAdjust(columnCalc, 2 );
	            }
	        },
	        _addRowsToAdjust: function (sourceModel, row, rowCount) {
	            var self = this;
	            for (var r = row; r !== -1 && r < row + rowCount; r++) {
	                if (!sourceModel._getCalc(r, -1) && !sourceModel._getExpr(r, -1)) {
	                    continue;
	                }
	                sourceModel._removeCalc(r, -1, 1);
	                var rowCalc = sourceModel._getRowCalc(r, true);
	                self._addAdjust(rowCalc, 1 );
	            }
	        },
	        _addVolatitleToAdjust: function (sourceModel) {
	            var self = this, calcModel;
	            var sheetModels = sourceModel._getCalcServiceInternal().getAllSourceModels(), volatiles, volatiCalc;
	            for (var sheetIndex = 0; sheetIndex < sheetModels.length; sheetIndex++) {
	                calcModel = sheetModels[sheetIndex];
	                if (calcModel._getAllVolatiles) {
	                    volatiles = calcModel._getAllVolatiles();
	                    for (var volatileIndex = 0; volatileIndex < volatiles.length; volatileIndex++) {
	                        volatiCalc = volatiles[volatileIndex];
	                        if (volatiCalc && volatiCalc.isVolatile && (volatiCalc instanceof Calc.CellCalc) && !self.isAdjustCell(volatiCalc)) {
	                            self._addAdjust(volatiCalc, 0 );
	                        }
	                    }
	                }
	            }
	        },
	        onBeforeAddRemoveRows: function (sourceModel, row) {
	            var rc = sourceModel.rC(), cc = sourceModel.cC();
	            sourceModel._unlinkCellExpression(row, 0, rc - row, cc);
	            sourceModel._unlinkRowExpression(row, rc - row);
	            addDependentsToAdjust(sourceModel, row, -1, rc - row, -1, true );
	        },
	        onAfterAddRemoveRows: function (sourceModel, row, count, isAdd) {
	            var self = this;
	            var rc = sourceModel.rC(), cc = sourceModel.cC();
	            if (isAdd) {
	                sourceModel._addCellsToDirty(row, 0, count, cc);
	            } else {
	                rc += count;
	            }
	            self._addCellsToAdjust(sourceModel, row, 0, rc - row, cc);
	            self._addRowsToAdjust(sourceModel, row, rc - row);
	            self._addVolatitleToAdjust(sourceModel);
	            self._adjustFormulasOnAddRemove(sourceModel.getSource(), row, count, true, isAdd);
	            if (sourceModel._getCalcServiceInternal().autoCalculation) {
	                sourceModel._getCalcServiceInternal().recalculateAll(false);
	            }
	        },
	        onAfterAddRemoveColumns: function (sourceModel, column, count, isAdd) {
	            var self = this;
	            var rc = sourceModel.rC(), cc = sourceModel.cC();
	            if (isAdd) {
	                sourceModel._addCellsToDirty(0, column, rc, count);
	            } else {
	                cc += count;
	            }
	            self._addCellsToAdjust(sourceModel, 0, column, rc, cc - column);
	            self._addColumnsToAdjust(sourceModel, column, cc - column);
	            self._addVolatitleToAdjust(sourceModel);
	            self._adjustFormulasOnAddRemove(sourceModel.getSource(), column, count, false, isAdd);
	            if (sourceModel._getCalcServiceInternal().autoCalculation) {
	                sourceModel._getCalcServiceInternal().recalculateAll(false);
	            }
	        },
	        onBeforeAddRemoveColumns: function (sourceModel, column) {
	            var rc = sourceModel.rC(), cc = sourceModel.cC();
	            sourceModel._unlinkCellExpression(0, column, rc, cc - column);
	            sourceModel._unlinkColumnExpression(column, cc - column);
	            addDependentsToAdjust(sourceModel, -1, column, -1, cc - column, true );
	        },
	        onAfterRemoveName: function (calcModel, name) {
	            var nameCalc = calcModel._getNameCalc(name, false);
	            if (nameCalc) {
	                nameCalc.updateListening(true, false);
	                nameCalc._addToDirty();
	                nameCalc.updateListeningOnRemoved();
	            }
	        },
	        adjustFormulaOnRemoveName: function (baseModel, oldExpr, name) {
	            return adjustFormulaOnRemoveNameImp(baseModel, oldExpr, name);
	        },
	        invalidName: function (source, name) {
	            if (!name) {
	                return;
	            }
	            var model = source.getCalcSourceModel();
	            var nameCalc = model._getNameCalc(name.toUpperCase(), true);
	            if (nameCalc) {
	                nameCalc._addListenersToAdjust();
	            }
	        },
	        onAfterRemoveTable: function (tables, convertToError) {
	            var self = this, calcModel, row, column, expr;
	            var heads = self._heads;
	            if (!heads) {
	                return;
	            }
	
	            for (var i = 0; i < tables.length; i++) {
	                var table = tables[i];
	                addDependentsToAdjust(table.source().getCalcSourceModel(), table.startRow(), table.startColumn(),
	                    table.endRow() - table.startRow() + 1, table.endColumn() - table.startColumn() + 1);
	            }
	            var settedMap = {};
	            while (heads[0]) {
	                var head = heads[0];
	                calcModel = head._sourceModel;
	                row = head.row;
	                column = head.column;
	                if (settedMap[row] && settedMap[row][column]) {
	                    self._removeAdjust(head, 0 );
	                    continue;
	                }
	                expr = calcModel._getExpr(row, column);
	                if (expr) {
	                    expr = adjustExpressionOnRemoveTable(expr, tables, row, column, convertToError);
	                    var arrayInfo = calcModel._getArrayInfo(row, column);
	                    if (arrayInfo) {
	                        arrayInfo = createRange(row, column, arrayInfo.rowCount, arrayInfo.colCount);
	                        for (var r = row; r < row + arrayInfo.rowCount; r++) {
	                            if (!settedMap[r]) {
	                                settedMap[r] = {};
	                            }
	                            for (var c = column; c < column + arrayInfo.colCount; c++) {
	                                calcModel._setExpression(r, c, expr, arrayInfo, r === row && c === column);
	                                settedMap[r][c] = true;
	                            }
	                        }
	                    } else {
	                        calcModel._setExpression(row, column, expr, arrayInfo, true);
	                    }
	                } else if ((calcModel.getRowExpression && calcModel.getRowExpression(row)) || (calcModel.getColumnExpression && calcModel.getColumnExpression(column))) {
	                    calcModel._addCellsToDirty(row, column, 1, 1);
	                }
	                self._removeAdjust(head, 0 );
	            }
	        }
	    };
	
	    function adjustExpressionOnRemoveTable (expr, tables, baseRow, baseCol, convertToError) {
	        var selfFunc = adjustExpressionOnRemoveTable;
	        if (expr.type === 9 ) {
	            var left = expr.value, right = expr.value2;
	            var newLeft = selfFunc(left, tables, baseRow, baseCol, convertToError);
	            var newRight = right && selfFunc(right, tables, baseRow, baseCol, convertToError);
	            if (left !== newLeft || right !== newRight) {
	                return Calc._createOperatorExpression(expr.operatorType, newLeft, newRight);
	            }
	        } else if (expr.type === 7 ) {
	            var hasChange = false, newArgs = [];
	            for (var i = 0; i < expr.arguments.length; i++) {
	                var arg = expr.arguments[i];
	                var newArg = selfFunc(arg, tables, baseRow, baseCol, convertToError);
	                hasChange = hasChange || arg !== newArg;
	                newArgs.push(newArg);
	            }
	            if (hasChange) {
	                return Calc._createFunctionExpression(expr, newArgs);
	            }
	        } else if (expr.type === 10 ) {
	            var partExp = expr, argExp = partExp.value,
	                newExp = selfFunc(argExp, tables, baseRow, baseCol, convertToError);
	            if (argExp !== newExp) {
	                return Calc._createParenthesesExpression(newExp);
	            }
	        } else if (expr.type === 13 ) {
	            var tableExpr = expr;
	            for (i = 0; i < tables.length; i++) {
	                if (tableExpr.baseTable() === tables[i]) {
	                    if (convertToError) {
	                        return Calc._referenceErrorExpr;
	                    }
	                    var range = tableExpr.getRange(baseRow === -1 ? 0 : baseRow, baseCol === -1 ? 0 : baseCol, true);
	                    var isRowRelative = baseRow === -1 || tableExpr.referencePortions() === 1 ;
	                    var isCell = range.rowCount === 1 && range.columnCount === 1;
	                    var extSource = tableExpr.source();
	                    if (isCell) {
	                        return Calc._createCellExpression(extSource, keyword_null, range.row, range.col, isRowRelative, false);
	                    }
	                    return new Calc._createRangeExpression(extSource, keyword_null, range.row, range.col, range.row + range.rowCount - 1, range.col + range.colCount - 1, isRowRelative, false, isRowRelative, false);
	                }
	            }
	        }
	        return expr;
	    }
	
	    CalcOperatorAdjustor.adjustExpressionOnRemoveTable = adjustExpressionOnRemoveTable;
	
	    function adjustIndexesOnAdd(baseModel, refModel, baseIndex, index, relative, endIndex, endRelative, addModel, addIndex, addCount) {
	        if (baseIndex >= 0 || !relative) {
	            var refIndex = index + (relative ? baseIndex : 0);
	            var refEndIndex = endIndex + (endRelative ? baseIndex : 0);
	            if (addModel === baseModel && (addIndex + addCount <= baseIndex)) {
	                refIndex -= (relative ? addCount : 0);
	                refEndIndex -= (endRelative ? addCount : 0);
	            }
	            if (addModel === refModel) {
	                if (addIndex <= refIndex) {
	                    refIndex += addCount;
	                    refEndIndex += addCount;
	                } else if (addIndex <= refEndIndex) {
	                    refEndIndex += addCount;
	                }
	            }
	            refIndex -= (relative ? baseIndex : 0);
	            refEndIndex -= (endRelative ? baseIndex : 0);
	            return {index: refIndex, endIndex: refEndIndex};
	        }
	        return {index: index, endIndex: endIndex};
	    }
	
	    function adjustCellExpressionOnAddRemove(baseModel, refModel, baseRow, baseColumn, refExpr, opModel, opIndex, opCount, isRow, isAdd) {
	        if (refModel) {
	            var index = isRow ? refExpr.row : refExpr.column,
	                isRelative = isRow ? refExpr.rowRelative : refExpr.columnRelative, newIndex;
	            if (isRow && baseRow >= 0 || !isRow && baseColumn >= 0 || !isRelative) {
	                if (isAdd) {
	                    newIndex = adjustIndexesOnAdd(baseModel, refModel, isRow ? baseRow : baseColumn, index, isRelative, -1, false, opModel, opIndex, opCount).index;
	                } else {
	                    newIndex = adjustCellOnRemove(baseModel, refModel, isRow ? baseRow : baseColumn, index, isRelative, opModel, opIndex, opCount);
	                    if (_isError(newIndex)) {
	                        return createErrorExpression(newIndex);
	                    }
	                }
	                if (newIndex !== index) {
	                    refExpr = refExpr.offset(isRow ? newIndex - index : 0, isRow ? 0 : newIndex - index, true);
	                }
	            }
	        }
	        return refExpr;
	    }
	
	    function adjustRangeExpressionOnAddRemove(baseModel, refModel, baseRow, baseColumn, refExpr, opModel, opIndex, opCount, isRow, isAdd) {
	        if (refModel) {
	            var rangeType = refExpr._getRangeType();
	            if (rangeType === 3  || isRow && rangeType === 2  || !isRow && rangeType === 1 ) {
	                return refExpr;
	            }
	            var isStartRelative = isRow ? refExpr.rowRelative : refExpr.columnRelative,
	                isEndRelative = isRow ? refExpr.endRowRelative : refExpr.endColumnRelative,
	                startIndex = isRow ? refExpr.row : refExpr.column,
	                endIndex = isRow ? refExpr.endRow : refExpr.endColumn, result;
	            if (isRow && baseRow >= 0 || !isRow && baseColumn >= 0 || !isStartRelative || !isEndRelative) {
	                if (isAdd) {
	                    result = adjustIndexesOnAdd(baseModel, refModel, isRow ? baseRow : baseColumn, startIndex, isStartRelative, endIndex, isEndRelative, opModel, opIndex, opCount);
	                } else {
	                    result = adjustRangeOnRemove(baseModel, refModel, isRow ? baseRow : baseColumn, startIndex, isStartRelative, endIndex, isEndRelative, opModel, opIndex, opCount);
	                    if (_isError(result)) {
	                        return createErrorExpression(result);
	                    }
	                }
	                var newStartIndex = result.index;
	                var newEndIndex = result.endIndex;
	                if (newStartIndex !== startIndex || newEndIndex !== endIndex) {
	                    refExpr = refExpr.offset2(isRow ? newStartIndex - startIndex : 0, isRow ? 0 : newStartIndex - startIndex, isRow ? newEndIndex - endIndex : 0, isRow ? 0 : newEndIndex - endIndex);
	                }
	            }
	        }
	        return refExpr;
	    }
	
	    function adjustStructReferenceExpressionOnAddRemoveColumn(baseModel, refModel, baseRow, baseColumn, refExpr, opModel, opColumn, opColumnCount, isAdd) {
	        if (refModel) {
	            var table = refExpr;
	            if (table && refModel === table.source()) {
	                return table.offsetWhenInsertRemoveColumn(opColumn, opColumnCount, isAdd);
	            }
	        }
	        return refExpr;
	    }
	
	    function adjustFormulaOnAddRemove(baseModel, baseRow, baseColumn, oldExpr, opModel, opIndex, opCount, isRow, isAdd) {
	        var selfFunction = adjustFormulaOnAddRemove;
	        var newExpr = oldExpr, arg;
	        
	        if (!oldExpr) { return; }
	
	        if (oldExpr.type === 1  && oldExpr._isCell()) {
	            newExpr = adjustCellExpressionOnAddRemove(baseModel, oldExpr.source || baseModel, baseRow, baseColumn, oldExpr, opModel, opIndex, opCount, isRow, isAdd);
	        } else if (oldExpr.type === 1 ) {
	            newExpr = adjustRangeExpressionOnAddRemove(baseModel, oldExpr.source || baseModel, baseRow, baseColumn, oldExpr, opModel, opIndex, opCount, isRow, isAdd);
	        } else if (oldExpr.type === 10 ) {
	            arg = selfFunction(baseModel, baseRow, baseColumn, oldExpr.value, opModel, opIndex, opCount, isRow, isAdd);
	            if (arg !== oldExpr.value) {
	                newExpr = createParenthesesExpression(arg);
	            }
	        } else if (oldExpr.type === 9 ) {
	            var arg0 = selfFunction(baseModel, baseRow, baseColumn, oldExpr.value, opModel, opIndex, opCount, isRow, isAdd);
	            var arg1 = oldExpr.value2 && selfFunction(baseModel, baseRow, baseColumn, oldExpr.value2, opModel, opIndex, opCount, isRow, isAdd);
	            if (arg0 !== oldExpr.value || arg1 !== oldExpr.value2) {
	                newExpr = createOperatorExpression(oldExpr.operatorType, arg0, arg1);
	            }
	        } else if (oldExpr.type === 7 ) {
	            var args = keyword_null, fnArg, i, funcExpr = oldExpr;
	            var argCount = funcExpr.arguments.length;
	            for (i = 0; i < argCount; i++) {
	                fnArg = funcExpr.arguments[i];
	                arg = selfFunction(baseModel, baseRow, baseColumn, fnArg, opModel, opIndex, opCount, isRow, isAdd);
	                if (arg !== fnArg) {
	                    args = [];
	                    args[i] = arg;
	                    break;
	                }
	            }
	            if (args) {
	                for (i = 0; i < argCount; i++) {
	                    fnArg = funcExpr.arguments[i];
	                    if (args[i] === keyword_undefined || args[i] === keyword_null) {
	                        args[i] = selfFunction(baseModel, baseRow, baseColumn, fnArg, opModel, opIndex, opCount, isRow, isAdd);
	                    }
	                }
	                newExpr = createFunctionExpression(funcExpr, args);
	            }
	        } else if (!isRow && oldExpr.type === 13 ) {
	            newExpr = adjustStructReferenceExpressionOnAddRemoveColumn(baseModel, baseModel, baseRow, baseColumn, oldExpr, opModel, opIndex, opCount, isAdd);
	        }
	        return newExpr;
	    }
	
	    function adjustValidatorFormulasOnOperator(model, expressionAdjustor, index, count, beginRow, beginCol, endRow, endCol, isRow, isAdd) {
	
	        var adjustExpression = function (sheetSource, expr, baseRow, baseCol) {
	           
	           
	           
	           
	           
	            return expressionAdjustor.call(this, sheetSource, baseRow, baseCol, expr, model, index, count, isRow, isAdd);
	        };
	        var sheet = model.getSheet(),
	            validators = sheet._validations && (sheet.parent || sheet)._getValidatorsWithFormula();
	        adjustValidatorFormulas(validators, adjustExpression, isRow);
	    }
	
	    function adjustValidatorFormulas(validators, adjustExpression, isRow) {
	        if (!validators) {
	            return;
	        }
	        var dataValidator, condition, sheet, r, c;
	        for (var i = 0; i < validators.length; i++) {
	            var isFullRow = true, isFullCol = true;
	            var baseRow = Calc.maxRowCount - 1, baseCol = Calc.maxColumnCount - 1;
	            dataValidator = validators[i].validator;
	            var ranges = dataValidator._ranges;
	            for (var n = 0, count = ranges.length; n < count; n++) {
	                var range = ranges[n];
	
	                var rc = range.rowCount, cc = range.colCount;
	                r = range.row;
	                c = range.col;
	                if (rc !== -1) {
	                    isFullCol = false;
	                    baseRow = baseRow > r ? r : baseRow;
	                }
	                if (cc !== -1) {
	                    isFullRow = false;
	                    baseCol = baseCol > c ? c : baseCol;
	                }
	                if (!isFullRow && !isFullCol) {
	                    break;
	                }
	            }
	
	            if (isRow && isFullCol || !isRow && isFullRow) {
	                continue;
	            }
	
	            sheet = validators[i].sheet;
	            var sheetSource = sheet._getSheetSource();
	            condition = dataValidator.condition();
	            var expressions = condition.getExpressions();
	            if (expressions && expressions.length > 0) {
	                for (var j = 0; j < expressions.length; j++) {
	                    var expr = expressions[j];
	                    expressions[j] = adjustExpression(sheetSource, expr, baseRow, baseCol);
	                }
	                condition.setExpressions(expressions);
	            }
	        }
	    }
	
	    function adjustCellOnRemove(baseModel, refModel, baseIndex, index, relative, removeModel, removeIndex, removeCount) {
	        if (baseIndex >= 0 || !relative) {
	            var refIndex = index + (relative ? baseIndex : 0);
	            if (removeModel === baseModel && removeIndex <= baseIndex) {
	                refIndex += (relative ? removeCount : 0);
	            }
	            if (removeModel === refModel) {
	                if (removeIndex + removeCount <= refIndex) {
	                    refIndex -= removeCount;
	                } else if (removeIndex <= refIndex) {
	                    return CalcErrorsReference;
	                }
	            }
	            refIndex -= (relative ? baseIndex : 0);
	            return refIndex;
	        }
	        return index;
	    }
	
	    function adjustRangeOnRemove(baseModel, refModel, baseIndex, index, relative, endIndex, endRelative, removeModel, removeIndex, removeCount) {
	        if (baseIndex >= 0 || !relative) {
	            var refIndex = index + (relative ? baseIndex : 0);
	            var refEndIndex = endIndex + (endRelative ? baseIndex : 0);
	            var removeEndIndex = removeIndex + removeCount - 1;
	            if (removeModel === baseModel && removeIndex <= baseIndex) {
	                refIndex += (relative ? removeCount : 0);
	                refEndIndex += (endRelative ? removeCount : 0);
	            }
	            if (removeModel === refModel) {
	                if (removeEndIndex < refIndex) {
	                    refIndex -= removeCount;
	                    refEndIndex -= removeCount;
	                } else if (removeIndex <= refIndex && removeEndIndex >= refEndIndex) {
	                    return CalcErrorsReference;
	                } else if (removeIndex > refEndIndex) {
	                   
	                } else if (removeEndIndex <= refEndIndex) {
	                    refIndex = removeIndex >= refIndex ? refIndex : removeIndex;
	                    refEndIndex -= removeCount;
	                } else {
	                    refEndIndex = removeIndex - 1;
	                }
	            }
	            refIndex -= (relative ? baseIndex : 0);
	            refEndIndex -= (endRelative ? baseIndex : 0);
	            return {index: refIndex, endIndex: refEndIndex};
	        }
	        return {index: index, endIndex: endIndex};
	    }
	
	    function adjustFormulaOnRemoveSheet(baseModel, oldExpr, removeModel) {
	        var selfFunction = adjustFormulaOnRemoveSheet;
	        var newExpr = oldExpr, arg, fnArg, i;
	        if (oldExpr) {
	            if (oldExpr.source) {
	                var refModel = oldExpr.source;
	                if ((baseModel !== removeModel && refModel === removeModel) || (baseModel === removeModel && refModel !== removeModel)) {
	                    newExpr = ReferenceErrorExpr;
	                }
	            } else if (oldExpr.type === 10 ) {
	                arg = selfFunction(baseModel, oldExpr.value, removeModel);
	                if (arg !== oldExpr.value) {
	                    newExpr = createParenthesesExpression(arg);
	                }
	            } else if (oldExpr.type === 9 ) {
	                var arg0 = selfFunction(baseModel, oldExpr.value, removeModel);
	                var arg1 = oldExpr.value2 && selfFunction(baseModel, oldExpr.value2, removeModel);
	                if (arg0 !== oldExpr.value || arg1 !== oldExpr.value2) {
	                    newExpr = createOperatorExpression(oldExpr.operatorType, arg0, arg1);
	                }
	            } else if (oldExpr.type === 7 ) {
	                var args = keyword_null;
	                var argCount = oldExpr.arguments.length;
	                for (i = 0; i < argCount; i++) {
	                    fnArg = oldExpr.arguments[i];
	                    arg = selfFunction(baseModel, fnArg, removeModel);
	                    if (arg !== fnArg) {
	                        args = [];
	                        args[i] = arg;
	                        break;
	                    }
	                }
	                if (args) {
	                    for (i = 0; i < argCount; i++) {
	                        fnArg = oldExpr.arguments[i];
	                        if (args[i] === keyword_undefined || args[i] === keyword_null) {
	                            args[i] = selfFunction(baseModel, fnArg, removeModel);
	                        }
	                    }
	                    newExpr = createFunctionExpression(oldExpr, args);
	                }
	            }
	        }
	        return newExpr;
	    }
	
	    function adjustFormulaOnRemoveSheet2(baseModel, baseRow, baseCol, oldExpr, removeModel) {
	        return adjustFormulaOnRemoveSheet(baseModel, oldExpr, removeModel);
	    }
	
	    function adjustCellExpressionOnMove(baseModel, baseRow, baseColumn, refExpr, info) {
	        var isExternal = !!(refExpr.source);
	        var refModel = isExternal ? refExpr.source : baseModel;
	        var refRowRelative = refExpr.rowRelative;
	        var refColumnRelative = refExpr.columnRelative;
	        var refRow, refColumn, moveRef, moveSource;
	        var rowOffset = info._rowOffset(), colOffset = info._colOffset();
	        if ((baseRow >= 0 || !refRowRelative) && (baseColumn >= 0 || !refColumnRelative)) {
	            refRow = refExpr.row + (refRowRelative ? baseRow : 0);
	            refColumn = refExpr.column + (refColumnRelative ? baseColumn : 0);
	            moveSource = info._destinationContains(info._toModel, baseRow, baseColumn, 1, 1);
	           
	            if (refModel === info._toModel && info._destinationContains(refModel, refRow, refColumn, 1, 1) && !info._sourceContains(refModel, refRow, refColumn, 1, 1)
	                && (!refRowRelative && !refColumnRelative || !moveSource)) {
	                return ReferenceErrorExpr;
	            }
	            moveRef = (isExternal && refModel === info._fromModel || !isExternal && baseModel === info._fromModel)
	                && (!moveSource && info._sourceContains(info._fromModel, refRow, refColumn, 1, 1)
	                || moveSource && info._destinationContains(info._toModel, refRow, refColumn, 1, 1));
	            if (moveSource) {
	                refRow -= (refRowRelative ? rowOffset : 0);
	                refColumn -= (refColumnRelative ? colOffset : 0);
	            }
	            if (moveRef) {
	                refRow += rowOffset;
	                refColumn += colOffset;
	            }
	            refRow -= (refRowRelative ? baseRow : 0);
	            refColumn -= (refColumnRelative ? baseColumn : 0);
	            if (info._fromModel === info._toModel) {
	                refModel = isExternal ? refExpr.source : keyword_undefined;
	            } else {
	                refModel = keyword_undefined;
	                if (moveRef && moveSource && isExternal) {
	                    refModel = info._toModel;
	                } else if (moveRef && moveSource) {
	                   
	                } else if (moveRef) {
	                    refModel = info._toModel;
	                } else if (moveSource && !isExternal) {
	                    refModel = info._fromModel;
	                }
	            }
	            if (refRow !== refExpr.row || refColumn !== refExpr.column || refModel !== refExpr.source) {
	                return createCellExpression(refModel, keyword_null, refRow, refColumn, refRowRelative, refColumnRelative);
	            }
	        } else if ((baseRow >= 0 || !refRowRelative) && baseColumn === -1) {
	            refRow = refExpr.row + (refRowRelative ? baseRow : 0);
	            if (info._destinationContains(baseModel, baseRow, baseColumn, 1, 1)) {
	                refRow -= (refRowRelative ? rowOffset : 0);
	            }
	            if (info._sourceContains(refModel, refRow, -1, refRowRelative, -1)) {
	                refRow += rowOffset;
	            } else if (info._destinationContains(refModel, refRow, -1, 1, -1)) {
	                return ReferenceErrorExpr;
	            }
	            refRow -= (refRowRelative ? baseRow : 0);
	            if (refRow !== refExpr.row) {
	                return createCellExpression(refExpr.source, keyword_null, refRow, refExpr.column, refRowRelative, refExpr.columnRelative);
	            }
	        } else if (baseRow === -1 && (baseColumn >= 0 && !refColumnRelative)) {
	            refColumn = refExpr.column + (refColumnRelative ? baseColumn : 0);
	            if (info._destinationContains(baseModel, baseRow, baseColumn, 1, 1)) {
	                refColumn -= (refColumnRelative ? colOffset : 0);
	            }
	            if (info._sourceContains(refModel, refRow, refColumn, 1, 1)) {
	                refColumn += colOffset;
	            } else if (info._destinationContains(refModel, refRow, refColumn, 1, 1)) {
	                return ReferenceErrorExpr;
	            }
	            refColumn -= (refColumnRelative ? baseColumn : 0);
	            if (refRow !== refExpr.row || refColumn !== refExpr.column) {
	                return createCellExpression(refExpr.source, refExpr.endSource, refExpr.row, refColumn, refExpr.rowRelative, refColumnRelative);
	            }
	        }
	        return refExpr;
	    }
	
	    function adjustRangeExpressionOnMove(baseModel, baseRow, baseColumn, refExpr, info) {
	        var isExternal = !!refExpr.source;
	        var refModel = isExternal ? refExpr.source : baseModel;
	        var rangeType = refExpr._getRangeType();
	        var refStartRowRelative, refStartColumnRelative, refEndRowRelative, refEndColumnRelative;
	        var refStartRow, refEndRow, refStartColumn, refEndColumn, refRowCount, refColumnCount;
	        var ro, co, ro1, ro2, co1, co2, moveRef, moveSource;
	        var rowOffset = info._rowOffset(), colOffset = info._colOffset();
	        if (rangeType === 0 ) {
	            refStartRowRelative = refExpr.rowRelative;
	            refStartColumnRelative = refExpr.columnRelative;
	            refEndRowRelative = refExpr.endRowRelative;
	            refEndColumnRelative = refExpr.endColumnRelative;
	            if ((baseRow >= 0 || !refStartRowRelative || !refEndRowRelative) || (baseColumn >= 0 || !refStartColumnRelative || !refEndColumnRelative)) {
	                refStartRow = refExpr.row + (refStartRowRelative ? baseRow : 0);
	                refEndRow = refExpr.endRow + (refEndRowRelative ? baseRow : 0);
	                refStartColumn = refExpr.column + (refStartColumnRelative ? baseColumn : 0);
	                refEndColumn = refExpr.endColumn + (refEndColumnRelative ? baseColumn : 0);
	                refRowCount = refEndRow - refStartRow + 1;
	                refColumnCount = refEndColumn - refStartColumn + 1;
	                moveSource = info._destinationContains(info._toModel, baseRow, baseColumn, 1, 1);
	                if (moveSource) {
	                    var offsetRow = info._toRow - info._toColumn, offsetCol = info._toColumn - info._toRow;
	                    refRowCount += (refStartRowRelative ? -offsetRow : 0) + (refEndRowRelative ? offsetRow : 0);
	                    refColumnCount += (refStartColumnRelative ? -offsetCol : 0) + (refEndColumnRelative ? offsetCol : 0);
	                }
	               
	                if (refModel === info._toModel
	                    && info._destinationContains(refModel, refStartRow, refStartColumn, refRowCount, refColumnCount)
	                    && !(refColumnCount)
	                    && (!refStartRowRelative && !refStartColumnRelative && !refEndRowRelative && !refEndColumnRelative || !moveSource)) {
	                    return ReferenceErrorExpr;
	                }
	                moveRef = (isExternal && refModel === info._fromModel || !isExternal && baseModel === info._fromModel) && (!moveSource && info._sourceContains(info._fromModel, refStartRow, refStartColumn, refRowCount, refColumnCount) || moveSource && info._destinationContains(info._toModel, refStartRow, refStartColumn, refRowCount, refColumnCount));
	                if (moveSource) {
	                    ro1 = (refStartRowRelative ? rowOffset : 0);
	                    ro2 = (refEndRowRelative ? rowOffset : 0);
	                    co1 = (refStartColumnRelative ? colOffset : 0);
	                    co2 = (refEndColumnRelative ? colOffset : 0);
	                    refStartRow -= ro1;
	                    refEndRow -= ro2;
	                    refStartColumn -= co1;
	                    refEndColumn -= co2;
	                }
	                var refRangeChanged = false;
	                if (moveRef) {
	                    ro = rowOffset;
	                    co = colOffset;
	                    refStartRow += ro;
	                    refEndRow += ro;
	                    refStartColumn += co;
	                    refEndColumn += co;
	                } else if (info._destinationContains(refModel, refStartRow, refStartColumn, refRowCount, refColumnCount)) {
	                    var intersectedRange = info.intersectWith(refModel, refStartRow, refStartColumn, refRowCount, refColumnCount);
	                    if (intersectedRange && (intersectedRange.rowCount === refRowCount || intersectedRange.colCount === refColumnCount)) {
	                        refStartRow = intersectedRange.row + rowOffset;
	                        refStartColumn = intersectedRange.col + colOffset;
	                        refEndRow = refStartRow + intersectedRange.rowCount;
	                        refEndColumn = refStartColumn + intersectedRange.colCount;
	                        refRangeChanged = true;
	                    } else {
	                        return ReferenceErrorExpr;
	                    }
	                }
	                refStartRow -= (refStartRowRelative ? baseRow : 0);
	                refEndRow -= (refEndRowRelative ? baseRow : 0);
	                refStartColumn -= (refStartColumnRelative ? baseColumn : 0);
	                refEndColumn -= (refEndColumnRelative ? baseColumn : 0);
	                if (info._fromModel === info._toModel) {
	                    refModel = isExternal ? refExpr.source : keyword_undefined;
	                } else {
	                    refModel = keyword_undefined;
	                    if (moveRef && moveSource && isExternal) {
	                        refModel = info._toModel;
	                    } else if (moveRef && moveSource) {
	                    } else if (moveRef) {
	                        refModel = info._toModel;
	                    } else if (moveSource && !isExternal) {
	                        refModel = info._fromModel;
	                    }
	                }
	                if (refStartRow !== refExpr.row || refStartColumn !== refExpr.column || refEndRow !== refExpr.endRow || refEndColumn !== refExpr.endColumn || refRangeChanged || refModel !== refExpr.source) {
	                    return createRangeExpression(refModel, keyword_null, refStartRow, refStartColumn, refEndRow, refEndColumn, refStartRowRelative, refStartColumnRelative, refEndRowRelative, refEndColumnRelative);
	                }
	            } else if ((baseRow >= 0 || !refStartRowRelative || !refEndRowRelative) && baseColumn === -1) {
	                refStartRow = refExpr.row + (refStartRowRelative ? baseRow : 0);
	                refEndRow = refExpr.endRow + (refEndRowRelative ? baseRow : 0);
	                if (refStartRow > refEndRow) {
	                    return ReferenceErrorExpr;
	                }
	                if (info._destinationContains(baseModel, baseRow, baseColumn, 1, 1)) {
	                    ro1 = (refStartRowRelative ? rowOffset : 0);
	                    ro2 = (refEndRowRelative ? rowOffset : 0);
	                    refStartRow -= ro1;
	                    refEndRow -= ro2;
	                }
	                refRowCount = refEndRow - refStartRow;
	                if (info._sourceContains(refModel, refStartRow, -1, refRowCount, -1)) {
	                    ro = rowOffset;
	                    refStartRow += ro;
	                    refEndRow += ro;
	                } else if (info._destinationContains(refModel, refStartRow, -1, refRowCount, -1)) {
	                    return ReferenceErrorExpr;
	                }
	                refStartRow -= (refStartRowRelative ? baseRow : 0);
	                refEndRow -= (refEndRowRelative ? baseRow : 0);
	                if (refStartRow !== refExpr.row || refEndRow !== refExpr.endRow) {
	                    return createRangeExpression(refExpr.source, keyword_null, refStartRow, refExpr.column, refEndRow, refExpr.endColumn, refStartRowRelative, refExpr.columnRelative, refEndRowRelative, refExpr.endColumnRelative);
	                }
	            } else if (baseRow === -1 && (baseColumn >= 0 || !refStartColumnRelative || !refEndColumnRelative)) {
	                refStartColumn = refExpr.column + (refStartColumnRelative ? baseColumn : 0);
	                refEndColumn = refExpr.endColumn + (refEndColumnRelative ? baseColumn : 0);
	                if (refStartColumn > refEndColumn) {
	                    return ReferenceErrorExpr;
	                }
	                if (info._destinationContains(baseModel, baseRow, baseColumn, 1, 1)) {
	                    co1 = (refStartColumnRelative ? colOffset : 0);
	                    co2 = (refEndColumnRelative ? colOffset : 0);
	                    refStartColumn -= co1;
	                    refEndColumn -= co2;
	                }
	                refColumnCount = refEndColumn - refStartColumn;
	                if (info._sourceContains(refModel, -1, refStartColumn, -1, refColumnCount)) {
	                    co = colOffset;
	                    refStartColumn += co;
	                    refEndColumn += co;
	                } else if (info._destinationContains(refModel, -1, refStartColumn, -1, refColumnCount)) {
	                    return ReferenceErrorExpr;
	                }
	                refStartColumn -= (refStartColumnRelative ? baseColumn : 0);
	                refEndColumn -= (refEndColumnRelative ? baseColumn : 0);
	                if (refStartColumn !== refExpr.column || refEndColumn !== refExpr.endColumn) {
	                    return createRangeExpression(refExpr.source, keyword_null, refExpr.row, refStartColumn, refExpr.endRow, refEndColumn, refExpr.rowRelative, refStartColumnRelative, refExpr.endRowRelative, refEndColumnRelative);
	                }
	            }
	        } else if (rangeType === 1 ) {
	            refStartRowRelative = refExpr.rowRelative;
	            refEndRowRelative = refExpr.endRowRelative;
	            if (baseRow >= 0 || !refStartRowRelative || !refEndRowRelative) {
	                refStartRow = refExpr.row + (refStartRowRelative ? baseRow : 0);
	                refEndRow = refExpr.endRow + (refEndRowRelative ? baseRow : 0);
	                if (refStartRow > refEndRow) {
	                    return ReferenceErrorExpr;
	                }
	                if (info._destinationContains(baseModel, baseRow, baseColumn, 1, 1)) {
	                    ro1 = (refStartRowRelative ? rowOffset : 0);
	                    ro2 = (refEndRowRelative ? rowOffset : 0);
	                    refStartRow -= ro1;
	                    refEndRow -= ro2;
	                }
	                refRowCount = refEndRow - refStartRow;
	                if (info._sourceContains(refModel, refStartRow, -1, refRowCount, -1)) {
	                    ro = rowOffset;
	                    refStartRow += ro;
	                    refEndRow += ro;
	                } else if (info._destinationContains(refModel, refStartRow, -1, refRowCount, -1)) {
	                    return ReferenceErrorExpr;
	                }
	                refStartRow -= (refStartRowRelative ? baseRow : 0);
	                refEndRow -= (refEndRowRelative ? baseRow : 0);
	                if (refStartRow !== refExpr.row || refEndRow !== refExpr.endRow) {
	                    return createRangeExpression(refExpr.source, refExpr.endSource, refStartRow, BAND_INDEX_CONST, refEndRow, BAND_INDEX_CONST, refStartRowRelative, false, refEndRowRelative, false);
	                }
	            }
	        } else if (rangeType === 2 ) {
	            refStartColumnRelative = refExpr.columnRelative;
	            refEndColumnRelative = refExpr.endColumnRelative;
	            refStartColumn = refExpr.column + (refStartColumnRelative ? baseColumn : 0);
	            refEndColumn = refExpr.endColumn + (refEndColumnRelative ? baseColumn : 0);
	            if (refStartColumn < refEndColumn) {
	                return ReferenceErrorExpr;
	            }
	            if (info._destinationContains(baseModel, baseRow, baseColumn, 1, 1)) {
	                co1 = (refStartColumnRelative ? colOffset : 0);
	                co2 = (refEndColumnRelative ? colOffset : 0);
	                refStartColumn -= co1;
	                refEndColumn -= co2;
	            }
	            refColumnCount = refEndColumn - refStartColumn;
	            if (info._sourceContains(refModel, -1, refStartColumn, -1, refColumnCount)) {
	                co = colOffset;
	                refStartColumn += co;
	                refEndColumn += co;
	            } else if (info._destinationContains(refModel, -1, refStartColumn, -1, refColumnCount)) {
	                return ReferenceErrorExpr;
	            }
	            refStartColumn -= (refStartColumnRelative ? baseColumn : 0);
	            refEndColumn -= (refEndColumnRelative ? baseColumn : 0);
	            if (refStartColumn !== refExpr.column || refEndColumn !== refExpr.endColumn) {
	                return createRangeExpression(refExpr.source, refExpr.endSource, BAND_INDEX_CONST, refStartColumn, BAND_INDEX_CONST, refEndColumn, false, refStartColumnRelative, false, refEndColumnRelative);
	            }
	        }
	        return refExpr;
	    }
	
	    function adjustFormulaOnMoveSwap(baseModel, baseRow, baseColumn, oldExpr, info, isMove) {
	        var selfFunction = adjustFormulaOnMoveSwap;
	        var newExpr = oldExpr, arg;
	        if (oldExpr.type === 1  && oldExpr._isCell()) {
	            newExpr = isMove ? adjustCellExpressionOnMove(baseModel, baseRow, baseColumn, oldExpr, info) : adjustCellExpressionOnSwap(baseModel, baseRow, baseColumn, oldExpr, info);
	        } else if (oldExpr.type === 1 ) {
	            newExpr = isMove ? adjustRangeExpressionOnMove(baseModel, baseRow, baseColumn, oldExpr, info) : adjustRangeExpressionOnSwap(baseModel, baseRow, baseColumn, oldExpr, info);
	        } else if (oldExpr.type === 10 ) {
	            arg = selfFunction(baseModel, baseRow, baseColumn, oldExpr.value, info, isMove);
	            if (arg !== oldExpr.value) {
	                newExpr = createParenthesesExpression(arg);
	            }
	        } else if (oldExpr.type === 9 ) {
	            var arg0 = selfFunction(baseModel, baseRow, baseColumn, oldExpr.value, info, isMove);
	            var arg1 = oldExpr.value2 && selfFunction(baseModel, baseRow, baseColumn, oldExpr.value2, info, isMove);
	            if (arg0 !== oldExpr.value || arg1 !== oldExpr.value2) {
	                newExpr = createOperatorExpression(oldExpr.operatorType, arg0, arg1);
	            }
	        } else if (oldExpr.type === 7 ) {
	            var args = keyword_null, fnArg, i;
	            var argCount = oldExpr.arguments.length;
	            for (i = 0; i < argCount; i++) {
	                fnArg = oldExpr.arguments[i];
	                arg = selfFunction(baseModel, baseRow, baseColumn, fnArg, info, isMove);
	                if (arg !== fnArg) {
	                    args = [];
	                    args[i] = arg;
	                    break;
	                }
	            }
	            if (args) {
	                for (i = 0; i < argCount; i++) {
	                    fnArg = oldExpr.arguments[i];
	                    if (args[i] === keyword_undefined || args[i] === keyword_null) {
	                        args[i] = selfFunction(baseModel, baseRow, baseColumn, fnArg, info, isMove);
	                    }
	                }
	                newExpr = createFunctionExpression(oldExpr, args);
	            }
	        }
	        return newExpr;
	    }
	
	    function adjustDataValidatorFormulasOnMoveSwap(validators, info, isMove) {
	        var dataValidator, condition, expressions, expression, sheet;
	        var baseRowCol, baseRow, baseCol;
	        for (var i = 0; i < validators.length; i++) {
	           
	           
	            dataValidator = validators[i].validator;
	            var ranges = dataValidator._ranges;
	            baseRowCol = getBaseRowBaseCol(ranges);
	            baseRow = baseRowCol.r;
	            baseCol = baseRowCol.c;
	            sheet = validators[i].sheet;
	            var sheetSource = sheet._getSheetSource();
	            condition = dataValidator.condition();
	            expressions = condition.getExpressions();
	            if (expressions && expressions.length > 0) {
	                for (var j = 0; j < expressions.length; j++) {
	                    expression = expressions[j];
	                    expressions[j] = adjustFormulaOnMoveSwap(sheetSource, baseRow, baseCol, expression, info, isMove);
	                }
	                condition.setExpressions(expressions);
	            }
	        }
	    }
	
	    function adjustCellExpressionOnSwap(baseModel, baseRow, baseColumn, refExpr, info) {
	        var refModel = refExpr.source || baseModel;
	        var refRowRelative = refExpr.rowRelative, refColumnRelative = refExpr.columnRelative, refRow, refColumn;
	        var rowOffset = info._rowOffset(), colOffset = info._colOffset();
	        if ((baseRow >= 0 || !refRowRelative) && (baseColumn >= 0 || !refColumnRelative)) {
	            refRow = refExpr.row + (refRowRelative ? baseRow : 0);
	            refColumn = refExpr.column + (refColumnRelative ? baseColumn : 0);
	            if (info._destinationContains(baseModel, baseRow, baseColumn, 1, 1)) {
	                refRow -= (refRowRelative ? rowOffset : 0);
	                refColumn -= (refColumnRelative ? colOffset : 0);
	            } else if (info._sourceContains(baseModel, refRow, refColumn, 1, 1)) {
	                refRow += (refRowRelative ? rowOffset : 0);
	                refColumn += (refColumnRelative ? colOffset : 0);
	            }
	            if (info._sourceContains(refModel, refRow, refColumn, 1, 1)) {
	                refRow += rowOffset;
	                refColumn += colOffset;
	            } else if (info._destinationContains(refModel, refRow, refColumn, 1, 1)) {
	                refRow -= rowOffset;
	                refColumn -= colOffset;
	            }
	            refRow -= (refRowRelative ? baseRow : 0);
	            refColumn -= (refColumnRelative ? baseColumn : 0);
	            if (refRow !== refExpr.row || refColumn !== refExpr.column) {
	                return createCellExpression(refExpr.source, keyword_null, refRow, refColumn, refRowRelative, refColumnRelative);
	            }
	        } else if ((baseRow >= 0 || !refRowRelative) && baseColumn === -1) {
	            refRow = refExpr.row + (refRowRelative ? baseRow : 0);
	            if (info._destinationContains(baseModel, baseRow, -1, 1, -1)) {
	                refRow -= (refRowRelative ? rowOffset : 0);
	            } else if (info._sourceContains(baseModel, refRow, -1, 1, -1)) {
	                refRow += (refRowRelative ? rowOffset : 0);
	            }
	            if (info._sourceContains(refModel, refRow, -1, 1, -1)) {
	                refRow += rowOffset;
	            } else if (info._destinationContains(refModel, refRow, -1, 1, -1)) {
	                refRow -= rowOffset;
	            }
	            refRow -= (refRowRelative ? baseRow : 0);
	            if (refRow !== refExpr.row || refColumn !== refExpr.column) {
	                return createCellExpression(refExpr.source, keyword_null, refRow, refExpr.column, refRowRelative, refExpr.columnRelative);
	            }
	        } else if (baseRow === -1 && (baseColumn >= 0 && !refColumnRelative)) {
	            refColumn = refExpr.column + 0;
	            if (info._destinationContains(baseModel, -1, baseColumn, -1, 1)) {
	                refColumn -= 0;
	            } else if (info._sourceContains(baseModel, -1, refColumn, -1, 1)) {
	                refColumn += 0;
	            }
	            if (info._sourceContains(refModel, -1, refColumn, -1, 1)) {
	                refColumn += colOffset;
	            } else if (info._destinationContains(refModel, -1, refColumn, -1, 1)) {
	                refColumn -= colOffset;
	            }
	            refColumn -= 0;
	            if (refRow !== refExpr.row || refColumn !== refExpr.column) {
	                return createCellExpression(refExpr.source, keyword_null, refExpr.row, refColumn, refExpr.rowRelative, refColumnRelative);
	            }
	        }
	        return refExpr;
	    }
	
	    function adjustRangeExpressionOnSwap(baseModel, baseRow, baseColumn, refExpr, info) {
	        var refModel = refExpr.source || baseModel;
	        var rangeType = refExpr._getRangeType();
	        var refStartRow, refEndRow, refStartColumn, refEndColumn, refRowCount, refColumnCount;
	        var refStartRowRelative, refStartColumnRelative, refEndRowRelative, refEndColumnRelative;
	        var ro, co, ro1, co1, ro2, co2;
	        var rowOffset = info._rowOffset(), colOffset = info._colOffset();
	        if (rangeType === 0 ) {
	            refStartRowRelative = refExpr.rowRelative;
	            refStartColumnRelative = refExpr.columnRelative;
	            refEndRowRelative = refExpr.endRowRelative;
	            refEndColumnRelative = refExpr.endColumnRelative;
	            if ((baseRow >= 0 || !refStartRowRelative || !refEndRowRelative) && (baseColumn >= 0 || !refStartColumnRelative || !refEndColumnRelative)) {
	                refStartRow = refExpr.row + (refStartRowRelative ? baseRow : 0);
	                refEndRow = refExpr.endRow + (refEndRowRelative ? baseRow : 0);
	                refStartColumn = refExpr.column + (refStartColumnRelative ? baseColumn : 0);
	                refEndColumn = refExpr.endColumn + (refEndColumnRelative ? baseColumn : 0);
	                refRowCount = refEndRow - refStartRow;
	                refColumnCount = refEndColumn - refStartColumn;
	                if (info._destinationContains(baseModel, baseRow, baseColumn, 1, 1)) {
	                    ro1 = (refStartRowRelative ? rowOffset : 0);
	                    co1 = (refStartColumnRelative ? colOffset : 0);
	                    ro2 = (refEndRowRelative ? rowOffset : 0);
	                    co2 = (refEndColumnRelative ? colOffset : 0);
	                    refStartRow -= ro1;
	                    refEndRow -= ro2;
	                    refStartColumn -= co1;
	                    refEndColumn -= co2;
	                } else if (info._sourceContains(baseModel, refStartRow, refStartColumn, refRowCount, refColumnCount)) {
	                    ro1 = (refStartRowRelative ? rowOffset : 0);
	                    co1 = (refStartColumnRelative ? colOffset : 0);
	                    ro2 = (refEndRowRelative ? rowOffset : 0);
	                    co2 = (refEndColumnRelative ? colOffset : 0);
	                    refStartRow += ro1;
	                    refEndRow += ro2;
	                    refStartColumn += co1;
	                    refEndColumn += co2;
	                }
	                if (info._sourceContains(refModel, refStartRow, refStartColumn, refRowCount, refColumnCount)) {
	                    ro = rowOffset;
	                    co = colOffset;
	                    refStartRow += ro;
	                    refEndRow += ro;
	                    refStartColumn += co;
	                    refEndColumn += co;
	                } else if (info._destinationContains(refModel, refStartRow, refStartColumn, refRowCount, refColumnCount)) {
	                    ro = rowOffset;
	                    co = colOffset;
	                    refStartRow -= ro;
	                    refEndRow -= ro;
	                    refStartColumn -= co;
	                    refEndColumn -= co;
	                }
	                refStartRow -= (refStartRowRelative ? baseRow : 0);
	                refEndRow -= (refEndRowRelative ? baseRow : 0);
	                refStartColumn -= (refStartColumnRelative ? baseColumn : 0);
	                refEndColumn -= (refEndColumnRelative ? baseColumn : 0);
	                if (refStartRow !== refExpr.row || refStartColumn !== refExpr.column || refEndRow !== refExpr.endRow || refEndColumn !== refExpr.endColumn) {
	                    return createRangeExpression(refExpr.source, keyword_null, refStartRow, refStartColumn, refEndRow, refEndColumn, refStartRowRelative, refStartColumnRelative, refEndRowRelative, refEndColumnRelative);
	                }
	            } else if ((baseRow >= 0 || !refStartRowRelative || !refEndRowRelative) && baseColumn === -1) {
	                refStartRow = refExpr.row + (refStartRowRelative ? baseRow : 0);
	                refEndRow = refExpr.endRow + (refEndRowRelative ? baseRow : 0);
	                if (refStartRow < refEndRow) {
	                    return ReferenceErrorExpr;
	                }
	                if (info._destinationContains(baseModel, baseRow, -1, 1, -1)) {
	                    ro1 = (refStartRowRelative ? rowOffset : 0);
	                    ro2 = (refStartRowRelative ? rowOffset : 0);
	                    refStartRow -= ro1;
	                    refEndRow -= ro2;
	                } else if (info._sourceContains(baseModel, baseRow, -1, 1, -1)) {
	                    ro1 = (refStartRowRelative ? rowOffset : 0);
	                    ro2 = (refStartRowRelative ? rowOffset : 0);
	                    refStartRow += ro1;
	                    refEndRow += ro2;
	                }
	                refRowCount = refEndRow - refStartRow;
	                if (info._sourceContains(refModel, refStartRow, -1, refRowCount, -1)) {
	                    ro = rowOffset;
	                    refStartRow += ro;
	                    refEndRow += ro;
	                } else if (info._destinationContains(refModel, refStartRow, -1, refRowCount, -1)) {
	                    ro = rowOffset;
	                    refStartRow -= ro;
	                    refEndRow -= ro;
	                }
	                refStartRow -= (refStartRowRelative ? baseRow : 0);
	                refEndRow -= (refEndRowRelative ? baseRow : 0);
	                if (refStartRow !== refExpr.row || refEndRow !== refExpr.endRow) {
	                    return createRangeExpression(refExpr.source, keyword_null, refStartRow, refExpr.column, refEndRow, refExpr.endColumn, refStartRowRelative, refExpr.columnRelative, refEndRowRelative, refExpr.endColumnRelative);
	                }
	            } else if (baseRow === -1 && (baseColumn >= 0 || !refStartColumnRelative || !refEndColumnRelative)) {
	                refStartColumn = refExpr.column + (refStartColumnRelative ? baseColumn : 0);
	                refEndColumn = refExpr.endColumn + (refEndColumnRelative ? baseColumn : 0);
	                if (refStartColumn < refEndColumn) {
	                    return ReferenceErrorExpr;
	                }
	                if (info._destinationContains(baseModel, -1, baseColumn, -1, 1)) {
	                    co1 = (refStartColumnRelative ? colOffset : 0);
	                    co2 = (refEndColumnRelative ? colOffset : 0);
	                    refStartColumn -= co1;
	                    refEndColumn -= co2;
	                } else if (info._sourceContains(baseModel, -1, baseColumn, -1, 1)) {
	                    co1 = (refStartColumnRelative ? colOffset : 0);
	                    co2 = (refEndColumnRelative ? colOffset : 0);
	                    refStartColumn += co1;
	                    refEndColumn += co2;
	                }
	                refColumnCount = refEndColumn - refStartColumn;
	                if (info._sourceContains(refModel, -1, refStartColumn, -1, refColumnCount)) {
	                    co = colOffset;
	                    refStartColumn += co;
	                    refEndColumn += co;
	                } else if (info._destinationContains(refModel, -1, refStartColumn, -1, refColumnCount)) {
	                    co = colOffset;
	                    refStartColumn -= co;
	                    refEndColumn -= co;
	                }
	                refStartColumn -= (refStartColumnRelative ? baseColumn : 0);
	                refEndColumn -= (refEndColumnRelative ? baseColumn : 0);
	                if (refStartColumn !== refExpr.column || refEndColumn !== refExpr.endColumn) {
	                    return createRangeExpression(refExpr.source, keyword_null, refStartColumn, refExpr.endRow, refEndColumn, refExpr.rowRelative, refStartColumnRelative, refExpr.endRowRelative, refEndColumnRelative);
	                }
	            }
	        } else if (rangeType === 1 ) {
	            refStartRowRelative = refExpr.rowRelative;
	            refEndRowRelative = refExpr.endRowRelative;
	            if (baseRow >= 0 || !refStartRowRelative || !refEndRowRelative) {
	                refStartRow = refExpr.row + (refStartRowRelative ? baseRow : 0);
	                refEndRow = refExpr.endRow + (refEndRowRelative ? baseRow : 0);
	                if (refStartRow < refEndRow) {
	                    return ReferenceErrorExpr;
	                }
	                if (info._destinationContains(baseModel, baseRow, -1, 1, -1)) {
	                    ro1 = (refStartRowRelative ? rowOffset : 0);
	                    ro2 = (refEndRowRelative ? rowOffset : 0);
	                    refStartRow -= ro1;
	                    refEndRow -= ro2;
	                } else if (info._sourceContains(baseModel, baseRow, -1, 1, -1)) {
	                    ro1 = (refStartRowRelative ? rowOffset : 0);
	                    ro2 = (refEndRowRelative ? rowOffset : 0);
	                    refStartRow += ro1;
	                    refEndRow += ro2;
	                }
	                refRowCount = refEndRow - refStartRow;
	                if (info._sourceContains(refModel, refStartRow, -1, refRowCount, -1)) {
	                    ro = rowOffset;
	                    refStartRow += ro;
	                    refEndRow += ro;
	                } else if (info._destinationContains(refModel, refStartRow, -1, refRowCount, -1)) {
	                    ro = rowOffset;
	                    refStartRow -= ro;
	                    refEndRow -= ro;
	                }
	                refStartRow -= (refStartRowRelative ? baseRow : 0);
	                refEndRow -= (refEndRowRelative ? baseRow : 0);
	                if (refStartRow !== refExpr.row || refEndRow !== refExpr.endRow) {
	                    return createRangeExpression(refExpr.source, keyword_null, refStartRow, BAND_INDEX_CONST, refEndRow, BAND_INDEX_CONST, refStartRowRelative, false, refEndRowRelative, false);
	                }
	            }
	        } else if (rangeType === 2 ) {
	            refStartColumnRelative = refExpr.columnRelative;
	            refEndColumnRelative = refExpr.endColumnRelative;
	            refStartColumn = refExpr.column + (refStartColumnRelative ? baseColumn : 0);
	            refEndColumn = refExpr.endColumn + (refEndColumnRelative ? baseColumn : 0);
	            if (refStartColumn > refEndColumn) {
	                return ReferenceErrorExpr;
	            }
	            if (info._destinationContains(baseModel, -1, baseColumn, -1, 1)) {
	                co1 = (refStartColumnRelative ? colOffset : 0);
	                co2 = (refEndColumnRelative ? colOffset : 0);
	                refStartColumn -= co1;
	                refEndColumn -= co2;
	            } else if (info._sourceContains(baseModel, -1, baseColumn, -1, 1)) {
	                co1 = (refStartColumnRelative ? colOffset : 0);
	                co2 = (refEndColumnRelative ? colOffset : 0);
	                refStartColumn += co1;
	                refEndColumn += co2;
	            }
	            refColumnCount = refEndColumn - refStartColumn;
	            if (info._sourceContains(refModel, -1, refStartColumn, -1, refColumnCount)) {
	                co = colOffset;
	                refStartColumn += co;
	                refEndColumn += co;
	            } else if (info._destinationContains(refModel, -1, refStartColumn, -1, refColumnCount)) {
	                co = colOffset;
	                refStartColumn -= co;
	                refEndColumn -= co;
	            }
	            refStartColumn -= (refStartColumnRelative ? baseColumn : 0);
	            refEndColumn -= (refEndColumnRelative ? baseColumn : 0);
	            if (refStartColumn !== refExpr.column || refEndColumn !== refExpr.endColumn) {
	                return createRangeExpression(refExpr.source, keyword_null, BAND_INDEX_CONST, refStartColumn, BAND_INDEX_CONST, refEndColumn, false, refStartColumnRelative, false, refEndColumnRelative);
	            }
	        }
	        return refExpr;
	    }
	
	    function addDependentsToAdjust(sourceModel, row, col, rowCount, colCount, needSaveChanges) {
	        sourceModel._addDependents(row, col, rowCount, colCount, true, false, needSaveChanges);
	    }
	
	    function adjustFormulaOnRemoveNameImp(baseModel, oldExpr, name) {
	        var selfFunction = adjustFormulaOnRemoveNameImp;
	        var newExpr = oldExpr, arg, fnArg, i;
	        if (oldExpr.type === 8 ) {
	            if (oldExpr.value === name && (!oldExpr.source || oldExpr.source === baseModel.getSource())) {
	                return createErrorExpression(CalcErrorsReference, oldExpr.source);
	            }
	        } else if (oldExpr.type === 10 ) {
	            arg = selfFunction(baseModel, oldExpr.value, name);
	            if (arg !== oldExpr.value) {
	                newExpr = createParenthesesExpression(arg);
	            }
	        } else if (oldExpr.type === 9 ) {
	            var arg0 = selfFunction(baseModel, oldExpr.value, name);
	            var arg1 = oldExpr.value2 && selfFunction(baseModel, oldExpr.value2, name);
	            if (arg0 !== oldExpr.value || arg1 !== oldExpr.value2) {
	                newExpr = createOperatorExpression(oldExpr.operatorType, arg0, arg1);
	            }
	        } else if (oldExpr.type === 7 ) {
	            var args = keyword_null;
	            var argCount = oldExpr.arguments.length;
	            for (i = 0; i < argCount; i++) {
	                fnArg = oldExpr.arguments[i];
	                arg = selfFunction(baseModel, fnArg, name);
	                if (arg !== fnArg) {
	                    args = [];
	                    args[i] = arg;
	                    break;
	                }
	            }
	            if (args) {
	                for (i = 0; i < argCount; i++) {
	                    fnArg = oldExpr.arguments[i];
	                    if (args[i] === keyword_undefined || args[i] === keyword_null) {
	                        args[i] = selfFunction(baseModel, fnArg, name);
	                    }
	                }
	                newExpr = createFunctionExpression(oldExpr, args);
	            }
	        }
	        return newExpr;
	    }
	
	}());

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	    
	    var exports = __webpack_require__(1);
	    var keyword_null = null, keyword_undefined = void 0;
	    var CalcEngine = __webpack_require__(2);
	    var $ = __webpack_require__(4).GC$;
	    var $_each = $.each;
	    var util_common = __webpack_require__(3);
	    var Common = __webpack_require__(5);
	    var toUpperCase = Common._StringHelper._toUpperCase;
	    var sR = function () {
	        return Common._getResource(exports.SR)();
	    };
	    var Worksheet = __webpack_require__(17).Worksheet;
	    var isNullOrUndefined = Common._Types._isNullOrUndefined;
	
	    var convertToInt = parseInt;
	
	    function getStartColumnRelative(obj) {
	        return obj.columnRelative;
	    }
	
	    function getEndColumnRelative(obj) {
	        return obj.endColumnRelative;
	    }
	
	    function getStartRowRelative(obj) {
	        return obj.rowRelative;
	    }
	
	    function getEndRowRelative(obj) {
	        return obj.endRowRelative;
	    }
	
	    function getCalcService(obj) {
	        return obj._getCalcServiceInternal();
	    }
	
	    function getStartColumn(obj) {
	        return obj.column;
	    }
	
	    function init() {
	        var self = this;
	        if (self._calcReseted) {
	            self._calcReseted = false;
	            return;
	        }
	        self._functions = {};
	        self._nameInfos = {};
	        if (self._vpCalcSheetModel) {
	            self._vpCalcSheetModel.clearAll();
	        } else {
	            self._vpSheetSource = new exports.CalcEngine.SheetSource(self);
	        }
	    }
	
	   
	    
	    exports.ReferenceStyle = {
	        
	        a1: 0,
	        
	        r1c1: 1
	    };
	
	   
	    var NameInfo = (function () {
	       
	        
	        function NameInfo(name, expr, row, column, comment) {
	            var self = this;
	            self._name = name;
	            self._baseRow = row;
	            self._baseColumn = column;
	            self._expr = expr;
	            if(!isNullOrUndefined(comment)) {
	                self._comment = comment;
	            }
	        }
	
	        NameInfo.prototype = {
	           
	            
	            getName: function () {
	                return this._name;
	            },
	           
	            
	            getRow: function () {
	                return this._baseRow;
	            },
	           
	            
	            getColumn: function () {
	                return this._baseColumn;
	            },
	           
	            
	            getExpression: function () {
	                return this._expr;
	            },
	           
	            
	            getComment: function () {
	                return this._comment;
	            },
	           
	            _setExpression: function (expr) {
	                this._expr = expr;
	            }
	        };
	        return NameInfo;
	    })();
	    exports.NameInfo = NameInfo;
	   
	
	    function _hasArrayFormula(sheet, row, column, rowCount, columnCount) {
	        var result = sheet._getsArrayFormulas(row, column, rowCount, columnCount),
	            formulas = result && result.formulas;
	        return formulas && formulas.length > 0;
	    }
	
	    var sheetEx = {
	        resetCalc: function () {
	            init.call(this);
	            this._calcReseted = true;
	        },
	       
	       
	        
	        recalcAll: function (refreshAll) {
	            var calcService = getCalcService(this);
	            if (calcService) {
	                this.suspendPaint();
	                calcService.suspend(true);
	                if (refreshAll) {
	                    var parent = this.parent, sheets;
	                    sheets = parent && parent.sheets || [this];
	                    for (var sheetIndex = 0; sheetIndex < sheets.length; sheetIndex++) {
	                        var sheet = sheets[sheetIndex];
	                        var names = sheet._nameInfos, calcSource = sheet._getSheetSource();
	                        if (names) {
	                            for (var n in names) { 
	                                var ni = names[n];
	                                var expr = ni._expr;
	                                var formula = calcService.unparse(calcSource, expr, 0, 0);
	                                ni._expr = calcService.parse(calcSource, formula, 0, 0);
	                            }
	                        }
	                        var calcSourceModel = calcSource.getCalcSourceModel();
	                        var nodes = calcSourceModel.getAllNodes();
	                        for (var i = 0; i < nodes.length; i++) {
	                            var node = nodes[i];
	                            var calc = node.calc;
	                            if (calc && node._expr) {
	                                adjustOneFormula(calcService, calc);
	                            }
	                        }
	                    }
	                }
	                calcService.resume(true);
	                this.resumePaint();
	            }
	        },
	        recalcRange: function (row, col, rowCount, colCount) {
	            var calcService = getCalcService(this);
	            if (calcService) {
	                calcService.recalcRange(this._getSheetSource(), row, col, rowCount, colCount);
	            }
	        },
	        recalcRows: function (rows) {
	            var calcService = getCalcService(this);
	            if (calcService && !calcService.ignoreDirty()) {
	                calcService.suspend();
	                for (var i = 0; i < rows.length; i++) {
	                    calcService.recalculate(this._vpSheetSource, rows[i], -1);
	                }
	                calcService.resume(false);
	            }
	        },
	        _recalcCell: function (row, col) {
	            var calcService = getCalcService(this);
	            if (calcService && !calcService.ignoreDirty()) {
	                calcService.recalculate(this._vpSheetSource, row, col);
	            }
	        },
	        
	        getCalcService: function () {
	            if (!this._calcService) {
	                this._calcService = new CalcEngine.CalcService();
	                this._getSheetSource().setCalcService(this._calcService);
	                this._calcService.initParserContext(this._getSheetSource());
	            }
	            return this._calcService;
	        },
	        _getCalcServiceInternal: function () {
	            return this.getCalcService();
	        },
	       
	        
	        suspendCalcService: function (ignoreDirty) {
	            if (getCalcService(this)) {
	                getCalcService(this).suspend(ignoreDirty);
	            }
	        },
	       
	        
	        resumeCalcService: function (recalcAll) {
	            if (getCalcService(this)) {
	                getCalcService(this).resume(recalcAll);
	            }
	        },
	        _getSheetSource: function (sheetArea) {
	            if (isNullOrUndefined(sheetArea) || sheetArea === 3 ) {
	                return this._vpSheetSource;
	            }
	           
	            return keyword_null;
	        },
	        _getCalcModel: function () {
	            var self = this;
	            if (!self._vpCalcSheetModel && self._vpSheetSource) {
	                self._vpCalcSheetModel = self._getCalcServiceInternal().getSourceModel(self._vpSheetSource);
	            }
	            return self._vpCalcSheetModel;
	        },
	        _hasPartArrayFormulas: function (row, column, rowCount, columnCount) {
	            return this._getCalcModel() && this._getCalcModel()._getFormulaExps(row, column, rowCount, columnCount, true, true);
	        },
	        _getsArrayFormulas: function (row, column, rowCount, columnCount) {
	            return this._getCalcModel() && this._getCalcModel()._getFormulaExps(row, column, rowCount, columnCount, false, true);
	        },
	        _checkArrayFormula: function (row, column, rowCount, columnCount, onlyCheckIntersected) {
	            onlyCheckIntersected = onlyCheckIntersected === keyword_undefined ? true : onlyCheckIntersected;
	            if (exports._supportsCalc && onlyCheckIntersected && this._hasPartArrayFormulas(row, column, rowCount, columnCount) ||
	                !onlyCheckIntersected && _hasArrayFormula(this, row, column, rowCount, columnCount)) {
	                this._raiseInvalidOperation(4 , sR().Exp_ChangePartOfArray);
	                return false;
	            }
	            return true;
	        },
	       
	        
	        addCustomFunction: function (fn) {
	            this._addCustomFunctionCore(fn);
	            this.recalcAll();
	        },
	        _addCustomFunctionCore: function (fn) {
	            if (!fn || !(fn instanceof CalcEngine.Functions.Function)) {
	                throw new Error(sR().Exp_InvalidCustomFunction);
	            }
	            this._functions[toUpperCase(fn.name)] = fn;
	        },
	       
	        
	        getCustomFunction: function (fnName) {
	            return fnName ? this._functions[toUpperCase(fnName)] : keyword_null;
	        },
	       
	        
	        removeCustomFunction: function (fnName) {
	            if (fnName) {
	                delete this._functions[toUpperCase(fnName)];
	                this.recalcAll();
	            }
	        },
	       
	        
	        clearCustomFunctions: function () {
	            this._functions = {};
	            this.recalcAll();
	        },
	        _findCustomFunction: function (name) {
	            if (!name) {
	                return keyword_null;
	            }
	            var self = this, parent = self.parent;
	            var fn = self.getCustomFunction(name);
	            if (!fn && parent && parent.getCustomFunction) {
	                fn = parent.getCustomFunction(name);
	            }
	            return fn;
	        },
	
	       
	        
	        addCustomName: function (name, formula, baseRow, baseCol, comment) {
	            this._addCustomNameCore(name, formula, baseRow, baseCol, false, comment);
	        },
	       
	        
	        getCustomName: function (fnName) {
	            return fnName ? this._nameInfos[toUpperCase(fnName)] : keyword_undefined;
	        },
	       
	        
	        getCustomNames: function () {
	            var result = [];
	            $_each(this._nameInfos, function (p, v) {
	                result.push(v);
	            });
	            return result;
	        },
	       
	        
	        removeCustomName: function (fnName) {
	            if (fnName) {
	                var upperCaseName = toUpperCase(fnName);
	                delete this._nameInfos[upperCaseName];
	                var names = {};
	                names[upperCaseName] = upperCaseName;
	                this._updateCalc(names, false);
	            }
	        },
	       
	        
	        clearCustomNames: function () {
	            var self = this;
	            var names = self._nameInfos;
	            self._nameInfos = {};
	            this._updateCalc(names, false);
	        },
	        createNameInfo: function (name, formula, comment, baseRow, baseCol) {
	            var self = this;
	            var calcService = getCalcService(self);
	            var sheetSource = self._getSheetSource();
	            if (calcService && sheetSource) {
	                var expr = calcService.parse(sheetSource, formula, baseRow, baseCol);
	                return new NameInfo(name, expr, comment, baseRow, baseCol);
	            }
	
	            return keyword_null;
	        },
	        _isUniqueCustomName: function (name) {
	            var self = this;
	            var isValid = !self._nameInfos[toUpperCase(name)];
	            if (isValid) {
	                var tableManager = self.tables;
	                if (tableManager) {
	                    isValid = !tableManager.findByName(name);
	                }
	            }
	            return isValid;
	        },
	        isValidCustomName: function(name) {
	            return name && util_common._util._isValidCustomName(name) && this._isUniqueCustomName(name);
	        },
	        _addCustomNameCore: function (name, formula, baseRow, baseCol, ignoreError, comment) {
	            var self = this;
	            if (!name || !formula || (!ignoreError && !self.isValidCustomName(name))) {
	                throw new Error(sR().Exp_InvalidCustomName);
	            }
	            var calcService = getCalcService(self);
	            var sheetSource = self._getSheetSource();
	            if (calcService && sheetSource) {
	                var expr;
	                if (ignoreError) {
	                    try {
	                        expr = calcService.parse(sheetSource, formula, baseRow, baseCol, false, false, true);
	                    } catch (ex) {
	                    }
	                } else {
	                    expr = calcService.parse(sheetSource, formula, baseRow, baseCol);
	                }
	                self._nameInfos[toUpperCase(name)] = new NameInfo(name, expr, baseRow, baseCol, comment);
	                if (!ignoreError) {
	                    var names = {};
	                    names[name] = name;
	                    this._updateCalc(names, true);
	                }
	            }
	        },
	        _updateCalc: function (names, start) {    
	            var calcModel = this._getCalcModel();
	            if (calcModel) {
	                for (var name in names) { 
	                    calcModel.updateNameCalc(name, start);
	                }
	                this.recalcAll();
	            }
	        },
	        _findCustomName: function (name) {
	            if (!name) {
	                return keyword_null;
	            }
	            var self = this, parent = self.parent;
	            var cn = self.getCustomName(name);
	            if (!cn && parent && parent.getCustomName) {
	                cn = parent.getCustomName(name);
	            }
	            return cn;
	        },
	       
	        
	        setFormula: function (row, col, value) {
	            this._setFormulaCore(row, col, value, keyword_null, false);
	        },
	        _setFormulaCore: function (row, col, formula, expr, ignoreError, sheetArea, ignoreEvent) {
	            var self = this;
	            if (sheetArea === 1  || sheetArea === 2 ) {
	                return;
	            }
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	           
	            if (row < 0 || row >= self.getRowCount() || col < 0 || col >= self.getColumnCount()) {
	                self._raiseInvalidOperation(0 , sR().Exp_IndexOutOfRange);
	                return;
	            }
	            var fixedRow = row >= 0 ? row : 0;
	            var fixedCol = col >= 0 ? col : 0;
	            expr = expr || (formula && self._calcService ? self._calcService.parse(self._vpSheetSource, formula, fixedRow, fixedCol, false, ignoreError, ignoreError) : keyword_null);
	
	           
	            var tableManager = self.tables;
	            if (sheetArea === 3  && row >= 0 && col >= 0 && tableManager) {
	                var valid = tableManager._updataFooterFormulaWhenSetSheetFormula(row, col, 1, 1, formula, expr);
	                if (!valid) {
	                    return;
	                }
	            }
	
	            var calcModel = self._getCalcModel(), conditionalFormats = self.conditionalFormats;
	            if (calcModel) {
	                var oldValue = calcModel.getFormula(row, col);
	                var modelManager = self._modelManager;
	                calcModel.setFormula(row, col, formula, expr, ignoreError, keyword_undefined, modelManager._getChangesForCalcEngine());
	                if (conditionalFormats) {
	                    conditionalFormats._clearCache();
	                }
	                if (!ignoreEvent) {
	                    self._raiseCellChanged('formula', row, col, sheetArea, oldValue, formula);
	                }
	            }
	
	            self._updateTableSlicer && self._updateTableSlicer(row, col, 1, 1, sheetArea);
	            self._invalidate();
	        },
	       
	        
	        setArrayFormula: function (row, col, rowCount, colCount, value) {
	            this._setArrayFormulaCore(row, col, rowCount, colCount, value, false);
	        },
	        _setArrayFormulaCore: function (row, col, rowCount, colCount, value, ignoreError, sheetArea) {
	            var self = this;
	            if (sheetArea === 1  || sheetArea === 2 ) {
	                return;
	            }
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	           
	            if (row < 0 || row + rowCount > self.getRowCount() || col < 0 || col + colCount > self.getColumnCount()) {
	                self._raiseInvalidOperation(0 , sR().Exp_IndexOutOfRange);
	                return;
	            }
	            if (self._modelManager._hasSpans(row, col, rowCount, colCount)) {
	                self._raiseInvalidOperation(0 , sR().Exp_ArrayFromulaSpan);
	                return;
	            }
	           
	            var tableManager = self.tables;
	            if (sheetArea === 3  && row >= 0 && col >= 0 && tableManager) {
	                var valid = tableManager._updataFooterFormulaWhenSetSheetFormula(row, col, rowCount, colCount, value);
	                if (!valid) {
	                    return;
	                }
	            }
	
	            var calcModel = self._getCalcModel(), conditionalFormats = self.conditionalFormats;
	            if (calcModel) {
	                self.suspendEvent();
	                calcModel.setArrayFormula(row, col, rowCount, colCount, value, ignoreError, self._modelManager._getChangesForCalcEngine());
	                self.resumeEvent();
	                if (conditionalFormats) {
	                    conditionalFormats._clearCache();
	                }
	                if (self._eventSuspended < 1) {
	                    var changedCells = [];
	                    for (var r = row; r < row + rowCount; r++) {
	                        for (var c = col; c < col + colCount; c++) {
	                            changedCells.push({row: r, col: c});
	                        }
	                    }
	                    self._raiseRangeDataChanged(row, col, rowCount, colCount, changedCells, 5 , sheetArea, value);
	                }
	            }
	            self._invalidate();
	        },
	       
	        
	        getFormula: function (row, col, culture) {
	            var calcModel = this._getCalcModel();
	            if (calcModel) {
	                return calcModel.getFormula(row, col, culture);
	            }
	            return keyword_null;
	        },
	        _getExpression: function (row, col) {
	            var calcModel = this._getCalcModel();
	            if (calcModel) {
	                return calcModel._getExpr(row, col);
	            }
	            return keyword_null;
	        },
	       
	        
	        getFormulaInformation: function (row, col) {
	            var info = {};
	            var calcModule = this._getCalcModel();
	            if (calcModule) {
	                var expr = calcModule._getExpr(row, col);
	                if (expr) {
	                    var arrayInfo = calcModule._getArrayInfo(row, col);
	                    info.hasFormula = true;
	                    if (arrayInfo) {
	                        info.baseRange = new util_common.Range(arrayInfo.row, arrayInfo.col, arrayInfo.rowCount, arrayInfo.colCount);
	                    }
	                    info.isArrayFormula = !!arrayInfo;
	                    row = arrayInfo ? arrayInfo.row : row;
	                    col = arrayInfo ? arrayInfo.col : col;
	                    info.formula = this._calcService.unparse(this._vpSheetSource, expr, row, col);
	                    info.formulaWithCulture = this._calcService.unparse(this._vpSheetSource, expr, row, col, true);
	                    info.hasFormula = !!info.formula;
	                }
	            }
	            return info;
	        },
	        hasFormula: function (row, col) {
	            var calcModel = this._getCalcModel();
	            if (calcModel) {
	                return calcModel.hasFormula(row, col);
	            }
	            return false;
	        },
	        _findFormulas: function (row, column, rowCount, columnCount) { 
	
	        },
	        _rebuildCalcNodes: function () {
	            var calcModel = this._getCalcModel();
	            if (!calcModel) {
	                return;
	            }
	            var row = 0;
	            var rowCount = calcModel.rC();
	            var colCount = calcModel.cC();
	            while (row < rowCount) {
	                var col = 0;
	                while (col < colCount) {
	                    var cellCalc = calcModel._getCellCalc(row, col);
	                    if (cellCalc) {
	                        cellCalc._stopListening();
	                        cellCalc._startListening();
	                    }
	                    col++;
	                }
	                row++;
	            }
	        },
	        clearFormula: function (row, column, rowCount, columnCount, conditionFn) {
	            var self = this;
	            if (row < 0) {
	                row = 0;
	                rowCount = self.getRowCount();
	            }
	            if (column < 0) {
	                column = 0;
	                columnCount = self.getColumnCount();
	            }
	            for (var r = 0; r < rowCount; r++) {
	                if (conditionFn(self, r + row)) {
	                    for (var c = 0; c < columnCount; c++) {
	                        self.setFormula(r + row, c + column, keyword_null);
	                    }
	                }
	            }
	        },
	        nameFunctionsFromJSON: function (sheetSettings, noSchema) {
	            if (!sheetSettings) {
	                return;
	            }
	            var sheet = this;
	            var customFunctions = sheetSettings.customFunctions;
	            if (customFunctions) {
	                for (var func in customFunctions) {
	                    if (customFunctions.hasOwnProperty(func)) {
	                        var funcJsonData = customFunctions[func];
	                        var customFunctionClass = util_common.getTypeFromString(funcJsonData.typeName);
	                        if (customFunctionClass) {
	                            var customFunc = new customFunctionClass();
	                            customFunc.fromJSON(funcJsonData, noSchema);
	                            sheet._addCustomFunctionCore(customFunc);
	                        }
	                    }
	                }
	            }
	           
	            var sheetSettingsNames = sheetSettings.names;
	            if (sheetSettingsNames) {
	                for (var n = 0; n < sheetSettingsNames.length; n++) {
	                    var ni = sheetSettingsNames[n];
	                    sheet._addCustomNameCore(ni.name, ni.formula, ni.row, ni.col, true, ni.comment);
	                }
	                sheet._rebuildCalcNodes();
	            }
	        },
	        formulaFromJSON: function (sheetSettings, noSchema, deserializationOptions) {
	            if (!sheetSettings) {
	                return;
	            }
	            var sheet = this;
	            var sheetSettingsData = sheetSettings.data;
	            var ignoreFormula = deserializationOptions && deserializationOptions.ignoreFormula;
	            if (sheetSettingsData && !ignoreFormula) {
	               
	                var data = sheetSettingsData.dataTable;
	                if (data) {
	                    var dr, node;
	                    var rowCount = sheet.getRowCount();
	                    var colCount = sheet.getColumnCount();
	                    for (var r = 0; r < rowCount; r++) {
	                        dr = data[r];
	                        if (!dr) {
	                            continue;
	                        }
	                        for (var c = 0; c < colCount; c++) {
	                            node = dr[c];
	                            var formula = node && node.formula;
	                            if (formula) {
	                                var arrayInfo = node.arrayInfo;
	                                if (arrayInfo) {
	                                    sheet._setArrayFormulaCore(r, c, convertToInt(arrayInfo.rowCount, 10), convertToInt(arrayInfo.colCount, 10), formula, true);
	                                } else {
	                                    sheet._setFormulaCore(r, c, formula, keyword_null, true, keyword_null, true);
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            var Worksheet_features = Worksheet._features;
	           
	            if (Worksheet_features) {
	                $_each(Worksheet_features, function (n, f) {
	                    var temp = f.fromJsonAfterFormula;
	                    if (temp) {
	                        temp.call(sheet, sheetSettings, noSchema, deserializationOptions);
	                    }
	                });
	            }
	        },
	        _initCalc: function (service) {
	            var self = this, oldService = self._calcService;
	            if (oldService && !service) {
	                return;
	            }
	            self._calcService = service ? service : new CalcEngine.CalcService();
	            self._getSheetSource().setCalcService(self._calcService);
	            self._calcService.initParserContext(self._getSheetSource());
	            if (oldService) {
	                service.setSourceModel(self._getSheetSource(), oldService.getSourceModel(self._vpSheetSource));
	            } else {
	                self._vpCalcSheetModel = self._calcService.getSourceModel(self._vpSheetSource);
	            }
	        },
	        setCalc: function(service, source) {
	            this._calcService = service;
	            this._vpSheetSource = source;
	            this._vpCalcSheetModel = service.getSourceModel(source);
	            if(this.parent) {
	                this.parent._calcService = service;
	            }
	        },
	        _commitArrayFormula: function () {
	            this._endEditImp(false, 1 );
	        },
	        _doCalcLayoutChange: function (args) {
	            var self = this, changeType = args.changeType, 
	                row = args.row, rowCount = args.rowCount, col = args.col, colCount = args.colCount;
	            var calcModel = self._getCalcModel();
	            if (calcModel) {
	                var calcChanges = self._modelManager._getChangesForCalcEngine();
	                var service = getCalcService(calcModel), source = calcModel._source,
	                    operatorAdjustor = service._getOperatorAdjustor(), asyncManager = service._evaluator.asyncManager;
	                if (changeType === 'addingRows') {
	                    if (!self._checkArrayFormula(row, 0, 0, self.getColumnCount())) {
	                        args.canAdd = false;
	                    } else {
	                        operatorAdjustor.onBeforeAddRemoveRows(calcModel, row);
	                        Worksheet.adjustCustomNameOnInsertRemove(self, row, rowCount, true, true);
	                        calcModel.addRows(row, rowCount);
	                        asyncManager.addRows(source, row, rowCount);
	                    }
	                } else if (changeType === 'addRows') {
	                    if (calcChanges) {
	                        calcChanges.push({ type: 'addRows', row: row, rowCount: rowCount });
	                    }
	                    service.suspend();
	                    operatorAdjustor.onAfterAddRemoveRows(calcModel, row, rowCount, true);
	                    service.resume(false);
	                } else if (changeType === 'deletingRows') {
	                    if (!self._checkArrayFormula(row, 0, rowCount, self.getColumnCount())) {
	                        args.canDelete = false;
	                    } else {
	                        operatorAdjustor.onBeforeAddRemoveRows(calcModel, row);
	                        Worksheet.adjustCustomNameOnInsertRemove(self, row, rowCount, false, true);
	                        calcModel.deleteRows(row, rowCount);
	                        asyncManager.deleteRows(source, row, rowCount);
	                    }
	                } else if (changeType === 'deleteRows') {
	                    if (calcChanges) {
	                        calcChanges.push({ type: 'deleteRows', row: row, rowCount: rowCount });
	                    }
	                    service.suspend();
	                    operatorAdjustor.onAfterAddRemoveRows(calcModel, row, rowCount, false);
	                    service.resume(false);
	                } else if (changeType === 'addingColumns') {
	                    if (!self._checkArrayFormula(0, col, self.getRowCount(), 0)) {
	                        args.canAdd = false;
	                    } else {
	                        operatorAdjustor.onBeforeAddRemoveColumns(calcModel, col);
	                        Worksheet.adjustCustomNameOnInsertRemove(self, col, colCount, true, false);
	                        calcModel.addColumns(col, colCount);
	                        asyncManager.addColumns(source, row, rowCount);
	                    }
	                } else if (changeType === 'addColumns') {
	                    if (calcChanges) {
	                        calcChanges.push({ type: 'addColumns', col: col, colCount: colCount });
	                    }
	                    service.suspend();
	                    operatorAdjustor.onAfterAddRemoveColumns(calcModel, col, colCount, true);
	                    service.resume(false);
	                } else if (changeType === 'deletingColumns') {
	                    if (!self._checkArrayFormula(0, col, self.getRowCount(), colCount)) {
	                        args.canDelete = false;
	                    } else {
	                        operatorAdjustor.onBeforeAddRemoveColumns(calcModel, col);
	                        Worksheet.adjustCustomNameOnInsertRemove(self, col, colCount, false, false);
	                        calcModel.deleteColumns(col, colCount);
	                        asyncManager.deleteColumns(source, row, rowCount);
	                    }
	                } else if (changeType === 'deleteColumns') {
	                    if (calcChanges) {
	                        calcChanges.push({ type: 'deleteColumns', col: col, colCount: colCount });
	                    }
	                    service.suspend();
	                    operatorAdjustor.onAfterAddRemoveColumns(calcModel, col, colCount, false);
	                    service.resume(false);
	                }
	            }
	        },
	        _undoCalcAction: function (calcService, calcModel, change) {
	            var type = change.type, _this = this;
	           
	            if (type === 'addRows') {
	                change.changeType = 'deletingRows';
	                _this._doCalcLayoutChange(change);
	                change.changeType = 'deleteRows';
	                _this._doCalcLayoutChange(change);
	            } else if (type === 'deleteRows') {
	                change.changeType = 'addingRows';
	                _this._doCalcLayoutChange(change);
	                change.changeType = 'addRows';
	                _this._doCalcLayoutChange(change);
	            } else if (type === 'addColumns') {
	                change.changeType = 'deletingColumns';
	                _this._doCalcLayoutChange(change);
	                change.changeType = 'deleteColumns';
	                _this._doCalcLayoutChange(change);
	            } else if (type === 'deleteColumns') {
	                change.changeType = 'addingColumns';
	                _this._doCalcLayoutChange(change);
	                change.changeType = 'addColumns';
	                _this._doCalcLayoutChange(change);
	            }
	        },
	        _undoCalcChange: function (calcChanges) {
	            var calcService = getCalcService(this), calcModel = this._getCalcModel();
	            var item;
	            calcService.suspend();
	            while(calcChanges.length) {
	                item = calcChanges.pop();
	                if (item.type) {
	                    this._undoCalcAction(calcService, calcModel, item);
	                } else {
	                    calcModel._restoreNodeItem.apply(calcModel, item);
	                }
	            }
	            calcService.resume(false);
	        }
	
	       
	
	    };
	
	    $.extend(Worksheet.prototype, sheetEx);
	
	    Worksheet.adjustCustomNameOnInsertRemove = function (src, index, count, isInsert, isRow) {
	        var sheetNames, self = this;
	        var oldExpr, newExpr;
	        if (!src.parent || !src.parent.sheets) {
	            sheetNames = src.getCustomNames();
	            if (sheetNames) {
	                $_each(sheetNames, function (i, ne) {
	                    oldExpr = ne.getExpression();
	                    newExpr = self.adjustCustomNameExpOnInsertRemove(src, src, index, count, isInsert, isRow, oldExpr);
	                    if (newExpr !== oldExpr) {
	                        ne._setExpression(newExpr);
	                    }
	                });
	            }
	            return;
	        }
	        var sheets = src.parent.sheets, workbookCustomNames = src.parent.getCustomNames();
	        if (workbookCustomNames) {
	            $_each(workbookCustomNames, function (i, ne) {
	                oldExpr = ne.getExpression();
	                newExpr = self.adjustCustomNameExpOnInsertRemove(null, src, index, count, isInsert, isRow, oldExpr);
	                if (newExpr !== oldExpr) {
	                    ne._setExpression(newExpr);
	                }
	            });
	        }
	        for (var sheetIndex = 0; sheetIndex < sheets.length; sheetIndex++) {
	            sheetNames = sheets[sheetIndex].getCustomNames();
	            if (sheetNames) {
	                $_each(sheetNames, function (i, ne) { 
	                    oldExpr = ne.getExpression();
	                    newExpr = self.adjustCustomNameExpOnInsertRemove(sheets[sheetIndex], src, index, count, isInsert, isRow, oldExpr);
	                    if (newExpr !== oldExpr) {
	                        ne._setExpression(newExpr);
	                    }
	                });
	            }
	        }
	    };
	    Worksheet.adjustCustomNameExpOnInsertRemove = function (owner, src, index, count, isInsert, isRow, expr) {
	        var srcSource = src._getSheetSource(),
	            refError = CalcEngine._createErrorExpression(CalcEngine.Errors.Reference, srcSource);
	        if (expr.type === 9 ) {
	            var left = expr.value, right = expr.value2;
	            var newLeft = this.adjustCustomNameExpOnInsertRemove(owner, src, index, count, isInsert, isRow, left);
	            var newRight = right && this.adjustCustomNameExpOnInsertRemove(owner, src, index, count, isInsert, isRow, right);
	            if (left !== newLeft || right !== newRight) {
	                return CalcEngine._createOperatorExpression(expr.operatorType, newLeft, newRight);
	            }
	        } else if (expr.type === 7 ) {
	            var hasChange = false, newArgs = [], arg;
	            for (var argIndex = 0; argIndex < expr.arguments.length; argIndex++) {
	                arg = expr.arguments[argIndex];
	                var newArg = this.adjustCustomNameExpOnInsertRemove(owner, src, index, count, isInsert, isRow, arg);
	                hasChange = hasChange || arg !== newArg;
	                newArgs.push(newArg);
	            }
	            if (hasChange) {
	                return CalcEngine._createFunctionExpression(expr, newArgs);
	            }
	        } else if (expr.type === 1  && expr._isCell()) {
	            var source = expr.source || owner && owner._getSheetSource();
	            var row = expr.row, col = expr.column, oldRow = row, oldCol = col;
	            if (source && source === srcSource && (isRow && !expr.rowRelative || !isRow && !expr.columnRelative)) {
	                if (isRow && isInsert) {
	                    row += row >= index ? count : 0;
	                } else if (!isRow && isInsert) {
	                    col += col >= index ? count : 0;
	                } else if (isRow) {
	                    if (row >= index + count) {
	                        row -= count;
	                    } else if (row >= index) {
	                        return refError;
	                    }
	                } else if (col >= index + count) {
	                    col -= count;
	                } else if (col >= index) {
	                    return refError;
	                }
	                if (row !== oldRow || col !== oldCol) {
	                    return CalcEngine._createCellExpression(srcSource, keyword_null, row, col, expr.rowRelative, expr.columnRelative);
	                }
	            }
	        } else if (expr.type === 1 ) {
	            source = expr.source || owner && owner._getSheetSource();
	            var startRow = expr.row, startColumn = expr.column, endRow = expr.endRow, endColumn = expr.endColumn,
	                startRowRelative = expr.rowRelative, startColumnRelative = expr.columnRelative,
	                endRowRelative = expr.endRowRelative, endColumnRelative = expr.endColumnRelative,
	                oldStartRow = startRow, oldColumn = startColumn, oldEndRow = endRow, oldEndColumn = endColumn;
	            if (source && source === srcSource) {
	                if (isRow && isInsert) {
	                    startRow += !startRowRelative && startRow >= index ? count : 0;
	                    endRow += !endRowRelative && endRow >= index ? count : 0;
	                } else if (!isRow && isInsert) {
	                    startColumn += !startColumnRelative && startColumn >= index ? count : 0;
	                    endColumn += !endColumnRelative && endColumn >= index ? count : 0;
	                } else if (isRow && !isInsert) { 
	                    if (!startRowRelative && startRow >= index && !endRowRelative && endRow < index + count) {
	                        return refError;
	                    }
	                    if (startRowRelative && endRowRelative || endRow < index) {
	                        return expr;
	                    }
	                    if (!startRowRelative) {
	                        if (startRow >= index + count) {
	                            startRow -= count;
	                        } else if (startRow < index) {
	                        } else if (endRowRelative) {
	                            return refError;
	                        } else if (startRow > index) {
	                            startRow = index;
	                        }
	                    }
	                    if (!endRowRelative) {
	                        if (endRow >= index + count) {
	                            endRow -= count;
	                        } else if (startRowRelative) {
	                            return refError;
	                        } else if (endRow < index + count) {
	                            endRow = index - 1;
	                        }
	                    }
	                } else {
	                    if (!startColumnRelative && startColumn >= index && !endColumnRelative && endColumn < index + count) {
	                        return refError;
	                    }
	                    if (startColumnRelative && endColumnRelative || endColumn < index) {
	                        return expr;
	                    }
	                    if (!startColumnRelative) {
	                        if (startColumn >= index + count) {
	                            startColumn -= count;
	                        } else if (startColumn < index) {
	                        } else if (endColumnRelative) {
	                            return refError;
	                        } else if (startColumn > index) {
	                            startColumn = index;
	                        }
	                    }
	                    if (!endColumnRelative) {
	                        if (endColumn >= index + count) {
	                            endColumn -= count;
	                        } else if (startColumnRelative) {
	                            return refError;
	                        } else if (endColumn < index + count) {
	                            endColumn = index - 1;
	                        }
	                    }
	                }
	                if (startColumn !== oldColumn || endColumn !== oldEndColumn || startRow !== oldStartRow || endRow !== oldEndRow) {
	                    return CalcEngine._createRangeExpression(srcSource, keyword_null, startRow, startColumn, endRow, endColumn, startRowRelative, startColumnRelative, endRowRelative, endColumnRelative);
	                }
	            }
	        } else if (expr.type === 10 ) {
	            var argExp = expr.value,
	                newExp = this.adjustCustomNameExpOnInsertRemove(owner, src, index, count, isInsert, isRow, argExp);
	            if (argExp !== newExp) {
	                return CalcEngine._createParenthesesExpression(newExp);
	            }
	        }
	        return expr;
	    };
	
	    function adjustOneFormula(service, calcInfo) {
	        var calcModel = calcInfo._sourceModel;
	        var source = calcModel.getSource();
	        var depNode, name;
	        var row = -1, col = -1;
	        var hasID, id;
	        if (calcInfo.name) {
	            name = calcInfo.name;
	            id = calcInfo.id;
	            if (isNullOrUndefined(id)) {
	                depNode = calcModel.getNodeByName(name);
	            } else {
	               
	                depNode = { _expr: calcInfo.expression };
	                hasID = true;
	            }
	        } else {
	            row = calcInfo.row;
	            col = calcInfo.column;
	            row = row === undefined ? -1 : row;
	            col = col === undefined ? -1 : col;
	            depNode = calcModel.getNode(row, col);
	        }
	        var expr = depNode._expr;
	        var arrayInfo = depNode._arrayInfo;
	        var formula = service.unparse(source, expr, row < 0 ? 0 : row, col < 0 ? 0 : col);
	        if (arrayInfo) {
	            calcModel.setArrayFormula(arrayInfo.row, arrayInfo.col, arrayInfo.rowCount, arrayInfo.colCount, formula);
	        } else if (name) {
	            if (hasID) {
	               
	                calcModel.setFormula(id, name, formula);
	            } else {
	                calcModel.setFormulaByName(name, formula);
	            }
	        } else {
	            calcModel.setFormula(row, col, formula, null, true, true);
	        }
	    }
	
	   
	    Worksheet.adjustModelFormulasAfterSetSheetName = function (sheet) {
	        var service = getCalcService(sheet), sourceModel = service.getSourceModel(sheet._getSheetSource());
	        if (!sourceModel) {
	            return;
	        }
	        var nodes = sourceModel.getAllNodes();
	        for (var i = 0; i < nodes.length; i++) {
	            var node = nodes[i];
	            var calc = node.calc;
	            if (calc) {
	                if (node._expr) {
	                    adjustOneFormula(service, calc);
	                }
	                var listeners = calc._listeners, dep;
	                for (var lIndex = 0; lIndex < listeners.length; lIndex++) {
	                    var cls = calc[listeners[lIndex]];
	                    if (cls) {
	                        for (var key in cls) { 
	                            dep = cls[key];
	                            if (dep && dep._sourceModel !== sourceModel) {
	                                adjustOneFormula(service, dep);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    };
	
	    Worksheet.copyFormula = function (src, srcRow, srcColumn, dest, destRow, destColumn, rowCount, columnCount, ignoreFilteredOutRow) {
	        CalcEngine && CalcEngine.CalcOperatorAdjustor.copyFormula(src._getCalcModel(), srcRow, srcColumn, dest._getCalcModel(), destRow, destColumn, rowCount, columnCount, ignoreFilteredOutRow);
	    };
	    Worksheet.moveFormula = function (src, fromRow, fromColumn, dest, toRow, toColumn, rowCount, columnCount) {
	        CalcEngine && CalcEngine.CalcOperatorAdjustor.moveFormula(src, fromRow, fromColumn, dest, toRow, toColumn, rowCount, columnCount);
	    };
	    Worksheet.adjustCustomNameOnMove = function (src, srcRow, srcColumn, dest, destRow, destColumn, moveRowCount, moveColumnCount) {
	        var sheetNames;
	        var oldExpr, newExpr;
	        if (!src.parent || !src.parent.sheets) {
	            sheetNames = src.getCustomNames();
	            if (sheetNames) {
	                $_each(sheetNames, function (i, ne) {
	                    oldExpr = ne.getExpression();
	                    newExpr = adjustCustomNameExpOnMove(src, src, srcRow, srcColumn, dest, destRow, destColumn, moveRowCount, moveColumnCount, oldExpr);
	                    if (newExpr !== oldExpr) {
	                        ne._setExpression(newExpr);
	                    }
	                });
	            }
	            return;
	        }
	
	        var sheets = src.parent.sheets, workbook = src.parent.getCustomNames();
	        if (workbook) {
	            $_each(workbook, function (i, ne) {
	                oldExpr = ne.getExpression();
	                newExpr = adjustCustomNameExpOnMove(null, src, srcRow, srcColumn, dest, destRow, destColumn, moveRowCount, moveColumnCount, oldExpr);
	                if (newExpr !== oldExpr) {
	                    ne._setExpression(newExpr);
	                }
	            });
	        }
	        for (var sheetIndex = 0; sheetIndex < sheets.length; sheetIndex++) {
	            sheetNames = sheets[sheetIndex].getCustomNames();
	            if (sheetNames) {
	                $_each(sheetNames, function (i, ne) { 
	                    oldExpr = ne.getExpression();
	                    newExpr = adjustCustomNameExpOnMove(sheets[sheetIndex], src, srcRow, srcColumn, dest, destRow, destColumn, moveRowCount, moveColumnCount, oldExpr);
	                    if (newExpr !== oldExpr) {
	                        ne._setExpression(newExpr);
	                    }
	                });
	            }
	        }
	    };
	    function adjustCustomNameExpOnMove(owner, src, srcRow, srcColumn, dest, destRow, destColumn, moveRowCount, moveColumnCount, expr) {
	        var offsetRow = destRow - srcRow, offsetColumn = destColumn - srcColumn, srcSource = src._getSheetSource(),
	            destSource = dest._getSheetSource();
	        if (expr.type === 9 ) {
	            var left = expr.value, right = expr.value2;
	            var newLeft = adjustCustomNameExpOnMove(owner, src, srcRow, srcColumn, dest, destRow, destColumn, moveRowCount, moveColumnCount, left);
	            var newRight = right && adjustCustomNameExpOnMove(owner, src, srcRow, srcColumn, dest, destRow, destColumn, moveRowCount, moveColumnCount, right);
	            if (left !== newLeft || right !== newRight) {
	                return CalcEngine._createOperatorExpression(expr.operatorType, newLeft, newRight);
	            }
	        } else if (expr.type === 7 ) {
	            var hasChange = false, newArgs = [], arg;
	            for (var argIndex = 0; argIndex < expr.arguments.length; argIndex++) {
	                arg = expr.arguments[argIndex];
	                var newArg = adjustCustomNameExpOnMove(owner, src, srcRow, srcColumn, dest, destRow, destColumn, moveRowCount, moveColumnCount, arg);
	                hasChange = hasChange || arg !== newArg;
	                newArgs.push(newArg);
	            }
	            if (hasChange) {
	                return CalcEngine._createFunctionExpression(expr, newArgs);
	            }
	        } else if (expr.type === 1  && expr._isCell()) {
	            if ((!expr.source || expr.source === srcSource) && !expr.rowRelative && expr.row >= srcRow && expr.row < srcRow + moveRowCount
	                && !expr.columnRelative && expr.column >= srcColumn && expr.column < srcColumn + moveColumnCount) {
	                return CalcEngine._createCellExpression(destSource, keyword_null, expr.row + offsetRow, expr.column + offsetColumn);
	            }
	        } else if (expr.type === 1 ) {
	            var startCellAbsolute = !getStartRowRelative(expr) && !getStartColumnRelative(expr),
	                endCellAbsolute = !getEndRowRelative(expr) && !getEndColumnRelative(expr);
	            if ((!expr.source || expr.source === srcSource) && (startCellAbsolute && expr.row >= srcRow && getStartColumn(expr) >= srcColumn
	                || endCellAbsolute && expr.endColumn < srcColumn + moveColumnCount && expr.endRow < srcRow + moveRowCount)) {
	                return CalcEngine._createRangeExpression(destSource, keyword_null, expr.row + (startCellAbsolute ? offsetRow : 0), getStartColumn(expr) + (startCellAbsolute ? offsetColumn : 0), expr.endRow + (endCellAbsolute ? offsetRow : 0), expr.endColumn + (endCellAbsolute ? offsetColumn : 0), getStartRowRelative(expr), getStartColumnRelative(expr), getEndRowRelative(expr), getEndColumnRelative(expr));
	            }
	        } else if (expr.type === 10 ) {
	            var argExp = expr.value,
	                newExp = adjustCustomNameExpOnMove(owner, src, srcRow, srcColumn, dest, destRow, destColumn, moveRowCount, moveColumnCount, argExp);
	            if (argExp !== newExp) {
	                return CalcEngine._createParenthesesExpression(newExp);
	            }
	        }
	        return expr;
	    }
	
	   
	    Worksheet._registerFeature('calc', {
	        priority: 1000,
	        init: init,
	        dispose: function (clearCache) {
	            if (clearCache !== false) {
	                this._vpSheetSource = keyword_null;
	                this._calcService = keyword_null;
	            }
	        },
	        attach: function (parent) {
	            var self = this;
	            var Workbook = __webpack_require__(22).Workbook;
	            if (parent instanceof Workbook) {
	                self._initCalc(parent._calcService);
	            } else {
	                self._initCalc();
	            }
	        },
	        onLayoutChanged: function (args) {
	            if (exports._supportsCalc && !this._getCalcServiceInternal().isAdjustSuspended()) {
	                this._doCalcLayoutChange(args);
	            }
	        },
	        toJson: function (data, serializationOption) {
	            var sheet = this;
	           
	            var functions = sheet._functions;
	            if (!$.isEmptyObject(functions)) {
	                data.customFunctions = functions;
	            }
	           
	            var names = [], sheetNames = sheet.getCustomNames(), calcService = getCalcService(sheet);
	            if (sheetNames && calcService) {
	                $_each(sheetNames, function (i, ni) {
	                    var name = ni.getName(), row = ni.getRow(), col = ni.getColumn(), expr = ni.getExpression(),
	                        comment = ni.getComment();
	                    var f = calcService.unparse(sheet._getSheetSource(), expr, row, col, false, true);
	                    var nameProperty = {name: name, formula: f, row: row, col: col};
	                    if(comment) {
	                        nameProperty.comment = comment;
	                    }
	                    names.push(nameProperty);
	                });
	                if (names.length > 0) {
	                    data['names'] = names;
	                }
	            }
	           
	            var ignoreFormula = serializationOption && serializationOption.ignoreFormula;
	            var clacModel = sheet._vpCalcSheetModel;
	            if (clacModel && !ignoreFormula) {
	                clacModel.toJSON(data);
	            }
	        },
	        fromJson: function (sheetSettings, noSchema, deserializationOptions, setFormulaDirectly) {
	            var sheet = this;
	            sheet.clearCustomFunctions();
	            sheet.clearCustomNames();
	            if (setFormulaDirectly) {
	                sheet.nameFunctionsFromJSON(sheetSettings, noSchema, deserializationOptions);
	                sheet.formulaFromJSON(sheetSettings, noSchema, deserializationOptions);
	            }
	        },
	        setName: function (options) {
	            Worksheet.adjustModelFormulasAfterSetSheetName(this);
	            var calcModel = this._getCalcModel();
	            var service = getCalcService(calcModel),
	                asyncManager = service._evaluator.asyncManager;
	            asyncManager.changeSourceName(options.oldName, options.newName);
	        },
	        beforeSetName: function () {
	           this._validations && (this.parent || this)._getValidatorsWithFormula();
	        }
	    });
	
	   
	    
	    module.exports = exports;
	
	}());

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var exports = __webpack_require__(1);
	
	    var Common = __webpack_require__(5);
	    var Commands = __webpack_require__(23);
	    var $$ = __webpack_require__(4).GC$;
	    var util_common = __webpack_require__(3);
	    var _ImageLoader = __webpack_require__(9)._ImageLoader;
	    var Sheets_Commands = __webpack_require__(24).Commands;
	    var Scrollbar = __webpack_require__(26)._Scrollbar;
	    var _SheetTab = __webpack_require__(27)._SheetTab;
	    var _SheetTab2007 = __webpack_require__(29)._SheetTab2007;
	    var StyleHelper = __webpack_require__(11)._StyleHelper;
	    var _ClipboardHelper = __webpack_require__(15)._ClipboardHelper;
	
	    var UndoManager = Commands.UndoManager;
	    var CommandManager = Commands.CommandManager;
	    var $$_each = $$.each, $$_extend = $$.extend;
	    var util_common_util = util_common._util;
	    var hasCalc = exports._supportsCalc;
	    var _DPIHelper = util_common._DPIHelper;
	    var Events = util_common.Events;
	    var _FocusHelper = util_common._FocusHelper;
	    var Rect = util_common.Rect;
	    var _ThemeStyleHelper = util_common._ThemeStyleHelper;
	    var isNullOrUndefined = Common._Types._isNullOrUndefined;
	    var createElement = util_common._util._createElement;
	    var defProperty = util_common._util._defProperty;
	    var createOptions = util_common_util._createOptions;
	    var adjustFontWithFallback = util_common_util._adjustFontWithFallback;
	
	    var $ = window.jQuery;
	    var convertToInt = parseInt;
	    var WINDOW = window, DOCUMENT = document, keyword_null = null, Math_round = Math.round, Math_min = Math.min, Math_abs = Math.abs,
	        CONST_NUMBER = 'number',
	        E_MOUSEDOWN = 'mousedown', E_MOUSEUP = 'mouseup', E_SCROLL = 'scroll', E_RESIZE = 'resize', E_FOCUS = 'focus',
	        NS_SPREAD = '.gcSpread', NS_SPREADINTERNAL = '.gcSpreadInternal', NS_SCROLLBAR = '.gcScrollbar',
	        TAG_DIV = 'div', TAG_TABLE = 'table', PIXEL = 'px', CSS_SCROLL_HANDLE = 'gc-scroll-handle',
	        CSS_SCROLLBAR = 'gc-scroll-bar', CSS_NONE = 'none',
	        CSS_ABSOLUTE = 'absolute', CSS_CONTENT_BOX = 'content-box', CSS_SOLID = 'solid',
	        SCROLLBAR_PART_CLASS = ' ui-widget-header ui-state-default btn btn-default';
	    var CULTURE_CHANGED_EVENT = 'cultureChanged', STORE_KEY = 'workbook', GC_UIELEMENT = 'gcUIElement',
	        NO_USER_SELECT = 'gc-no-user-select', VISIBLE = 'visible', OVERFLOW = 'overflow';
	
	    function sR() {
	        return Common._getResource(exports.SR)();
	    }
	
	    function getActiveSheet(workbook) {
	        return workbook.getActiveSheet();
	    }
	
	    function triggerActiveSheetChanged(spread, oldSheet, newSheet) {
	        spread._trigger(Events.ActiveSheetChanged, {
	            oldSheet: oldSheet,
	            newSheet: newSheet
	        });
	    }
	
	    function triggerActiveSheetChanging(spread, data) {
	        spread._trigger(Events.ActiveSheetChanging, data);
	    }
	
	    function triggerFormulatexgboxActiveSheetChanging(spread, data) {
	        spread._trigger(Events.FormulatextboxActiveSheetChanging, data);
	    }
	
	    function triggerFormulatextboxActiveSheetChanged(spread, oldSheet, newSheet) {
	        spread._trigger(Events.FormulatextboxActiveSheetChanged, {
	            oldSheet: oldSheet,
	            newSheet: newSheet
	        });
	    }
	
	   
	   
	   
	   
	   
	   
	
	   
	    
	    exports.HorizontalPosition = {
	        
	        left: 0,
	        
	        center: 1,
	        
	        right: 2,
	        
	        nearest: 3
	    };
	
	   
	    
	    exports.VerticalPosition = {
	        
	        top: 0,
	        
	        center: 1,
	        
	        bottom: 2,
	        
	        nearest: 3
	    };
	
	   
	    
	    exports.ShowResizeTip = {
	        
	        none: 0,
	        
	        column: 1,
	        
	        row: 2,
	        
	        both: 3
	    };
	
	   
	    
	    exports.ShowScrollTip = {
	        
	        none: 0,
	        
	        horizontal: 1,
	        
	        vertical: 2,
	        
	        both: 3
	    };
	
	   
	    
	    exports.AutoFitType = {
	        
	        cell: 0,
	        
	        cellWithHeader: 1
	    };
	
	   
	    
	    exports.InvalidOperationType = {
	        
	        setFormula: 0,
	        
	        copyPaste: 1,
	        
	        dragFill: 2,
	        
	        dragDrop: 3,
	        
	        changePartOfArrayFormula: 4,
	        
	        changeSheetName: 5
	    };
	
	   
	    
	    exports.ResizeZeroIndicator = {
	        
	        default: 0,
	        
	        enhanced: 1
	    };
	
	   
	    
	    exports.CopyPasteHeaderOptions = {
	        
	        noHeaders: 0,
	        
	        rowHeaders: 1,
	        
	        columnHeaders: 2,
	        
	        allHeaders: 3
	    };
	
	   
	    var defaultOptions = {
	        allowUserDragDrop: true,
	        allowUserDragFill: true,
	        allowUserZoom: true,
	        allowUserResize: true,
	        allowUndo: true,
	        allowSheetReorder: true,
	        allowContextMenu: true,
	        allowUserDeselect: true,
	        defaultDragFillType: 5 ,
	        showDragFillSmartTag: true,
	        showHorizontalScrollbar: true,
	        showVerticalScrollbar: true,
	        scrollbarShowMax: true,
	        scrollbarMaxAlign: false,
	        tabStripVisible: true,
	        tabStripRatio: 0.5,
	        tabEditable: true,
	        newTabVisible: true,
	        cutCopyIndicatorVisible: true,
	        cutCopyIndicatorBorderColor: '#217346',
	        tabNavigationVisible: true,
	        backColor: 'white',
	        backgroundImage: keyword_null,
	        backgroundImageLayout: 0 ,
	        showResizeTip: 0 ,
	        showDragDropTip: true,
	        showDragFillTip: true,
	        scrollIgnoreHidden: false,
	        highlightInvalidData: false,
	        showScrollTip: 0,
	        grayAreaBackColor: keyword_null,
	        useTouchLayout: false,
	        hideSelection: false,
	        resizeZeroIndicator: 1 ,
	        allowUserEditFormula: true,
	        enableFormulaTextbox: true,
	        referenceStyle: 0 ,
	        autoFitType: 0 ,
	        allowCopyPasteExcelStyle: true,
	        allowExtendPasteRange: false,
	        copyPasteHeaderOptions: 3 ,
	        allowUserDragMerge: false,
	
	        font: keyword_null
	    };
	
	    function refreshVScrollContainer(container, vScrollbarContainerWidth, scrollbarSize) {
	        var themeStyle = _ThemeStyleHelper._getCssClassThemeStyle('gc-vertical-scrollbar' + SCROLLBAR_PART_CLASS);
	        var paddingRight, paddingLeft, borderWidth = convertToInt(themeStyle.zIndex) > 2007  ? 1 : 0;
	        var width = vScrollbarContainerWidth - scrollbarSize;
	        if (width % 2 === 0) {
	            paddingRight = width / 2;
	            paddingLeft = paddingRight - borderWidth;
	        } else {
	            paddingRight = (width - borderWidth) / 2;
	            paddingLeft = paddingRight;
	        }
	        $$(container).css({
	            'box-sizing': CSS_CONTENT_BOX,
	            'border': CSS_NONE,
	            'border-color': CSS_NONE,
	            'border-left-style': CSS_SOLID,
	            'border-left-width': borderWidth + PIXEL,
	            'border-left-color': themeStyle.borderLeftColor,
	            'background-color': themeStyle.backgroundColor,
	            'width': scrollbarSize,
	            'padding': '0px ' + paddingRight + 'px 0px ' + paddingLeft + PIXEL,
	            'margin': 0
	        });
	    }
	
	    function refreshHScrollContainer(container, tabStripHeight, scrollbarSize) {
	        var themeStyle = _ThemeStyleHelper._getCssClassThemeStyle('gc-horizontal-scrollbar' + SCROLLBAR_PART_CLASS);
	        var paddingBottom, paddingTop, borderWidth = convertToInt(themeStyle.zIndex) > 2007  ? 1 : 0;
	        var height = tabStripHeight - scrollbarSize;
	        if (height % 2 === 0) {
	            paddingBottom = height / 2;
	            paddingTop = paddingBottom - borderWidth;
	        } else {
	            paddingBottom = (height - borderWidth) / 2;
	            paddingTop = paddingBottom;
	        }
	        $$(container).css({
	            'box-sizing': CSS_CONTENT_BOX,
	            'border': CSS_NONE,
	            'border-color': CSS_NONE,
	            'border-top-style': CSS_SOLID,
	            'border-top-width': borderWidth + PIXEL,
	            'border-top-color': themeStyle.borderTopColor,
	            'background-color': themeStyle.backgroundColor,
	            'height': scrollbarSize,
	            'padding': paddingTop + 'px 0px ' + paddingBottom + 'px 0px',
	            'margin': 0
	        });
	    }
	
	    function refreshFooterCorner(container, width, height) {
	        var themeStyle = _ThemeStyleHelper._getCssClassThemeStyle('gc-footer-corner' + SCROLLBAR_PART_CLASS);
	        $$(container).css({
	            'border': CSS_NONE,
	            'padding': 0,
	            'margin': 0,
	            'width': width + PIXEL,
	            'height': height + PIXEL,
	            'background-color': themeStyle.backgroundColor
	        });
	    }
	
	   
	    
	   
	    
	   
	    
	
	   
	    
	    function Workbook(host, options) {
	        var self = this;
	        self.name = '';
	       
	        self._isResizing = false;
	        self._availableSheetIndex = -1;
	        self._activeSheetIndex = 0;
	        self._suspendSetFocus = false;
	
	        self.options = createOptions(defaultOptions, function (pn, value, old) {
	            self._onOptionChanged(pn, value, old);
	        });
	        self._initOptions(options);
	
	        var sheetCount = 1;
	        if (options) {
	            var options_sheetCount = options.sheetCount;
	            if (typeof options_sheetCount === CONST_NUMBER) {
	                sheetCount = options_sheetCount;
	            }
	        }
	        self._host = host;
	        self._init(sheetCount, host);
	    }
	
	    util_common._defineFeature(Workbook);
	    Workbook._defaultOptions = defaultOptions;
	    Workbook._defaultSheetCount = 1;
	    Workbook._defaultActiveSheetIndex = 0;
	    Workbook.prototype = {
	        constructor: Workbook,
	
	       
	        
	        commandManager: function () {
	            return this._commandManager;
	        },
	       
	        
	        undoManager: function () {
	            return this._undoManager;
	        },
	
	        _onOptionChanged: function (pn, value, old) { 
	            var self = this;
	            var sheet = getActiveSheet(self);
	            switch (pn) {
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	                case 'allowUndo':
	                    if (self._undoManager) {
	                        self._undoManager._allowUndo = value;
	                    }
	                    break;
	                case 'backColor':
	                case 'cutCopyIndicatorBorderColor':
	                case 'cutCopyIndicatorVisible':
	                case 'grayAreaBackColor':
	                case 'hideSelection':
	                case 'highlightInvalidData':
	                case 'resizeZeroIndicator':
	                case 'allowUserDragFill':
	                case 'allowUserDragMerge':
	                    if (sheet) {
	                        sheet._invalidate();
	                    }
	                    break;
	                case 'backgroundImage':
	                case 'backgroundImageLayout':
	                    self._paintWorkbookBackgroundImage();
	                    if (sheet) {
	                        sheet._invalidate();
	                    }
	                    break;
	                case 'newTabVisible':
	                case 'tabNavigationVisible':
	                    var tab = self._tab;
	                    tab && tab.repaint();
	                    break;
	                case 'showHorizontalScrollbar':
	                case 'showVerticalScrollbar':
	                case 'useTouchLayout':
	                case 'tabStripVisible':
	                    self._doResize();
	                    break;
	                case 'tabStripRatio':
	                    self._doTabHSResize();
	                    break;
	                case 'scrollIgnoreHidden':
	                case 'scrollbarMaxAlign':
	                case 'scrollbarShowMax':
	                    if (sheet) {
	                        sheet._needSyncHScrollbarSize = true;
	                        sheet._needSyncVScrollbarSize = true;
	                        sheet._invalidate();
	                    }
	                    break;
	                case 'referenceStyle':
	                    var calcService = hasCalc && self._getCalcServiceInternal();
	                    if (calcService) {
	                        calcService.useR1C1 = (value === 1 );
	                    }
	                    break;
	            }
	        },
	
	        _init: function (count, host) {
	            var self = this;
	            hasCalc && self._initCalcService();
	            self._userEvents = [];
	            self._userEventsElem = createElement('input');
	            self._eventSuspended = 0;
	            self._paintSuspended = 0;
	            self._floatingObjectClipboardHelper = {fromSheet: keyword_null, isCutting: false};
	            self._shapeClipboardHelper = {fromSheet: keyword_null, isCutting: false};
	            self._containerDiv = keyword_null;
	            self.sheets = [];
	            self._namedStyles = {};
	           
	            self._undoManager = new UndoManager(self, -1, self.options.allowUndo);
	           
	            var commandManager = self._commandManager = new CommandManager(self);
	            commandManager.addListener('workbookUndo', function (arg) {
	                var command = arg.command, inTransaction = Sheets_Commands._isInTransaction(command);
	                var undoCmd = self._commandManager[command.cmd];
	                if (undoCmd && undoCmd.canUndo() && !inTransaction && !command._fromUndoManager) {
	                    self.undoManager()._addCommand(command, arg._actionType);
	                }
	            });
	            Sheets_Commands._initWorkbookCommands(commandManager);
	
	            Workbook._callFeatureHandler(self, 'init');
	
	            var i;
	            for (i = 0; i < count; i++) {
	                var sheet = self._createSheet(self._getDefaultSheetName(i));
	                self.sheets.push(sheet);
	                sheet._onAttached(self);
	            }
	
	            self.suspendPaint();
	            if (host) {
	                self._setHost(host);
	            }
	            self._clipboardHelper = new _ClipboardHelper(self);
	
	            self.resumePaint();
	        },
	       
	        
	        hitTest: function (x, y, ignoreProtected) {
	            var self = this;
	            var sheet = self.getActiveSheet(), tab = self._tab, scrollbarH = self._scrollbarH,
	                scrollbarV = self._scrollbarV;
	            var spreadWidth = $$(self.getHost()).width();
	            var spreadHeight = $$(self.getHost()).height();
	
	            if (x < 0 || x > spreadWidth || y < 0 || y > spreadHeight) {
	                return keyword_null;
	            }
	
	            var spreadOffset = self._getSpreadOffset();
	            var sheetOffset = sheet._getCanvasOffset();
	            var sheetRect = sheet._getBounds();
	            var sheetX = sheetOffset.left - spreadOffset.left;
	            var sheetY = sheetOffset.top - spreadOffset.top;
	            if (x > sheetX && x < sheetRect.width + sheetX
	                && y > sheetY && y < sheetRect.height + sheetY) {
	                return {
	                    worksheetHitInfo: sheet.hitTest(x - sheetX, y - sheetY, false, ignoreProtected),
	                    x: x,
	                    y: y
	                };
	            }
	
	            var tabOffset = $$(tab._getCanvas()).offset();
	            var tabRect = tab._getBounds();
	            var tabX = tabOffset.left - spreadOffset.left;
	            var tabY = tabOffset.top - spreadOffset.top;
	            if (x > tabX && x < tabRect.width + tabX
	                && y > tabY && y < tabRect.height + tabY) {
	                var tabStripInfo = tab.hitTest(x - tabX, y - tabY);
	                var tabStripHitInfo = {}, sheetIndex = tabStripInfo.index, hittedSheet = self.sheets[sheetIndex], sheetName = hittedSheet && hittedSheet.name();
	                switch (tabStripInfo.type) {
	                    case "navButton":
	                        tabStripHitInfo = {navButton: tabStripInfo.element};
	                        break;
	                    case "sheetTab":
	                        tabStripHitInfo = {sheetTab: {sheetName: sheetName || tabStripInfo.element, sheetIndex: sheetIndex}};
	                        break;
	                    case "resize":
	                        tabStripHitInfo = {resize: true};
	                        break;
	                    default:
	                        tabStripHitInfo = {blank: true};
	                        break;
	                }
	                return {
	                    tabStripHitInfo: tabStripHitInfo,
	                    x: x,
	                    y: y
	                };
	            }
	
	            var scrollbarHOffset = $$(scrollbarH._getScrollbar()).offset();
	            var scrollbarHRect = scrollbarH._getScrollbarRect();
	            var horizontalScrollBarX = scrollbarHOffset.left - spreadOffset.left;
	            var horizontalScrollBarY = scrollbarHOffset.top - spreadOffset.top;
	            if (x > horizontalScrollBarX && x < scrollbarHRect.width + horizontalScrollBarX
	                && y > horizontalScrollBarY && y < scrollbarHRect.height + horizontalScrollBarY) {
	                return {
	                    horizontalScrollBarHitInfo: {
	                        element: scrollbarH.hitTest(x - horizontalScrollBarX, y - horizontalScrollBarY).element
	                    },
	                    x: x,
	                    y: y
	                };
	            }
	
	            var scrollbarVOffset = $$(scrollbarV._getScrollbar()).offset();
	            var scrollbarVRect = scrollbarV._getScrollbarRect();
	            var verticalScrollBarX = scrollbarVOffset.left - spreadOffset.left;
	            var verticalScrollBarY = scrollbarVOffset.top - spreadOffset.top;
	            if (x > verticalScrollBarX && x < scrollbarVRect.width + verticalScrollBarX
	                && y > verticalScrollBarY && y < scrollbarVRect.height + verticalScrollBarY) {
	                return {
	                    verticalScrollBarHitInfo: {
	                        element: scrollbarV.hitTest(x - verticalScrollBarX, y - verticalScrollBarY).element
	                    },
	                    x: x,
	                    y: y
	                };
	            }
	
	            var footerOffset = $$(self._footerCornerContainer).offset();
	            var footerWidth = parseInt(self._footerCornerContainer.style.width.substr(0, self._footerCornerContainer.style.width.indexOf("px")));
	            var footerHeight = parseInt(self._footerCornerContainer.style.height.substr(0, self._footerCornerContainer.style.height.indexOf("px")));
	            var footerX = footerOffset.left - spreadOffset.left;
	            var footerY = footerOffset.top - spreadOffset.top;
	            if (x > footerX && x < footerWidth + footerX
	                && y > footerY && y < footerHeight + footerY) {
	                return {
	                    footerCornerHitInfo: {
	                        element: "footerCorner"
	                    },
	                    x: x,
	                    y: y
	                };
	            }
	        },
	
	        _getSpreadOffset: function () {
	            var spread = this, t;
	            if ($) {
	                t = $(spread._host).offset();
	            } else {
	                t = $$(spread._host).offset();
	            }
	            if (t) {
	                t.top += DOCUMENT.body.clientTop || 0;
	                t.left += DOCUMENT.body.clientLeft || 0;
	            } else {
	                t = {top: 0, left: 0};
	            }
	            return t;
	        },
	
	
	        _initOptions: function (options) {
	            var ownOptions = this.options;
	            var workbookOptions = options || {};
	            workbookOptions = $$_extend(true, {}, defaultOptions, workbookOptions);
	            $$_each(workbookOptions, function (p, v) {
	                if (ownOptions.hasOwnProperty(p)) {
	                    ownOptions[p] = v;
	                }
	            });
	        },
	        _getContainerDiv: function () {
	            var self = this;
	            if (!self._containerDiv && self._host) {
	                self._containerDiv = createElement(TAG_DIV);
	                $$(self._containerDiv).css({
	                    position: 'relative',
	                    left: 0,
	                    top: 0,
	                    height: 0
	                });
	                $$(self._host).prepend(self._containerDiv);
	            }
	            return self._containerDiv;
	        },
	        _getDefaultSheetName: function (sheetIndex) {
	            var self = this, sheetCount = self.getSheetCount();
	            if (self._availableSheetIndex < sheetCount) {
	                self._availableSheetIndex = sheetCount;
	            } else {
	                self._availableSheetIndex++;
	            }
	            if (isNullOrUndefined(sheetIndex) || sheetIndex < self._availableSheetIndex) {
	                sheetIndex = self._availableSheetIndex;
	            }
	            var conflict = false, name, sheets = self.sheets;
	            do {
	                name = 'Sheet' + (sheetIndex + 1);
	                var len = sheets.length;
	                for (var i = 0; i < len; i++) {
	                    if (i in sheets) {
	                        var sheet = sheets[i];
	                        if (sheet.name().toUpperCase() === name.toUpperCase()) {
	                            sheetIndex++;
	                            conflict = true;
	                            break;
	                        } else if (conflict) {
	                            conflict = false;
	                        }
	                    }
	                }
	            } while (conflict);
	            return name;
	        },
	        _createSheet: function (sheetName) {
	           
	            return new exports.Worksheet(sheetName);
	        },
	        _setHost: function (host) {
	            var self = this;
	            if (host) {
	                self._host = host;
	                if ($) {
	                    $(host).data(STORE_KEY, self);
	                }
	               
	               
	               
	               
	               
	               
	               
	                $$(host).data(STORE_KEY, self).attr(GC_UIELEMENT, 'gcSpread').addClass(NO_USER_SELECT).css(OVERFLOW, VISIBLE);
	
	                WINDOW._gcGlobal._createDummyObjects();
	
	                self.cultureChangedHandler = function () {
	                    self._onCultureChanged(self);
	                };
	                DOCUMENT.addEventListener(CULTURE_CHANGED_EVENT, self.cultureChangedHandler);
	
	
	               
	                var table = createElement(TAG_TABLE), tableStyle = table.style, i, j, trElement, tdElement,
	                    tdElementStyle, A_HUNDRED_PERCENT = '100%';
	                table.cellSpacing = 0;
	                table.cellPadding = 0;
	                table.border = 0;
	                tableStyle.width = A_HUNDRED_PERCENT;
	                tableStyle.height = A_HUNDRED_PERCENT;
	                tableStyle.border = 0;
	                tableStyle.margin = 0;
	                tableStyle.borderCollapse = "collapse";
	                for (i = 0; i < 2; i++) {
	                    trElement = createElement('tr');
	                    for (j = 0; j < 2; j++) {
	                        tdElement = createElement('td');
	                        tdElementStyle = tdElement.style;
	                        tdElementStyle.padding = 0;
	                        tdElementStyle.border = 0;
	                        trElement.appendChild(tdElement);
	                    }
	                    table.appendChild(trElement);
	                }
	                host.appendChild(table);
	               
	                self._vp = createElement(TAG_DIV);
	                self._vp.id = host.id + 'vp';
	                $$(table.rows[0].cells[0]).append(self._vp);
	               
	                self._scrollbarV = new Scrollbar(false);
	                var vScrollbar = self._scrollbarV._getScrollbar();
	                var scrollbarVContainer = self._scrollbarVContainer = createElement(TAG_DIV);
	                $$(scrollbarVContainer).append(vScrollbar);
	                $$(table.rows[0].cells[1]).append(scrollbarVContainer);
	                $$(vScrollbar).bind(E_SCROLL + NS_SCROLLBAR, function (e, args) {
	                    var scrollEventType = args.scrollEventType;
	                    e.data = self;
	                    if (args.scrollOrientation === 1 ) {
	                        if (scrollEventType === 0  || scrollEventType === 1  ||
	                            scrollEventType === 2  || scrollEventType === 3  ||
	                            scrollEventType === 5 ) {
	                            ScrollService._vscrollDelegate(e, args);
	                        } else if (scrollEventType === 4 ) {
	                            ScrollService._vScrollStop(e);
	                        }
	                    }
	                }).bind(E_MOUSEDOWN + NS_SCROLLBAR, function (e) {
	                    e.data = self;
	                    ScrollService._vScrollMouseDown(e);
	                }).bind(E_MOUSEUP + NS_SCROLLBAR, function (e) {
	                    e.data = self;
	                    ScrollService._scrollMouseUp(e);
	                });
	               
	                var ts_hs_table = createElement(TAG_TABLE), ts_hs_tableStyle = ts_hs_table.style;
	                ts_hs_table.cellSpacing = 0;
	                ts_hs_table.cellPadding = 0;
	                ts_hs_table.border = 0;
	                ts_hs_tableStyle.border = 0;
	                ts_hs_tableStyle.margin = 0;
	                $$(ts_hs_table).css('user-select', CSS_NONE);
	                trElement = createElement('tr');
	                for (j = 0; j < 2; j++) {
	                    tdElement = createElement('td');
	                    tdElementStyle = tdElement.style;
	                    tdElementStyle.padding = 0;
	                    tdElementStyle.border = 0;
	                    trElement.appendChild(tdElement);
	                }
	                ts_hs_table.appendChild(trElement);
	                $$(table.rows[1].cells[0]).append(ts_hs_table);
	               
	                var tabs, tabsStyle;
	                tabs = self._tabs = createElement(TAG_DIV);
	                tabsStyle = tabs.style;
	                tabsStyle.width = '' + self._getActualTabStripRatio() * $$(host).width() + PIXEL;
	                tabsStyle.height = '' + self._getTabStripHeight() + PIXEL;
	                tabsStyle.fontSize = '10pt';
	                tabsStyle.fontFamily = 'Arial';
	                $$(ts_hs_table.rows[0].cells[0]).append(tabs);
	               
	                self._scrollbarH = new Scrollbar(true);
	                var hScrollbar = self._scrollbarH._getScrollbar();
	                var scrollbarHContainer = self._scrollbarHContainer = createElement(TAG_DIV);
	                $$(scrollbarHContainer).append(hScrollbar);
	                $$(ts_hs_table.rows[0].cells[1]).append(scrollbarHContainer);
	                $$(hScrollbar).bind(E_SCROLL + NS_SCROLLBAR, function (e, args) {
	                    var scrollEventType = args.scrollEventType;
	                    e.data = self;
	                    if (args.scrollOrientation === 0 ) {
	                        if (scrollEventType === 0  || scrollEventType === 1  ||
	                            scrollEventType === 2  || scrollEventType === 3  ||
	                            scrollEventType === 5 ) {
	                            ScrollService._hscrollDelegate(e, args);
	                        } else if (scrollEventType === 4 ) {
	                            ScrollService._hScrollStop(e);
	                        }
	                    }
	                }).bind(E_MOUSEDOWN + NS_SCROLLBAR, function (e) {
	                    e.data = self;
	                    ScrollService._hScrollMouseDown(e);
	                }).bind(E_MOUSEUP + NS_SCROLLBAR, function (e) {
	                    e.data = self;
	                    ScrollService._scrollMouseUp(e);
	                });
	               
	                self._footerCornerContainer = createElement(TAG_DIV);
	                $$(table.rows[1].cells[1]).append(self._footerCornerContainer);
	
	
	                self._scrollService = new ScrollService(this);
	
	                var resizeHandler = self._windowResizeHandler = function () {
	                    self._doWindowResize();
	                };
	                $$(WINDOW).bind(E_RESIZE + NS_SPREAD, resizeHandler);
	
	                var sheet = getActiveSheet(self);
	                if (sheet) {
	                    sheet._setHost(self._vp);
	                }
	                self._refreshScrollbarAndTabStrip();
	                self._doResize();
	                self._createFocusElementForTab(host);
	
	                Workbook._callFeatureHandler(self, 'setHost', host);
	            }
	        },
	        _createFocusElementForTab: function (host) {
	            var self = this, TAB_INDEX = 'tabindex';
	            var tabIndex = convertToInt($$(host).attr(TAB_INDEX), 10) || 0;
	            var focusElement = createElement(TAG_DIV);
	            $$(focusElement).css({
	                'position': CSS_ABSOLUTE,
	                'overflow': 'hidden'
	            })
	                .attr(GC_UIELEMENT, 'gcSheetFocusElementForTab')
	                .attr(TAB_INDEX, tabIndex)
	                .bind(E_FOCUS, function () {
	                    if (!self._ignoreFocusEvent) {
	                        getActiveSheet(self)._setFocus();
	                    }
	                    self._ignoreFocusEvent = false;
	                });
	            host.insertBefore(focusElement, keyword_null);
	            self._tabFocusElement = focusElement;
	        },
	        _focusTabFocusElement: function () {
	            var self = this, focusElement = self._tabFocusElement;
	            if (focusElement) {
	                self._ignoreFocusEvent = true;
	                focusElement.focus();
	            }
	        },
	        _dispose: function () {
	            var self = this, scrollbarH = self._scrollbarH, scrollbarV = self._scrollbarV,
	                i, sheets = self.sheets;
	            _DPIHelper._disposeSpread(self);
	            util_common_util._dispose();
	            self._windowResizeHandler && $$(WINDOW).unbind(E_RESIZE + NS_SPREAD, self._windowResizeHandler);
	            if (self._windowResizeTimer) {
	                clearTimeout(self._windowResizeTimer);
	            }
	            if (scrollbarH) {
	                scrollbarH.dispose();
	            }
	            if (scrollbarV) {
	                scrollbarV.dispose();
	            }
	            self._disposeUserEvents();
	            for (i = 0; i < sheets.length; i++) {
	                sheets[i]._dispose(true);
	            }
	            sheets.splice(0, sheets.length);
	
	            var clipboardHelper = self._clipboardHelper;
	            if (clipboardHelper) {
	                clipboardHelper._dispose();
	            }
	
	            var host = self._host, $host, ATTR_CLASS = 'class', ATTR_UNSELECTABLE = 'unselectable';
	            if (host) {
	                $host = $$(host);
	                DOCUMENT.removeEventListener(CULTURE_CHANGED_EVENT, self.cultureChangedHandler);
	                $host.html('').removeAttr(GC_UIELEMENT).removeClass(NO_USER_SELECT);
	                if (!$host.attr(ATTR_CLASS)) {
	                    $host.removeAttr(ATTR_CLASS);
	                }
	                if (!$host.attr(ATTR_UNSELECTABLE)) {
	                    $host.removeAttr(ATTR_UNSELECTABLE);
	                }
	                if ($host.data(STORE_KEY)) {
	                    $host.data(STORE_KEY, keyword_null);
	                }
	                if ($ && $(host).data(STORE_KEY)) {
	                    $(host).data(STORE_KEY, keyword_null);
	                }
	            }
	
	            self._scrollbarHContainer = keyword_null;
	            self._scrollbarVContainer = keyword_null;
	            self._undoManager = keyword_null;
	            if (self._tab) {
	                self._tab._dispose();
	                self._tab = keyword_null;
	            }
	            Workbook._callFeatureHandler(self, 'dispose');
	
	            if (self._tabFocusElement) {
	                $$(self._tabFocusElement).unbind(E_FOCUS);
	                self._tabFocusElement = keyword_null;
	            }
	            if (self._calcService) {
	                self._calcService.dispose();
	                self._calcService = keyword_null;
	                self._spreadSource = keyword_null;
	                self._spreadSourceModel = keyword_null;
	            }
	            if (self._imageLoader) {
	                self._imageLoader._dispose();
	                self._imageLoader = keyword_null;
	            }
	            StyleHelper._dispose();
	        },
	        _disposeUserEvents: function () {
	            var self = this, sheets = self.sheets, i, sheet;
	            $$(self._userEventsElem).unbind(NS_SPREAD);
	            for (i = 0; i < sheets.length; i++) {
	                sheet = sheets[i];
	                sheet._disposeUserEvents();
	            }
	        },
	        _refreshScrollbarAndTabStrip: function () {
	            var self = this, themeVersion = convertToInt(_ThemeStyleHelper._getCssClassThemeStyle('').zIndex),
	                isThemeVersionChanged = themeVersion !== self._themeVersion;
	            var host = self._host, tabStripName = host.getAttribute('id') + '_tabStrip', tab = self._tab;
	
	            if (isThemeVersionChanged) {
	                self._themeVersion = themeVersion;
	            }
	
	            var tabStripHeight = self._getTabStripHeight(), scrollbarSize = self._getScrollbarSize(),
	                vScrollbarContainerWidth = self._getVScrollbarContainerWidth();
	
	            if (tab && !isThemeVersionChanged) {
	                tab.repaint();
	            } else {
	                if (tab) {
	                    tab._dispose();
	                }
	                tab = self._tab = themeVersion > 2007  ? new _SheetTab(tabStripName) : new _SheetTab2007(tabStripName);
	                tab._setOwner(self);
	                tab._setHost(self._tabs);
	            }
	            refreshVScrollContainer(self._scrollbarVContainer, vScrollbarContainerWidth, scrollbarSize);
	            refreshHScrollContainer(self._scrollbarHContainer, tabStripHeight, scrollbarSize);
	            refreshFooterCorner(self._footerCornerContainer, vScrollbarContainerWidth, tabStripHeight);
	        },
	        _doWindowResize: function () {
	            var self = this, windowResizeTimer = self._windowResizeTimer;
	            if (windowResizeTimer) {
	                clearTimeout(windowResizeTimer);
	            }
	            self._windowResizeTimer = setTimeout(function () {
	                _DPIHelper._updateDPI();
	                self._doResize();
	                self._windowResizeTimer = keyword_null;
	            }, 100);
	        },
	        _doResize: function () {
	            var self = this;
	            if (self._isResizing) {
	                return;
	            }
	            self._isResizing = true;
	            self._doResizeImp();
	            self._isResizing = false;
	        },
	        _doResizeImp: function () {
	            var self = this, CSS_DISPLAY = 'display', CSS_BLOCK = 'block';
	            var tabStripHeight = self._getTabStripHeight(), scrollbarSize = self._getScrollbarSize(),
	                vScrollbarContainerWidth = self._getVScrollbarContainerWidth();
	            var host = self._host;
	            if (!host) {
	                return;
	            }
	            var options = self.options, showVerticalScrollbar = options.showVerticalScrollbar,
	                showHorizontalScrollbar = options.showHorizontalScrollbar,
	                tabStripVisible = options.tabStripVisible,
	                showHorizontalScrollbar_or_tabStripVisible = showHorizontalScrollbar || tabStripVisible;
	            var $host = $$(host), hostWidth = $host.width(), hostHeight = $host.height();
	            var footerCornerContainer = self._footerCornerContainer, scrollbarH = self._scrollbarH,
	                scrollbarV = self._scrollbarV,
	                vpStyle = self._vp.style, tabsStyle = self._tabs.style;
	
	            vpStyle.width = '' + (hostWidth - (showVerticalScrollbar ? vScrollbarContainerWidth : 0)) + PIXEL;
	            $$(self._scrollbarVContainer).css(CSS_DISPLAY, showVerticalScrollbar ? CSS_BLOCK : CSS_NONE);
	            $$(footerCornerContainer).css('width', (showVerticalScrollbar ? vScrollbarContainerWidth : 0) + PIXEL);
	
	            var vpHeight = hostHeight - (showHorizontalScrollbar_or_tabStripVisible ? tabStripHeight : 0);
	            vpStyle.height = '' + (vpHeight >= 2 ? vpHeight : 2) + PIXEL;
	            $$(self._scrollbarHContainer).css(CSS_DISPLAY, showHorizontalScrollbar_or_tabStripVisible ? CSS_BLOCK : CSS_NONE);
	            $$(footerCornerContainer).css('height', showHorizontalScrollbar_or_tabStripVisible ? tabStripHeight : 0 + PIXEL);
	
	            if (showHorizontalScrollbar) {
	                $$(scrollbarH._getScrollbar()).show();
	                options.tabStripRatio = options.tabStripRatio;
	            } else {
	                $$(scrollbarH._getScrollbar()).hide();
	            }
	            var availableWidth = $$(self._vp).width();
	            var tabStripWidth = Math_round(self._getActualTabStripRatio() * availableWidth);
	            if (tabStripWidth === availableWidth) {
	                tabStripWidth = availableWidth - 1;
	            }
	            tabsStyle.width = '' + tabStripWidth + PIXEL;
	            tabsStyle.height = '' + tabStripHeight + PIXEL;
	
	            scrollbarV._width(scrollbarSize);
	            scrollbarV._height($$(self._vp).height());
	
	            var hsWidth = hostWidth - (tabStripVisible ? tabStripWidth : 0) - (showVerticalScrollbar ? vScrollbarContainerWidth : 0);
	            scrollbarH._width(hsWidth > 0 ? hsWidth : 1);
	            scrollbarH._height(scrollbarSize);
	
	           
	            var sheet = getActiveSheet(self);
	            if (sheet) {
	                if (sheet._scrollTopRow === 0) {
	                    sheet._scrollTopRow = sheet._getFirstPageTopRow();
	                }
	                if (sheet._scrollLeftCol === 0) {
	                    sheet._scrollLeftCol = sheet._getFirstPageLeftColumn();
	                }
	                sheet._doResize();
	            }
	            self._resizeHScrollBar();
	            self._resizeVScrollBar();
	            if (sheet) {
	                sheet.invalidateLayout();
	                sheet.repaint();
	            }
	           
	
	            if (tabStripVisible) {
	                $$(self._tabs).show();
	            } else {
	                $$(self._tabs).hide();
	            }
	            self._tab && self._tab._doResize();
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	
	           
	            var fixWidth = $host.width(), needAdjust = (hostWidth !== fixWidth && Math_abs(hostWidth - fixWidth) > 2);
	            if (needAdjust && !self._haveLayoutFixing) {
	                self._haveLayoutFixing = true;
	                setTimeout(function () {
	                    delete self._haveLayoutFixing;
	                    self._doResizeImp();
	                }, 1);
	            }
	        },
	        _resizeHScrollBar: function () {
	            var self = this, sheet = getActiveSheet(self), options = self.options;
	            if (sheet) {
	                var frozenColCount = sheet.frozenColumnCount();
	                var columnCount = sheet.getColumnCount() - sheet.frozenTrailingColumnCount() - frozenColCount,
	                    startColumn = frozenColCount,
	                    layout = sheet._getSheetLayout(),
	                    endColumn = columnCount === 0 ? startColumn : startColumn + columnCount - 1,
	                    scrollLeftCol = sheet._scrollLeftCol, pageValueH;
	                var leftCol = sheet._getLeftColWhenLastColShowComplete(layout._viewportWidth, startColumn, endColumn);
	                if (options.scrollbarMaxAlign) {
	                    endColumn = leftCol;
	                }
	                if (!options.scrollbarShowMax) {
	                    var lastNonNullRowAndCol = sheet._getLastNonNullRowAndCol(),
	                        lastNonNullCol = lastNonNullRowAndCol.lastNonNullCol,
	                        maxDirtyEndColumn = sheet._getLeftColWhenLastColShowComplete(layout._viewportWidth, startColumn, lastNonNullCol);
	                    if (maxDirtyEndColumn === startColumn) {
	                        maxDirtyEndColumn++;
	                        if (maxDirtyEndColumn > endColumn) {
	                            maxDirtyEndColumn = endColumn;
	                        }
	                    }
	                    if (scrollLeftCol > maxDirtyEndColumn) {
	                        endColumn = scrollLeftCol < endColumn ? scrollLeftCol : endColumn;
	                    } else {
	                        endColumn = maxDirtyEndColumn;
	                    }
	                }
	                if (scrollLeftCol > endColumn) {
	                    sheet._scrollLeftCol = endColumn;
	                }
	                var newLeftCol = sheet._getScrollableColumn(sheet._scrollLeftCol);
	                if (newLeftCol !== -1 && newLeftCol !== sheet._scrollLeftCol) {
	                    sheet._scrollLeftCol = newLeftCol;
	                }
	                pageValueH = sheet._getPageValueH();
	                if (pageValueH < 1) {
	                    pageValueH = 1;
	                }
	                var scrollbarH = self._scrollbarH;
	                if (scrollbarH) {
	                    scrollbarH._minimum(sheet._getVisibleColIndex(startColumn));
	                    scrollbarH._maximum(sheet._getVisibleColIndex(endColumn));
	                    scrollbarH._pageValue(pageValueH);
	                    scrollbarH._refreshLayout();
	                    scrollbarH.value(sheet._getVisibleColIndex(sheet._scrollLeftCol));
	                }
	            }
	        },
	        _resizeVScrollBar: function () {
	            var self = this, sheet = getActiveSheet(self), options = self.options;
	            if (sheet) {
	                var frozenRowCount = sheet.frozenRowCount();
	                var rowCount = sheet.getRowCount() - sheet.frozenTrailingRowCount() - frozenRowCount,
	                    startRow = frozenRowCount,
	                    layout = sheet._getSheetLayout(), endRow = rowCount === 0 ? startRow : startRow + rowCount - 1,
	                    scrollTopRow = sheet._scrollTopRow, pageValueV;
	                var topRow = sheet._getTopRowWhenLastRowShowComplete(layout._viewportHeight, startRow, endRow);
	                if (options.scrollbarMaxAlign) {
	                    endRow = topRow;
	                }
	                if (!options.scrollbarShowMax) {
	                    var lastNonNullRowAndCol = sheet._getLastNonNullRowAndCol(),
	                        lastNonNullRow = lastNonNullRowAndCol.lastNonNullRow,
	                        maxDirtyEndRow = sheet._getTopRowWhenLastRowShowComplete(layout._viewportHeight, startRow, lastNonNullRow);
	                    if (maxDirtyEndRow === startRow) {
	                        maxDirtyEndRow++;
	                        if (maxDirtyEndRow > endRow) {
	                            maxDirtyEndRow = endRow;
	                        }
	                    }
	                    if (scrollTopRow > maxDirtyEndRow) {
	                        endRow = scrollTopRow < endRow ? scrollTopRow : endRow;
	                    } else {
	                        endRow = maxDirtyEndRow;
	                    }
	                }
	                if (scrollTopRow > endRow) {
	                    sheet._scrollTopRow = endRow;
	                }
	                var newTopRow = sheet._getScrollableRow(sheet._scrollTopRow);
	                if (newTopRow !== -1 && newTopRow !== sheet._scrollTopRow) {
	                    sheet._scrollTopRow = newTopRow;
	                }
	                pageValueV = sheet._getPageValueV();
	                if (pageValueV < 1) {
	                    pageValueV = 1;
	                }
	                var scrollbarV = self._scrollbarV;
	                if (scrollbarV) {
	                    scrollbarV._minimum(sheet._getVisibleRowIndex(startRow));
	                    scrollbarV._maximum(sheet._getVisibleRowIndex(endRow));
	                    scrollbarV._pageValue(pageValueV);
	                    scrollbarV._refreshLayout();
	                    scrollbarV.value(sheet._getVisibleRowIndex(sheet._scrollTopRow));
	                }
	            }
	        },
	        _doTabHSResize: function () {
	            var self = this;
	            var tabStripHeight = self._getTabStripHeight(), scrollbarSize = self._getScrollbarSize(),
	                vScrollbarContainerWidth = self._getVScrollbarContainerWidth();
	            var host = self._host;
	            if (!host) {
	                return;
	            }
	            var options = self.options, tabStripVisible = options.tabStripVisible;
	            var $host = $$(host), hostWidth = $host.width();
	            var scrollbarH = self._scrollbarH, tabsStyle = self._tabs.style;
	            var availableWidth = $$(self._vp).width();
	            var tabStripWidth = Math_round(self._getActualTabStripRatio() * availableWidth);
	            if (tabStripWidth === availableWidth) {
	                tabStripWidth = availableWidth - 1;
	            }
	            tabsStyle.width = '' + tabStripWidth + PIXEL;
	            tabsStyle.height = '' + tabStripHeight + PIXEL;
	            var hsWidth = hostWidth - (tabStripVisible ? tabStripWidth : 0) - (options.showVerticalScrollbar ? vScrollbarContainerWidth : 0);
	            scrollbarH._width(hsWidth > 0 ? hsWidth : 1);
	            scrollbarH._height(scrollbarSize);
	
	            var sheet = getActiveSheet(self);
	            if (sheet && sheet._scrollLeftCol === 0) {
	                sheet._scrollLeftCol = sheet._getFirstPageLeftColumn();
	            }
	            self._resizeHScrollBar();
	
	            if (tabStripVisible) {
	                $$(self._tabs).show();
	            } else {
	                $$(self._tabs).hide();
	            }
	            self._tab && self._tab._doResize();
	        },
	       
	        
	        suspendPaint: function () {
	            var self = this, tab = self._tab;
	            var sheets = self.sheets;
	            self._paintSuspended++;
	            for (var i = 0; i < sheets.length; i++) {
	                sheets[i].suspendPaint();
	            }
	            if (tab) {
	                tab._suspendPaint();
	            }
	        },
	       
	        
	        resumePaint: function () {
	            var self = this, tab = self._tab;
	            var sheets = self.sheets;
	            self._paintSuspended -= (self._paintSuspended > 0 ? 1 : 0);
	            for (var i = 0; i < sheets.length; i++) {
	                sheets[i].resumePaint();
	            }
	            if (tab) {
	                tab._resumePaint();
	            }
	        },
	       
	        
	        isPaintSuspended: function () {
	            return this._paintSuspended > 0;
	        },
	
	        _paintWorkbookBackgroundImage: function () {
	            var self = this, backgroundImage = self.options.backgroundImage,
	                backgroundImageLayout = self.options.backgroundImageLayout;
	            var sheet = getActiveSheet(self);
	            if (sheet && backgroundImage) {
	                var canvas = $$(sheet._getCanvas()), imageLoader;
	                canvas.css({
	                    'background-image': 'url(\'' + backgroundImage + '\')',
	                    'background-repeat': 'no-repeat'
	                });
	                if (!isNullOrUndefined(backgroundImageLayout)) {
	                    imageLoader = self._imageLoader;
	                    if (!imageLoader) {
	                        imageLoader = self._imageLoader = new _ImageLoader(function () {
	                            if (self._imageLoader) {
	                                self._paintWorkbookBackgroundImage();
	                            }
	                        });
	                    }
	                    try {
	                        if (imageLoader._getState(backgroundImage)) {
	                            var img = imageLoader._getImage(backgroundImage), bounds = sheet._getBounds(),
	                                contentWidth = bounds.width, contentHeight = bounds.height;
	                            util_common_util._applyBackgroundImageLayout(sheet._getCanvas(), contentWidth, contentHeight, img.width, img.height, backgroundImageLayout);
	                        } else {
	                            imageLoader._addImage(backgroundImage);
	                        }
	                    } catch (ex) {
	                       
	                    }
	                }
	            }
	        },
	        _changeSheetForFormulaAcrossSheet: function (sheet, saveValue) {
	            if (saveValue === void 0) {
	                saveValue = true;
	            }
	            var self = this;
	            self._tab._doSheetTabClickChange(self.getSheetIndex(sheet.name()), saveValue);
	        },
	
	       
	        
	        startSheetIndex: function (value) {
	            var self = this, tab = self._tab;
	            if (arguments.length === 0) {
	                return (tab) ? tab._firstTab : 0;
	            }
	
	            if (tab) {
	                if (!tab._tabVisible(value)) {
	                    value = tab._getNextVisibleIndex(value);
	                    if (value === -1) {
	                        value = tab._getPreVisibleIndex(value);
	                    }
	                }
	                tab._firstTab = value;
	            }
	            self._doTabHSResize();
	            return self;
	        },
	
	        _getActualTabStripRatio: function () {
	            var self = this, options = self.options;
	            if (options.showHorizontalScrollbar) {
	                var r = options.tabStripRatio;
	                if (isNaN(r)) {
	                    return 0.5;
	                }
	                var minRatio = 0, vp = self._vp, tab = self._tab;
	                if (vp && tab) {
	                    var totalWidth = $$(vp).width();
	                    minRatio = tab._resizeBarWidth / totalWidth;
	                }
	                if (r < minRatio) {
	                    r = minRatio;
	                } else if (r > 1) {
	                    r = 1;
	                }
	                return r;
	            }
	            return 1;
	        },
	       
	        
	        destroy: function () {
	            this._windowResizeHandler && $$(WINDOW).unbind(E_RESIZE + NS_SPREAD, this._windowResizeHandler);
	            this._dispose();
	        },
	       
	        
	        repaint: function () {
	            var self = this, tab = self._tab;
	            if (tab) {
	                tab.repaint();
	            }
	            var sheet = getActiveSheet(self);
	            if (sheet) {
	                sheet.repaint();
	            }
	        },
	       
	        
	        refresh: function () {
	            var self = this;
	            if (self._host) {
	                _ThemeStyleHelper._clearCache();
	                self._refreshScrollbarAndTabStrip();
	                self._doResize();
	                self.repaint();
	            }
	        },
	       
	        
	        getHost: function () {
	            return this._host;
	        },
	       
	        
	        invalidateLayout: function () {
	            var sheet = getActiveSheet(this);
	            if (sheet) {
	                sheet.invalidateLayout();
	            }
	        },
	       
	        
	        addNamedStyle: function (style) {
	            this._addNamedStyleImp(style);
	            var sheet = getActiveSheet(this);
	            if (sheet) {
	                sheet._invalidate();
	            }
	        },
	        _addNamedStyleImp: function (style) {
	            if (style) {
	                if (!style.name) {
	                    throw new Error(sR.Exp_EmptyNamedStyle);
	                }
	                var name = style.name.toUpperCase();
	                this._namedStyles[name] = style;
	            }
	        },
	       
	        
	        getNamedStyle: function (name) {
	            return this._getNamedStyleImp(name, true);
	        },
	        _getNamedStyleImp: function (name, clearCache) {
	            var namedStyles = this._namedStyles;
	            if (namedStyles && name) {
	                name = name.toUpperCase();
	                var result = namedStyles[name];
	                if (result && clearCache) {
	                    this._clearStyleCache();
	                }
	                return result;
	            }
	            return keyword_null;
	        },
	        _clearStyleCache: function () {
	            var sheets = this.sheets;
	            for (var i = 0; i < sheets.length; i++) {
	                sheets[i]._clearStyleCache();
	            }
	        },
	       
	        
	        removeNamedStyle: function (name) {
	            var namedStyles = this._namedStyles;
	            if (namedStyles && name) {
	                name = name.toUpperCase();
	                if (namedStyles.hasOwnProperty(name)) {
	                    delete namedStyles[name];
	                    this._clearStyleCache();
	                    var sheet = getActiveSheet(this);
	                    if (sheet) {
	                        sheet._invalidate();
	                    }
	                }
	            }
	        },
	       
	        
	        getNamedStyles: function () {
	            var namedStylesClone = [],
	                namedStyles = this._namedStyles;
	            if (namedStyles) {
	                $$_each(namedStyles, function (index, item) {
	                    namedStylesClone.push(item);
	                });
	            }
	            this._clearStyleCache();
	            return namedStylesClone;
	        },
	
	       
	        
	        getActiveSheet: function () {
	            if (this.sheets && this.sheets.length > 0) {
	                return this.sheets[this._activeSheetIndex];
	            }
	            return keyword_null;
	        },
	       
	        
	        setActiveSheet: function (name) {
	           
	            this._setActiveSheetInternal(name, 2 );
	        },
	        _setActiveSheetInternal: function (name, focusPolicy) {
	            var sheets = this.sheets;
	            for (var i = 0; i < sheets.length; i++) {
	                if (sheets[i].name() === name) {
	                    this._setActiveSheetIndexImp(i, focusPolicy);
	                }
	            }
	        },
	       
	        
	        getActiveSheetIndex: function () {
	            return this._activeSheetIndex;
	        },
	       
	        
	        setActiveSheetIndex: function (value) {
	           
	            this._setActiveSheetIndexImp(value, 2 );
	        },
	        _setActiveSheetIndexImp: function (value, focusPolicy, doNotGetCellTypeFocus, triggerEvent) {
	            if (typeof value !== CONST_NUMBER) {
	                return;
	            }
	            var self = this;
	            if (value === self._activeSheetIndex) {
	                return;
	            }
	            var newSheet = self.sheets[value];
	            if (!(newSheet && newSheet.visible())) {
	                return;
	            }
	           
	           
	           
	            var device = util_common_util._device();
	            if (device.ipad || device.iphone) {
	                var lastSetActiveSheetTime = self._lastSetActiveSheetTime;
	                if (lastSetActiveSheetTime && new Date().valueOf() - lastSetActiveSheetTime < 300) {
	                    return;
	                }
	            }
	           
	
	            var sheet = getActiveSheet(self);
	           
	           
	           
	           
	            var argsForFormulatextbox = {oldSheet: sheet, newSheet: newSheet, needTriggerSheetChange: true};
	            triggerFormulatexgboxActiveSheetChanging(self, argsForFormulatextbox);
	            var args = {oldSheet: sheet, newSheet: newSheet, cancel: false};
	            var whetherTriggerEvent = argsForFormulatextbox.needTriggerSheetChange && triggerEvent;
	            if (whetherTriggerEvent) {
	                triggerActiveSheetChanging(self, args);
	            }
	           
	
	            if (args.cancel === false) {
	                self._activeSheetIndex = value;
	                if (newSheet !== sheet) {
	                    if (sheet) {
	                        sheet._dispose(false);
	                    }
	                    self._setActiveSheetImp(newSheet, focusPolicy, false, doNotGetCellTypeFocus);
	                }
	                self._doResize();
	
	               
	               
	                triggerFormulatextboxActiveSheetChanged(self, sheet, newSheet);
	                if (whetherTriggerEvent) {
	                    triggerActiveSheetChanged(self, sheet, newSheet);
	                }
	               
	            }
	           
	            if (device.ipad || device.iphone) {
	                self._lastSetActiveSheetTime = new Date().valueOf();
	            }
	           
	        },
	        _setActiveSheetImp: function (sheet, focusPolicy, ignoreSetHost, doNotGetCellTypeFocus) {
	            if (!ignoreSetHost) {
	                sheet._setHost(this._vp);
	            }
	           
	            var activeElement = _FocusHelper._getActiveElement(),
	                hasFocus = activeElement && activeElement.parent === this;
	            var setFocus = (focusPolicy === 2 ) ? hasFocus : focusPolicy === 1;
	            _FocusHelper._setActiveElement(keyword_null);
	            if (!this._suspendSetFocus && setFocus) {
	                sheet._setFocus(doNotGetCellTypeFocus);
	            }
	            sheet._syncHScrollbarPosition();
	            sheet._syncVScrollbarPosition();
	        },
	       
	        
	        addSheet: function (index, sheet) {
	           
	            this._addSheetImp(index, 2 , sheet);
	        },
	        _addSheetImp: function (index, focusPolicy, sheet) {
	            var self = this;
	            if (!sheet) {
	                sheet = self._createSheet(self._getDefaultSheetName(index));
	            }
	            var i, sheets = self.sheets, sheetCount = sheets.length;
	            if (!sheet.name()) {
	                sheet._setNameCore(self._getDefaultSheetName(index));
	            } else {
	                for (i = 0; i < sheetCount; i++) {
	                    if (sheets[i].name() === sheet.name()) {
	                        throw sR().Exp_NotSupported;
	                    }
	                }
	            }
	            self._copyUserEvents(sheet);
	            var oldActiveSheet = getActiveSheet(self);
	            var oldActiveSheetIndex = self._activeSheetIndex;
	            var p = sheetCount - index;
	            var tmp = [];
	            for (i = 0; i < p && sheetCount > 0; i++) {
	                tmp.push(sheets.pop());
	            }
	            sheets.push(sheet);
	            sheet._onAttached(self);
	            while (tmp.length > 0) {
	                sheets.push(tmp.pop());
	            }
	
	            sheetCount = sheets.length;
	            if (sheetCount === 1) {
	                if (self._vp) {
	                    sheet._setHost(self._vp);
	                }
	                self._activeSheetIndex = 0;
	            } else {
	                if (oldActiveSheetIndex < 0 && self._tab) {
	                    oldActiveSheetIndex = self._tab._getNextVisibleIndex(oldActiveSheetIndex);
	                }
	                self._activeSheetIndex = oldActiveSheetIndex;
	            }
	            var newActiveSheet = getActiveSheet(self);
	            if (newActiveSheet !== oldActiveSheet) {
	                if (oldActiveSheet) {
	                    oldActiveSheet._dispose(false);
	                }
	                if (newActiveSheet) {
	                    self._setActiveSheetImp(newActiveSheet, focusPolicy, sheetCount === 1);
	                }
	                self._doResize();
	            }
	            if (self._tab) {
	                if (self._tab._firstTab < 0) {
	                    self._tab._firstTab = self._activeSheetIndex;
	                }
	                self._tab.repaint();
	            }
	        },
	       
	        
	        removeSheet: function (index) {
	           
	            this._removeSheetImp(index, 2 );
	        },
	        _removeSheetImp: function (index, focusPolicy) {
	            var self = this, sheets = self.sheets, calcService = self._calcService, tab = self._tab;
	            var sheetCount = sheets.length;
	            if (isNaN(index) || index < 0 || index >= sheetCount) {
	                throw new Error(sR().Exp_IndexOutOfRange);
	            }
	            var activeSheetChanged = index <= self._activeSheetIndex || index === sheetCount - 1;
	            var oldActiveSheet = getActiveSheet(self);
	            if (index < self._activeSheetIndex) {
	                self._activeSheetIndex--;
	            }
	            var removedSheet = sheets[index];
	            removedSheet._disposeUserEvents();
	            sheets.splice(index, 1);
	            sheetCount = sheets.length;
	            if (sheetCount === 0) {
	                self._activeSheetIndex = -1;
	            } else if (self._activeSheetIndex >= sheetCount) {
	                self._activeSheetIndex = tab._getPreVisibleIndex(sheetCount);
	            } else {
	                for (var i = self._activeSheetIndex; i < sheetCount; i++) {
	                    if (sheets[i].visible()) {
	                        self._activeSheetIndex = i;
	                        break;
	                    }
	                }
	               
	                if (i >= sheetCount) {
	                    self._activeSheetIndex = tab._getPreVisibleIndex(sheetCount);
	                }
	            }
	            if (activeSheetChanged) {
	                var newSheet = sheets[self._activeSheetIndex];
	                if (oldActiveSheet !== newSheet) {
	                    if (oldActiveSheet) {
	                        oldActiveSheet._dispose(false);
	                    }
	                    if (newSheet) {
	                        self._setActiveSheetImp(newSheet, focusPolicy, false);
	                    }
	                }
	            }
	            if (calcService) {
	                calcService.removeSource(removedSheet._getSheetSource());
	            }
	            if (tab) {
	                if (tab._firstTab >= sheetCount) {
	                    self.startSheetIndex(tab._getPreVisibleIndex(sheetCount));
	                } else if (tab._firstTab < 0) {
	                    self.startSheetIndex(tab._getNextVisibleIndex(-1));
	                } else {
	                    self._doResize();
	                }
	            }
	        },
	       
	        
	        clearSheets: function () {
	            var self = this, sheets = self.sheets, calcService = self._calcService, tab = self._tab;
	            for (var i = 0; i < sheets.length; i++) {
	                sheets[i]._disposeUserEvents();
	                sheets[i]._dispose(true);//To avoid memory leak, set clearCache true when invoke clearSheets(fromJSON, setSheetCount 0, user code)
	            }
	            sheets.splice(0, sheets.length);
	
	            if (calcService) {
	                calcService.clearSource();
	            }
	            self._activeSheetIndex = -1;
	            if (tab) {
	                tab._firstTab = -1;
	                tab.repaint();
	            }
	        },
	       
	        
	        getSheet: function (index) {
	            var sheets = this.sheets;
	            return index >= 0 && index < sheets.length ? sheets[index] : keyword_null;
	        },
	       
	        
	        getSheetFromName: function (name) {
	            var sheets = this.sheets;
	            for (var i = 0; i < sheets.length; i++) {
	                if (sheets[i].name() === name) {
	                    return sheets[i];
	                }
	            }
	            return keyword_null;
	        },
	       
	        
	        getSheetIndex: function (name) {
	            var sheets = this.sheets;
	            for (var i = 0; i < sheets.length; i++) {
	                if (sheets[i].name() === name) {
	                    return i;
	                }
	            }
	            return keyword_null;
	        },
	       
	        
	        getSheetCount: function () {
	            return this.sheets.length;
	        },
	       
	        
	        setSheetCount: function (count) {
	           
	            this._setSheetCountImp(count, 2 );
	        },
	        _setSheetCountImp: function (count, focusPolicy) {
	            var self = this;
	            if (count < 0) {
	                throw sR().Exp_ArgumentOutOfRange;
	            } else if (count === 0) {
	                self.clearSheets();
	            }
	            var length = self.sheets.length, i;
	            if (count < length) {
	                for (i = length - 1; i >= count; i--) {
	                    self._removeSheetImp(i, focusPolicy);
	                }
	            } else if (count > length) {
	                for (i = length; i < count; i++) {
	                    self._addSheetImp(i, focusPolicy);
	                }
	            }
	           
	        },
	
	       
	        
	        bind: function (type, data, fn) {
	            var self = this, sheets = self.sheets;
	            self._userEvents.push({type: type, data: data, fn: fn});
	            $$(self._userEventsElem).bind(type + NS_SPREAD, data, fn);
	            for (var i = 0; i < sheets.length; i++) {
	                var sheet = sheets[i];
	                sheet.bind(type, data, fn);
	            }
	        },
	       
	        
	        unbind: function (type, fn) {
	            var self = this, sheets = self.sheets, userEvents = self._userEvents;
	            for (var e = 0; e < userEvents.length; e++) {
	                var item = userEvents[e];
	                if (item.type === type) {
	                    userEvents.splice(e, 1);
	                }
	            }
	            $$(self._userEventsElem).unbind(type + NS_SPREAD, fn);
	            for (var i = 0; i < sheets.length; i++) {
	                var sheet = sheets[i];
	                sheet.unbind(type, fn);
	            }
	        },
	       
	        
	        unbindAll: function () {
	            var self = this, sheets = self.sheets;
	            self._userEvents.length = 0;
	            $$(self._userEventsElem).unbind(NS_SPREAD);
	            for (var i = 0; i < sheets.length; i++) {
	                var sheet = sheets[i];
	                sheet.unbindAll();
	            }
	        },
	        _bind: function (type, data, fn) {
	            var self = this, sheets = self.sheets;
	            self._userEvents.push({type: type, data: data, fn: fn});
	            $$(self._userEventsElem).bind(type + NS_SPREADINTERNAL, data, fn);
	            for (var i = 0; i < sheets.length; i++) {
	                var sheet = sheets[i];
	                sheet._bind(type, data, fn);
	            }
	        },
	        _unbind: function (type, fn) {
	            var self = this, sheets = self.sheets, userEvents = self._userEvents;
	            for (var e = 0; e < userEvents.length; e++) {
	                var item = userEvents[e];
	                if (item.type === type) {
	                    userEvents.splice(e, 1);
	                }
	            }
	            $$(self._userEventsElem).unbind(type + NS_SPREADINTERNAL, fn);
	            for (var i = 0; i < sheets.length; i++) {
	                var sheet = sheets[i];
	                sheet._unbind(type, fn);
	            }
	        },
	        _unbindAll: function () {
	            var self = this, sheets = self.sheets;
	            self._userEvents.length = 0;
	            $$(self._userEventsElem).unbind(NS_SPREADINTERNAL);
	            for (var i = 0; i < sheets.length; i++) {
	                var sheet = sheets[i];
	                sheet._unbindAll();
	            }
	        },
	        _trigger: function (type, data) {
	            if (this._eventSuspended === 0) {
	                $$(this._userEventsElem).trigger(type, data);
	            }
	        },
	        _triggerButtonClicked: function (sheet, row, col, sheetArea) {
	            this._trigger(Events.ButtonClicked, {
	                sheet: sheet,
	                sheetName: sheet.name(),
	                row: row,
	                col: col,
	                sheetArea: sheetArea
	            });
	        },
	        _copyUserEvents: function (sheet) {
	            var userEvents = this._userEvents;
	            for (var e = 0; e < userEvents.length; e++) {
	                var item = userEvents[e];
	                sheet.bind(item.type, item.data, item.fn);
	            }
	        },
	       
	        
	        suspendEvent: function () {
	            var self = this, sheets = self.sheets;
	            self._eventSuspended++;
	            for (var i = 0; i < sheets.length; i++) {
	                var sheet = sheets[i];
	                sheet.suspendEvent();
	            }
	        },
	       
	        
	        resumeEvent: function () {
	            var self = this, sheets = self.sheets;
	            self._eventSuspended--;
	            if (self._eventSuspended < 0) {
	                self._eventSuspended = 0;
	            }
	            for (var i = 0; i < sheets.length; i++) {
	                var sheet = sheets[i];
	                sheet.resumeEvent();
	            }
	        },
	
	       
	        
	        focus: function (focusIn) {
	            if (focusIn === false) {
	                _FocusHelper._setActiveElement(keyword_null);
	            } else {
	                var sheet = getActiveSheet(this);
	                if (sheet) {
	                    sheet._setFocus();
	                }
	            }
	        },
	       
	        
	        nextControl: defProperty('nextControl', keyword_null),
	       
	        
	        previousControl: defProperty('previousControl', keyword_null),
	
	        _getScrollbarSize: function () {
	            return this._themeVersion > 2007  ? 15 : 18;
	        },
	        _getVScrollbarContainerWidth: function () {
	            return this._themeVersion > 2007  ? 22 : this._getScrollbarSize();
	        },
	        _getTabStripHeight: function () {
	            return this._themeVersion > 2007  ? 28 : this._getScrollbarSize();
	        },
	
	       
	        _showTooltip: function (info, left, top, isAbsoluteDistanse) {
	            var cssAuto = 'auto';
	            var self = this;
	            if (!self._tooltip) {
	                var tooltip = createElement(TAG_DIV);
	                $$(tooltip).addClass('gc-spread-toolTip ui-state-default ui-widget-content btn-default')
	                    .css({
	                        'position': CSS_ABSOLUTE,
	                        'padding': '0px 3px 0px 3px',
	                        'font': adjustFontWithFallback('normal normal normal 11pt calibri'),
	                        'box-shadow': '1px 2px 5px rgba(0,0,0,0.4)'
	                    }).width(cssAuto).height(cssAuto).appendTo(DOCUMENT.body);
	                self._tooltip = tooltip;
	            }
	            self._refreshTooltip(info, left, top, isAbsoluteDistanse);
	        },
	        _refreshTooltip: function (info, left, top, isAbsoluteDistanse) {
	            var self = this;
	            var sheet = getActiveSheet(self);
	            if (sheet) {
	                var tooltipElement = self._tooltip;
	                if (tooltipElement) {
	                    var tooltip = $$(tooltipElement);
	                    if (!info) {
	                        tooltip.hide();
	                    } else {
	                        tooltip.html(info);
	                        tooltip.show();
	                    }
	                    var offset = sheet._getCanvasOffset();
	                    if (isAbsoluteDistanse) {
	                        top -= offset.top;
	                        left -= offset.left;
	                    }
	                    var bounds = sheet._getBounds();
	                    top = Math_min(top, bounds.y + bounds.height - tooltip.outerHeight());
	                    left = Math_min(left, bounds.x + bounds.width - tooltip.outerWidth());
	
	                    if (!isNullOrUndefined(top)) {
	                        tooltip.css('top', top + offset.top);
	                    }
	                    if (!isNullOrUndefined(left)) {
	                        tooltip.css('left', left + offset.left);
	                    }
	                }
	            }
	        },
	        _removeTooltip: function () {
	            var self = this, tooltip = self._tooltip;
	            if (tooltip) {
	                $$(tooltip).remove();
	                self._tooltip = keyword_null;
	            }
	        },
	
	        _onCultureChanged: function (self) {
	            var sheets = self.sheets;
	            util_common._CacheMgr._clearFormatCache();
	            self.invalidateLayout();
	            for (var i = 0, len = sheets.length; i < len; i++) {
	                var sheet = sheets[i];
	                var rowCount = sheet.getRowCount();
	                var colCount = sheet.getColumnCount();
	                for (var row = 0; row < rowCount; row++) {
	                    for (var col = 0; col < colCount; col++) {
	                        var value = sheet.getValue(row, col);
	                        if (!(value instanceof Date)) {
	                            continue;
	                        }
	                        var style = sheet.getStyle(row, col);
	                        if (style) {
	                            style._setActualAutoFormatter(value);
	                        }
	                        sheet._setStyleObject(row, col, style);
	                    }
	                }
	            }
	            self.repaint();
	            Workbook._callFeatureHandler(self, 'onCultureChanged');
	        },
	        getTab: function () {
	            return this._tab;
	        }
	    };
	
	    exports.Workbook = Workbook;
	   
	
	   
	    var VSCROLLTOOLTIP_LEFT = 100, HSCROLLTOOLTIP_LEFT = 30, HSCROLLTOOLTIP_TOP = 40;
	
	    function ScrollService(workbook) {
	        this._wb = workbook;
	    }
	
	    $$_extend(ScrollService, {
	        _hscrollDelegate: function (e, data) {
	            var hostWorkbook = e.data;
	            var sheet = getActiveSheet(hostWorkbook);
	            if (sheet && data) {
	                var data_newValue = data.newValue, data_oldValue = data.oldValue,
	                    data_scrollEventType = data.scrollEventType;
	                var v = convertToInt(data_newValue, 10), newV;
	                v = sheet._getOriginalColIndex(v);
	                data_oldValue = data.oldValue = isNullOrUndefined(data_oldValue) ? 0 : convertToInt(data_oldValue, 10);
	                sheet._needSyncHScrollbarSize = false;
	                var scrollbarShowMax = hostWorkbook.options.scrollbarShowMax;
	                if (data_scrollEventType === 2  || data_scrollEventType === 0 ) {
	                    if (data_scrollEventType === 2 ) {
	                        v = sheet._getPrevPageLeftColumn();
	                    }
	                    newV = sheet._getScrollableColumn(v, true);
	                    if (newV !== -1 && newV !== v) {
	                        v = newV;
	                    }
	                    if (!scrollbarShowMax) {
	                        sheet._needSyncHScrollbarSize = true;
	                        data.ignoreUpdatePosition = true;
	                    }
	                } else if (data_scrollEventType === 3  || data_scrollEventType === 1 ) {
	                    if (data_scrollEventType === 3 ) {
	                        v = sheet._getPageRightColumn();
	                        if (v === sheet._scrollLeftCol) {
	                            v++;
	                        }
	                    }
	                    if (!scrollbarShowMax) {
	                        sheet._needSyncHScrollbarSize = true;
	                        if (data_scrollEventType === 1  && data_newValue === data_oldValue) {
	                            v++;
	                        }
	                    }
	                    newV = sheet._getScrollableColumn(v);
	                    if (newV !== -1 && newV !== v) {
	                        v = newV;
	                    }
	                }
	                var firstPageLeftColumn = sheet._getFirstPageLeftColumn(),
	                    lastVisualScrollColumn = sheet._getLastVisualScrollColumn();
	                if (v < firstPageLeftColumn) {
	                    v = firstPageLeftColumn;
	                }
	                if (v > lastVisualScrollColumn) {
	                    v = lastVisualScrollColumn;
	                }
	                var scrollValue = sheet._getVisibleColIndex(v);
	                if (data_newValue !== scrollValue) {
	                    data.newValue = scrollValue;
	                }
	                if (data_oldValue !== scrollValue) {
	                    hostWorkbook._scrollService._doScroll(v, true);
	                }
	            }
	        },
	        _hScrollStop: function (e) {
	            var hostWorkbook = e.data;
	            var sheet = getActiveSheet(hostWorkbook);
	            if (sheet) {
	                var scrollbarH = hostWorkbook._scrollbarH, value = sheet._getOriginalColIndex(scrollbarH.value());
	                var firstPageLeftColumn = sheet._getFirstPageLeftColumn(),
	                    lastVisualScrollColumn = sheet._getLastVisualScrollColumn(),
	                    formulaTextBox = sheet._formulaTextBox;
	                if (value < firstPageLeftColumn) {
	                    scrollbarH.value(sheet._getVisibleColIndex(firstPageLeftColumn));
	                } else if (value > lastVisualScrollColumn) {
	                    scrollbarH.value(sheet._getVisibleColIndex(lastVisualScrollColumn));
	                }
	
	                hostWorkbook._removeTooltip();
	                if (!hostWorkbook.options.scrollbarShowMax) {
	                    if (hostWorkbook._scrollService.scrolling) {
	                        sheet._needSyncHScrollbarSize = true;
	                    } else {
	                        hostWorkbook._resizeHScrollBar();
	                    }
	                }
	                if (formulaTextBox) {
	                    formulaTextBox.focus();
	                }
	            }
	        },
	        _hScrollMouseDown: function (e) {
	            var hostWorkbook = e.data;
	            if (hostWorkbook) {
	                var sheet = getActiveSheet(hostWorkbook);
	                if (sheet) {
	                   
	                   
	                    var touchHelper = hostWorkbook._scrollbarH._simulateMouseEvents;
	                    if (touchHelper && touchHelper._touchHandled) {
	                        sheet._isTouchMode = true;
	                    }
	                    sheet._setFocus();
	                    var showScrollTip = hostWorkbook.options.showScrollTip;
	                    if (showScrollTip === 1  || showScrollTip === 3 ) {
	                        var ele = $$(e.srcElement || e.target);
	                        var parent = ele.parent();
	                        if (ele && (ele.hasClass(CSS_SCROLL_HANDLE) || ele.hasClass(CSS_SCROLLBAR)) || parent && (parent.hasClass(CSS_SCROLL_HANDLE) || parent.hasClass(CSS_SCROLLBAR))) {
	                            hostWorkbook._scrollService._showScrollTooltip(false, e);
	                        }
	                    }
	                }
	            }
	        },
	        _vscrollDelegate: function (e, data) {
	            var hostWorkbook = e.data;
	            var sheet = getActiveSheet(hostWorkbook);
	            if (sheet && data) {
	                var data_newValue = data.newValue, data_oldValue = data.oldValue,
	                    data_scrollEventType = data.scrollEventType;
	                var v = convertToInt(data_newValue, 10), newV;
	                v = sheet._getOriginalRowIndex(v);
	                data_oldValue = data.oldValue = isNullOrUndefined(data_oldValue) ? 0 : convertToInt(data_oldValue, 10);
	                sheet._needSyncVScrollbarSize = false;
	                var scrollbarShowMax = hostWorkbook.options.scrollbarShowMax;
	                if (data_scrollEventType === 2  || data_scrollEventType === 0 ) {
	                    if (data_scrollEventType === 2 ) {
	                        v = sheet._getPrevPageTopRow();
	                    }
	                    newV = sheet._getScrollableRow(v, true);
	                    if (newV !== -1 && newV !== v) {
	                        v = newV;
	                    }
	                    if (!scrollbarShowMax) {
	                        sheet._needSyncVScrollbarSize = true;
	                        data.ignoreUpdatePosition = true;
	                    }
	                } else if (data_scrollEventType === 3  || data_scrollEventType === 1 ) {
	                    if (data_scrollEventType === 3 ) {
	                        v = sheet._getPageBottomRow();
	                        if (v === sheet._scrollTopRow) {
	                            v++;
	                        }
	                    }
	                    if (!scrollbarShowMax) {
	                        sheet._needSyncVScrollbarSize = true;
	                        if (data_scrollEventType === 1  && data_newValue === data_oldValue) {
	                            v++;
	                        }
	                    }
	                    newV = sheet._getScrollableRow(v);
	                    if (newV !== -1 && newV !== v) {
	                        v = newV;
	                    }
	                }
	                var firstPageTopRow = sheet._getFirstPageTopRow(),
	                    lastVisualScrollRow = sheet._getLastVisualScrollRow();
	                if (v < firstPageTopRow) {
	                    v = firstPageTopRow;
	                }
	                if (v > lastVisualScrollRow) {
	                    v = lastVisualScrollRow;
	                }
	                var scrollValue = sheet._getVisibleRowIndex(v);
	                if (data_newValue !== scrollValue) {
	                    data.newValue = scrollValue;
	                }
	                if (data_oldValue !== scrollValue) {
	                    hostWorkbook._scrollService._doScroll(v);
	                }
	            }
	        },
	        _vScrollStop: function (e) {
	            var hostWorkbook = e.data;
	            var sheet = getActiveSheet(hostWorkbook);
	            if (sheet) {
	                var scrollbarV = hostWorkbook._scrollbarV, value = sheet._getOriginalRowIndex(scrollbarV.value());
	                var firstPageTopRow = sheet._getFirstPageTopRow(),
	                    lastVisualScrollRow = sheet._getLastVisualScrollRow(),
	                    formulaTextBox = sheet._formulaTextBox;
	                if (value < firstPageTopRow) {
	                    scrollbarV.value(sheet._getVisibleRowIndex(firstPageTopRow));
	                } else if (value > lastVisualScrollRow) {
	                    scrollbarV.value(sheet._getVisibleRowIndex(lastVisualScrollRow));
	                }
	
	                hostWorkbook._removeTooltip();
	                if (!hostWorkbook.options.scrollbarShowMax) {
	                    if (hostWorkbook._scrollService.scrolling) {
	                        sheet._needSyncVScrollbarSize = true;
	                    } else {
	                        hostWorkbook._resizeVScrollBar();
	                    }
	                }
	                if (formulaTextBox) {
	                    formulaTextBox.focus();
	                }
	            }
	        },
	        _vScrollMouseDown: function (e) {
	            var hostWorkbook = e.data;
	            if (hostWorkbook) {
	                var sheet = getActiveSheet(hostWorkbook);
	                if (sheet) {
	                   
	                   
	                    var touchHelper = hostWorkbook._scrollbarV._simulateMouseEvents;
	                    if (touchHelper && touchHelper._touchHandled) {
	                        sheet._isTouchMode = true;
	                    }
	                    sheet._setFocus();
	                    var showScrollTip = hostWorkbook.options.showScrollTip;
	                    if (showScrollTip === 2  || showScrollTip === 3 ) {
	                        var ele = $$(e.srcElement || e.target);
	                        if (ele) {
	                            var parent = ele.parent();
	
	                            if (ele.hasClass(CSS_SCROLL_HANDLE) || parent && parent.hasClass(CSS_SCROLL_HANDLE) ||
	                                ele.hasClass(CSS_SCROLLBAR) || parent && parent.hasClass(CSS_SCROLLBAR)) {
	                                hostWorkbook._scrollService._showScrollTooltip(true, e);
	                            }
	                        }
	                    }
	                }
	            }
	        },
	        _scrollMouseUp: function (e) {
	            var hostWorkbook = e.data;
	            if (hostWorkbook) {
	                hostWorkbook._removeTooltip();
	            }
	        }
	    });
	    ScrollService.prototype = {
	        _doScroll: function (newIndex, isHorizontal) {
	            var self = this;
	            var sheet = getActiveSheet(self._wb);
	            if (sheet) {
	                self._scrolling = true;
	                self._newTop = isHorizontal ? sheet._scrollTopRow : newIndex;
	                self._newLeft = isHorizontal ? newIndex : sheet._scrollLeftCol;
	                window.setTimeout(function () {
	                    self._scrollView();
	                }, 0);
	            }
	        },
	        _scrollView: function () {
	            var self = this;
	            var sheet = getActiveSheet(self._wb);
	            if (sheet && self._scrolling) {
	                self._scrolling = false;
	                self._updateView();
	            }
	        },
	        _updateView: function () {
	            var self = this;
	            if (self._painting) {
	                return;
	            }
	
	            self._painting = true;
	            var workbook = self._wb;
	            var sheet = getActiveSheet(workbook);
	            if (sheet) {
	                var showScrollTip = workbook.options.showScrollTip, newTop = self._newTop, newLeft = self._newLeft;
	                if (newTop !== sheet._scrollTopRow) {
	                    self._vScrollTo(newTop);
	                    if (showScrollTip === 2  || showScrollTip === 3 ) {
	                        workbook._refreshTooltip(self._getScrollTooltipContent(true));
	                    }
	                } else if (newLeft !== sheet._scrollLeftCol) {
	                    self._hScrollTo(newLeft);
	                    if (showScrollTip === 1  || showScrollTip === 3 ) {
	                        workbook._refreshTooltip(self._getScrollTooltipContent(false));
	                    }
	                }
	            }
	            self._painting = false;
	        },
	        _vScrollTo: function (newTopRow) {
	            var sheet = getActiveSheet(this._wb);
	            if (sheet) {
	                var oldTopRow = sheet._scrollTopRow;
	                if (newTopRow === oldTopRow) {
	                    return;
	                }
	                sheet._scrollTopRow = newTopRow;
	                if (sheet._layoutSuspended > 0) {
	                    sheet._trigger(Events.TopRowChanged, {
	                        sheet: sheet,
	                        sheetName: sheet.name(),
	                        oldTopRow: oldTopRow,
	                        newTopRow: newTopRow
	                    });
	                    return;
	                }
	                var painted = false, options = sheet.options, offsetTop = options.sheetAreaOffset.top;
	                var adj = offsetTop;
	                var bounds = sheet._bounds, layout = sheet._getSheetLayout(), viewportY = layout._viewportY,
	                    viewportHeight = layout._viewportHeight, x, y, width = layout.width + options.sheetAreaOffset.left, height;
	                var render = sheet._render, ctx = render._getCtx();
	                if (newTopRow > oldTopRow) {
	                    var rl1, rl2;
	                    var rowLayouts = sheet._getRowLayout(1);
	                    if (rowLayouts && rowLayouts.length > 0) {
	                        rl1 = rowLayouts.findRow(newTopRow);
	                    }
	                    if (rl1) {
	                        var i = rowLayouts.length - 1;
	                        rl2 = rowLayouts[i];
	                        while (rl2.y + rl2.height > viewportY + viewportHeight) {
	                            i = i - 1;
	                            rl2 = rowLayouts[i];
	                        }
	                        if (rl2.row > newTopRow) {
	                            painted = true;
	
	                            x = bounds ? bounds.x : layout.x;
	                            y = rl1.y;
	                            height = rl2.y + rl2.height - rl1.y - adj;
	                           
	                            render._copyScreen(x, y, width, height, x, viewportY);
	
	                            if(!options.colHeaderVisible) {
	                               
	                                sheet.invalidateLayout();
	                                render._paintBody(ctx, new Rect(x, 0, width, offsetTop));
	                            }
	                           
	                            sheet.invalidateLayout();
	                            render._paintBody(ctx, new Rect(x, viewportY + height, width, viewportHeight - height));
	                            render._paintAdornment(ctx, new Rect(x, viewportY - 2, width, viewportHeight + 2));//2 for selection border
	
	                        }
	                    }
	                } else {
	                    var h = 0;
	                    for (var j = newTopRow; j < oldTopRow && h < viewportHeight; j++) {
	                        h += sheet._getZoomRowHeight(j);
	                    }
	                    if (h < viewportHeight) {
	                        painted = true;
	
	                        x = bounds ? bounds.x : layout.x;
	                        y = viewportY;
	                        height = viewportHeight - h;
	                        if (sheet.frozenTrailingRowCount() > 0) {
	                            height -= 1;
	                        }
	                       
	                        render._copyScreen(x, y, width, height, x, y + h);
	                       
	                        sheet.invalidateLayout();
	                       
	                        var extensionForRowOutlines = sheet.rowOutlines && !sheet.rowOutlines._isEmpty() ? sheet.rowOutlines._getOutlineLineWidth() + offsetTop + 1 : 0;
	                        render._paintBody(ctx, new Rect(x, y - offsetTop, width, h + offsetTop + extensionForRowOutlines + 1));
	                        render._paintAdornment(ctx, new Rect(x, viewportY - 2, width, viewportHeight + 2));//2 for selection border
	                    }
	                }
	                if (!painted) {
	                    sheet.invalidateLayout();
	                    sheet.repaint();
	                }
	                sheet._trigger(Events.TopRowChanged, {
	                    sheet: sheet,
	                    sheetName: sheet.name(),
	                    oldTopRow: oldTopRow,
	                    newTopRow: newTopRow
	                });
	                var handler = sheet._eventHandler;
	                if (handler) {
	                    handler._updateEditingEditor();
	                }
	            }
	        },
	        _hScrollTo: function (newLeftCol) {
	            var sheet = getActiveSheet(this._wb);
	            if (sheet) {
	                var oldLeftCol = sheet._scrollLeftCol;
	                if (newLeftCol === oldLeftCol) {
	                    return;
	                }
	                sheet._scrollLeftCol = newLeftCol;
	                if (sheet._layoutSuspended > 0) {
	                    sheet._trigger(Events.LeftColumnChanged, {
	                        sheet: sheet,
	                        sheetName: sheet.name(),
	                        oldLeftCol: oldLeftCol,
	                        newLeftCol: newLeftCol
	                    });
	                    return;
	                }
	                var painted = false, options = sheet.options, offsetLeft = options.sheetAreaOffset.left;
	                var adj = offsetLeft;
	                var bounds = sheet._bounds, layout = sheet._getSheetLayout(), viewportX = layout._viewportX,
	                    viewportWidth = layout._viewportWidth, x, y, width, height = layout.height + options.sheetAreaOffset.top;
	                var render = sheet._render, ctx = render._getCtx();
	                if (newLeftCol > oldLeftCol) {
	                    var cl1, cl2;
	                    var colLayouts = sheet._getColumnLayout(1);
	                    if (colLayouts && colLayouts.length > 0) {
	                        cl1 = colLayouts.findCol(newLeftCol);
	                    }
	                    if (cl1) {
	                        var j = colLayouts.length - 1;
	                        cl2 = colLayouts[j];
	                        while (cl2.x + cl2.width > viewportX + viewportWidth) {
	                            j = j - 1;
	                            cl2 = colLayouts[j];
	                        }
	                        if (cl2.col > newLeftCol) {
	                            painted = true;
	
	                            x = cl1.x;
	                            y = bounds ? bounds.y : layout.y;
	                            width = cl2.x + cl2.width - cl1.x - adj;
	                           
	                            render._copyScreen(x, y, width, height, viewportX, y);
	
	                            if(!options.rowHeaderVisible) {
	                           
	                                sheet.invalidateLayout();
	                                render._paintBody(ctx, new Rect(0, y, offsetLeft, height));
	                            }
	
	                            sheet.invalidateLayout();
	                            render._paintBody(ctx, new Rect(viewportX + width, y, viewportWidth - width, height));
	                            render._paintAdornment(ctx, new Rect(viewportX - 2, y, viewportWidth + 2, height));//2 for selection border
	
	                        }
	                    }
	                } else {
	                    var w = 0;
	                    for (var i = newLeftCol; i < oldLeftCol && w < viewportWidth; i++) {
	                        w += sheet._getZoomColumnWidth(i);
	                    }
	                    if (w < viewportWidth) {
	                        painted = true;
	
	                        x = viewportX;
	                        y = bounds ? bounds.y : layout.y;
	                        width = viewportWidth - w;
	                        if (sheet.frozenTrailingColumnCount() > 0) {
	                            width -= 1;
	                        }
	                       
	                        render._copyScreen(x, y, width, height, x + w, y);
	                       
	                        sheet.invalidateLayout();
	
	                       
	                        var extensionForColumnOutlines = sheet.columnOutlines && !sheet.columnOutlines._isEmpty() ? sheet.columnOutlines._getOutlineLineWidth() + offsetLeft + 1 : 0;
	                        render._paintBody(ctx, new Rect(x - offsetLeft, y, w + offsetLeft + extensionForColumnOutlines + 1, height));
	                        render._paintAdornment(ctx, new Rect(viewportX - 2, y, viewportWidth + 2, height));//2 for selection border
	
	                    }
	                }
	
	                if (!painted) {
	                    sheet.invalidateLayout();
	                    sheet.repaint();
	                }
	                sheet._trigger(Events.LeftColumnChanged, {
	                    sheet: sheet,
	                    sheetName: sheet.name(),
	                    oldLeftCol: oldLeftCol,
	                    newLeftCol: newLeftCol
	                });
	                var handler = sheet._eventHandler;
	                if (handler) {
	                    handler._updateEditingEditor();
	                }
	            }
	        },
	        _doMouseWheel: function (event, detailY, detailX) {
	            var self = this, wb = self._wb, sheet = getActiveSheet(wb), retY = false, retX = false;
	            var scrollbarShowMax = wb.options.scrollbarShowMax;
	            if (sheet) {
	                if (event.ctrlKey) {
	                    if (wb.options.allowUserZoom) {
	                       
	                        var oldZoomFactor = sheet.zoom();
	                        var newZoomFactor = oldZoomFactor - 0.05 * detailY;
	                        if (sheet.isEditing() && !sheet.endEdit()) {
	                            return;
	                        }
	                        sheet._commandManager().execute({
	                            cmd: 'zoom',
	                            sheetName: sheet.name(),
	                            zoomFactor: newZoomFactor
	                        });
	
	                        newZoomFactor = sheet.zoom();
	                        if (oldZoomFactor !== newZoomFactor) {
	                            sheet._trigger(Events.UserZooming, {
	                                sheet: sheet,
	                                sheetName: sheet.name(),
	                                oldZoomFactor: oldZoomFactor,
	                                newZoomFactor: newZoomFactor
	                            });
	                        }
	                    } else {
	                       
	                        return true;
	                    }
	                } else {
	                    detailX = detailX || 0;
	
	                    var oldTopRow = sheet._scrollTopRow, newTopRow = self._getNewTopRow(sheet, detailY);
	                    if (oldTopRow !== newTopRow) {
	                        self._vScrollTo(newTopRow);
	                        sheet._syncVScrollbarPosition();
	                        if (!scrollbarShowMax) {
	                            sheet._syncVScrollbarSize();
	                        }
	                    } else {
	                        retY = true;
	                    }
	
	                    var oldLeftCol = sheet._scrollLeftCol, newLeftCol = self._getNewLeftCol(sheet, detailX);
	                    if (oldLeftCol !== newLeftCol) {
	                        self._hScrollTo(newLeftCol);
	                        sheet._syncHScrollbarPosition();
	                        if (!scrollbarShowMax) {
	                            sheet._syncHScrollbarSize();
	                        }
	                    } else {
	                        retX = true;
	                    }
	                }
	
	                var canvasOffset = sheet._getCanvasOffset();
	                var target = sheet.hitTest(event.pageX - canvasOffset.left, event.pageY - canvasOffset.top);
	                var oldTarget = sheet._currentTarget, cellTypeHitInfo = oldTarget && oldTarget.cellTypeHitInfo;
	                if (cellTypeHitInfo) {
	                    cellTypeHitInfo.cellRect = sheet.getCellRect(oldTarget.row, oldTarget.col);
	                }
	                var eventHandler = sheet._eventHandler;
	                eventHandler._updateCanvasCursor(target);
	                eventHandler._setHoverCell(target);
	            }
	            return retY && retX;
	        },
	        _getNewTopRow: function (sheet, detailY) {
	            var newTopRow = sheet._scrollTopRow;
	            var frozenRowCount = sheet.frozenRowCount();
	            if (frozenRowCount > 0) {
	                if (newTopRow === 0 && detailY > 0) {
	                    newTopRow = frozenRowCount;
	                } else if (detailY < 0 && newTopRow === frozenRowCount - detailY) {
	                    newTopRow = 0;
	                }
	            }
	
	           
	            var tmpRow = sheet._getScrollableRow(newTopRow + detailY, detailY < 0);
	            if (tmpRow !== -1) {
	                newTopRow = tmpRow;
	            } else {
	                newTopRow = newTopRow + detailY;
	            }
	            var firstPageTopRow = sheet._getFirstPageTopRow(),
	                lastVisualScrollRow = sheet._getLastVisualScrollRow();
	            if ((sheet.getRowCount() - frozenRowCount - sheet.frozenTrailingRowCount() <= 0) || firstPageTopRow === keyword_null) {
	                newTopRow = sheet._scrollTopRow;
	            } else {
	                if (newTopRow < firstPageTopRow) {
	                    newTopRow = firstPageTopRow;
	                } else if (newTopRow > lastVisualScrollRow) {
	                    newTopRow = lastVisualScrollRow;
	                }
	                if (newTopRow === keyword_null) {
	                    newTopRow = -1;
	                }
	            }
	            return newTopRow;
	        },
	        _getNewLeftCol: function (sheet, detailX) {
	            var newLeftCol = sheet._scrollLeftCol;
	            var frozenColCount = sheet.frozenColumnCount();
	            if (frozenColCount > 0) {
	                if (newLeftCol === 0 && detailX > 0) {
	                    newLeftCol = frozenColCount;
	                } else if (detailX < 0 && newLeftCol === frozenColCount - detailX) {
	                    newLeftCol = 0;
	                }
	            }
	
	           
	            var tmpCol = sheet._getScrollableColumn(newLeftCol + detailX, detailX < 0);
	            if (tmpCol !== -1) {
	                newLeftCol = tmpCol;
	            } else {
	                newLeftCol = newLeftCol + detailX;
	            }
	            var firstPageLeftColumn = sheet._getFirstPageLeftColumn(),
	                lastVisualScrollColumn = sheet._getLastVisualScrollColumn();
	            if ((sheet.getColumnCount() - frozenColCount - sheet.frozenTrailingColumnCount() <= 0) || firstPageLeftColumn === keyword_null) {
	                newLeftCol = sheet._scrollLeftCol;
	            } else {
	                if (newLeftCol < firstPageLeftColumn) {
	                    newLeftCol = firstPageLeftColumn;
	                } else if (newLeftCol > lastVisualScrollColumn) {
	                    newLeftCol = lastVisualScrollColumn;
	                }
	                if (newLeftCol === keyword_null) {
	                    newLeftCol = -1;
	                }
	            }
	            return newLeftCol;
	        },
	        _showScrollTooltip: function (isVScroll, e) {
	            var self = this, wb = self._wb;
	            var top, left;
	            var sheet = getActiveSheet(wb);
	            if (sheet) {
	                if (isVScroll) {
	                    top = e.pageY;
	                    left = e.pageX - VSCROLLTOOLTIP_LEFT;
	                } else {
	                    top = e.pageY - HSCROLLTOOLTIP_TOP;
	                    left = e.pageX - HSCROLLTOOLTIP_LEFT;
	                }
	
	                wb._showTooltip(self._getScrollTooltipContent(isVScroll), left, top, true);
	            }
	        },
	        _getScrollTooltipContent: function (isVScroll) {
	            var sheet = getActiveSheet(this._wb);
	            var info, num = sheet._scrollLeftCol + 1;
	            if (sheet) {
	                if (isVScroll) {
	                    info = sR().Tip_Row + (sheet._scrollTopRow + 1);
	                } else {
	                    if (sheet.options.colHeaderAutoText !== 1 ) {
	                        num = sheet._indexToLetters(num);
	                    }
	                    info = sR().Tip_Column + num;
	                }
	            }
	            return info;
	        }
	    };
	   
	
	   
	    
	
	   
	    
	
	   
	    
	
	   
	    
	
	   
	    
	
	   
	    
	
	   
	    
	
	    module.exports = exports;
	
	
	}());

/***/ }),
/* 23 */
/***/ (function(module, exports) {

	module.exports = GC.Spread.Commands;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var exports = __webpack_require__(1);
	    var Common = __webpack_require__(5);
	    var Formatter = __webpack_require__(6);
	    var Worksheet = __webpack_require__(17).Worksheet;
	    var Style = __webpack_require__(12).Style;
	    var util_common = __webpack_require__(3);
	    var $ = __webpack_require__(4).GC$;
	    var staticMembers = __webpack_require__(25).staticMembers;
	
	    var isNullOrUndefined = Common._Types._isNullOrUndefined, ArrayHelper_contains = Common._ArrayHelper._contains,
	        StringHelper = Common._StringHelper, StringHelper_endsWith = StringHelper._endsWith,
	        Events = util_common.Events, Events_CellChanged = Events.CellChanged,
	        Events_ColumnWidthChanging = Events.ColumnWidthChanging, Events_ColumnWidthChanged = Events.ColumnWidthChanged,
	        Events_RowHeightChanging = Events.RowHeightChanging, Events_RowHeightChanged = Events.RowHeightChanged,
	        Range = util_common.Range, Rect = util_common.Rect, _CacheMgr = util_common._CacheMgr,
	        util_common_util = util_common._util, browser = util_common_util._browser,
	        isDefined = util_common_util._isDefined,
	        $_extend = $.extend, $_inherit = $.inherit;
	
	    var keyword_null = null, keyword_undefined = void 0, Math_max = Math.max,
	        Math_floor = Math.floor;
	
	   
	   
	   
	   
	   
	   
	   
	   
	
	   
	    
	    exports.ClipboardPasteOptions = {
	        
	        all: 0,
	        
	        values: 1,
	        
	        formatting: 2,
	        
	        formulas: 3
	    };
	
	   
	    
	    exports.CopyToOptions = {
	        
	        value: 0x01,
	        
	        formula: 0x02,
	        
	        comment: 0x04,
	        
	        outline: 0x08,
	        
	        sparkline: 0x10,
	        
	        span: 0x20,
	        
	        style: 0x40,
	        
	        tag: 0x80,
	        
	        bindingPath: 0x100,
	        
	        conditionalFormat: 0x200,
	        
	        all: 0x3ff
	    };
	
	    function getSheetRowCount(sheet, sheetArea) {
	        return sheet.getRowCount(sheetArea);
	    }
	
	    function getSheetColumnCount(sheet, sheetArea) {
	        return sheet.getColumnCount(sheetArea);
	    }
	
	    function getRowCount(obj) {
	        return obj.rowCount;
	    }
	
	    function getColCount(obj) {
	        return obj.colCount;
	    }
	
	    function allowExtendPasteRange(sheet) {
	        var workbook = sheet.parent;
	        return workbook && workbook.options.allowExtendPasteRange;
	    }
	
	    function allowCopyPasteExcelStyle(sheet) {
	        var workbook = sheet.parent;
	        return workbook && workbook.options.allowCopyPasteExcelStyle;
	    }
	
	    function copyPasteHeaderOptions(sheet) {
	        var workbook = sheet.parent;
	        return workbook && workbook.options.copyPasteHeaderOptions;
	    }
	
	   
	    function sR() {
	        return Common._getResource(exports.SR)();
	    }
	
	    function raiseInvalidRangeException(item, value, start, end) {
	        throw new Error(StringHelper._format(sR().Exp_InvalidAndSpace, [item, value, start, end]));
	    }
	
	    function suspendPaint(sheet) {
	        sheet.suspendPaint();
	    }
	
	    function resumePaint(sheet) {
	        sheet.resumePaint();
	    }
	
	    function suspendEvent(sheet) {
	        sheet.suspendEvent();
	    }
	
	    function resumeEvent(sheet) {
	        sheet.resumeEvent();
	    }
	
	    function suspendCalcService(sheet, ignoreDirty) {
	        if (sheet && exports._supportsCalc) {
	            sheet.suspendCalcService(ignoreDirty);
	        }
	    }
	
	    function resumeCalcService(sheet, recalcAll) {
	        if (sheet && exports._supportsCalc) {
	            sheet.resumeCalcService(recalcAll);
	        }
	    }
	
	    function isHiddenInSpan(sheet, row, col, sheetArea, forClipboard) {
	        var span = sheet.getSpan(row, col, sheetArea);
	        if (span && forClipboard && (span.row !== row || span.col !== col)) {
	            return true;
	        }
	    }
	
	    function ImportExportOptions(flags) {
	        var self = this;
	        self._rowHeader = ((flags & 1 ) === 1 );
	        self._columnHeader = ((flags & 2 ) === 2 );
	        self._unFormatted = ((flags & 8 ) === 8 );
	        self._formula = exports._supportsCalc && ((flags & 16 ) === 16 );
	        self._expandRows = true;
	        self._expandColumns = true;
	    }
	
	    function parseText(data, rowDelimiter, columnDelimiter, cellDelimiter) {
	        if (isNullOrUndefined(data) || data === '') {
	            return keyword_null;
	        }
	        if (isNullOrUndefined(rowDelimiter) || rowDelimiter === '') {
	            rowDelimiter = '\r\n';
	        }
	        var rowDelimiter2 = '\n';
	        if (isNullOrUndefined(columnDelimiter) || columnDelimiter === '') {
	            columnDelimiter = '\t';
	        }
	        if (isNullOrUndefined(cellDelimiter) || cellDelimiter === '') {
	            cellDelimiter = '"';
	        }
	        if (!StringHelper_endsWith(data, rowDelimiter)) {
	            data += rowDelimiter;
	        }
	        var sheetData = [], rowData = [];
	        var sbr = '', sbrLength;
	        var inCell = false;
	        var dl = cellDelimiter.length;
	        var rdl = rowDelimiter.length;
	        var rdl2 = rowDelimiter2.length;
	        var cdl = columnDelimiter.length;
	        var dataLength = data.length;
	        for (var index = 0; index < dataLength; index++) {
	            sbr += data[index];
	            sbrLength = sbr.length;
	           
	            if (sbrLength >= dl && cellDelimiter === sbr.substr(sbrLength - dl, dl)) {
	               
	               
	               
	                if (inCell && dataLength >= index + 1 + dl && cellDelimiter === data.substr(index + 1, dl)) {
	                    index += dl;
	                } else if (!inCell) {
	                    var temp = sbr;
	                    if (temp.indexOf(cellDelimiter) === 0) {
	                        sbr = sbr.substr(0, sbrLength - dl);
	                        inCell = true;
	                    }
	                } else {
	                    sbr = sbr.substr(0, sbrLength - dl);
	                    inCell = false;
	                }
	            } else if (!inCell && sbrLength >= cdl && columnDelimiter === sbr.substr(sbrLength - cdl, cdl)) {
	                sbr = sbr.substr(0, sbrLength - cdl);
	                rowData.push(sbr.toString());
	                sbr = '';
	            } else if (!inCell && sbrLength >= rdl && rowDelimiter === sbr.substr(sbrLength - rdl, rdl)) {
	                sbr = sbr.substr(0, sbrLength - rdl);
	                rowData.push(sbr.toString());
	                sheetData.push(rowData);
	                rowData = [];
	                sbr = '';
	            } else if (!inCell && sbrLength >= rdl2 && rowDelimiter2 === sbr.substr(sbrLength - rdl2, rdl2)) {
	                sbr = sbr.substr(0, sbrLength - rdl2);
	                rowData.push(sbr.toString());
	                sheetData.push(rowData);
	                rowData = [];
	                sbr = '';
	            } else if (inCell && dataLength >= index + 1 + cdl && columnDelimiter === data.substr(index + 1, cdl) && columnDelimiter !== ',') {
	               
	                index += dl;
	            }
	        }
	       
	       
	        if (inCell) {
	           
	           
	            if (rowData.length > 0) {
	                for (var i = 0; i < sheetData.length; i++) {
	                    if (sheetData[i] === rowData) {
	                        break;
	                    }
	                }
	                if (i >= sheetData.length) {
	                    sheetData.push(rowData);
	                }
	            }
	            var inCellStr = sbr.toString();
	           
	           
	            if (inCellStr) {
	                inCellStr = inCellStr.replace(new RegExp(columnDelimiter, 'g'), '');
	                if (StringHelper_endsWith(inCellStr, rowDelimiter)) {
	                    inCellStr = inCellStr.substr(0, inCellStr.length - rdl);
	                }
	                if (sheetData.length === 0) {
	                    sheetData.push([inCellStr]);
	                }
	            }
	        }
	       
	        if (sheetData.length === 0) {
	            var text = data;
	            if (StringHelper_endsWith(data, rowDelimiter)) {
	                text = text.substr(0, text.length - rdl);
	            }
	            sheetData.push([text]);
	        }
	        return sheetData;
	    }
	
	    function setSheetData(sheet, rowIndex, columnIndex, data, flags) {
	        var dataRowCount = data.length;
	        var dataColumnCount = getMaxLength(data);
	        if (dataRowCount === 0 || dataColumnCount === 0) {
	            return;
	        }
	        var opt = new ImportExportOptions(flags);
	       
	        if (sheet) {
	            if (getSheetColumnCount(sheet, 2 ) <= 0) {
	                opt._rowHeader = false;
	            }
	            if (getSheetRowCount(sheet, 1 ) <= 0) {
	                opt._columnHeader = false;
	            }
	        }
	
	        var rowHeaderColumnCount = opt._rowHeader ? getSheetColumnCount(sheet, 2 ) : 0;
	        var columnHeaderRowCount = opt._columnHeader ? getSheetRowCount(sheet, 1 ) : 0;
	        var columnFooterRowCount = 0;
	       
	        dataColumnCount -= rowHeaderColumnCount;
	        if (dataColumnCount <= 0) {
	            dataColumnCount = 0;
	        }
	        dataRowCount -= columnHeaderRowCount;
	        if (dataRowCount <= 0) {
	            columnFooterRowCount = 0;
	        }
	        dataRowCount -= columnFooterRowCount;
	        if (dataRowCount <= 0) {
	            dataRowCount = 0;
	        }
	       
	        if (opt._expandRows && rowIndex + dataRowCount > getSheetRowCount(sheet)) {
	            sheet.setRowCount(rowIndex + dataRowCount);
	        }
	        if (opt._expandColumns && columnIndex + dataColumnCount > getSheetColumnCount(sheet)) {
	            sheet.setColumnCount(columnIndex + dataColumnCount);
	        }
	        for (var r = 0, sheetRowIndex = 0; r < data.length; r++, sheetRowIndex++) {
	            var rowData = data[r];
	            if (rowData.length <= 0) {
	                continue;
	            }
	           
	            if (columnHeaderRowCount > 0 && r < columnHeaderRowCount) {
	                setRowData(sheet, rowData, sheetRowIndex, columnIndex, dataColumnCount, 1 , opt);
	            } else if (dataRowCount > 0 && sheetRowIndex < getSheetRowCount(sheet)) {
	                if (r === columnHeaderRowCount) {
	                    sheetRowIndex = rowIndex;
	                }
	                setRowData(sheet, rowData, sheetRowIndex, 0, rowHeaderColumnCount, 2 , opt);
	                rowData.splice(0, rowHeaderColumnCount);
	                setRowData(sheet, rowData, sheetRowIndex, columnIndex, dataColumnCount, 3 , opt);
	            }
	        }
	    }
	
	    function setRowData(sheet, rowData, sheetRowIndex, columnIndex, columnCount, area, opt) {
	        for (var c = 0, sheetColumnIndex = columnIndex; c < rowData.length; c++, sheetColumnIndex++) {
	            if (columnCount > 0 && sheetColumnIndex < getSheetColumnCount(sheet, area)) {
	                setCellData(sheet, area, sheetRowIndex, sheetColumnIndex, rowData[c], opt);
	            }
	        }
	    }
	
	    function setCellData(sheet, area, rowIndex, columnIndex, value, opt) {
	        var setvalue = value;
	        var autodisplayformatter = keyword_null;
	        if (opt._unFormatted === false) {
	            var formaterRef = {value: keyword_null};
	            setvalue = util_common_util._parseText2Value(keyword_null, value, !opt._unFormatted, formaterRef);
	            autodisplayformatter = formaterRef.value;
	        }
	        if (isNullOrUndefined(setvalue)) {
	            sheet.setValue(rowIndex, columnIndex, setvalue, area);
	        } else if (value !== '') {
	            if (opt._formula && value[0] === '=' && value.length > 1) {
	                try {
	                    sheet.setFormula(rowIndex, columnIndex, value.substr(1));
	                } catch (ex) {
	                    sheet.setText(rowIndex, columnIndex, value, area);
	                }
	            } else {
	                var formatter = sheet._getStyleProperty(rowIndex, columnIndex, 'formatter', area);
	                if (opt._unFormatted === false && autodisplayformatter) {
	                    if (!formatter) {
	                       
	                        autodisplayformatter.isAuto = true;
	                        sheet.getCell(rowIndex, columnIndex, area)._setStyleProperty('_autoFormatter', autodisplayformatter);
	
	                       
	                       
	                       
	                       
	                        var t = value;
	                        var ct = sheet.getCellType(rowIndex, columnIndex, area);
	                        var formatStr = autodisplayformatter.formatString();
	                        if (ct && ct.typeName === '7') {
	                            var context = {sheet: sheet, row: rowIndex, col: columnIndex, sheetArea: area};
	                            t = ct.parse(value, formatStr, context);
	                            setvalue = isNullOrUndefined(t) ? value : t;
	                        }
	                       
	                    } else if (formatter) {
	                        if (typeof formatter === "string" && Formatter) {
	                            formatter = new Formatter.GeneralFormatter(formatter);
	                        }
	                        var parseValue = formatter.parse && formatter.parse(value);
	                        setvalue = isNullOrUndefined(parseValue) ? setvalue : parseValue;
	                    }
	                } else if (formatter) {
	                    sheet.getCell(rowIndex, columnIndex, area).formatter(keyword_null);
	                }
	                sheet.setValue(rowIndex, columnIndex, setvalue, area);
	            }
	        } else {
	            sheet.setValue(rowIndex, columnIndex, keyword_null, area);
	        }
	    }
	
	    function getMaxLength(data) {
	        var len = 0;
	        for (var i = 0; i < (data && data.length); i++) {
	            var list = data[i];
	            len = Math_max(list.length, len);
	        }
	        return len;
	    }
	
	    function setRangeText(sheet, row, column, data, rowDelimiter, columnDelimiter, cellDelimiter, flags) {
	        if (!sheet) {
	            throw new Error(sR().Exp_SheetIsNull);
	        }
	        if (row < -1 || row >= getSheetRowCount(sheet)) {
	            raiseInvalidRangeException('row', row, '-1', getSheetRowCount(sheet) - 1);
	        }
	        if (column < -1 || column >= getSheetColumnCount(sheet)) {
	            raiseInvalidRangeException('column', column, '-1', getSheetColumnCount(sheet) - 1);
	        }
	        if (isNullOrUndefined(data) || data === '') {
	            return;
	        }
	       
	        if (row === -1) {
	            row = 0;
	        }
	        if (column === -1) {
	            column = 0;
	        }
	        var sheetData = parseText(data, rowDelimiter, columnDelimiter, cellDelimiter);
	        if (sheetData && sheetData.length > 0) {
	           
	            setSheetData(sheet, row, column, sheetData, flags);
	        }
	    }
	
	    function getRangeText(sheet, row, rowCount, column, columnCount, rowDelimiter, columnDelimiter, cellDelimiter, forceCellDelimiter, ignoredRows, ignoredCols, forClipboard, replaceEmpty, forCompare) {
	        if (!sheet) {
	            throw new Error(sR().Exp_SheetIsNull);
	        }
	        var sheetRowCount = getSheetRowCount(sheet), sheetColumnCount = getSheetColumnCount(sheet);
	        if (row < -1 || row >= sheetRowCount) {
	            raiseInvalidRangeException('row', row, '-1', sheetRowCount - 1);
	        }
	        if (rowCount < -1 || row + rowCount > sheetRowCount) {
	            raiseInvalidRangeException('rowCount', rowCount, '-1', sheetRowCount - row);
	        }
	        if (column < -1 || column >= sheetColumnCount) {
	            raiseInvalidRangeException('column', column, '-1', sheetColumnCount - 1);
	        }
	        if (columnCount < -1 || column + columnCount > sheetColumnCount) {
	            raiseInvalidRangeException('columnCount', columnCount, '-1', sheetColumnCount - column);
	        }
	       
	        var endRow = -1;
	        var endColumn = -1;
	       
	        var includeColumnHeader = false;
	        var includeRowHeader = false;
	        if (row === -1 && column === -1 && rowCount === -1 && columnCount === -1) {
	           
	            row = 0;
	            column = 0;
	            endRow = getSheetRowCount(sheet) - 1;
	            endColumn = getSheetColumnCount(sheet) - 1;
	        } else {
	            if (row === -1) {
	                row = 0;
	               
	                if ((sheet.parent.options.copyPasteHeaderOptions & 2) === 2 ) {
	                    includeColumnHeader = true;
	                }
	            }
	            if (column === -1) {
	                column = 0;
	               
	                if ((sheet.parent.options.copyPasteHeaderOptions & 1) === 1 ) {
	                    includeRowHeader = true;
	                }
	            }
	            if (rowCount === -1) {
	                rowCount = getSheetRowCount(sheet) - row;
	            }
	            if (columnCount === -1) {
	                columnCount = getSheetColumnCount(sheet) - column;
	            }
	            endRow = row + rowCount - 1;
	            endColumn = column + columnCount - 1;
	        }
	        if (isNullOrUndefined(rowDelimiter) || rowDelimiter === '') {
	            rowDelimiter = '\r\n';
	        }
	        if (isNullOrUndefined(columnDelimiter) || columnDelimiter === '') {
	            columnDelimiter = '\t';
	        }
	        if (isNullOrUndefined(cellDelimiter) || cellDelimiter === '') {
	            cellDelimiter = '"';
	        }
	
	        var cellDelimiterReg = new RegExp(cellDelimiter, 'g');
	       
	        var rowHeaderText = null, columnHeaderText = null,
	            viewportText = getRangeTextImp(sheet, row, endRow, column, endColumn, 3, ignoredRows, ignoredCols, rowDelimiter, columnDelimiter, cellDelimiter, cellDelimiterReg, forceCellDelimiter, forClipboard, replaceEmpty, forCompare);
	        if (includeRowHeader) {
	            var rowHeaderCount = sheet.getColumnCount(2 );
	            rowHeaderText = getRangeTextImp(sheet, row, endRow, 0, rowHeaderCount - 1, 2 , ignoredRows, ignoredCols, rowDelimiter, columnDelimiter, cellDelimiter, cellDelimiterReg, forceCellDelimiter, forClipboard, replaceEmpty, forCompare);
	        }
	        if (includeColumnHeader) {
	            var colHeaderRowCount = sheet.getRowCount(1 );
	            columnHeaderText = getRangeTextImp(sheet, 0, colHeaderRowCount - 1, column, endColumn, 1 , ignoredRows, ignoredCols, rowDelimiter, columnDelimiter, cellDelimiter, cellDelimiterReg, forceCellDelimiter, forClipboard, replaceEmpty, forCompare);
	        }
	        return join(viewportText, rowHeaderText, columnHeaderText, rowDelimiter, columnDelimiter);
	    }
	
	    function join(viewportTextRage, rowHeaderTextRange, colHeaderTextRage, rowDelimiter, columnDelimiter) {//eslint-disable-line
	        var arrayBuilder = viewportTextRage, rowHeaderColumnCount = 0;
	        var concatOnRow = function (sourceRange, targetRange) {
	            var rangeBuilder = [], rowCount = sourceRange.length;
	            for (var row = 0; row < rowCount; row++) {
	                rangeBuilder.push(sourceRange[row].concat(targetRange[row]));
	            }
	            return rangeBuilder;
	        };
	
	        if (rowHeaderTextRange) {
	           
	           
	            rowHeaderColumnCount = rowHeaderTextRange[0].length;
	            arrayBuilder = concatOnRow(rowHeaderTextRange, viewportTextRage);
	        }
	        if (colHeaderTextRage) {
	            var colHeaderRowCount = colHeaderTextRage.length;
	            var cornerTextRange = null;
	            if (rowHeaderColumnCount) {
	               
	               
	                cornerTextRange = getRangeTextImp(null, 0, colHeaderRowCount - 1, 0, rowHeaderColumnCount - 1, null, [], [], rowDelimiter, columnDelimiter, null, null, null, false, false);
	                colHeaderTextRage = concatOnRow(cornerTextRange, colHeaderTextRage);
	            }
	           
	           
	           
	            arrayBuilder = colHeaderTextRage.concat(arrayBuilder);
	        }
	        return buildStr(arrayBuilder, rowDelimiter, columnDelimiter);
	    }
	
	    function buildStr(arrayBuilder, rowDelimiter, columnDelimiter) {
	        var row, col, strBuilder = '';
	        var rowCount = arrayBuilder.length;
	        for (row = 0; row < rowCount; row++) {
	            for (col = 0; col < arrayBuilder[row].length; col++) {
	                if (col !== 0) {
	                    strBuilder += columnDelimiter;
	                }
	                strBuilder += arrayBuilder[row][col];
	            }
	
	           
	           
	            strBuilder += rowDelimiter;
	           
	        }
	        return strBuilder;
	    }
	
	    function getRangeTextImp(sheet, row, endRow, column, endColumn, sheetArea, ignoredRows, ignoredCols, rowDelimiter, columnDelimiter, cellDelimiter, cellDelimiterReg, forceCellDelimiter, forClipboard, replaceEmpty, forCompare) {
	        var rangeText = [];
	        var r, c, allowExcelStyle = sheet && allowCopyPasteExcelStyle(sheet);
	        for (r = row; r <= endRow; r++) {
	            if (ignoredRows && ArrayHelper_contains(ignoredRows, r)) {
	                continue;
	            }
	            var rowText = [];
	            for (c = column; c <= endColumn; c++) {
	                if (ignoredCols && ArrayHelper_contains(ignoredCols, c)) {
	                    continue;
	                }
	                var cellText = '';
	                if (sheet && !isHiddenInSpan(sheet, r, c, sheetArea, forClipboard)) {
	                    cellText = sheet.getText(r, c, sheetArea);
	                    if (forCompare
	                        && allowExcelStyle
	                        && cellText
	                        && (cellText[0] === ' ' || cellText[cellText.length - 1] === ' ')
	                        && typeof sheet.getValue(r, c, sheetArea) === 'number') {
	                       
	                       
	                       
	                       
	                       
	                       
	                        cellText = cellText.trim();
	                    }
	                }
	                cellText = getCellStr(cellText, forClipboard, allowExcelStyle, cellDelimiterReg, cellDelimiter, replaceEmpty, forceCellDelimiter, columnDelimiter, rowDelimiter);
	                rowText.push(cellText);
	            }
	            rangeText.push(rowText);
	        }
	        return rangeText;
	    }
	
	    function getCellStr(cellData, forClipboard, copyPasteExcelStyle, cellDelimiterReg, cellDelimiter, replaceEmpty, forceCellDelimiter, columnDelimiter, rowDelimiter) {
	        var cellStr = '';
	        if (!isNullOrUndefined(cellData)) {
	            cellStr = cellData;
	            if (!forClipboard) {
	                cellStr = cellStr.replace(cellDelimiterReg, cellDelimiter + cellDelimiter);
	            }
	        }
	        if (replaceEmpty && !cellStr) {
	            cellStr = ' ';
	        }
	        if (forClipboard && copyPasteExcelStyle) {
	            cellStr = cellStr.replace(/\n/g, ' ');
	        } else if (forceCellDelimiter || cellStr.indexOf(cellDelimiter) !== -1 || cellStr.indexOf(columnDelimiter) !== -1 ||
	            cellStr.indexOf(rowDelimiter) !== -1 || cellStr.indexOf('\n') !== -1) {
	            cellStr = cellDelimiter + cellStr + cellDelimiter;
	        }
	        return cellStr;
	    }
	
	    function parseCsv(text, rowDelimiter, columnDelimiter, cellDelimiter) {
	        var ret = keyword_null;
	        var parsedText = parseText(text, rowDelimiter, columnDelimiter, cellDelimiter);
	        if (parsedText) {
	            var rowCount = parsedText.length;
	            var columnCount = getMaxLength(parsedText);
	            var textArray = [];
	            for (var r = 0; r < rowCount; r++) {
	                textArray[r] = [];
	                for (var c = 0; c < columnCount; c++) {
	                    if (c < parsedText[r].length) {
	                        textArray[r][c] = parsedText[r][c];
	                    } else {
	                        textArray[r][c] = keyword_null;
	                    }
	                }
	            }
	            ret = textArray;
	        }
	        return ret;
	    }
	
	    $_extend(Worksheet.prototype, {
	       
	        
	        autoFitColumn: function (column) {
	            if (0 <= column && column < getSheetColumnCount(this)) {
	                this._commandManager().execute({
	                    cmd: 'autoFitColumn',
	                    sheetName: this.name(),
	                    columns: [{col: column}],
	                    rowHeader: false
	                });
	            }
	        },
	       
	        
	        autoFitRow: function (row) {
	            if (0 <= row && row < getSheetRowCount(this)) {
	                this._commandManager().execute({
	                    cmd: 'autoFitRow',
	                    sheetName: this.name(),
	                    rows: [{row: row}],
	                    columnHeader: false
	                });
	            }
	        },
	       
	        
	        setCsv: function (row, column, text, rowDelimiter, columnDelimiter, flags) {
	            var self = this;
	            suspendPaint(self);
	            suspendEvent(self);
	            setRangeText(self, row, column, text, rowDelimiter, columnDelimiter, '"', flags);
	            resumeEvent(self);
	            resumePaint(self);
	        },
	       
	        
	        getCsv: function (row, column, rowCount, columnCount, rowDelimiter, columnDelimiter) {
	            return getRangeText(this, row, rowCount, column, columnCount, rowDelimiter, columnDelimiter, '"', true);
	        },
	       
	        
	        copyTo: function (fromRow, fromColumn, toRow, toColumn, rowCount, columnCount, option) {
	            this._copyToCore(fromRow, fromColumn, toRow, toColumn, rowCount, columnCount, option);
	        },
	        _copyToCore: function (fromRow, fromColumn, toRow, toColumn, rowCount, columnCount, option, ignoreFilteredOutRow) {
	            var self = this;
	            suspendPaint(self);
	            suspendEvent(self);
	            staticMembers.copyTo(self, fromRow, fromColumn, self, toRow, toColumn, rowCount, columnCount, option, ignoreFilteredOutRow, 0 );
	            resumeEvent(self);
	            resumePaint(self);
	        },
	       
	        
	        moveTo: function (fromRow, fromColumn, toRow, toColumn, rowCount, columnCount, option) {
	            var self = this;
	            if (exports._supportsCalc && (option & exports.CopyToOptions.formula)
	                && (!self._checkArrayFormula(fromRow, fromColumn, rowCount, columnCount, true)
	                    || !self._checkArrayFormula(toRow, toColumn, rowCount, columnCount, true))) {
	                return;
	            }
	            suspendPaint(self);
	            suspendEvent(self);
	            staticMembers.moveTo(self, fromRow, fromColumn, self, toRow, toColumn, rowCount, columnCount, option);
	            resumeEvent(self);
	            resumePaint(self);
	        },
	        _clipboardCopy: function (ranges, isCutting, ignoreClipboard) {
	            var self = this;
	            var range = self._getCopyRange(ranges);
	            if (!range) {
	                return;
	            }
	            var ignoredRowsCols = self._getIgnoredRowsCols(ranges);
	            var columnDelimiter = '\t';
	            var rowDelimiter = '\r\n';
	            var cellDelimiter = '"';
	            var eventHandler = self._eventHandler;
	            var copyText = getRangeText(self, range.row, getRowCount(range), range.col, getColCount(range), rowDelimiter, columnDelimiter, cellDelimiter, false, ignoredRowsCols.rows, ignoredRowsCols.cols, true);
	            var ch = self._getClipboardHelper();
	            ch._fromSheet = self;
	            ch._ranges = ranges;
	            ch._isCutting = isCutting;
	            var copyHtml = ch._getRangeHtml(self, range.row, getRowCount(range), range.col, getColCount(range), allowCopyPasteExcelStyle(self), ignoredRowsCols.rows, ignoredRowsCols.cols);
	           
	           
	            self._clearFloatingObjectClipboardHelper && self._clearFloatingObjectClipboardHelper();
	            self._clearShapeClipboardHelper && self._clearShapeClipboardHelper();
	            try {
	                var args = {
	                    sheet: self,
	                    sheetName: self.name(),
	                    copyData: {text: copyText, html: copyHtml},
	                    cancel: false
	                };
	                self._trigger(Events.ClipboardChanging, args);
	                if (args && args.cancel === false) {
	                    if (eventHandler && !ignoreClipboard) {
	                        eventHandler._switchFocusForClipboard(allowCopyPasteExcelStyle(self) ? copyHtml : copyText);
	                    }
	                    self._trigger(Events.ClipboardChanged, {
	                        sheet: self,
	                        sheetName: self.name(),
	                        copyData: {text: copyText, html: copyHtml}
	                    });
	                    setTimeout(function () {
	                        if (eventHandler && !ignoreClipboard && !self._disposed) {
	                            eventHandler._switchBackFocusAfterClipboard();
	                        }
	                    }, 100);
	                    return {copyText: copyText, copyHtml: copyHtml};
	                } else {
	                    ch._reset();
	                }
	            } catch (e) {
	               
	            }
	        },
	        _checkPastedRange: function (fromSheet, fromRanges, toRange, isCutting, clipboardText, outPara) {
	            var msg_sheetViewPasteSouceSheetCellsAreLocked = sR().Exp_PasteSourceCellsLocked;
	            outPara.pastedInternal = false;
	            outPara.pastedRange = keyword_null;
	            if (!fromSheet && !clipboardText) {
	                return false;
	            }
	            var self = this;
	            var toSheet = self;
	            var ignoredRowsCols = self._getIgnoredRowsCols(fromRanges);
	            if (self._isPastedInternal(fromSheet, self._getCopyRange(fromRanges), toSheet, clipboardText, ignoredRowsCols.rows, ignoredRowsCols.cols) || !clipboardText) {
	                outPara.pastedInternal = true;
	                if (isCutting && fromSheet.options.isProtected && fromSheet._isAnyCellInRangesLocked(fromRanges)) {
	                    self._raiseInvalidOperation(1 , msg_sheetViewPasteSouceSheetCellsAreLocked);
	                    return false;
	                }
	                outPara.pastedRange = self._getPastedRange(fromSheet, fromRanges, toSheet, toRange, isCutting);
	            } else {
	                outPara.pastedRange = self._getPastedRangefromText(toRange, clipboardText);
	            }
	            return self._checkPasteRangeImp(fromSheet, fromRanges, toRange, isCutting, outPara);
	        },
	        _checkPasteRangeImp: function (fromSheet, fromRanges, toRange, isCutting, outPara) {
	            var msg_sheetViewTheCopyAreaAndPasteAreaAreNotTheSameSize = sR().Exp_InvalidCopyPasteSize;
	            var msg_sheetViewPasteDestinationSheetCellsAreLocked = sR().Exp_PasteDestinationCellsLocked;
	            var msg_sheetViewPasteChangeMergeCell = sR().Exp_PasteChangeMergeCell;
	            var msg_sheetViewPasteChangePartOfArrayFormula = sR().Exp_ChangePartOfArray;
	            var self = this;
	            var toSheet = self;
	            var pastedRange = outPara.pastedRange;
	            if (!pastedRange) {
	                self._raiseInvalidOperation(1 , msg_sheetViewTheCopyAreaAndPasteAreaAreNotTheSameSize);
	                return false;
	            }
	            if (!toSheet._canChange(pastedRange.row, pastedRange.col, getRowCount(pastedRange), getColCount(pastedRange),
	                    msg_sheetViewPasteDestinationSheetCellsAreLocked, msg_sheetViewPasteChangePartOfArrayFormula)) {
	                return false;
	            }
	            if (outPara.pastedInternal) {
	                var fromRangesLength = fromRanges.length;
	                if (fromRangesLength === 1) {
	                    var fromRange = fromRanges[0];
	                    if (isCutting && !fromSheet._canChange(fromRange.row, fromRange.col, getRowCount(fromRange), getColCount(fromRange),
	                            msg_sheetViewPasteDestinationSheetCellsAreLocked, msg_sheetViewPasteChangePartOfArrayFormula)) {
	                        return false;
	                    }
	                    if (fromSheet._hasPartSpans(fromRange.row, fromRange.col, getRowCount(fromRange), getColCount(fromRange))) {
	                        self._raiseInvalidOperation(1 , msg_sheetViewPasteChangeMergeCell);
	                        return false;
	                    }
	                    var toRowCount = pastedRange.row < 0 ? getSheetRowCount(toSheet) : getRowCount(pastedRange);
	                    var toColumnCount = pastedRange.col < 0 ? getSheetColumnCount(toSheet) : getColCount(pastedRange);
	                    var rowCount = fromRange.row < 0 ? getSheetRowCount(fromSheet) : getRowCount(fromRange);
	                    var columnCount = fromRange.col < 0 ? getSheetColumnCount(fromSheet) : getColCount(fromRange);
	                    if (toRowCount > rowCount || toColumnCount > columnCount) {
	                        var toRow = toRange.row;
	                        var toColumn = toRange.col;
	                        if (toRange.row < 0 && rowCount < getSheetRowCount(toSheet)) {
	                            toRow = 0;
	                        }
	                        if (toRange.col < 0 && columnCount < getSheetColumnCount(toSheet)) {
	                            toColumn = 0;
	                        }
	                        if (toRowCount % rowCount === 0 && toColumnCount === 1) {
	                            toColumnCount = columnCount;
	                            pastedRange = outPara.pastedRange = new Range(toRow, toColumn, toRowCount, toColumnCount);
	                        } else if (toRowCount === 1 && toColumnCount % columnCount === 0) {
	                            toRowCount = rowCount;
	                            pastedRange = outPara.pastedRange = new Range(toRow, toColumn, toRowCount, toColumnCount);
	                        } else if (toRowCount % rowCount !== 0 || toColumnCount % columnCount !== 0) {
	                            toRowCount = rowCount;
	                            toColumnCount = columnCount;
	                            pastedRange = outPara.pastedRange = new Range(toRow, toColumn, toRowCount, toColumnCount);
	                        }
	                        var rn = Math_floor(toRowCount / rowCount);
	                        var cn = Math_floor(toColumnCount / columnCount);
	                        for (var r = 0; r < rn; r++) {
	                            for (var c = 0; c < cn; c++) {
	                                if (!self._isSingleCellToSpanCell(fromRange, pastedRange) &&
	                                    toSheet._hasPartSpans((toRow < 0 ? -1 : toRow + r * rowCount),
	                                        (toColumn < 0 ? -1 : toColumn + c * columnCount),
	                                        (toRow < 0 ? -1 : rowCount),
	                                        (toColumn < 0 ? -1 : columnCount))) {
	                                    self._raiseInvalidOperation(1 , msg_sheetViewPasteChangeMergeCell);
	                                    return false;
	                                }
	                            }
	                        }
	                    } else if (!self._isSingleCellToSpanCell(fromRange, pastedRange) &&
	                        toSheet._hasPartSpans(pastedRange.row, pastedRange.col, getRowCount(pastedRange), getColCount(pastedRange))) {
	                        self._raiseInvalidOperation(1 , msg_sheetViewPasteChangeMergeCell);
	                        return false;
	                    }
	                } else if (fromRangesLength > 1) {
	                    for (var i = 0; i < fromRangesLength; i++) {
	                        var currentFromRange = fromRanges[i];
	                        if (fromSheet._hasPartSpans(currentFromRange.row, currentFromRange.col, getRowCount(currentFromRange), getColCount(currentFromRange))) {
	                            self._raiseInvalidOperation(1 , msg_sheetViewPasteChangeMergeCell);
	                            return false;
	                        }
	                    }
	                    if (toSheet._hasPartSpans(pastedRange.row, pastedRange.col, getRowCount(pastedRange), getColCount(pastedRange))) {
	                        self._raiseInvalidOperation(1 , msg_sheetViewPasteChangeMergeCell);
	                        return false;
	                    }
	                }
	            } else {
	                if (toSheet._hasPartSpans(pastedRange.row, pastedRange.col, getRowCount(pastedRange), getColCount(pastedRange))) {
	                    self._raiseInvalidOperation(1 , msg_sheetViewPasteChangeMergeCell);
	                    return false;
	                }
	                if (!toSheet._isValidPasteRange(pastedRange.row, pastedRange.col, getRowCount(pastedRange), getColCount(pastedRange))) {
	                    self._raiseInvalidOperation(1 , msg_sheetViewTheCopyAreaAndPasteAreaAreNotTheSameSize);
	                    return false;
	                }
	            }
	            return true;
	        },
	        _isSingleCellToSpanCell: function (fromRange, pastedRange) {
	            if (fromRange && getRowCount(fromRange) === 1 && getColCount(fromRange) === 1) {
	                var span = this.getSpan(pastedRange.row, pastedRange.col);
	                if (span && span.equals(pastedRange)) {
	                    return true;
	                }
	            }
	            return false;
	        },
	        _isPastedInternal: function (srcSheet, srcRange, destSheet, clipboadText, ignoredRows, ignoredCols) {
	            if (srcSheet && srcRange && destSheet) {
	                try {
	                    var csvText = getRangeText(srcSheet, srcRange.row, getRowCount(srcRange), srcRange.col, getColCount(srcRange), '\r\n', '\t', '"', false, ignoredRows, ignoredCols, true, browser.safari, true);
	                    var isTextEqual = csvText === clipboadText;
	                    if (!isTextEqual) {
	                        isTextEqual = csvText === clipboadText + '\r\n';
	                        if (!isTextEqual && browser.chrome) {
	                            isTextEqual = csvText === clipboadText + '\t\r\n';
	                        }
	                        if (!isTextEqual && (browser.safari || !allowCopyPasteExcelStyle(destSheet))) {
	                            isTextEqual = csvText.replace(/\s/g, '') === clipboadText.replace(/\s/g, '');
	                        }
	                       
	                        if (!isTextEqual) {
	                            isTextEqual = csvText.replace(/\s+$/, '') === clipboadText.replace(/\s+$/, '');
	                        }
	                    }
	                    return isTextEqual;
	                } catch (ex) {
	                   
	                   
	                   
	                    return false;
	                }
	            }
	            return false;
	        },
	        _getPastedRange: function (fromSheet, fromRanges, toSheet, toRange, isCutting) {
	            var self = this;
	            var fromRangesLength = fromRanges.length;
	            if (fromRangesLength === 1) {
	                var fromRange = fromRanges[0];
	                var fromRow = fromRange.row < 0 ? 0 : fromRange.row;
	                var fromColumn = fromRange.col < 0 ? 0 : fromRange.col;
	                var fromRowCount = fromRange.row < 0 ? getSheetRowCount(fromSheet) : getRowCount(fromRange);
	                var fromColumnCount = fromRange.col < 0 ? getSheetColumnCount(fromSheet) : getColCount(fromRange);
	                var toRow = toRange.row < 0 ? 0 : toRange.row;
	                var toColumn = toRange.col < 0 ? 0 : toRange.col;
	                var toRowCount = toRange.row < 0 ? getSheetRowCount(toSheet) : getRowCount(toRange);
	                var toColumnCount = toRange.col < 0 ? getSheetColumnCount(toSheet) : getColCount(toRange);
	                if (isCutting) {
	                    toRowCount = fromRowCount;
	                    toColumnCount = fromColumnCount;
	                } else if (toRowCount % fromRowCount === 0 && toColumnCount === 1) {
	                    toColumnCount = fromColumnCount;
	                } else if (toRowCount === 1 && toColumnCount % fromColumnCount === 0) {
	                    toRowCount = fromRowCount;
	                } else if (toRowCount % fromRowCount !== 0 || toColumnCount % fromColumnCount !== 0) { 
	                    toRowCount = fromRowCount;
	                    toColumnCount = fromColumnCount;
	                }
	                if (!self._isValidRange(fromRow, fromColumn, fromRowCount, fromColumnCount, getSheetRowCount(fromSheet), getSheetColumnCount(fromSheet))) {
	                    return keyword_null;
	                }
	                if (!toSheet._isValidPasteRange(toRow, toColumn, toRowCount, toColumnCount)) {
	                    return keyword_null;
	                }
	                var fixedToRange = new Range(toRow, toColumn, toRowCount, toColumnCount);
	                if (!isCutting && fromSheet.name() === toSheet.name()) {
	                    if (fixedToRange.contains(fromRow, fromColumn, fromRowCount, fromColumnCount)) {
	                        if ((fromRow - toRow) % fromRowCount !== 0 || (fromColumn - toColumn) % fromColumnCount !== 0) {
	                            return keyword_null;
	                        }
	                    } else if (fixedToRange.intersect(fromRow, fromColumn, fromRowCount, fromColumnCount) && (toRowCount > fromRowCount || toColumnCount > fromColumnCount)) {
	                        return keyword_null;
	                    }
	                }
	                if (toRange.row === -1) {
	                    toRow = -1;
	                    toRowCount = -1;
	                }
	                if (toRange.col === -1) {
	                    toColumn = -1;
	                    toColumnCount = -1;
	                }
	                return new Range(toRow, toColumn, toRowCount, toColumnCount);
	            } else if (fromRangesLength > 1) {
	                return self._getPastedRangeForMultiCopy(fromRanges, toRange);
	            }
	            return keyword_null;
	        },
	        _getPastedRangeForMultiCopy: function (fromRanges, toRange) {
	            if (fromRanges.length > 1) {
	                var firstRange = fromRanges[0], secondRange = fromRanges[1],
	                    firstRangeRowCount = firstRange.rowCount, firstRangeColCount = firstRange.colCount;
	                if (firstRange.row === secondRange.row && firstRangeRowCount === secondRange.rowCount) {
	                    var colCount = 0;
	                    fromRanges.forEach(function (range) {
	                        colCount += range.colCount;
	                    });
	                    return util_common._createRange(toRange.row, toRange.col, firstRangeRowCount, colCount);
	                } else if (firstRange.col === secondRange.col && firstRangeColCount === secondRange.colCount) {
	                    var rowCount = 0;
	                    fromRanges.forEach(function (range) {
	                        rowCount += range.rowCount;
	                    });
	                    return util_common._createRange(toRange.row, toRange.col, rowCount, firstRangeColCount);
	                }
	            }
	            return keyword_null;
	        },
	        _getPastedRangefromText: function (toRange, clipboadText) {
	            var ret = keyword_null;
	            var textArray = parseCsv(clipboadText, '\r\n', '\t', '"');
	            if (textArray) {
	                var row = toRange.row < 0 ? 0 : toRange.row;
	                var column = toRange.col < 0 ? 0 : toRange.col;
	                var rowCount = textArray.length;
	                var columnCount = getMaxLength(textArray);
	                if (rowCount > 0 && columnCount > 0) {
	                    ret = new Range(row, column, rowCount, columnCount);
	                }
	            }
	            return ret;
	        },
	        _clearClipboard: function () {
	            var ch = this._getClipboardHelper();
	            if (ch) {
	                ch._reset();
	            }
	        },
	        _clipboardPaste: function (fromSheet, fromRange, toSheet, toRange, isCutting, clipboardText, clipboardHtml, option, ignoreFilteredOutRow) {
	            if (fromSheet && toSheet.name() === fromSheet.name() && (toSheet.parent && !ArrayHelper_contains(toSheet.parent.sheets, fromSheet))) {
	                fromSheet._clearClipboard();
	                return;
	            }
	            var toRow, toColumn, rowCount, columnCount, r, c;
	            var pasteOption = ClipboardPasteRangeUndoAction._convertPasteOption(option);
	            suspendCalcService(fromSheet);
	            suspendCalcService(toSheet);
	            try {
	                if (fromSheet && fromRange) {
	                    if ((pasteOption & 2 ) !== 0 && (isCutting &&
	                            exports._supportsCalc && (fromSheet._hasPartArrayFormulas(fromRange.row, fromRange.col, getRowCount(fromRange), getColCount(fromRange)) ||
	                                toSheet._hasPartArrayFormulas(toRange.row, toRange.col, getRowCount(toRange), getColCount(toRange))))) {
	                        throw sR().Exp_ChangePartOfArray;
	                    }
	                    if (isCutting) {
	                        staticMembers.moveTo(fromSheet, fromRange.row, fromRange.col, toSheet, toRange.row, toRange.col,
	                            getRowCount(fromRange), getColCount(fromRange), pasteOption);
	                        fromSheet._clearClipboard();
	                    } else {
	                        var toRowCount = toRange.row < 0 ? getSheetRowCount(toSheet) : getRowCount(toRange);
	                        var toColumnCount = toRange.col < 0 ? getSheetColumnCount(toSheet) : getColCount(toRange);
	                        rowCount = fromRange.row < 0 ? getSheetRowCount(fromSheet) : getRowCount(fromRange);
	                        columnCount = fromRange.col < 0 ? getSheetColumnCount(fromSheet) : getColCount(fromRange);
	                        if (toRowCount > rowCount || toColumnCount > columnCount) {
	                            toRow = toRange.row;
	                            toColumn = toRange.col;
	                            if (toRange.row < 0 && rowCount < getSheetRowCount(toSheet)) {
	                                toRow = 0;
	                            }
	                            if (toRange.col < 0 && columnCount < getSheetColumnCount(toSheet)) {
	                                toColumn = 0;
	                            }
	                            if (toRowCount % rowCount === 0 && toColumnCount === 1) {
	                                toColumnCount = columnCount;
	                            } else if (toRowCount === 1 && toColumnCount % columnCount === 0) {
	                                toRowCount = rowCount;
	                            } else if (toRowCount % rowCount !== 0 || toColumnCount % columnCount !== 0) {
	                                toRowCount = rowCount;
	                                toColumnCount = columnCount;
	                            }
	                            var rn = Math_floor(toRowCount / rowCount);
	                            var cn = Math_floor(toColumnCount / columnCount);
	                            for (r = 0; r < rn; r++) {
	                                for (c = 0; c < cn; c++) {
	                                    staticMembers.copyTo(fromSheet, fromRange.row, fromRange.col, toSheet,
	                                        (toRow < 0 ? -1 : toRow + r * rowCount), (toColumn < 0 ? -1 : toColumn + c * columnCount),
	                                        (toRow < 0 ? -1 : rowCount), (toColumn < 0 ? -1 : columnCount), pasteOption, ignoreFilteredOutRow, copyPasteHeaderOptions(fromSheet));
	                                }
	                            }
	                        } else {
	                            staticMembers.copyTo(fromSheet, fromRange.row, fromRange.col, toSheet, toRange.row, toRange.col,
	                                getRowCount(fromRange), getColCount(fromRange), pasteOption, ignoreFilteredOutRow, copyPasteHeaderOptions(fromSheet));
	                        }
	                    }
	                } else {
	                    toRow = toRange.row;
	                    toColumn = toRange.col;
	                    rowCount = getRowCount(toRange);
	                    columnCount = getColCount(toRange);
	                    var modelManager = toSheet._modelManager;
	                    var removedSpans = modelManager.getSpans(util_common._createRange(toRow, toColumn, rowCount, columnCount));
	                    for (var i = removedSpans.length - 1; i >= 0; i--) {
	                        modelManager.do('removeSpan', removedSpans[i]);
	                    }
	                   
	                    if (exports._supportsCalc && (pasteOption & 1 ) > 0) {
	                        toSheet.clearFormula(toRow, toColumn, rowCount, columnCount, function (sheet, row) {
	                            return !sheet._isRowFilterOut || !sheet._isRowFilterOut(row);
	                        });
	                    }
	                    if ((!clipboardText) || (clipboardText === '')) {
	                        for (r = 0; r < rowCount; r++) {
	                            for (c = 0; c < columnCount; c++) {
	                                toSheet.setValue(toRow + r, toColumn + c, keyword_null);
	                            }
	                        }
	                    } else {
	                        var pasteFormatting = option === 0  || option === 2 ;
	                        if (pasteFormatting && clipboardHtml) {
	                            var ch = toSheet._getClipboardHelper();
	                            if (ch) {
	                                ch._setRangeHtml(clipboardHtml, toSheet, toRow, toColumn);
	                            }
	                        }
	                        toSheet.setCsv(toRow, toColumn, clipboardText, '\r\n', '\t', 16 );
	                    }
	                }
	            } finally {
	                resumeCalcService(fromSheet, false);
	                resumeCalcService(toSheet, false);
	            }
	        },
	       
	        _doCut: function (ignoreClipboard) {
	            if (!this.isEditing()) {
	                var sels = this.getSelections();
	                if (sels && sels.length === 1) {
	                    return this._clipboardCopy(sels, true, ignoreClipboard);
	                }
	            }
	            return keyword_null;
	        },
	        _isValidMultiCopyRanges: function (ranges, outParam) {
	            if (ranges) {
	                var length = ranges.length;
	                if (length > 1) {
	                    for (var i = 0; i < length; i++) {
	                        var range1 = ranges[i];
	                        for (var j = i + 1; j < length; j++) {
	                            var range2 = ranges[j];
	                            if (range1.intersect(range2.row, range2.col, range2.rowCount, range2.colCount)) {
	                                return false;
	                            }
	                        }
	                    }
	
	                    var firstRange = ranges[0], currentRange;
	                    for (i = 1; i < length; i++) {
	                        currentRange = ranges[i];
	                        if (firstRange.row !== currentRange.row || firstRange.rowCount !== currentRange.rowCount) {
	                            break;
	                        }
	                    }
	                    if (i >= length) {
	                        if (outParam) {
	                            outParam.inSameRow = true;
	                        }
	                        return true;
	                    }
	
	                    for (i = 1; i < length; i++) {
	                        currentRange = ranges[i];
	                        if (firstRange.col !== currentRange.col || firstRange.colCount !== currentRange.colCount) {
	                            break;
	                        }
	                    }
	                    if (i >= length) {
	                        if (outParam) {
	                            outParam.inSameCol = true;
	                        }
	                        return true;
	                    }
	                }
	            }
	            return false;
	        },
	        _getCopyRange: function (ranges) {
	            if (ranges) {
	                var length = ranges.length;
	                if (length === 1) {
	                    return ranges[0];
	                } else if (length > 1) {
	                    var firstRange = ranges[0], lastRange = ranges[length - 1];
	                    if (firstRange.row === lastRange.row && firstRange.rowCount === lastRange.rowCount) {
	                        for (var i = 0; i < length; i++) {
	                            var currentRange = ranges[i];
	                            if (currentRange.col < firstRange.col) {
	                                firstRange = currentRange;
	                            }
	                            if (currentRange.col > lastRange.col) {
	                                lastRange = currentRange;
	                            }
	                        }
	                        return util_common._createRange(firstRange.row, firstRange.col, firstRange.rowCount, lastRange.col + lastRange.colCount - firstRange.col);
	                    } else if (firstRange.col === lastRange.col && firstRange.colCount === lastRange.colCount) {
	                        for (i = 0; i < length; i++) {
	                            currentRange = ranges[i];
	                            if (currentRange.row < firstRange.row) {
	                                firstRange = currentRange;
	                            }
	                            if (currentRange.row > lastRange.row) {
	                                lastRange = currentRange;
	                            }
	                        }
	                        return util_common._createRange(firstRange.row, firstRange.col, lastRange.row + lastRange.rowCount - firstRange.row, firstRange.colCount);
	                    }
	                }
	            }
	            return keyword_null;
	        },
	        _getIgnoredRowsCols: function (ranges) {
	            var ignoredRows = [], ignoredColumns = [];
	            if (ranges) {
	                var length = ranges.length;
	                if (length > 1) {
	                    var firstRange = ranges[0], lastRange = ranges[length - 1];
	                    var isSameRow = firstRange.row === lastRange.row && firstRange.rowCount === lastRange.rowCount,
	                        isSameCol = firstRange.col === lastRange.col && firstRange.colCount === lastRange.colCount;
	                    if (isSameRow || isSameCol) {
	                        ranges.sort(isSameRow ? function (r1, r2) {
	                            return r1.col - r2.col;
	                        } : function (r1, r2) {
	                            return r1.row - r2.row;
	                        });
	
	                        for (var i = 1; i < length; i++) {
	                            var range1 = ranges[i - 1],
	                                range2 = ranges[i],
	                                startIndex = isSameRow ? range1.col + range1.colCount : range1.row + range1.rowCount,
	                                endIndex = isSameRow ? range2.col : range2.row,
	                                ignoredList = isSameRow ? ignoredColumns : ignoredRows;
	                            for (var index = startIndex; index < endIndex; index++) {
	                                ignoredList.push(index);
	                            }
	                        }
	                    }
	                }
	            }
	            return {
	                rows: ignoredRows,
	                cols: ignoredColumns
	            };
	        },
	       
	        _doCopy: function (ignoreClipboard) {
	            var self = this;
	            if (!self.isEditing()) {
	                var sels = self.getSelections();
	                if (sels && sels.length === 1) {
	                    var originalRange = sels[0];
	                    if (originalRange.row !== -1 && self._hasRowFilterOut && self._hasRowFilterOut()) {
	                        var newRanges = [];
	                        var lastVisibleRow = -1;
	                        for (var r = 0; r < originalRange.rowCount; r++) {
	                            var row = originalRange.row + r;
	                            if (self._isRowFilterOut(row)) {
	                                if (lastVisibleRow !== -1) {
	                                    newRanges.push(util_common._createRange(lastVisibleRow, originalRange.col, row - lastVisibleRow, originalRange.colCount));
	                                    lastVisibleRow = -1;
	                                }
	                            } else if (lastVisibleRow === -1) {
	                                lastVisibleRow = row;
	                            }
	                        }
	                        if (lastVisibleRow !== -1) {
	                            newRanges.push(util_common._createRange(lastVisibleRow, originalRange.col, originalRange.row + originalRange.rowCount - lastVisibleRow, originalRange.colCount));
	                        }
	                        sels = newRanges;
	                    }
	                    return self._clipboardCopy(sels, false, ignoreClipboard);
	                } else if (self._isValidMultiCopyRanges(sels)) {
	                    return self._clipboardCopy(sels, false, ignoreClipboard);
	                }
	            }
	            return keyword_null;
	        },
	       
	        _doPaste: function (options) {
	            var sheet = this, eventHandler = sheet._eventHandler, pasteText, pasteHtml, callback;
	            if (sheet.isEditing()) {
	                return;
	            }
	            if (options) {
	                pasteText = options.pasteText;
	                pasteHtml = options.pasteHtml;
	                callback = options.callback;
	            }
	            if (eventHandler && !pasteText) {
	                eventHandler._switchFocusForClipboard('');
	            }
	            setTimeout(function () {
	                if (sheet._disposed) {
	                    return;
	                }
	                var clipboardText = pasteText || '', clipboardHtml = pasteHtml || '';
	                if (eventHandler && !pasteText) {
	                    var clipboardHelper = sheet._getClipboardHelper();
	                    if (clipboardHelper) {
	                        var clipboardData = clipboardHelper._getClipboardData();
	                        clipboardText = clipboardData.text;
	                        clipboardHtml = clipboardData.html;
	                    }
	                    eventHandler._switchBackFocusAfterClipboard();
	                }
	
	               
	               
	               
	                if (browser.msie || browser.edge || pasteText || (!clipboardText && !clipboardHtml)) {
	                    sheet._doClipboardPaste(clipboardText, clipboardHtml);
	                    if (callback) {
	                        callback();
	                    }
	                }
	            }, 100);
	        },
	        _doClipboardPaste: function (clipboardText, clipboardHtml) {
	            var sheet = this;
	            var pasteInfo = sheet._getPasteInfo(clipboardText);
	            if (!pasteInfo) {
	                return;
	            }
	            pasteInfo.cmd = 'clipboardPaste';
	            pasteInfo.sheetName = sheet.name();
	            if (allowCopyPasteExcelStyle(sheet)) {
	                pasteInfo.clipboardHtml = clipboardHtml;
	            }
	            sheet._commandManager().execute(pasteInfo);
	        },
	        _getPasteInfo: function (clipboardText) {
	            var sheet = this;
	            var msg_spreadActionPasteSizeDifferent = sR().Exp_InvalidPastedArea;
	            var ch = sheet._getClipboardHelper();
	            var fromSheet = ch._fromSheet;
	            var fromRanges = ch._ranges;
	            var isCutting = ch._isCutting;
	           
	            if (isCutting && fromSheet && fromRanges && fromSheet.options.isProtected && fromSheet._isAnyCellInRangesLocked(fromRanges)) {
	                isCutting = false;
	            }
	            var outPara = {pastedRange: keyword_null, pastedInternal: false};
	            var pastedRanges = [];
	            var selections = sheet.getSelections();
	            var toRange;
	            if (selections.length > 1) {
	                for (var i = 0; i < selections.length; i++) {
	                    toRange = selections[i];
	                    if (!sheet._checkPastedRange(fromSheet, [fromRanges[0]], toRange, isCutting, clipboardText, outPara)) {
	                        return;
	                    }
	                   
	                    if (toRange.containsRange(outPara.pastedRange) && !toRange.equals(outPara.pastedRange)) {
	                        sheet._raiseInvalidOperation(1 , msg_spreadActionPasteSizeDifferent);
	                        return;
	                    }
	                    pastedRanges.push(outPara.pastedRange);
	                }
	            } else {
	                if (selections.length > 0) {
	                    toRange = selections[0];
	                } else {
	                    toRange = sheet._modelManager.getSpan(sheet._activeRowIndex, sheet._activeColIndex);
	                }
	                if (!sheet._checkPastedRange(fromSheet, fromRanges, toRange, isCutting, clipboardText, outPara)) {
	                    return;
	                }
	                pastedRanges.push(outPara.pastedRange);
	            }
	            var cutCopyIndicator = sheet._cutCopyIndicatorManager;
	            if (cutCopyIndicator) {
	                cutCopyIndicator._isPastedInternal(outPara.pastedInternal);
	            }
	            if (!outPara.pastedInternal) {
	                fromSheet = keyword_null;
	                fromRanges = keyword_null;
	                isCutting = false;
	            }
	            var pasteOption = sheet.options.clipBoardOptions;
	           
	            if (isCutting) {
	                pasteOption = 0 ;
	            }
	            if (fromRanges && fromRanges.length === 1) {
	                for (var index = 0; index < pastedRanges.length; index++) {
	                    var range = pastedRanges[index];
	                    if (sheet._isSingleCellToSpanCell(fromRanges[0], range)) {
	                        range.rowCount = 1;
	                        range.colCount = 1;
	                    }
	                }
	            }
	            return {
	                fromSheet: fromSheet,
	                fromRanges: fromRanges,
	                isCutting: isCutting,
	                pasteOption: pasteOption,
	                pastedRanges: pastedRanges,
	                clipboardText: clipboardText
	            };
	        },
	        _isValidPasteRange: function (row, column, rowCount, colCount, ignoreMax) {
	            var self = this;
	            var maxRowCount = getSheetRowCount(self), maxColumnCount = getSheetColumnCount(self);
	            if (allowExtendPasteRange(self)) {
	                return -1 <= row && (ignoreMax || row < maxRowCount) && -1 <= column && (ignoreMax || column < maxColumnCount);
	            }
	            return self._isValidRange(row, column, rowCount, colCount, maxRowCount, maxColumnCount);
	        },
	        _isAnyCellInRangesLocked: function (ranges) {
	            for (var i = 0; i < ranges.length; i++) {
	                if (this._isAnyCellInRangeLocked(ranges[i])) {
	                    return true;
	                }
	            }
	            return false;
	        },
	
	        _moveActiveCell: function (dir, wrap, beginRow, beginCol) {
	            var self = this;
	            var args = {
	                sheet: self,
	                sheetName: self.name(),
	                row: self._activeRowIndex,
	                col: self._activeColIndex,
	                cancel: false
	            };
	            self._trigger(Events.LeaveCell, args);
	            if (args.cancel === true) {
	                return;
	            }
	            if (self.endEdit && !self.endEdit()) {
	                return;
	            }
	            var prevRowIndex = self._activeRowIndex;
	            var prevcolIndex = self._activeColIndex;
	            if (isNullOrUndefined(beginRow)) {
	                beginRow = self._activeRowIndex;
	            }
	            if (isNullOrUndefined(beginCol)) {
	                beginCol = self._activeColIndex;
	            }
	
	            if (dir === 3 ) {
	                self._moveActiveCellLeft(beginRow, beginCol, wrap);
	            } else if (dir === 4 ) {
	                self._moveActiveCellRight(beginRow, beginCol, wrap);
	            } else if (dir === 1 ) {
	                self._moveActiveCellUp(beginRow, beginCol, wrap);
	            } else if (dir === 2 ) {
	                self._moveActiveCellDown(beginRow, beginCol, wrap);
	            } else if (dir === 5 ) {
	                self._moveActiveCellFirst();
	            } else if (dir === 6 ) {
	                self._moveActiveCellLast();
	            }
	            self._moveActiveCellEnd(dir, prevRowIndex, prevcolIndex);
	        },
	        _moveActiveCellInSelection: function (dir) {
	            var self = this;
	            var args = {
	                sheet: self,
	                sheetName: self.name(),
	                row: self._activeRowIndex,
	                col: self._activeColIndex,
	                cancel: false
	            };
	            self._trigger(Events.LeaveCell, args);
	            if (args.cancel === true) {
	                return;
	            }
	            if (!self.endEdit()) {
	                return;
	            }
	            var prevRowIndex = self._activeRowIndex;
	            var prevcolIndex = self._activeColIndex;
	            if (dir === 3 ) {
	                self._moveActiveCellLeftInSelection(self._activeRowIndex, self._activeColIndex);
	            } else if (dir === 4 ) {
	                self._moveActiveCellRightInSelection(self._activeRowIndex, self._activeColIndex);
	            }
	            self._moveActiveCellEnd(dir, prevRowIndex, prevcolIndex);
	        },
	        _moveActiveCellEnd: function (dir, prevRowIndex, prevcolIndex) {
	            var self = this, handler = self._eventHandler;
	            var oldSelections = self._modelManager.getSelections(), needRepaint = false;
	            if (!self._isNavigateInSelection) {
	                var activeSelectedRange = self._getActualRange(self._getActiveSelectedRange());
	                if (oldSelections.length > 1 || getRowCount(activeSelectedRange) > 1 || getColCount(activeSelectedRange) > 1) {
	                    needRepaint = true;
	                }
	                self._clearSelectionImp();
	            }
	            var activeRowIndex = self._activeRowIndex, activeColIndex = self._activeColIndex,
	                span = self._modelManager.getSpan(activeRowIndex, activeColIndex);
	            self._activeRowCount = getRowCount(span);
	            self._activeColCount = getColCount(span);
	
	            if (!self._isNavigateInSelection) {
	                var activeRange = self._getExtendedRange(activeRowIndex, activeColIndex);
	                var selectionPolicy = self.selectionPolicy(), selectionUnit = self.selectionUnit();
	                if (selectionPolicy === 0 ) {
	                    self._modelManager.do('clearSelection');
	                } else if (selectionPolicy === 1 ) {
	                    self._modelManager.do('clearSelection');
	                }
	                if (selectionUnit === 1 ) {
	                    activeRange.col = -1;
	                    activeRange.colCount = -1;
	                } else if (selectionUnit === 2 ) {
	                    activeRange.row = -1;
	                    activeRange.rowCount = -1;
	                }
	                self._replaceActiveSelectedRange(activeRange.row, activeRange.col, getRowCount(activeRange), getColCount(activeRange), false);
	                var newSelections = self._modelManager.getSelections();
	                if (handler._notEqualSelecions(oldSelections, newSelections)) {
	                    self._raiseSelectionChanging(oldSelections, newSelections);
	                    self._raiseSelectionChanged(oldSelections);
	                }
	            }
	           
	            self._scrollByMoveCell(activeRowIndex, activeColIndex);
	           
	            if (prevRowIndex !== activeRowIndex) {
	                var bm = self._bindingManager;
	                if (bm) {
	                    bm._doDataItemChanged();
	                }
	            }
	           
	            var render = self._render;
	            if (needRepaint) {
	               
	               
	                var layout = self._getSheetLayout(), x = layout._headerX, y = layout._headerY, width = layout.width - x,
	                    height = layout.height - y;
	                render._copyDoubleBuffer(x, y, width, height);
	                render.repaint(new Rect(x, y, width, layout._colHeaderHeight));
	                render.repaint(new Rect(x, y, layout._rowHeaderWidth, height));
	               
	                render._paintAdornment(render._getCtx());
	            } else {
	                var prevSpan = self._modelManager.getSpan(prevRowIndex, prevcolIndex);
	                var rs = getRowCount(prevSpan);
	                var cs = getColCount(prevSpan);
	
	                render._repaintSelection(new Range(activeRowIndex, activeColIndex,
	                    self._activeRowCount, self._activeColCount).union(new Range(prevRowIndex, prevcolIndex, rs, cs)));
	            }
	            var enterCellArgs = {
	                sheet: self,
	                sheetName: self.name(),
	                row: activeRowIndex,
	                col: activeColIndex
	            };
	            self._trigger(Events.EnterCell, enterCellArgs);
	            self._trigger(Events.FormulatextboxEnterCell, enterCellArgs);
	            handler._updateValidationUI && handler._updateValidationUI(activeRowIndex, activeColIndex);
	        },
	
	        _validationError: function (row, column) {
	            var self = this;
	            var dv = self.getDataValidator && self.getDataValidator(row, column);
	            var args = {
	                sheet: self,
	                sheetName: self.name(),
	                row: row,
	                col: column,
	                validator: dv,
	                validationResult: 0 
	            };
	            self._trigger(Events.ValidationError, args);
	            return args.validationResult;
	        }
	    });
	
	   
	
	    function getWorksheet(context, options) {
	        return context.sheets ? context.getSheetFromName(options.sheetName) : context;
	    }
	
	    function executeCommand(context, commandAction, options, isUndo) {
	        var sheet = getWorksheet(context, options);
	        var cmd = new commandAction(sheet, options, isUndo);
	        return isUndo ? cmd.undo(sheet) : cmd.execute(sheet);
	    }
	
	   
	    var Commands = exports.Commands = {};
	   
	    Commands._navigateNoWrap = function (sheet, direction) {
	        if (sheet) {
	            if (sheet._editorStatus === 2 ) {
	                return false;
	            }
	            sheet._moveActiveCell(direction, false);
	            return true;
	        }
	        return false;
	    };
	    Commands._navigateNoWrapFrom = function (sheet, direction, row, col) {
	        if (sheet) {
	            if (sheet._editorStatus === 2 ) {
	                return false;
	            }
	            sheet._moveActiveCell(direction, false, row, col);
	            return true;
	        }
	        return false;
	    };
	    Commands._alterSelection = function (sheet, key, isCtrl) {
	        if (sheet) {
	            if (sheet._editorStatus === 2 ) {
	                return false;
	            }
	            if (sheet.endEdit && !sheet.endEdit()) {
	                return false;
	            }
	            sheet._changeActiveSelectedRange(key, isCtrl);
	            return true;
	        }
	        return false;
	    };
	
	    function defNavigation(direction) {
	        var dir = direction;
	        return function (context, options) {
	            var sheet = getWorksheet(context, options);
	            return Commands._navigateNoWrap(sheet, dir);
	        };
	    }
	
	    function defSelectionAction(direction, isCtrl) {
	        var dir = direction;
	        var ctrl = isCtrl;
	        return function (context, options) {
	            var sheet = getWorksheet(context, options);
	            return Commands._alterSelection(sheet, dir, ctrl);
	        };
	    }
	
	    function moveToNextSheet(sheet, next) {
	        var workbook = sheet.parent;
	        if (workbook) {
	            var count = workbook.getSheetCount(), old, index;
	            old = index = workbook.getActiveSheetIndex();
	            if (next) {
	                if (index < count - 1) {
	                    index++;
	                }
	            } else if (index > 0) {
	                index--;
	            }
	            if (old !== index) {
	                workbook._setActiveSheetIndexImp(index, 1 );
	                workbook.repaint();
	            }
	        }
	    }
	
	    function tabNavigation(sheet, direction) {
	        sheet._isTabNavigation = true;
	        if (sheet._isNavigateInSelection) {
	            sheet._moveActiveCellInSelection(direction);
	        } else {
	            sheet._moveActiveCell(direction, true);
	        }
	        sheet._isTabNavigation = false;
	    }
	
	    function nextControl(sheet, callback) {
	        if (!sheet.endEdit()) {
	            return false;
	        }
	        var eventHandler = sheet._eventHandler;
	        eventHandler._clearRepeatKeyDownTimeout();
	        eventHandler._resetMetaKeyState();
	        util_common._FocusHelper._setActiveElement(keyword_null);
	
	        var needCancelDefault = false;
	        var sheetParent = sheet.parent;
	        if (sheetParent) {
	            var t = callback.call(sheetParent);
	            if (t && t.focus) {
	                t.focus();
	                needCancelDefault = true;
	            } else {
	                sheetParent._focusTabFocusElement();
	            }
	        }
	
	        return {ignoreCancelDefault: !needCancelDefault};
	    }
	
	   
	    var NAVIGATION_LEFT = 'navigationLeft',
	        NAVIGATION_RIGHT = 'navigationRight',
	        NAVIGATION_UP = 'navigationUp',
	        NAVIGATION_DOWN = 'navigationDown',
	        NAVIGATION_HOME_2 = 'navigationHome2',
	        NAVIGATION_END_2 = 'navigationEnd2',
	        NAVIGATION_TOP = 'navigationTop',
	        NAVIGATION_BOTTOM = 'navigationBottom',
	        NAVIGATION_HOME = 'navigationHome',
	        NAVIGATION_FIRST = 'navigationFirst',
	        NAVIGATION_END = 'navigationEnd',
	        NAVIGATION_LAST = 'navigationLast',
	        MOVE_TO_NEXT_CELL = 'moveToNextCell',
	        MOVE_TO_PREVIOUS_CELL = 'moveToPreviousCell',
	        NAVIGATION_PAGE_UP = 'navigationPageUp',
	        NAVIGATION_PAGE_DOWN = 'navigationPageDown',
	        NAVIGATION_PREVIOUS_SHEET = 'navigationPreviousSheet',
	        NAVIGATION_NEXT_SHEET = 'navigationNextSheet',
	        CLEAR = 'clear',
	        CLEAR_AND_EDITING = 'clearAndEditing',
	        COMMIT_INPUT_NAVIGATION_DOWN = 'commitInputNavigationDown',
	        COMMIT_INPUT_NAVIGATION_UP = 'commitInputNavigationUp',
	        CANCEL_INPUT = 'cancelInput',
	        COMMIT_ARRAY_FORMULA = 'commitArrayFormula',
	        SELECTION_LEFT = 'selectionLeft',
	        SELECTION_RIGHT = 'selectionRight',
	        SELECTION_UP = 'selectionUp',
	        SELECTION_DOWN = 'selectionDown',
	        SELECTION_HOME = 'selectionHome',
	        SELECTION_END = 'selectionEnd',
	        SELECTION_PAGEUP = 'selectionPageUp',
	        SELECTION_PAGEDOWN = 'selectionPageDown',
	        SELECTION_TOP = 'selectionTop',
	        SELECTION_BOTTOM = 'selectionBottom',
	        SELECTION_FIRST = 'selectionFirst',
	        SELECTION_LAST = 'selectionLast',
	        COPY = 'copy',
	        CUT = 'cut',
	        PASTE = 'paste',
	        UNDO = 'undo',
	        REDO = 'redo',
	        RESIZE_COLUMN = 'resizeColumn',
	        RESIZE_ROW = 'resizeRow',
	        AUTO_FIT_COLUMN = 'autoFitColumn',
	        AUTO_FIT_ROW = 'autoFitRow',
	        EDIT_CELL = 'editCell',
	        RENAME_SHEET = 'renameSheet',
	        ZOOM = 'zoom',
	        CLEAR_VALUES = 'clearValues',
	        CLIPBOARD_PASTE = 'clipboardPaste',
	        SELECT_NEXT_CONTROL = 'selectNextControl',
	        SELECT_PREVIOUS_CONTROL = 'selectPreviousControl',
	        MOVE_TO_NEXT_CELL_THEN_CONTROL = 'moveToNextCellThenControl',
	        MOVE_TO_PREVIOUS_CELL_THEN_CONTROL = 'moveToPreviousCellThenControl',
	        CHANGE_FORMULA_REFERENCE = 'changeFormulaReference';
	    Commands._getWorksheet = getWorksheet;
	    Commands._executeCommand = executeCommand;
	
	    Commands._initWorkbookCommands = function (commandManager) {
	        var isMac = util_common_util._isMacOS(), ctrl = !isMac, meta = isMac;
	
	       
	       
	        commandManager.register(NAVIGATION_LEFT, Commands[NAVIGATION_LEFT], 37 , false, false, false, false);
	       
	        commandManager.register(NAVIGATION_RIGHT, Commands[NAVIGATION_RIGHT], 39 , false, false, false, false);
	       
	        commandManager.register(NAVIGATION_UP, Commands[NAVIGATION_UP], 38 , false, false, false, false);
	       
	        commandManager.register(NAVIGATION_DOWN, Commands[NAVIGATION_DOWN], 40 , false, false, false, false);
	
	       
	        commandManager.register(NAVIGATION_HOME_2, Commands[NAVIGATION_HOME_2], 37 , ctrl, false, false, meta);
	       
	        commandManager.register(NAVIGATION_END_2, Commands[NAVIGATION_END_2], 39 , ctrl, false, false, meta);
	       
	        commandManager.register(NAVIGATION_TOP, Commands[NAVIGATION_TOP], 38 , ctrl, false, false, meta);
	       
	        commandManager.register(NAVIGATION_BOTTOM, Commands[NAVIGATION_BOTTOM], 40 , ctrl, false, false, meta);
	
	       
	        commandManager.register(NAVIGATION_HOME, Commands[NAVIGATION_HOME], 36 , false, false, false, false);
	       
	        commandManager.register(NAVIGATION_FIRST, Commands[NAVIGATION_FIRST], 36 , true, false, false, false);
	       
	        commandManager.register(NAVIGATION_END, Commands[NAVIGATION_END], 35 , false, false, false, false);
	       
	        commandManager.register(NAVIGATION_LAST, Commands[NAVIGATION_LAST], 35 , true, false, false, false);
	
	       
	        commandManager.register(MOVE_TO_NEXT_CELL, Commands[MOVE_TO_NEXT_CELL], 9 , false, false, false, false);
	       
	        commandManager.register(MOVE_TO_PREVIOUS_CELL, Commands[MOVE_TO_PREVIOUS_CELL], 9 , false, true, false, false);
	
	       
	        commandManager.register(NAVIGATION_PAGE_UP, Commands[NAVIGATION_PAGE_UP], 33 , false, false, false, false);
	       
	        commandManager.register(NAVIGATION_PAGE_DOWN, Commands[NAVIGATION_PAGE_DOWN], 34 , false, false, false, false);
	       
	        commandManager.register(NAVIGATION_PREVIOUS_SHEET, Commands[NAVIGATION_PREVIOUS_SHEET], 33 , ctrl, false, false, meta);
	       
	        commandManager.register(NAVIGATION_NEXT_SHEET, Commands[NAVIGATION_NEXT_SHEET], 34 , ctrl, false, false, meta);
	
	       
	       
	        commandManager.register(CLEAR, Commands[CLEAR], 46 , false, false, false, false);
	       
	        commandManager.register(CLEAR_AND_EDITING, Commands[CLEAR_AND_EDITING], 8 , false, false, false, false);
	
	       
	       
	        commandManager.register(COMMIT_INPUT_NAVIGATION_DOWN, Commands[COMMIT_INPUT_NAVIGATION_DOWN], 13 , false, false, false, false);
	       
	        commandManager.register(COMMIT_INPUT_NAVIGATION_UP, Commands[COMMIT_INPUT_NAVIGATION_UP], 13 , false, true, false, false);
	       
	        commandManager.register(CANCEL_INPUT, Commands[CANCEL_INPUT], 27 , false, false, false, false);
	       
	        commandManager.register(COMMIT_ARRAY_FORMULA, Commands[COMMIT_ARRAY_FORMULA], 13 , true, true, false, false);
	
	       
	       
	        commandManager.register(SELECTION_LEFT, Commands[SELECTION_LEFT], 37 , false, true, false, false);
	        commandManager.register(SELECTION_RIGHT, Commands[SELECTION_RIGHT], 39 , false, true, false, false);
	        commandManager.register(SELECTION_UP, Commands[SELECTION_UP], 38 , false, true, false, false);
	        commandManager.register(SELECTION_DOWN, Commands[SELECTION_DOWN], 40 , false, true, false, false);
	        commandManager.register(SELECTION_HOME, Commands[SELECTION_HOME], 36 , false, true, false, false);
	        commandManager.register(SELECTION_END, Commands[SELECTION_END], 35 , false, true, false, false);
	        commandManager.register(SELECTION_PAGEUP, Commands[SELECTION_PAGEUP], 33 , false, true, false, false);
	        commandManager.register(SELECTION_PAGEDOWN, Commands[SELECTION_PAGEDOWN], 34 , false, true, false, false);
	        commandManager.register(SELECTION_HOME, Commands[SELECTION_HOME], 37 , ctrl, true, false, meta);
	        commandManager.register(SELECTION_END, Commands[SELECTION_END], 39 , ctrl, true, false, meta);
	        commandManager.register(SELECTION_TOP, Commands[SELECTION_TOP], 38 , ctrl, true, false, meta);
	        commandManager.register(SELECTION_BOTTOM, Commands[SELECTION_BOTTOM], 40 , ctrl, true, false, meta);
	        commandManager.register(SELECTION_FIRST, Commands[SELECTION_FIRST], 36 , true, true, false, false);
	        commandManager.register(SELECTION_LAST, Commands[SELECTION_LAST], 35 , true, true, false, false);
	
	       
	       
	        commandManager.register(COPY, Commands[COPY], 67 , ctrl, false, false, meta);
	       
	       
	        commandManager.register(CUT, Commands[CUT], 88 , ctrl, false, false, meta);
	       
	       
	        commandManager.register(PASTE, Commands[PASTE], 86 , ctrl, false, false, meta);
	
	       
	        commandManager.register(UNDO, Commands[UNDO], 90 , ctrl, false, false, meta);
	       
	        commandManager.register(REDO, Commands[REDO], 89 , ctrl, false, false, meta);
	
	        commandManager.register(SELECT_NEXT_CONTROL, Commands[SELECT_NEXT_CONTROL]);
	
	        commandManager.register(SELECT_PREVIOUS_CONTROL, Commands[SELECT_PREVIOUS_CONTROL]);
	
	        commandManager.register(MOVE_TO_NEXT_CELL_THEN_CONTROL, Commands[MOVE_TO_NEXT_CELL_THEN_CONTROL]);
	
	        commandManager.register(MOVE_TO_PREVIOUS_CELL_THEN_CONTROL, Commands[MOVE_TO_PREVIOUS_CELL_THEN_CONTROL]);
	
	        commandManager.register(CHANGE_FORMULA_REFERENCE, Commands[CHANGE_FORMULA_REFERENCE]);
	
	        commandManager.register(RESIZE_COLUMN, Commands[RESIZE_COLUMN]);
	
	        commandManager.register(RESIZE_ROW, Commands[RESIZE_ROW]);
	
	        commandManager.register(AUTO_FIT_COLUMN, Commands[AUTO_FIT_COLUMN]);
	
	        commandManager.register(AUTO_FIT_ROW, Commands[AUTO_FIT_ROW]);
	
	        commandManager.register(EDIT_CELL, Commands[EDIT_CELL]);
	
	        commandManager.register(RENAME_SHEET, Commands[RENAME_SHEET]);
	
	        commandManager.register(ZOOM, Commands[ZOOM]);
	
	        commandManager.register(CLEAR_VALUES, Commands[CLEAR_VALUES]);
	
	        commandManager.register(CLIPBOARD_PASTE, Commands[CLIPBOARD_PASTE]);
	    };
	   
	    
	    Commands[NAVIGATION_LEFT] = {
	        canUndo: false,
	        execute: defNavigation(3 )
	    };
	   
	    
	    Commands[NAVIGATION_RIGHT] = {
	        canUndo: false,
	        execute: defNavigation(4 )
	    };
	   
	    
	    Commands[NAVIGATION_UP] = {
	        canUndo: false,
	        execute: defNavigation(1 )
	    };
	   
	    
	    Commands[NAVIGATION_DOWN] = {
	        canUndo: false,
	        execute: defNavigation(2 )
	    };
	   
	    
	    Commands[COMMIT_ARRAY_FORMULA] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            var formulatextboxCommands = Commands._FormulatextboxCommands;
	            if (formulatextboxCommands) {
	                sheet = formulatextboxCommands._commitArrayFormula(sheet);
	            }
	            sheet._commitArrayFormula && sheet._commitArrayFormula();
	            return true;
	        }
	    };
	   
	    
	    Commands[COMMIT_INPUT_NAVIGATION_DOWN] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            var formulatextboxCommands = Commands._FormulatextboxCommands;
	            if (formulatextboxCommands) {
	                sheet = formulatextboxCommands._commitInputNavigationDown(sheet);
	            }
	            sheet._moveActiveCell(2 , false);
	            return true;
	        }
	    };
	   
	    
	    Commands[COMMIT_INPUT_NAVIGATION_UP] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            var formulatextboxCommands = Commands._FormulatextboxCommands;
	            if (formulatextboxCommands) {
	                sheet = formulatextboxCommands._commitInputNavigationUp(sheet);
	            }
	            sheet._moveActiveCell(1 , false);
	            return true;
	        }
	    };
	   
	    
	    Commands[NAVIGATION_HOME] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            return Commands._navigateNoWrapFrom(sheet, 4 , keyword_null, sheet.frozenColumnCount() - 1);
	        }
	    };
	   
	    
	    Commands[NAVIGATION_HOME_2] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            return Commands._navigateNoWrapFrom(sheet, 4 , keyword_null, -1);
	        }
	    };
	   
	    
	    Commands[NAVIGATION_END] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            return Commands._navigateNoWrapFrom(sheet, 3 , keyword_null, getSheetColumnCount(sheet) - sheet.frozenTrailingColumnCount());
	        }
	    };
	   
	    
	    Commands[NAVIGATION_END_2] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            return Commands._navigateNoWrapFrom(sheet, 3 , keyword_null, getSheetColumnCount(sheet));
	        }
	    };
	   
	    
	    Commands[NAVIGATION_TOP] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            return Commands._navigateNoWrapFrom(sheet, 2 , -1, keyword_null);
	        }
	    };
	   
	    
	    Commands[NAVIGATION_BOTTOM] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            return Commands._navigateNoWrapFrom(sheet, 1 , getSheetRowCount(sheet), keyword_null);
	        }
	    };
	   
	    
	    Commands[NAVIGATION_PAGE_UP] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            if (!sheet || sheet._editorStatus === 2 ) {
	                return false;
	            }
	            var prevPageTopRow = sheet._getPrevPageTopRow();
	            if (prevPageTopRow === keyword_null || prevPageTopRow === sheet._scrollTopRow) {
	                return true;
	            }
	            var rls = sheet._getRowLayout(1, 3 );
	            var newActiveRow = sheet._getNextVisualRow(sheet._activeRowIndex - rls.length);
	            if (newActiveRow < prevPageTopRow) {
	                newActiveRow = prevPageTopRow;
	            }
	
	            var formulatextboxCommands = Commands._FormulatextboxCommands;
	            if (formulatextboxCommands) {
	                var returnObj = formulatextboxCommands._navigationPageUp(sheet, newActiveRow, prevPageTopRow);
	                if (returnObj.r) {
	                    return true;
	                }
	                sheet = returnObj.sheet;
	            }
	
	            if (!sheet.endEdit()) {
	                return false;
	            }
	            if (sheet._canSelect(newActiveRow, sheet.getActiveColumnIndex())) {
	                sheet._setActiveCellCore(newActiveRow, keyword_null);
	                sheet._leadingCellRow = newActiveRow;
	                sheet._moveActiveCell();
	            }
	           
	            sheet._setTopRow(prevPageTopRow);
	            return true;
	        }
	    };
	   
	    
	    Commands[NAVIGATION_PAGE_DOWN] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            if (!sheet || sheet._editorStatus === 2 ) {
	                return false;
	            }
	            var nextPageTopRow = sheet._getNextPageTopRow();
	            if (nextPageTopRow === keyword_null || nextPageTopRow === sheet._scrollTopRow) {
	                return true;
	            }
	            var rls = sheet._getRowLayout(1, 3 );
	            var newActiveRow = sheet._getPrevVisualRow(sheet._activeRowIndex + rls.length);
	            if (newActiveRow < nextPageTopRow) {
	                newActiveRow = nextPageTopRow;
	            }
	
	            var formulatextboxCommands = Commands._FormulatextboxCommands;
	            if (formulatextboxCommands) {
	                var returnObj = formulatextboxCommands._navigationPageDown(sheet, newActiveRow, nextPageTopRow);
	                if (returnObj.r) {
	                    return true;
	                }
	                sheet = returnObj.sheet;
	            }
	
	            if (!sheet.endEdit()) {
	                return false;
	            }
	            if (sheet._canSelect(newActiveRow, sheet.getActiveColumnIndex())) {
	                sheet._setActiveCellCore(newActiveRow, keyword_null);
	                sheet._leadingCellRow = newActiveRow;
	                sheet._moveActiveCell();
	            }
	           
	            sheet._setTopRow(nextPageTopRow);
	            return true;
	        }
	    };
	   
	    
	    Commands[NAVIGATION_NEXT_SHEET] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            moveToNextSheet(sheet, true);
	        }
	    };
	   
	    
	    Commands[NAVIGATION_PREVIOUS_SHEET] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            moveToNextSheet(sheet, false);
	        }
	    };
	   
	    
	    Commands[NAVIGATION_FIRST] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            if (!sheet || sheet._editorStatus === 2 ) {
	                return false;
	            }
	
	            var formulatextboxCommands = Commands._FormulatextboxCommands;
	            if (formulatextboxCommands) {
	                var returnObj = formulatextboxCommands._navigationFirst(sheet);
	                if (returnObj.r) {
	                    return true;
	                }
	                sheet = returnObj.sheet;
	            }
	
	            sheet._moveActiveCell(5 , false, sheet._activeRowIndex, sheet._activeColIndex);
	            return true;
	        }
	    };
	   
	    
	    Commands[NAVIGATION_LAST] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            if (!sheet || sheet._editorStatus === 2 ) {
	                return false;
	            }
	
	            var formulatextboxCommands = Commands._FormulatextboxCommands;
	            if (formulatextboxCommands) {
	                var returnObj = formulatextboxCommands._navigationLast(sheet);
	                if (returnObj.r) {
	                    return true;
	                }
	                sheet = returnObj.sheet;
	            }
	
	            sheet._moveActiveCell(6 , false, sheet._activeRowIndex, sheet._activeColIndex);
	            return true;
	        }
	    };
	   
	    
	    Commands[SELECT_NEXT_CONTROL] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            if (sheet.parent) {
	                return nextControl(sheet, sheet.parent.nextControl);
	            }
	            return false;
	        }
	    };
	   
	    
	    Commands[SELECT_PREVIOUS_CONTROL] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            if (sheet.parent) {
	                return nextControl(sheet, sheet.parent.previousControl);
	            }
	            return false;
	        }
	    };
	   
	    
	    Commands[MOVE_TO_NEXT_CELL] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            var formulatextboxCommands = Commands._FormulatextboxCommands;
	            if (formulatextboxCommands) {
	                sheet = formulatextboxCommands._moveToNextCell(sheet);
	            }
	            tabNavigation(sheet, 4 );
	            return true;
	        }
	    };
	   
	    
	    Commands[MOVE_TO_PREVIOUS_CELL] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            var formulatextboxCommands = Commands._FormulatextboxCommands;
	            if (formulatextboxCommands) {
	                sheet = formulatextboxCommands._moveToPreviousCell(sheet);
	            }
	            tabNavigation(sheet, 3 );
	            return true;
	        }
	    };
	   
	    
	    Commands[MOVE_TO_NEXT_CELL_THEN_CONTROL] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            var leadingCellRow = sheet._leadingCellRow, activeColumnIndex = sheet.getActiveColumnIndex();
	           
	            sheet._isTabNavigation = true;
	            var rightCell = sheet._getMoveRightCell(sheet.getActiveRowIndex(), activeColumnIndex, true, leadingCellRow);
	            sheet._isTabNavigation = false;
	            var isLastVisibleCell = rightCell ? ((rightCell.leadingCellRow < leadingCellRow) || (rightCell.leadingCellRow === leadingCellRow && activeColumnIndex > rightCell.col)) : true;
	            if (isLastVisibleCell) {
	                return Commands[SELECT_NEXT_CONTROL].execute(context, options);
	            }
	            return Commands[MOVE_TO_NEXT_CELL].execute(context, options);
	        }
	    };
	   
	    
	    Commands[MOVE_TO_PREVIOUS_CELL_THEN_CONTROL] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            var leadingCellRow = sheet._leadingCellRow, activeColumnIndex = sheet.getActiveColumnIndex();
	           
	            sheet._isTabNavigation = true;
	            var leftCell = sheet._getMoveLeftCell(sheet.getActiveRowIndex(), activeColumnIndex, true, leadingCellRow);
	            sheet._isTabNavigation = false;
	            var isFirstVisibleCell = leftCell ? ((leftCell.leadingCellRow > leadingCellRow) || (leftCell.leadingCellRow === leadingCellRow && activeColumnIndex < leftCell.col)) : true;
	            if (isFirstVisibleCell) {
	                return Commands[SELECT_PREVIOUS_CONTROL].execute(context, options);
	            }
	            return Commands[MOVE_TO_PREVIOUS_CELL].execute(context, options);
	        }
	    };
	   
	    
	    Commands[CANCEL_INPUT] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            var formulatextboxCommands = Commands._FormulatextboxCommands;
	            var cancelFormulatextbox;
	            if (formulatextboxCommands) {
	                cancelFormulatextbox = formulatextboxCommands._cancelInput(sheet);
	            }
	            if (sheet.isEditing()) {
	               
	                var cacheValue = sheet.getValue(sheet._activeRowIndex, sheet._activeColIndex, 3 , 1 );
	                if (!sheet.endEdit(true)) {
	                    return false;
	                }
	                sheet.setValue(sheet._activeRowIndex, sheet._activeColIndex, cacheValue, 3 , true);
	                return true;
	            }
	            if(!isNullOrUndefined(cancelFormulatextbox)) {
	                return cancelFormulatextbox;
	            }
	            var workbook = sheet.parent, sheets = workbook && workbook.sheets;
	            if (sheets) {
	                for (var index = 0, len = sheets.length; index < len; index++) {
	                    var item = sheets[index];
	                    if (item && item._cutCopyIndicatorManager) {
	                        item._cutCopyIndicatorManager._cancelIndicator();
	                    }
	                }
	            }
	        }
	    };
	   
	    
	    Commands[CLEAR] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            if (!sheet.isEditing()) {
	                var ranges = sheet.getSelections();
	                sheet._commandManager().execute({cmd: CLEAR_VALUES, sheetName: sheet.name(), ranges: ranges});
	                return true;
	            }
	            return false;
	        }
	    };
	   
	    
	    Commands[CLEAR_AND_EDITING] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            if (!sheet.isEditing()) {
	                if (util_common_util._isMacOS()) {
	                    Commands[CLEAR].execute(context, options);
	                    return true;
	                }
	                sheet.startEdit(true, '');
	                return true;
	            }
	            return false;
	        }
	    };
	   
	    
	    Commands[COPY] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            var copyData = options.copyData = sheet._doCopy(options.ignoreClipboard);
	            if (options.callback) {
	                options.callback();
	            }
	            return copyData ? keyword_undefined : true;
	        }
	    };
	   
	    
	    Commands[CUT] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            var cutData = options.cutData = sheet._doCut(options.ignoreClipboard);
	            if (options.callback) {
	                options.callback();
	            }
	            return cutData ? keyword_undefined : true;
	        }
	    };
	   
	    
	    Commands[PASTE] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            sheet._doPaste(options);
	        }
	    };
	   
	    
	    Commands[SELECTION_LEFT] = {
	        canUndo: false,
	        execute: defSelectionAction(37 )
	    };
	   
	    
	    Commands[SELECTION_RIGHT] = {
	        canUndo: false,
	        execute: defSelectionAction(39 )
	    };
	   
	    
	    Commands[SELECTION_UP] = {
	        canUndo: false,
	        execute: defSelectionAction(38 )
	    };
	   
	    
	    Commands[SELECTION_DOWN] = {
	        canUndo: false,
	        execute: defSelectionAction(40 )
	    };
	   
	    
	    Commands[SELECTION_HOME] = {
	        canUndo: false,
	        execute: defSelectionAction(37 , true)
	    };
	   
	    
	    Commands[SELECTION_END] = {
	        canUndo: false,
	        execute: defSelectionAction(39 , true)
	    };
	   
	    
	    Commands[SELECTION_PAGEUP] = {
	        canUndo: false,
	        execute: defSelectionAction(33 )
	    };
	   
	    
	    Commands[SELECTION_PAGEDOWN] = {
	        canUndo: false,
	        execute: defSelectionAction(34 )
	    };
	   
	    
	    Commands[SELECTION_TOP] = {
	        canUndo: false,
	        execute: defSelectionAction(38 , true)
	    };
	   
	    
	    Commands[SELECTION_BOTTOM] = {
	        canUndo: false,
	        execute: defSelectionAction(40 , true)
	    };
	   
	    
	    Commands[SELECTION_FIRST] = {
	        canUndo: false,
	        execute: defSelectionAction(36 , true)
	    };
	   
	    
	    Commands[SELECTION_LAST] = {
	        canUndo: false,
	        execute: defSelectionAction(35 , true)
	    };
	   
	    
	    Commands[CHANGE_FORMULA_REFERENCE] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = getWorksheet(context, options);
	            var eventHandler = sheet && sheet._eventHandler;
	            if (eventHandler) {
	                suspendPaint(sheet);
	                try {
	                    eventHandler._changeFormulaReference && eventHandler._changeFormulaReference();
	                } finally {
	                    resumePaint(sheet);
	                }
	            }
	        }
	    };
	   
	    
	    Commands[UNDO] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var parent = context;
	            if (parent) {
	                var undoManager = parent.undoManager();
	                if (undoManager && undoManager.canUndo()) {
	                    undoManager.undo();
	                }
	            }
	        }
	    };
	   
	    
	    Commands[REDO] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var parent = context;
	            if (parent) {
	                var undoManager = parent.undoManager();
	                if (undoManager && undoManager.canRedo()) {
	                    undoManager.redo();
	                }
	            }
	        }
	    };
	   
	    
	    Commands[RESIZE_COLUMN] = {
	        canUndo: true,
	        execute: function (context, options, isUndo) {
	            return executeCommand(context, ColumnResizeUndoAction, options, isUndo);
	        }
	    };
	   
	    
	    Commands[RESIZE_ROW] = {
	        canUndo: true,
	        execute: function (context, options, isUndo) {
	            return executeCommand(context, RowResizeUndoAction, options, isUndo);
	        }
	    };
	   
	    
	    Commands[AUTO_FIT_COLUMN] = {
	        canUndo: true,
	        execute: function (context, options, isUndo) {
	            return executeCommand(context, ColumnAutoFitUndoAction, options, isUndo);
	        }
	    };
	   
	    
	    Commands[AUTO_FIT_ROW] = {
	        canUndo: true,
	        execute: function (context, options, isUndo) {
	            return executeCommand(context, RowAutoFitUndoAction, options, isUndo);
	        }
	    };
	   
	    
	    Commands[EDIT_CELL] = {
	        canUndo: true,
	        execute: function (context, options, isUndo) {
	            return executeCommand(context, CellEditUndoAction, options, isUndo);
	        }
	    };
	   
	    
	    Commands[RENAME_SHEET] = {
	        canUndo: true,
	        execute: function (context, options, isUndo) {
	            return executeCommand(context, SheetRenameUndoAction, options, isUndo);
	        }
	    };
	
	   
	    
	    Commands[ZOOM] = {
	        canUndo: true,
	        execute: function (context, command, undo) {
	            return executeCommand(context, ZoomUndoAction, command, undo);
	        }
	    };
	
	   
	    
	    Commands[CLEAR_VALUES] = {
	        canUndo: true,
	        execute: function (context, options, isUndo) {
	            return executeCommand(context, ClearValueUndoAction, options, isUndo);
	        }
	    };
	   
	    
	
	    Commands[CLIPBOARD_PASTE] = {
	        canUndo: true,
	        execute: function (context, options, isUndo) {
	            return executeCommand(context, ClipboardPasteUndoAction, options, isUndo);
	        }
	    };
	   
	
	   
	    function ChangedCells(sheet, range, dataType) {
	        var self = this;
	        self._sheet = sheet;
	        self._range = range;
	        self._dataType = dataType;
	        self._cellsData = [];
	        self._changedCells = [];
	        self._initCellsData();
	    }
	
	    var copyToOptionDict = {
	        256 : 'bindingPath',
	        4 : 'comment',
	        2 : 'formula',
	        16 : 'sparkline',
	        64 : 'style',
	        128 : 'tag',
	        1 : 'value'
	    };
	    $_extend(ChangedCells.prototype, {
	        _initCellsData: function () {
	            var self = this, range = self._range, sheet = self._sheet;
	            if (!sheet || !range) {
	                return;
	            }
	            var dataType = self._dataType, baseRow = range.row, baseColumn = range.col,
	                rowCount = getRowCount(range), columnCount = getColCount(range), cellsData = self._cellsData,
	                isWholeRowOrColumn = false;
	            if (baseRow === -1) {
	                isWholeRowOrColumn = true;
	                baseRow = 0;
	                rowCount = getSheetRowCount(sheet);
	            }
	            if (baseColumn === -1) {
	                isWholeRowOrColumn = true;
	                baseColumn = 0;
	                columnCount = getSheetColumnCount(sheet);
	            }
	            var defaultRowStyle, defaultColStyles = [], cellStyle;
	            if ((dataType & 64 ) > 0) {
	                for (var j = 0; j < columnCount; j++) {
	                    defaultColStyles[j] = sheet._getStyleObject(-1, j) || keyword_null;
	                }
	            }
	            for (var r = 0; r < rowCount; r++) {
	                var sheetRow = baseRow + r;
	                if ((dataType & 64 ) > 0) {
	                    defaultRowStyle = sheet._getStyleObject(sheetRow, -1) || keyword_null;
	                }
	                for (var c = 0; c < columnCount; c++) {
	                    var formulaInfo, sheetCol = baseColumn + c;
	                   
	                    if (exports._supportsCalc && (dataType & 2 ) > 0 && sheet.getFormulaInformation) {
	                        formulaInfo = sheet.getFormulaInformation(sheetRow, sheetCol);
	                        if (formulaInfo.hasFormula) {
	                            if (formulaInfo.isArrayFormula) {
	                                var baseRange = formulaInfo.baseRange;
	                                if (baseRange.row === sheetRow && baseRange.col === sheetCol) {
	                                    for (var rowIndex = baseRange.row, len = baseRange.row + getRowCount(baseRange); rowIndex < len; rowIndex++) {
	                                        for (var colIndex = baseRange.col, len1 = baseRange.col + getColCount(baseRange); colIndex < len1; colIndex++) {
	                                            self._setCellData(cellsData, rowIndex - baseRow, colIndex - baseColumn, formulaInfo, 2 );
	                                        }
	                                    }
	                                }
	                            } else {
	                                self._setCellData(cellsData, r, c, formulaInfo.formula, 2 );
	                            }
	                        }
	                    }
	                   
	                    if ((dataType & 1 ) > 0 && (!formulaInfo || !formulaInfo.hasFormula)) {
	                        self._setCellData(cellsData, r, c, sheet.getValue(sheetRow, sheetCol, 3 ), 1 );
	                    }
	                   
	                    if ((dataType & 16 ) > 0 && sheet.getSparkline) {
	                        var sparkline = sheet.getSparkline(sheetRow, sheetCol);
	                        var dataRange = keyword_null;
	                        if (sparkline) {
	                            dataRange = sparkline.data();
	                        }
	                        if (sparkline && dataRange) {
	                            self._setCellData(cellsData, r, c, sparkline, 16 );
	                        }
	                    }
	                   
	                    if ((dataType & 64 ) > 0) {
	                        var styleObject;
	                        if (isWholeRowOrColumn) {
	                            styleObject = sheet.getActualStyle(sheetRow, sheetCol, 3 );
	                        } else {
	                            cellStyle = sheet._getStyleObject(sheetRow, sheetCol) || keyword_null;
	                            styleObject = sheet._getCompositeStyle(sheetRow, sheetCol, 3 , cellStyle, defaultRowStyle, defaultColStyles[c]);
	                        }
	                        var styleString = keyword_undefined;
	                        if (styleObject && styleObject.toJSON) {
	                            styleString = JSON.stringify(styleObject.toJSON(3 , true));
	                        }
	                        self._setCellData(cellsData, r, c, styleString, 64 );
	                    }
	                   
	                    var commentManager = sheet._modelManager._comments;
	                    if ((dataType & 4 ) > 0 && commentManager) {
	                        self._setCellData(cellsData, r, c, commentManager.get(sheetRow, sheetCol), 4 );
	                    }
	                   
	                    if ((dataType & 128 ) > 0) {
	                        self._setCellData(cellsData, r, c, sheet.getTag(sheetRow, sheetCol, 3 ), 128 );
	                    }
	                   
	                    if ((dataType & 256 ) > 0) {
	                        self._setCellData(cellsData, r, c, sheet.getBindingPath && sheet.getBindingPath(sheetRow, sheetCol, 3 ), 256 );
	                    }
	                }
	            }
	        },
	        _getCellsData: function () {
	            return this._cellsData;
	        },
	        _setCellData: function (cellsData, r, c, data, dataType) {
	            if (isNullOrUndefined(data) || !cellsData) {
	                return;
	            }
	            if (cellsData[r] === keyword_undefined) {
	                cellsData[r] = [];
	            }
	            if (cellsData[r][c] === keyword_undefined) {
	                cellsData[r][c] = {};
	            }
	            cellsData[r][c][copyToOptionDict[dataType]] = data;
	        },
	        _mergeCellsHasDiffData: function (outerData) {
	            if (!outerData) {
	                return;
	            }
	            var self = this;
	            var cellsData = self._cellsData;
	            for (var r = 0, len = outerData.length; r < len; r++) {
	                var outerRowData = outerData[r];
	                if (outerRowData) {
	                    for (var c = 0, len1 = outerRowData.length; c < len1; c++) {
	                        var outerCellData = outerRowData[c];
	                        if (outerCellData) {
	                            if (!cellsData[r]) {
	                                cellsData[r] = [];
	                            }
	                            var cellData = cellsData[r][c];
	                            if (!cellData) {
	                                cellsData[r][c] = outerCellData;
	                            } else if (self._isDataEqual(outerCellData, cellData)) {
	                                cellsData[r][c] = keyword_undefined;
	                            }
	                        }
	                    }
	                }
	            }
	        },
	        _isDataEqual: function (obj1, obj2) {
	            var dataType = this._dataType, dataPropStrs = [];
	            if (dataType & 256 ) {
	                dataPropStrs.push(copyToOptionDict[256 ]);
	            }
	            if (dataType & 4 ) {
	                dataPropStrs.push(copyToOptionDict[4 ]);
	            }
	            if (dataType & 2 ) {
	                dataPropStrs.push(copyToOptionDict[2 ]);
	            }
	            if (dataType & 16 ) {
	                dataPropStrs.push(copyToOptionDict[16 ]);
	            }
	            if (dataType & 64 ) {
	                dataPropStrs.push(copyToOptionDict[64 ]);
	            }
	            if (dataType & 128 ) {
	                dataPropStrs.push(copyToOptionDict[128 ]);
	            }
	            if (dataType & 1 ) {
	                dataPropStrs.push(copyToOptionDict[1 ]);
	            }
	            for (var i = 0, len = dataPropStrs.length; i < len; i++) {
	                var dataPropStr = dataPropStrs[i];
	                if (obj1[dataPropStr] !== obj2[dataPropStr]) {
	                    return false;
	                }
	            }
	            return true;
	        },
	        _getChangedCells: function () {
	            var self = this, baseRow = self._range.row, baseColumn = self._range.col, cellsData = self._cellsData;
	            var changedCells = self._changedCells;
	            if (changedCells && changedCells.length > 0) {
	                return changedCells;
	            }
	
	            changedCells = [];
	            baseRow = baseRow === -1 ? 0 : baseRow;
	            baseColumn = baseColumn === -1 ? 0 : baseColumn;
	            for (var r = 0, len = cellsData.length; r < len; r++) {
	                var rowData = cellsData[r];
	                if (rowData) {
	                    for (var c = 0, len1 = rowData.length; c < len1; c++) {
	                        if (rowData[c]) {
	                            changedCells.push({row: r + baseRow, col: c + baseColumn});
	                        }
	                    }
	                }
	            }
	            self._changedCells = changedCells;
	            return changedCells;
	        }
	    });
	    Commands._ChangedCells = ChangedCells;
	   
	
	    Commands._raiseRangeDataChanged = function (sheet, row, column, rowCount, columnCount, changedCells, action) {
	        if (sheet) {
	            if (row < 0) {
	                row = 0;
	                rowCount = getSheetRowCount(sheet);
	            }
	            if (column < 0) {
	                column = 0;
	                columnCount = getSheetColumnCount(sheet);
	            }
	            sheet._raiseRangeDataChanged(row, column, rowCount, columnCount, changedCells, action);
	        }
	    };
	
	    function getSheets(context, sheetName) {
	        var sheets = [];
	        if (typeof sheetName === 'string') {
	            sheets.push(context.getSheetFromName(sheetName));
	        } else if (Array.isArray(sheetName)) {
	            sheetName.forEach(function (name) {
	                sheets.push(context.getSheetFromName(name));
	            });
	        }
	        return sheets;
	    }
	
	    Commands._getChangesKey = function (sheetName) {
	        return 'changes' + sheetName;
	    };
	    Commands._isNotEmptyChanges = function (changes) {
	        return changes && (changes.length !== 0 || !$.isEmptyObject(changes));
	    };
	    Commands._isInTransaction = function (options) {
	        var names;
	        var sheetName = options.sheetName;
	        if (typeof sheetName === "string") {
	            names = [sheetName];
	        } else if (Array.isArray(sheetName)) {
	            names = sheetName;
	        }
	        if (names) {
	            return names.every(function (name) {
	                var changesKey = Commands._getChangesKey(name);
	                var changes = options[changesKey];
	                return changes && changes.length === 0 && $.isEmptyObject(changes);
	            });
	        }
	        return false;
	    };
	   
	    
	    Commands.startTransaction = function (context, options) {
	        getSheets(context, options.sheetName).forEach(function (sheet) {
	            sheet._modelManager.startTransaction();
	        });
	    };
	   
	    
	    Commands.endTransaction = function (context, options) {
	        getSheets(context, options.sheetName).forEach(function (sheet) {
	            var changesKey = Commands._getChangesKey(sheet.name());
	            options[changesKey] = sheet._modelManager.endTransaction();
	        });
	    };
	   
	    
	    Commands.undoTransaction = function (context, options) {
	        getSheets(context, options.sheetName).forEach(function (sheet) {
	            var changesKey = Commands._getChangesKey(sheet.name());
	            sheet._modelManager.undo(options[changesKey]);
	            sheet._invalidate();
	        });
	    };
	
	   
	    function beforeAction(sheet, ignoreEvent) {
	        suspendPaint(sheet);
	        if (!ignoreEvent) {
	            suspendEvent(sheet);
	        }
	    }
	
	    function afterAction(sheet, ignoreEvent) {
	        if (!ignoreEvent) {
	            resumeEvent(sheet);
	        }
	        resumePaint(sheet);
	    }
	
	    function ActionBase() {
	    }
	
	    ActionBase.prototype = {
	        constructor: ActionBase,
	        execute: function () {
	        },
	        canExecute: function () {
	            return true;
	        },
	        canUndo: function () {
	            return true;
	        },
	        undo: function () {
	            return true;
	        },
	        _beforeAction: beforeAction,
	        _afterAction: afterAction
	    };
	    Commands.ActionBase = ActionBase;
	   
	
	   
	    $_inherit(ColumnResizeUndoAction, ActionBase);
	
	    function ColumnResizeUndoAction(sheet, command) {
	        var self = this;
	        ActionBase.call(self);
	        self._sheet = sheet;
	        self._command = command;
	        if (isNullOrUndefined(command._scrollTopRow)) {
	            self._command._scrollTopRow = sheet._scrollTopRow;
	            self._command._scrollLeftCol = sheet._scrollLeftCol;
	        }
	    }
	
	    $_extend(ColumnResizeUndoAction.prototype, {
	        execute: function () {
	            var self = this;
	            var ret = false;
	            if (self.canExecute()) {
	                var command = self._command;
	                var sheet = self._sheet, columns = command.columns, isRowHeader = command.rowHeader,
	                    columnsLength = (columns && columns.length);
	                if (sheet && columnsLength > 0) {
	                    var colList = self._getColList(columns);
	                    var args = {
	                        sheet: sheet,
	                        sheetName: sheet.name(),
	                        colList: colList,
	                        header: isRowHeader,
	                        cancel: false
	                    };
	                    sheet._trigger(Events_ColumnWidthChanging, args);
	                    if (args && args.cancel === true) {
	                        return ret;
	                    }
	                    command._canUndo = true;
	                    sheet._modelManager.startTransaction();
	                    beforeAction(sheet);
	                    try {
	                        var rowHeaderArea = 2 , viewportArea = 3 ,
	                            columnCount = (isRowHeader ? getSheetColumnCount(sheet, rowHeaderArea) : getSheetColumnCount(sheet, viewportArea));
	                        sheet._scrollLeftCol = command._scrollLeftCol; 
	                        var newSize = command.size;
	                        for (var c = 0; c < columnsLength; c++) {
	                            var cw = columns[c], firstCol = cw.firstCol, lastCol = cw.lastCol;
	                            for (var c2 = firstCol; c2 <= lastCol; c2++) {
	                                if (0 <= c2 && c2 < columnCount) {
	                                    if (isRowHeader && sheet.getColumnResizable(c2, rowHeaderArea) &&
	                                        newSize !== sheet._getActualColumnWidth(c2, rowHeaderArea)) {
	                                        sheet.setColumnWidth(c2, newSize, rowHeaderArea);
	                                        ret = true;
	                                    } else if (!isRowHeader && sheet.getColumnResizable(c2, viewportArea) &&
	                                        newSize !== sheet._getActualColumnWidth(c2, viewportArea)) {
	                                        sheet.setColumnWidth(c2, newSize, viewportArea);
	                                        ret = true;
	                                    }
	                                }
	                            }
	                        }
	                    } finally {
	                        afterAction(sheet, false);
	                        var changesKey = Commands._getChangesKey(sheet.name());
	                        command[changesKey] = sheet._modelManager.endTransaction();
	                    }
	                    sheet._trigger(Events_ColumnWidthChanged, {
	                        sheet: sheet,
	                        sheetName: sheet.name(),
	                        colList: colList,
	                        header: command.rowHeader
	                    });
	                    sheet._syncHScrollbarPosition();
	                }
	            }
	
	            return ret;
	        },
	        undo: function () {
	            var self = this;
	            var ret = false;
	            if (self.canUndo()) {
	                var command = self._command;
	                var sheet = self._sheet, columns = command.columns, isRowHeader = command.rowHeader,
	                    columnsLength = (columns && columns.length);
	                if (sheet && columnsLength > 0) {
	                    var colList = self._getColList(columns);
	                    var args = {
	                        sheet: sheet,
	                        sheetName: sheet.name(),
	                        colList: colList,
	                        header: isRowHeader,
	                        cancel: false
	                    };
	                    sheet._trigger(Events_ColumnWidthChanging, args);
	
	                    if (args && args.cancel === true) {
	                        return ret;
	                    }
	                    beforeAction(sheet);
	                    try {
	                        var changesKey = Commands._getChangesKey(sheet.name());
	                        sheet._modelManager.undo(command[changesKey]);
	                        var lastItem = columns[columns.length - 1], firstColumn = lastItem.firstCol,
	                            row = command._scrollTopRow;
	                        sheet._needSyncHScrollbarSize = true;
	                        sheet.showCell(row, firstColumn, 0 , 1 );
	                        ret = true;
	                    } finally {
	                        afterAction(sheet, false);
	                    }
	                    sheet._trigger(Events_ColumnWidthChanged, {
	                        sheet: sheet,
	                        sheetName: sheet.name(),
	                        colList: colList,
	                        header: command.rowHeader
	                    });
	                }
	            }
	
	            return ret;
	        },
	        _getColList: function (columnWidthChangeExtents) {
	            var columns = [];
	            for (var i = 0, len = columnWidthChangeExtents.length; i < len; i++) {
	                var item = columnWidthChangeExtents[i], firstCol = item.firstCol, lastCol = item.lastCol;
	                for (var col = firstCol; col <= lastCol; col++) {
	                    columns.push(col);
	                }
	            }
	            return columns;
	        },
	        canUndo: function () {
	            return this._command._canUndo;
	        }
	    });
	   
	
	   
	    $_inherit(RowResizeUndoAction, ActionBase);
	
	    function RowResizeUndoAction(sheet, command) {
	        var self = this;
	        ActionBase.call(self);
	        self._sheet = sheet;
	        self._command = command;
	        if (isNullOrUndefined(command._scrollTopRow)) {
	            self._command._scrollTopRow = sheet._scrollTopRow;
	            self._command._scrollLeftCol = sheet._scrollLeftCol;
	        }
	    }
	
	    $_extend(RowResizeUndoAction.prototype, {
	        execute: function () {
	            var self = this;
	            var ret = false;
	            if (self.canExecute()) {
	                var sheet = self._sheet, command = self._command, rows = command.rows,
	                    rowsLength = (rows && rows.length);
	                if (sheet && rowsLength > 0) {
	                    var rowList = self._getRowList(rows);
	                    var args = {
	                        sheet: sheet,
	                        sheetName: sheet.name(),
	                        rowList: rowList,
	                        header: command.columnHeader,
	                        cancel: false
	                    };
	                    sheet._trigger(Events_RowHeightChanging, args);
	                    if (args && args.cancel === true) {
	                        return ret;
	                    }
	                    command._canUndo = true;
	                    sheet._modelManager.startTransaction();
	                    beforeAction(sheet);
	                    try {
	                        var viewportArea = 3 , colHeaderArea = 1 ,
	                            isColumnHeader = command.columnHeader,
	                            rowCount = (isColumnHeader ? getSheetRowCount(sheet, colHeaderArea) : getSheetRowCount(sheet, viewportArea));
	                        sheet._scrollTopRow = command._scrollTopRow;
	                        var newSize = command.size;
	                        for (var r = 0; r < rowsLength; r++) {
	                            var rh = rows[r], firstRow = rh.firstRow, lastRow = rh.lastRow;
	                            for (var r2 = firstRow; r2 <= lastRow; r2++) {
	                                if (0 <= r2 && r2 < rowCount) {
	                                    if (isColumnHeader && sheet.getRowResizable(r2, colHeaderArea) &&
	                                        newSize !== sheet._getActualRowHeight(r2, colHeaderArea)) {
	                                        sheet.setRowHeight(r2, newSize, colHeaderArea);
	                                        ret = true;
	                                    } else if (!isColumnHeader && sheet.getRowResizable(r2, viewportArea) &&
	                                        newSize !== sheet._getActualRowHeight(r2, viewportArea)) {
	                                        sheet.setRowHeight(r2, newSize, viewportArea);
	                                        ret = true;
	                                    }
	                                }
	                            }
	                        }
	                    } finally {
	                        afterAction(sheet, false);
	                        var changesKey = Commands._getChangesKey(sheet.name());
	                        command[changesKey] = sheet._modelManager.endTransaction();
	                    }
	                    sheet._trigger(Events_RowHeightChanged, {
	                        sheet: sheet,
	                        sheetName: sheet.name(),
	                        rowList: rowList,
	                        header: command.columnHeader
	                    });
	                    sheet._syncVScrollbarPosition();
	                }
	            }
	
	            return ret;
	        },
	        undo: function () {
	            var self = this;
	            var ret = false;
	            if (self.canUndo()) {
	                var sheet = self._sheet, command = self._command, rows = command.rows,
	                    rowsLength = (rows && rows.length);
	                if (sheet && rowsLength > 0) {
	                    var rowList = self._getRowList(rows);
	                    var args = {
	                        sheet: sheet,
	                        sheetName: sheet.name(),
	                        rowList: rowList,
	                        header: command.columnHeader,
	                        cancel: false
	                    };
	                    sheet._trigger(Events_RowHeightChanging, args);
	                    if (args && args.cancel === true) {
	                        return ret;
	                    }
	                    beforeAction(sheet);
	                    try {
	                        var changesKey = Commands._getChangesKey(sheet.name());
	                        sheet._modelManager.undo(command[changesKey]);
	                        var lastItem = rows[rows.length - 1], firstRow = lastItem.firstRow,
	                            column = command._scrollLeftCol;
	                        sheet._needSyncVScrollbarSize = true;
	                        sheet.showCell(firstRow, column, 1 , 0 );
	                        ret = true;
	                    } finally {
	                        afterAction(sheet, false);
	                    }
	                    sheet._trigger(Events_RowHeightChanged, {
	                        sheet: sheet,
	                        sheetName: sheet.name(),
	                        rowList: rowList,
	                        header: command.columnHeader
	                    });
	                }
	            }
	
	            return ret;
	        },
	        _getRowList: function (rowHeightChangeExtents) {
	            var rows = [];
	            for (var i = 0, len = rowHeightChangeExtents.length; i < len; i++) {
	                var item = rowHeightChangeExtents[i], firstRow = item.firstRow, lastRow = item.lastRow;
	                for (var row = firstRow; row <= lastRow; row++) {
	                    rows.push(row);
	                }
	            }
	            return rows;
	        },
	        canUndo: function () {
	            return this._command._canUndo;
	        }
	    });
	   
	
	   
	    $_inherit(ColumnAutoFitUndoAction, ActionBase);
	
	    function ColumnAutoFitUndoAction(sheet, command) {
	        var self = this, parent = sheet.parent;
	        ActionBase.call(self);
	        self._sheet = sheet;
	        self._command = command;
	        self._sheetArea = command.rowHeader ? 2  : 3 ;
	        if (!isDefined(command.autoFitType)) {
	            command.autoFitType = parent ? parent.options.autoFitType : 0 ;
	        }
	    }
	
	    $_extend(ColumnAutoFitUndoAction.prototype, {
	        canExecute: function () {
	            var command = this._command;
	            return this._sheet && command.columns && command.columns.length > 0;
	        },
	        execute: function () {
	            var self = this;
	            var ret = false;
	            if (self.canExecute()) {
	                var command = self._command;
	                var sheet = self._sheet;
	                var sheetArea = self._sheetArea;
	                var colList = self._getColList(command.columns);
	                var isHeader = sheetArea === 2 ;
	                var args = {
	                    sheet: sheet,
	                    sheetName: sheet.name(),
	                    colList: colList,
	                    header: isHeader,
	                    cancel: false
	                };
	                sheet._trigger(Events_ColumnWidthChanging, args);
	                if (args && args.cancel === true) {
	                    return ret;
	                }
	                command._canUndo = true;
	                var columnCount = getSheetColumnCount(sheet, sheetArea);
	                var startCol = columnCount - 1, endCol = 0, cTemp, c, len;
	                for (c = 0, len = command.columns.length; c < len; c++) {
	                    cTemp = command.columns[c].col;
	                    startCol = startCol > cTemp ? cTemp : startCol;
	                    endCol = endCol < cTemp ? cTemp : endCol;
	                }
	                _CacheMgr._startCache(sheet, 0, startCol, getSheetRowCount(sheet) - 1, endCol);
	                sheet._modelManager.startTransaction();
	                beforeAction(sheet);
	                try {
	                    var fitValue;
	                    for (c = 0, len = command.columns.length; c < len; c++) {
	                        var col = command.columns[c].col;
	                        if (0 <= col && col < columnCount && sheet.getColumnResizable(col, sheetArea)) {
	                            fitValue = self._getColumnAutoFitValue(col);
	                            if (fitValue !== sheet.getColumnWidth(col, sheetArea)) {
	                                sheet.setColumnWidth(col, fitValue, sheetArea);
	                                ret = true;
	                            }
	                        }
	                    }
	                } finally {
	                    _CacheMgr._clearCache();
	                    afterAction(sheet, false);
	                    var changesKey = Commands._getChangesKey(sheet.name());
	                    command[changesKey] = sheet._modelManager.endTransaction();
	                }
	                sheet._trigger(Events_ColumnWidthChanged, {
	                    sheet: sheet,
	                    sheetName: sheet.name(),
	                    colList: colList,
	                    header: isHeader
	                });
	            }
	
	            return ret;
	        },
	        undo: function () {
	            var self = this;
	            var ret = false;
	            if (self.canUndo()) {
	                var command = self._command;
	                var sheet = self._sheet;
	                var sheetArea = self._sheetArea;
	                var colList = self._getColList(command.columns);
	                var isHeader = sheetArea === 2 ;
	                var args = {
	                    sheet: sheet,
	                    sheetName: sheet.name(),
	                    colList: colList,
	                    header: isHeader,
	                    cancel: false
	                };
	                sheet._trigger(Events_ColumnWidthChanging, args);
	                if (args && args.cancel === true) {
	                    return ret;
	                }
	                beforeAction(sheet);
	                try {
	                    var changesKey = Commands._getChangesKey(sheet.name());
	                    sheet._modelManager.undo(command[changesKey]);
	                    ret = true;
	                } finally {
	                    afterAction(sheet, false);
	                }
	                sheet._trigger(Events_ColumnWidthChanged, {
	                    sheet: sheet,
	                    sheetName: sheet.name(),
	                    colList: colList,
	                    header: isHeader
	                });
	            }
	
	            return ret;
	        },
	        _getColList: function (columnWidthChangeExtents) {
	            var columns = [];
	            for (var i = 0; i < columnWidthChangeExtents.length; i++) {
	                var item = columnWidthChangeExtents[i];
	                columns.push(item.col);
	            }
	            return columns;
	        },
	        _getColumnAutoFitValue: function (col) {
	            return util_common_util._getColumnAutoFitValue(col, this._sheet, this._sheetArea, this._command.autoFitType);
	        },
	        canUndo: function () {
	            return this._command._canUndo;
	        }
	    });
	   
	
	   
	    $_inherit(RowAutoFitUndoAction, ActionBase);
	
	    function RowAutoFitUndoAction(sheet, command) {
	        var self = this, parent = sheet.parent;
	        ActionBase.call(self);
	        self._sheet = sheet;
	        self._command = command;
	        self._sheetArea = command.columnHeader ? 1  : 3 ;
	        if (!isDefined(command.autoFitType)) {
	            command.autoFitType = parent ? parent.options.autoFitType : 0 ;
	        }
	    }
	
	    $_extend(RowAutoFitUndoAction.prototype, {
	        canExecute: function () {
	            var command = this._command;
	            return this._sheet && command.rows && command.rows.length > 0;
	        },
	        execute: function () {
	            var self = this;
	            var ret = false;
	            if (self.canExecute()) {
	                var command = self._command;
	                var sheet = self._sheet;
	                var rowList = self._getRowList(command.rows);
	                var sheetArea = self._sheetArea;
	                var inHeader = self._sheetArea === 1 ;
	                var args = {
	                    sheet: sheet,
	                    sheetName: sheet.name(),
	                    rowList: rowList,
	                    header: inHeader,
	                    cancel: false
	                };
	                sheet._trigger(Events_RowHeightChanging, args);
	                if (args && args.cancel === true) {
	                    return ret;
	                }
	                command._canUndo = true;
	                sheet._modelManager.startTransaction();
	                beforeAction(sheet);
	                try {
	                    var rowCount = getSheetRowCount(sheet, sheetArea);
	                    var fitValue;
	                    for (var r = 0, len = command.rows.length; r < len; r++) {
	                        var row = command.rows[r].row;
	                        if (0 <= row && row < rowCount && sheet.getRowResizable(row, sheetArea)) {
	                            fitValue = self._getRowAutoFitValue(row);
	                            if (fitValue !== sheet.getRowHeight(row, sheetArea)) {
	                                sheet.setRowHeight(row, fitValue, sheetArea);
	                                ret = true;
	                            }
	                        }
	                    }
	                } finally {
	                    afterAction(sheet, false);
	                    var changesKey = Commands._getChangesKey(sheet.name());
	                    command[changesKey] = sheet._modelManager.endTransaction();
	                }
	                sheet._trigger(Events_RowHeightChanged, {
	                    sheet: sheet,
	                    sheetName: sheet.name(),
	                    rowList: rowList,
	                    header: inHeader
	                });
	            }
	
	            return ret;
	        },
	        undo: function () {
	            var self = this;
	            var ret = false;
	            if (self.canUndo()) {
	                var command = self._command;
	                var sheet = self._sheet;
	                var rowList = self._getRowList(command.rows);
	                var inHeader = self._sheetArea === 1 ;
	                var args = {
	                    sheet: sheet,
	                    sheetName: sheet.name(),
	                    rowList: rowList,
	                    header: inHeader,
	                    cancel: false
	                };
	                sheet._trigger(Events_RowHeightChanging, args);
	                if (args && args.cancel === true) {
	                    return ret;
	                }
	                beforeAction(sheet);
	                try {
	                    var changesKey = Commands._getChangesKey(sheet.name());
	                    sheet._modelManager.undo(command[changesKey]);
	                    ret = true;
	                } finally {
	                    afterAction(sheet, false);
	                }
	                sheet._trigger(Events_RowHeightChanged, {
	                    sheet: sheet,
	                    sheetName: sheet.name(),
	                    rowList: rowList,
	                    header: inHeader
	                });
	            }
	
	            return ret;
	        },
	        _getRowList: function (rowHeightChangeExtents) {
	            var rows = [];
	            for (var i = 0, len = rowHeightChangeExtents.length; i < len; i++) {
	                var item = rowHeightChangeExtents[i];
	                rows.push(item.row);
	            }
	            return rows;
	        },
	        _getRowAutoFitValue: function (row) {
	            return util_common_util._getRowAutoFitValue(row, this._sheet, this._sheetArea, this._command.autoFitType);
	        },
	        canUndo: function () {
	            return this._command._canUndo;
	        }
	    });
	   
	
	   
	    $_inherit(CellEditUndoAction, ActionBase);
	    var CELL_EDIT_ACTION_EVENT_NS = '.cellEditAction';
	
	    function CellEditUndoAction(sheet, command) {
	        var self = this;
	        ActionBase.call(self);
	        self._command = command;
	        self._sheet = sheet;
	       
	       
	        if (exports._supportsCalc && command.ranges && command.endEditType === 1 ) {
	            var range = sheet._getActualRange(command.ranges[0]);
	            command.ranges[0] = range;
	            if (getRowCount(range) === 1 && getColCount(range) === 1) {
	                var exFormulas = sheet._getsArrayFormulas(range.row, range.col, 1, 1);
	                if (exFormulas && exFormulas.ranges && exFormulas.ranges.length > 0) {
	                    command.ranges = [exFormulas.ranges[0]];
	                }
	            }
	        }
	    }
	
	    $_extend(CellEditUndoAction.prototype, {
	        canExecute: function () {
	            var self = this;
	            var sheet = self._sheet, command = self._command,
	                ranges = command.ranges, row = command.row, col = command.col;
	            if (ranges) {
	                for (var i = 0; i < ranges.length; i++) {
	                    var range = ranges[i];
	                    if (!sheet._canChange(range.row, range.col, getRowCount(range), getColCount(range))) {
	                        return false;
	                    }
	                }
	            } else if (!sheet._canChange(row, col, 1, 1)) {
	                return false;
	            }
	            return true;
	        },
	        _iteration: function (func) {
	            var self = this, command = self._command, ranges = command.ranges;
	            if (ranges) {
	                for (var rangeIndex = 0; rangeIndex < ranges.length; rangeIndex++) {
	                    var range = ranges[rangeIndex];
	                    for (var row = range.row; row < range.row + getRowCount(range); row++) {
	                        for (var col = range.col; col < range.col + getColCount(range); col++) {
	                            func(row, col);
	                        }
	                    }
	                }
	            } else {
	                func(command.row, command.col);
	            }
	        },
	        undo: function () {
	            var self = this;
	            if (self.canUndo()) {
	                var sheet = self._sheet, command = self._command;
	                beforeAction(sheet, true);
	                try {
	                    sheet._bind(Events_CellChanged + CELL_EDIT_ACTION_EVENT_NS, function (event, data) {
	                        if (data.propertyName === 'value') {
	                            sheet._raiseValueChanged(data.row, data.col, data.oldValue, data.newValue);
	                        }
	                    });
	                    var changesKey = Commands._getChangesKey(sheet.name());
	                    sheet._modelManager.undo(command[changesKey]);
	                } catch (ex) {
	                    return false;
	                } finally {
	                    sheet._unbind(Events_CellChanged + CELL_EDIT_ACTION_EVENT_NS);
	                    afterAction(sheet, true);
	                }
	                return true;
	            }
	            return false;
	        },
	        execute: function () {
	            var self = this;
	            var succeed = false;
	            if (self.canExecute()) {
	                var sheet = self._sheet;
	                sheet._modelManager.startTransaction();
	                beforeAction(sheet, true);
	                try {
	                    sheet._bind(Events_CellChanged + CELL_EDIT_ACTION_EVENT_NS, function (event, data) {
	                        if (data.propertyName === 'value') {
	                            sheet._raiseValueChanged(data.row, data.col, data.oldValue, data.newValue);
	                        }
	                    });
	                    self._command.applyResult = self._applyEditing();
	                    succeed = true;
	                } catch (e) {
	                    succeed = false;
	                } finally {
	                    sheet._unbind(Events_CellChanged + CELL_EDIT_ACTION_EVENT_NS);
	                    afterAction(sheet, true);
	                    var changesKey = Commands._getChangesKey(sheet.name());
	                    self._command[changesKey] = sheet._modelManager.endTransaction();
	                }
	               
	                var layout = sheet._getSheetLayout(), rect = new Rect(layout._frozenX, layout._frozenY,
	                    layout.width - layout._frozenX, layout.height - layout._frozenY);
	                sheet.repaint(rect);
	            }
	            return succeed;
	        },
	        _positionToString: function (row, col) {
	            return row + '_' + col;
	        },
	       
	       
	       
	       
	        _validateEditingValue: function (styleChangedInfo) {
	            var self = this;
	            var action = 0 ;
	            var sheet = self._sheet;
	            var command = self._command;
	            var row = command.row;
	            var col = command.col;
	            var text = command.newValue;
	            var autoFormat = command.hasOwnProperty('autoFormat') ? command.autoFormat : true;
	            if (exports._supportsCalc && text && text.length > 0 && text[0] === '=') {
	                if (sheet.getDataValidator && sheet.getDataValidator(row, col)) {
	                    var newFormula = text.substring(1);
	                    if (newFormula !== '' && newFormula !== sheet.getFormula(row, col)) {
	                        var svc = sheet._getCalcServiceInternal();
	                        if (svc) {
	                            var expr = svc.parse(sheet._getSheetSource(), newFormula, row >= 0 ? row : 0, col >= 0 ? col : 0, true);
	                            if (expr) {
	                                var calc = svc._evaluateParsedFormula(sheet._getSheetSource(), expr, {
	                                    row: row,
	                                    col: col
	                                });
	                                if (!(sheet.isValid ? sheet.isValid(row, col, calc) : true)) {
	                                    action = sheet._validationError(row, col);
	                                }
	                            }
	                        }
	                    }
	                }
	            } else {
	                var value = self._getValueFromEditing(row, col, text, autoFormat, styleChangedInfo);
	                var valid = sheet.isValid ? sheet.isValid(row, col, value) : true;
	                if (!valid) {
	                    action = sheet._validationError(row, col);
	                    sheet._eventHandler._forceCancelSelectiong = true;
	                }
	            }
	            return action;
	        },
	        _applyEditing: function () {
	            var self = this;
	            var sheet = self._sheet;
	            var command = self._command;
	            var text = command.newValue;
	            var styleChangedInfo = {
	                _isAutoFormatChanged: false,
	                _isQuotePrefixChanged: false,
	                _autoFormatter: keyword_undefined,
	                quotePrefix: keyword_undefined
	            };
	            var action = self._validateEditingValue(styleChangedInfo);
	            if (action === 1  || action === 2 ) {
	                return action;
	            }
	
	            var value;
	            var autoFormat = command.hasOwnProperty('autoFormat') ? command.autoFormat : true;
	            var baseRow = command.row;
	            baseRow = baseRow >= 0 ? baseRow : 0;
	            var baseCol = command.col;
	            baseCol = baseCol >= 0 ? baseCol : 0;
	            var CalcEngine = __webpack_require__(2);
	            var calcParser = exports._supportsCalc && CalcEngine && CalcEngine.Parser;
	            if (calcParser) {
	                var parent = sheet.parent, allowUserEditFormula = parent && parent.options.allowUserEditFormula;
	                var svc = sheet._getCalcServiceInternal();
	                var expr, range;
	                if (allowUserEditFormula && svc && text && text.length > 0 && text[0] === '=') {
	                    try {
	                        if (command.ranges && command.endEditType === 1 ) {
	                            range = command.ranges[0];
	                            sheet.setArrayFormula(range.row, range.col, getRowCount(range), getColCount(range), text.substring(1));
	                            return action;
	                        }
	                        expr = svc.parse(sheet._getSheetSource(), text.substring(1), baseRow, baseCol, true);
	                    } catch (e) {
	                        sheet._raiseInvalidOperation(0 , typeof (e) === 'string' ? e : e.message);
	                        throw e;
	                    }
	                } else if (command.ranges && command.endEditType === 1 ) {
	                    range = command.ranges[0];
	                    sheet.getRange(range.row, range.col, getRowCount(range), getColCount(range), 3 ).clear(1 );
	                }
	            }
	            if (!expr) {
	                if (text && text[0] === "'") {
	                    self._setQuotePrefix(baseRow, baseCol, true, styleChangedInfo);
	                } else {
	                    self._setQuotePrefix(baseRow, baseCol, keyword_undefined, styleChangedInfo);
	                }
	                value = self._getValueFromEditing(baseRow, baseCol, text, autoFormat, styleChangedInfo);
	            }
	            self._iteration(function (row, col) {
	                if (expr) {
	                    try {
	                        sheet._setFormulaCore(row, col, svc.unparse(sheet._getSheetSource(), expr, row, col), expr);
	                        sheet._trigger(Events.UserFormulaEntered, {
	                            sheet: sheet,
	                            sheetName: sheet.name(),
	                            row: row,
	                            col: col,
	                            formula: text.substring(1).toUpperCase()
	                        });
	                    } catch (e) {
	                        sheet._raiseInvalidOperation(0 , typeof (e) === 'string' ? e : e.message);
	                        throw e;
	                    }
	                } else {
	                    try {
	                        if (sheet.hasFormula && sheet.hasFormula(row, col)) {
	                            sheet.setFormula(row, col, keyword_null);
	                        }
	                    } catch (e) {
	                        sheet._raiseInvalidOperation(0 , typeof (e) === 'string' ? e : e.message);
	                        throw e;
	                    }
	                    try {
	                        sheet._setValueInternal(row, col, value);
	                    } catch (ex) {
	                        sheet.setValue(row, col, text);
	                    }
	                }
	            });
	            var isAutoFormatChanged = styleChangedInfo._isAutoFormatChanged, isQuotePrefixChanged = styleChangedInfo._isQuotePrefixChanged;
	            if (isAutoFormatChanged || isQuotePrefixChanged) {
	                var storedStyle = sheet._getStyleObject(baseRow, baseCol),
	                    isNamedStyle = (typeof (storedStyle) === 'string');
	                if (!storedStyle || isNamedStyle) {
	                    var newStyle = new Style();
	                    if (isNamedStyle) {
	                        newStyle.parentName = storedStyle;
	                    }
	                    storedStyle = newStyle;
	                }
	                if (isAutoFormatChanged) {
	                    storedStyle._autoFormatter = styleChangedInfo._autoFormatter;
	                }
	                if (isQuotePrefixChanged) {
	                    storedStyle.quotePrefix = styleChangedInfo.quotePrefix;
	                }
	                sheet.setStyle(baseRow, baseCol, storedStyle);
	            }
	            return action;
	        },
	        canUndo: function () {
	            return this._command.applyResult === 0 ;
	        },
	        _getValueFromEditing: function (row, col, text, autoFormat, styleChangedInfo) {
	            var self = this;
	            var sheet = self._sheet;
	            var command = self._command;
	            var style = sheet.getActualStyle(row, col);
	            var styleRef = {};
	            var value;
	            if (typeof text === "string") {
	                if (text && text[0] === "'") {
	                    value = text.substring(1);
	                } else {
	                    value = util_common_util._parseText2Value(style, text, autoFormat, styleRef, command.editingFormatter);
	                }
	            } else {
	                value = text;
	            }
	
	           
	           
	            if (styleChangedInfo.quotePrefix) {
	                styleChangedInfo._autoFormatter = keyword_undefined;
	                styleChangedInfo._isAutoFormatChanged = true;
	            } else {
	                var autoDisplayFormatter = styleRef.value;
	                if (autoFormat && autoDisplayFormatter) {
	                    var af = keyword_null;
	                    if (value !== keyword_null && autoDisplayFormatter.formatString() !== 'General' || !style._autoFormatter) {
	                        autoDisplayFormatter.isAuto = true;
	                        af = autoDisplayFormatter;
	                    }
	                    if (af) {
	                        styleChangedInfo._isAutoFormatChanged = true;
	                        styleChangedInfo._autoFormatter = af;
	                    }
	                }
	            }
	            return value;
	        },
	        _setQuotePrefix: function (row, col, quotePrefix, styleChangedInfo) {
	            var self = this;
	            var sheet = self._sheet;
	            var storedStyle = sheet._getStyleObject(row, col),
	                isNamedStyle = (typeof (storedStyle) === 'string');
	            if (!storedStyle || isNamedStyle) {
	                var newStyle = new Style();
	                if (isNamedStyle) {
	                    newStyle.parentName = storedStyle;
	                }
	                storedStyle = newStyle;
	            }
	            if (storedStyle.quotePrefix !== quotePrefix) {
	                styleChangedInfo._isQuotePrefixChanged = true;
	                styleChangedInfo.quotePrefix = quotePrefix;
	            }
	        }
	    });
	   
	   
	    function sheetRenameUndoAction_repaint(sheet) {
	        var parent = sheet.parent, tab = parent && parent._tab;
	        if (tab) {
	            tab.repaint();
	        }
	    }
	
	    $_inherit(SheetRenameUndoAction, ActionBase);
	
	    function SheetRenameUndoAction(sheet, command) {
	        var self = this;
	        ActionBase.call(self);
	        self._sheet = sheet;
	        self._command = command;
	    }
	
	    $_extend(SheetRenameUndoAction.prototype, {
	        canUndo: function () {
	            return !!this._command._oldName;
	        },
	        canExecute: function () {
	            var self = this;
	            var command = self._command;
	            return self._sheet && command.name && command.name !== command._oldName;
	        },
	        execute: function () {
	            var self = this;
	            var sheet = self._sheet;
	            var command = self._command;
	            var name = command.name;
	            var succeed = false;
	            if (self.canExecute()) {
	                command._oldName = sheet.name();
	
	                sheet._modelManager.startTransaction();
	                sheet._setNameCore(name);
	                sheetRenameUndoAction_repaint(sheet);
	                var changesKey = Commands._getChangesKey(sheet.name());
	                command[changesKey] = sheet._modelManager.endTransaction();
	
	                succeed = true;
	                command.sheetName = name;
	            }
	            return succeed;
	        },
	        undo: function () {
	            var self = this;
	            if (self.canUndo()) {
	                var sheet = self._sheet, command = self._command;
	                if (sheet) {
	                    var changesKey = Commands._getChangesKey(sheet.name());
	                    sheet._modelManager.undo(command[changesKey]);
	                    sheetRenameUndoAction_repaint(sheet);
	
	                    command.sheetName = command._oldName;
	                    return true;
	                }
	            }
	            return false;
	        }
	    });
	   
	
	   
	    $_inherit(ZoomUndoAction, ActionBase);
	
	    function ZoomUndoAction(sheet, command) {
	        var self = this;
	        ActionBase.call(self);
	        self._sheet = sheet;
	        self._command = command;
	    }
	
	    function zoomSheet(sheet, zoomFactor) {
	        if (sheet.isEditing() === true && !sheet.endEdit()) {
	            return false;
	        }
	        sheet.suspendPaint();
	        sheet.zoom(zoomFactor);
	        sheet.resumePaint();
	        return true;
	    }
	
	    $_extend(ZoomUndoAction.prototype, {
	        canExecute: function () {
	            var self = this;
	            return self._sheet && self._sheet.parent.options.allowUserZoom && self._sheet.zoom() !== self._command.zoomFactor;
	        },
	        execute: function () {
	            var self = this;
	            var command = self._command;
	            var succeed = false;
	            if (self.canExecute()) {
	                var sheet = self._sheet;
	                sheet._modelManager.startTransaction();
	                succeed = zoomSheet(sheet, command.zoomFactor);
	                var changesKey = Commands._getChangesKey(sheet.name());
	                command[changesKey] = sheet._modelManager.endTransaction();
	            }
	            return succeed;
	        },
	        undo: function () {
	            var sheet = this._sheet;
	            if (this.canUndo()) {
	                if (sheet.isEditing() === true && !sheet.endEdit()) {
	                    return false;
	                }
	                sheet.suspendPaint();
	                var changesKey = Commands._getChangesKey(sheet.name());
	                sheet._modelManager.undo(this._command[changesKey]);
	                sheet.resumePaint();
	                return true;
	            }
	        }
	    });
	   
	
	   
	   
	   
	   
	   
	
	    $_inherit(ClearRangeValueUndoAction, ActionBase);
	
	    function ClearRangeValueUndoAction(sheet, command) {
	        var self = this;
	        ActionBase.call(self);
	        self._sheet = sheet;
	        self._command = command;
	    }
	
	    $_extend(ClearRangeValueUndoAction.prototype, {
	        execute: function () {
	            var self = this;
	            if (self.canExecute()) {
	                var sheet = self._sheet, clearRange = self._command.clearRange;
	                if (!sheet.isDirtySuspended()) {
	                    self._command._changedCells = new ChangedCells(sheet, sheet._getActualRange(clearRange), 1  | 2 );
	                }
	
	                var range = sheet._getActualRange(clearRange),
	                    row = range.row, col = range.col, rowCount = getRowCount(range), colCount = getColCount(range);
	                if (colCount > 0 && rowCount > 0) {
	                    sheet._modelManager.startTransaction();
	                    beforeAction(sheet);
	
	                    sheet.getRange(row, col, rowCount, colCount, 3 ).clear(1 );
	
	                    afterAction(sheet);
	                    var changesKey = Commands._getChangesKey(sheet.name());
	                    self._command[changesKey] = sheet._modelManager.endTransaction();
	
	                    var changedCells = self._command._changedCells;
	                    Commands._raiseRangeDataChanged(sheet, row, col, rowCount, colCount,
	                        changedCells ? changedCells._getChangedCells() : [], 2 );
	                }
	            }
	        },
	        canExecute: function () {
	            var range = this._command.clearRange;
	            return this._sheet._canChange(range.row, range.col, getRowCount(range), getColCount(range));
	        },
	        canUndo: function () {
	            var changesKey = Commands._getChangesKey(this._sheet.name());
	            var changes = this._command[changesKey];
	            return Commands._isNotEmptyChanges(changes);
	        },
	        undo: function () {
	            var self = this;
	            var sheet = self._sheet;
	            if (self.canUndo() && sheet) {
	                var range = sheet._getActualRange(self._command.clearRange);
	                if (getColCount(range) > 0 && getRowCount(range) > 0) {
	                    beforeAction(sheet);
	                    try {
	                        var changesKey = Commands._getChangesKey(sheet.name());
	                        sheet._modelManager.undo(self._command[changesKey]);
	                    } finally {
	                        afterAction(sheet);
	                    }
	
	                    var changedCells = self._command._changedCells;
	                    Commands._raiseRangeDataChanged(sheet, range.row, range.col, getRowCount(range), getColCount(range), changedCells ? changedCells._getChangedCells() : [], 2 );
	
	                    return true;
	                }
	            }
	            return false;
	        }
	    });
	
	    $_inherit(ClearValueUndoAction, ActionBase);
	
	    function ClearValueUndoAction(sheet, command, undo) {
	        var self = this;
	        ActionBase.call(self);
	        self._sheet = sheet;
	        self._command = command;
	        if (!undo) {
	            command._cachedActions = [];
	            var ranges = command.ranges;
	            if (ranges && ranges.length > 0) {
	                for (var i = 0; i < ranges.length; i++) {
	                    command._cachedActions[i] = new ClearRangeValueUndoAction(sheet, {clearRange: ranges[i]});
	                }
	            }
	        }
	    }
	
	    $_extend(ClearValueUndoAction.prototype, {
	        canExecute: function () {
	            var cachedActions = this._command._cachedActions;
	            if (cachedActions) {
	                for (var i = 0; i < cachedActions.length; i++) {
	                    var item = cachedActions[i];
	                    if (!item.canExecute()) {
	                        return false;
	                    }
	                }
	                return true;
	            }
	            return false;
	        },
	        execute: function () {
	            var self = this;
	            if (self.canExecute()) {
	                var cachedActions = self._command._cachedActions;
	                var sheet = self._sheet;
	                if (cachedActions) {
	                    beforeAction(sheet, true);
	                    for (var i = 0; i < cachedActions.length; i++) {
	                        var item = cachedActions[i];
	                        item.execute();
	                    }
	                    afterAction(sheet, true);
	                    return true;
	                }
	            }
	            return false;
	        },
	        canUndo: function () {
	            var cachedActions = this._command._cachedActions;
	            if (cachedActions) {
	                for (var i = 0; i < cachedActions.length; i++) {
	                    var item = cachedActions[i];
	                    if (!item.canUndo()) {
	                        return false;
	                    }
	                }
	                return true;
	            }
	            return false;
	        },
	        undo: function () {
	            var self = this;
	            var cachedActions = self._command._cachedActions;
	            if (self.canUndo()) {
	                var sheet = self._sheet;
	                for (var i = cachedActions.length - 1; i >= 0; i--) {
	                    var action = cachedActions[i];
	                    beforeAction(sheet, true);
	                    var ret = action.undo();
	                    afterAction(sheet, true);
	
	                    if (!ret) {
	                        return false;
	                    }
	                }
	                return true;
	            }
	            return false;
	        }
	    });
	    Commands._ClearValueUndoAction = ClearValueUndoAction;
	   
	
	   
	   
	   
	   
	   
	   
	   
	   
	
	    $_inherit(ClipboardPasteRangeUndoAction, ActionBase);
	
	    function ClipboardPasteRangeUndoAction(sheet, command) {
	        var self = this;
	        ActionBase.call(self);
	        self._sheet = sheet;
	        self._command = command;
	    }
	
	    $_extend(ClipboardPasteRangeUndoAction.prototype, {
	        canExecute: function () {
	            var self = this, command = self._command, pasteExtent = command.pasteExtent;
	            var target = pasteExtent.targetRange;
	            var source = pasteExtent.sourceRange;
	            return command.toSheet._canChange(target.row, target.col, getRowCount(target), getColCount(target))
	                && (!pasteExtent.isCutting || command.fromSheet._canChange(source.row, source.col, getRowCount(source), getColCount(source)));
	        },
	        _beforeDataChange: function () {
	            var self = this, pasteExtent = self._command.pasteExtent;
	            var state = self._command._state = {};
	            var isCutting = pasteExtent.isCutting;
	            var option = ClipboardPasteRangeUndoAction._convertPasteOption(self._command.pasteOption);
	            var fromRange = pasteExtent.sourceRange;
	            var toRange = pasteExtent.targetRange;
	            var fromSheet = self._command.fromSheet,
	                toSheet = self._command.toSheet;
	            if (fromSheet && fromRange && isCutting && !fromSheet.isDirtySuspended()) {
	                state._savedFromBeforePastedChangedCells = new ChangedCells(fromSheet, fromRange, option);
	            }
	
	            if (!toSheet.isDirtySuspended()) {
	                state._savedToBeforePastedChangedCells = new ChangedCells(toSheet, toRange, option);
	            }
	        },
	        _pasteRange: function () {
	            return this._command.pasteExtent.targetRange;
	        },
	        execute: function () {
	            var self = this;
	            if (self.canExecute()) {
	                var fromSheet = self._command.fromSheet, toSheet = self._command.toSheet,
	                    pasteExtent = self._command.pasteExtent,
	                    pasteOption = self._command.pasteOption;
	                var fromRange = pasteExtent.sourceRange;
	                var toRange = pasteExtent.targetRange;
	               
	                if (fromSheet && fromRange && !fromSheet._isValidRange(fromRange.row, fromRange.col,
	                        getRowCount(fromRange), getColCount(fromRange), getSheetRowCount(fromSheet), getSheetColumnCount(fromSheet))) {
	                    return;
	                }
	                if (!(toSheet && toRange && toSheet._isValidPasteRange(toRange.row, toRange.col, getRowCount(toRange), getColCount(toRange), true))) {
	                    return;
	                }
	
	                self._beforeDataChange();
	
	                toSheet._modelManager.startTransaction();
	                if (fromSheet && fromSheet !== toSheet) {
	                    fromSheet._modelManager.startTransaction();
	                }
	
	                suspendPaint(toSheet);
	
	                suspendEvent(toSheet);
	                if (fromSheet) {
	                    suspendEvent(fromSheet);
	                }
	                try {
	                    if (allowExtendPasteRange(toSheet)) {
	                        var expectedRowCount = -1, expectedColCount = -1;
	                        if (toRange.row !== -1) {
	                            expectedRowCount = toRange.row + getRowCount(toRange);
	                        } else if (fromRange.row === -1) {
	                            expectedRowCount = getSheetRowCount(fromSheet);
	                        }
	                        var toSheetRowCount = getSheetRowCount(toSheet);
	                        if (expectedRowCount > toSheetRowCount && self._canExtendRange(fromRange, toRange)) {
	                            toSheet.addRows(toSheetRowCount, expectedRowCount - toSheetRowCount);
	                        }
	
	                        if (toRange.col !== -1) {
	                            expectedColCount = toRange.col + getColCount(toRange);
	                        } else if (fromRange.col === -1) {
	                            expectedColCount = getSheetColumnCount(fromSheet);
	                        }
	                        if (expectedColCount > getSheetColumnCount(toSheet) && self._canExtendRange(fromRange, toRange)) {
	                            toSheet.setColumnCount(expectedColCount);
	                        }
	                    }
	                    if (fromRange) {
	                        _CacheMgr._startCache(fromSheet, fromRange.row, fromRange.col, fromRange.row + getRowCount(fromRange) - 1,
	                            fromRange.col + getColCount(fromRange) - 1);
	                    }
	                    toSheet._clipboardPaste(fromSheet, fromRange, toSheet, toRange, pasteExtent.isCutting, pasteExtent.clipboardText, pasteExtent.clipboardHtml, pasteOption, !pasteExtent.includeFilteredOutRow);
	                } finally {
	                    resumeEvent(toSheet);
	                    if (fromSheet) {
	                        resumeEvent(fromSheet);
	                    }
	
	                    resumePaint(toSheet);
	
	                    var changesKey = Commands._getChangesKey(toSheet.name());
	                    self._command[changesKey] = toSheet._modelManager.endTransaction();
	                    if (fromSheet && fromSheet !== toSheet) {
	                        changesKey = Commands._getChangesKey(fromSheet.name());
	                        self._command[changesKey] = fromSheet._modelManager.endTransaction();
	                    }
	
	                    var state = self._command._state;
	                    var option = ClipboardPasteRangeUndoAction._convertPasteOption(pasteOption);
	                    if (pasteExtent.isCutting && fromSheet) {
	                        var fromSheetChangeCells = [];
	                        if (!fromSheet.isDirtySuspended()) {
	                            var savedFromAfterPastedChangedCells = new ChangedCells(fromSheet, fromRange, option);
	                            savedFromAfterPastedChangedCells._mergeCellsHasDiffData(state._savedFromBeforePastedChangedCells._getCellsData());
	                            state._savedFromAfterPastedChangedCells = savedFromAfterPastedChangedCells;
	                            fromSheetChangeCells = savedFromAfterPastedChangedCells._getChangedCells();
	                        }
	                        Commands._raiseRangeDataChanged(fromSheet, fromRange.row, fromRange.col, getRowCount(fromRange), getColCount(fromRange),
	                            fromSheetChangeCells, 3 );
	                    }
	
	                    if (toSheet) {
	                        var toSheetChangedCells = [];
	                        if (!toSheet.isDirtySuspended()) {
	                            var savedToAfterPastedChangedCells = new ChangedCells(toSheet, toRange, option);
	                            savedToAfterPastedChangedCells._mergeCellsHasDiffData(state._savedToBeforePastedChangedCells._getCellsData());
	                            state._savedToAfterPastedChangedCells = savedToAfterPastedChangedCells;
	                            toSheetChangedCells = savedToAfterPastedChangedCells._getChangedCells();
	                        }
	                        Commands._raiseRangeDataChanged(toSheet, toRange.row, toRange.col, getRowCount(toRange), getColCount(toRange),
	                            toSheetChangedCells, 3 );
	                    }
	                    if (fromRange) {
	                        _CacheMgr._clearCache();
	                    }
	                }
	            }
	        },
	        _canExtendRange: function (fromRange, toRange) {
	            if (!fromRange) {
	                return true;
	            }
	            var fromRow = fromRange.row, fromCol = fromRange.col, toRow = toRange.row, toCol = toRange.col;
	            var wholeCol = fromRow === -1 && fromCol !== -1;
	            var wholeRow = fromCol === -1 && fromRow !== -1;
	            var wholeSheet = fromRow === -1 && fromCol === -1;
	            return (fromRow !== -1 && fromCol !== -1)
	                || (wholeCol && toRow <= 0)
	                || (wholeRow && toCol <= 0)
	                || (wholeSheet && toRow <= 0 && toCol <= 0);
	        },
	        undo: function () {
	            var self = this;
	            if (self.canUndo()) {
	                var fromSheet = self._command.fromSheet, toSheet = self._command.toSheet,
	                    pasteExtent = self._command.pasteExtent;
	                var fromRange = pasteExtent.sourceRange;
	                var toRange = pasteExtent.targetRange;
	                if (!toSheet || !toRange) {
	                    return false;
	                }
	                if (!toSheet._isValidRange(toRange.row, toRange.col, getRowCount(toRange), getColCount(toRange), getSheetRowCount(toSheet),
	                        getSheetColumnCount(toSheet))) {
	                    return false;
	                }
	                if (fromSheet && fromRange) {
	                    if (!fromSheet._isValidRange(fromRange.row, fromRange.col, getRowCount(fromRange), getColCount(fromRange), getSheetRowCount(fromSheet),
	                            getSheetColumnCount(fromSheet))) {
	                        return false;
	                    }
	                    if (fromSheet && fromSheet.name() === toSheet.name() &&
	                        (toSheet.parent && !ArrayHelper_contains(toSheet.parent.sheets, fromSheet))) {
	                        return false;
	                    }
	                }
	
	                var state = self._command._state;
	                suspendPaint(toSheet);
	                try {
	                    var toRow = toRange.row < 0 ? 0 : toRange.row;
	                    var toColumn = toRange.col < 0 ? 0 : toRange.col;
	                    var toRowCount = toRange.row < 0 ? getSheetRowCount(toSheet) : getRowCount(toRange);
	                    var toColumnCount = toRange.col < 0 ? getSheetColumnCount(toSheet) : getColCount(toRange);
	
	                   
	                    var toSheetName = toSheet.name();
	                    var changesKey = Commands._getChangesKey(toSheetName);
	                    toSheet._modelManager.undo(self._command[changesKey]);
	
	                   
	                    var fromRow = 0;
	                    var fromColumn = 0;
	                    var fromRowCount = 0;
	                    var fromColumnCount = 0;
	                    if (fromSheet && fromRange) {
	                        fromRow = fromRange.row < 0 ? 0 : fromRange.row;
	                        fromColumn = fromRange.col < 0 ? 0 : fromRange.col;
	                        fromRowCount = fromRange.row < 0 ? getSheetRowCount(fromSheet) : getRowCount(fromRange);
	                        fromColumnCount = fromRange.col < 0 ? getSheetColumnCount(fromSheet) : getColCount(fromRange);
	                    }
	                    var fromSheetName = fromSheet.name();
	                    if (toSheetName !== fromSheetName) {
	                        changesKey = Commands._getChangesKey(fromSheetName);
	                        var changesOfFromSheet = self._command[changesKey];
	                        if (Commands._isNotEmptyChanges(changesOfFromSheet)) {
	                            fromSheet._modelManager.undo(changesOfFromSheet);
	                        }
	                    }
	                   
	                    if (toSheet) {
	                        var toChangedCells = state._savedToAfterPastedChangedCells;
	                        Commands._raiseRangeDataChanged(toSheet, toRow, toColumn, toRowCount, toColumnCount,
	                            toChangedCells ? toChangedCells._getChangedCells() : [], 3 );
	                    }
	                    if (fromSheet) {
	                        var fromChangedCells = state._savedFromAfterPastedChangedCells;
	                        Commands._raiseRangeDataChanged(fromSheet, fromRow, fromColumn, fromRowCount, fromColumnCount,
	                            fromChangedCells ? fromChangedCells._getChangedCells() : [], 3 );
	                    }
	                } finally {
	                    resumePaint(toSheet);
	                }
	            }
	            return true;
	        }
	    });
	    ClipboardPasteRangeUndoAction._convertPasteOption = function (pasteOption) {
	        var copyOption = 0;
	        if (pasteOption === 0  || pasteOption === 1 ) {
	            copyOption |= 1 ;
	        }
	        if (pasteOption === 0  || pasteOption === 2 ) {
	            copyOption |= 64 ;
	            copyOption |= 32 ;
	        }
	        if (pasteOption === 0  || pasteOption === 3 ) {
	            copyOption |= 2 ;
	        }
	        if (pasteOption === 0 ) {
	            copyOption |= 32 ;
	            copyOption |= 16 ;
	            copyOption |= 256 ;
	            copyOption |= 4 ;
	            copyOption |= 512 ;
	            copyOption |= 128 ;
	        }
	        return copyOption;
	    };
	
	    $_inherit(ClipboardPasteUndoAction, ActionBase);
	
	    function ClipboardPasteUndoAction(sheet, command, undo) {
	        var self = this;
	        ActionBase.call(self);
	        self._sheet = sheet;
	        self._command = command;
	
	        if (!undo) {
	            var destSheet = sheet;
	            var srcSheet = command.fromSheet;
	            if (!destSheet) {
	                throw new Error(sR().Exp_DestSheetIsNull);
	            }
	            var pasteExtent = command;
	            var pastedRanges = pasteExtent.pastedRanges;
	            if (pastedRanges && pastedRanges.length > 0) {
	                command._cachedActions = [];
	                var fromRanges = pasteExtent.fromRanges || [pasteExtent.fromRange],
	                    fromRangesLength = fromRanges.length,
	                    isCutting = pasteExtent.isCutting,
	                    clipboardText = pasteExtent.clipboardText,
	                    clipboardHtml = pasteExtent.clipboardHtml,
	                    pasteOption = pasteExtent.pasteOption;
	                var outParam = {};
	                var firstPastedRange = pastedRanges[0];
	                if (!isCutting && srcSheet && srcSheet._isValidMultiCopyRanges(fromRanges, outParam) &&
	                    firstPastedRange.equals(srcSheet._getPastedRangeForMultiCopy(fromRanges, firstPastedRange))) {
	                    var inSameRow = outParam.inSameRow,
	                        inSameCol = outParam.inSameCol;
	                    if (inSameRow) {
	                        fromRanges = fromRanges.sort(function (range1, range2) {
	                            return range1.col - range2.col;
	                        });
	                    } else if (inSameCol) {
	                        fromRanges = fromRanges.sort(function (range1, range2) {
	                            return range1.row - range2.row;
	                        });
	                    }
	
	                    var pastedRangeRow = firstPastedRange.row, pastedRangeCol = firstPastedRange.col;
	                    for (var j = 0; j < fromRangesLength; j++) {
	                        var currentFromRange = fromRanges[j],
	                            currentFromRangeRowCount = currentFromRange.rowCount,
	                            currentFromRangeColCount = currentFromRange.colCount;
	                        var ext = {
	                            sourceRange: currentFromRange,
	                            targetRange: util_common._createRange(pastedRangeRow, pastedRangeCol, currentFromRangeRowCount, currentFromRangeColCount),
	                            isCutting: isCutting,
	                            clipboardText: clipboardText,
	                            clipboardHtml: clipboardHtml,
	                            includeFilteredOutRow: true
	                        };
	                        command._cachedActions[j] = new ClipboardPasteRangeUndoAction(sheet, {
	                            fromSheet: srcSheet,
	                            toSheet: destSheet,
	                            pasteExtent: ext,
	                            pasteOption: pasteOption
	                        });
	                        if (inSameRow) {
	                            pastedRangeCol += currentFromRangeColCount;
	                        } else if (inSameCol) {
	                            pastedRangeRow += currentFromRangeRowCount;
	                        }
	                    }
	                    command._isMultiToSingle = true;
	                } else {
	                    for (var i = 0; i < pastedRanges.length; i++) {
	                        var extent = {
	                            sourceRange: fromRanges[0],
	                            targetRange: pastedRanges[i],
	                            isCutting: isCutting,
	                            clipboardText: clipboardText,
	                            clipboardHtml: clipboardHtml
	                        };
	                        command._cachedActions[i] = new ClipboardPasteRangeUndoAction(sheet, {
	                            fromSheet: srcSheet,
	                            toSheet: destSheet,
	                            pasteExtent: extent,
	                            pasteOption: pasteOption
	                        });
	                    }
	                }
	            }
	        }
	    }
	
	    $_extend(ClipboardPasteUndoAction.prototype, {
	        execute: function () {
	            var self = this;
	            var command = self._command;
	            var cachedActions = command._cachedActions;
	            var succeed = false;
	            if (self.canExecute() && cachedActions) {
	                var sheetView = self._sheet;
	                var activeSheet = sheetView.parent.getActiveSheet();
	                beforeAction(activeSheet, true);
	                try {
	                    var needRefreshSelection = false;
	                    for (var i = 0; i < cachedActions.length; i++) {
	                        var action = cachedActions[i];
	                        if (!sheetView) {
	                            succeed = action.execute();
	                        } else {
	                            var pasteExtent = action._command.pasteExtent;
	                            var args = {
	                                sheet: sheetView,
	                                sheetName: sheetView.name(),
	                                cellRange: action._pasteRange(),
	                                pasteOption: action._command.pasteOption,
	                                pasteData: {text: pasteExtent.clipboardText, html: pasteExtent.clipboardHtml},
	                                cancel: false
	                            };
	                            sheetView._trigger(Events.ClipboardPasting, args);
	                            if (!args.cancel) {
	                                succeed = action.execute();
	                                delete args.cancel;
	                                needRefreshSelection = true;
	                                sheetView._trigger(Events.ClipboardPasted, args);
	                            }
	                        }
	                    }
	                    if (needRefreshSelection) {
	                        self._refreshSelection();
	                    }
	                } finally {
	                    afterAction(activeSheet, true);
	                }
	            }
	            return succeed;
	        },
	        _refreshSelection: function () {
	            var self = this, command = self._command;
	            var cachedActions = command._cachedActions;
	            var sheetView = self._sheet;
	            if (sheetView && cachedActions) {
	                var oldSelection = sheetView.getSelections();
	                sheetView._clearSelectionImp();
	                if (command._isMultiToSingle) {
	                    var pasteRange = command.pastedRanges[0];
	                    sheetView.addSelection(pasteRange.row, pasteRange.col, getRowCount(pasteRange), getColCount(pasteRange));
	                } else if (cachedActions.length > 1) {
	                    for (var i = 0; i < cachedActions.length; i++) {
	                        var action = cachedActions[i];
	                        var range = action._pasteRange();
	                        sheetView.addSelection(range.row, range.col, getRowCount(range), getColCount(range));
	                    }
	                } else if (cachedActions.length > 0) {
	                    var toRange = cachedActions[0]._pasteRange();
	                    sheetView.addSelection(toRange.row, toRange.col, getRowCount(toRange), getColCount(toRange));
	                    if (!toRange.contains(sheetView._activeRowIndex, sheetView._activeColIndex)) {
	                        sheetView._setActiveCellCore(toRange.row, toRange.col);
	                    }
	                }
	                if (sheetView._raiseSelectionChanging(oldSelection, sheetView.getSelections())) {
	                    sheetView._raiseSelectionChanged(oldSelection);
	                }
	            }
	        },
	        canExecute: function () {
	            var cachedActions = this._command._cachedActions;
	            if (cachedActions) {
	                for (var i = 0; i < cachedActions.length; i++) {
	                    var action = cachedActions[i];
	                    if (!action.canExecute()) {
	                        return false;
	                    }
	                }
	                return true;
	            }
	            return false;
	        },
	        canUndo: function () {
	            var cachedActions = this._command._cachedActions;
	            if (cachedActions) {
	                for (var i = 0; i < cachedActions.length; i++) {
	                    var action = cachedActions[i];
	                    if (!action.canUndo()) {
	                        return false;
	                    }
	                }
	                return true;
	            }
	            return false;
	        },
	        undo: function () {
	            var self = this, cachedActions = self._command._cachedActions;
	            if (self.canUndo() && cachedActions) {
	                var ret = true;
	                var activeSheet = self._sheet.parent.getActiveSheet();
	                beforeAction(activeSheet, true);
	                try {
	                    for (var i = cachedActions.length - 1; i >= 0; i--) {
	                        var action = cachedActions[i];
	                        ret = (ret && action.undo());
	                    }
	                } finally {
	                    afterAction(activeSheet, true);
	                }
	                return ret;
	            }
	            return false;
	        }
	    });
	   
	
	    module.exports = exports;
	
	
	}());

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var exports = __webpack_require__(1);
	    var util_common = __webpack_require__(3);
	    var Common = __webpack_require__(5);
	    var _SparseArray = util_common._SparseArray;
	    var Worksheet = exports._supportsCalc && __webpack_require__(21).Worksheet;
	    var $ = __webpack_require__(4).GC$;
	    var createRange = util_common._createRange;
	    var isNullOrUndefined = Common._Types._isNullOrUndefined;
	
	    var keyword_null = null, keyword_undefined = void 0, Math_min = Math.min, Math_max = Math.max;
	
	    function sR() {
	        return Common._getResource(exports.SR)();
	    }
	
	    function _getRowCount(sheet, sheetArea) {
	        return sheet.getRowCount(sheetArea);
	    }
	
	    function _getColumnCount(sheet, sheetArea) {
	        return sheet.getColumnCount(sheetArea);
	
	    }
	
	    function getActualColumnWidth(sheet, col, sheetArea) {
	        return sheet._getActualColumnWidth(col, sheetArea);
	    }
	
	    function getActualRowHeight(sheet, row, sheetArea) {
	        return sheet._getActualRowHeight(row, sheetArea);
	    }
	
	    function setColumnWidth(sheet, col, width, sheetArea) {
	        sheet.setColumnWidth(col, width, sheetArea);
	    }
	
	    function setRowHeight(sheet, row, height, sheetArea) {
	        sheet.setRowHeight(row, height, sheetArea);
	    }
	
	    function getActualStyle(sheet, row, col, sheetArea) {
	        return sheet.getActualStyle(row, col, sheetArea);
	    }
	
	    function getDefaultStyle(sheet, sheetArea) {
	        return sheet.getDefaultStyle(sheetArea);
	    }
	
	    function setDefaultStyle(sheet, style, sheetArea) {
	        sheet.setDefaultStyle(style, sheetArea);
	    }
	
	    function setStyleWithoutLocked(sheet, row, col, style, sheetArea) {
	        sheet._setStyleWithoutLocked(row, col, style, sheetArea);
	    }
	
	    function raiseInvalidRangeException(item, value, start, end) {
	        throw new Error(Common._StringHelper._format(sR().Exp_InvalidAndSpace, [item, value, start, end]));
	    }
	
	    function isRowFilterOut(row, ignoreFilteredOutRow, sheet) {
	        return (ignoreFilteredOutRow && sheet._isRowFilterOut && sheet._isRowFilterOut(row));
	    }
	
	    function checkArguments(src, fromRow, fromColumn, dest, toRow, toColumn, rowCount, columnCount) {
	        if (!src) {
	            throw new Error(sR().Exp_SrcIsNull);
	        }
	        if (!dest) {
	            throw new Error(sR().Exp_DestIsNull);
	        }
	        var srcRowCount = _getRowCount(src), srcColumnCount = _getColumnCount(src);
	        var destRowCount = _getRowCount(dest), destColumnCount = _getColumnCount(dest);
	        if (fromRow < -1 || fromRow >= srcRowCount) {
	            raiseInvalidRangeException('from row index', fromRow, '-1', (srcRowCount - 1));
	        }
	        if (fromColumn < -1 || fromColumn >= srcColumnCount) {
	            raiseInvalidRangeException('from column index', fromColumn, '-1', (srcColumnCount - 1));
	        }
	        if (toRow < -1 || toRow >= destRowCount) {
	            raiseInvalidRangeException('to row index', toRow, '-1', (destRowCount - 1));
	        }
	        if (toColumn < -1 || toColumn >= destColumnCount) {
	            raiseInvalidRangeException('to column index', toColumn, '-1', (destColumnCount - 1));
	        }
	        var fromColumn2 = fromColumn;
	        if (fromColumn < 0) {
	            fromColumn2 = 0;
	            columnCount = srcColumnCount;
	        }
	        var toColumn2 = toColumn < 0 ? 0 : toColumn;
	        if (columnCount < 1 || fromColumn2 + columnCount > srcColumnCount || toColumn2 + columnCount > destColumnCount) {
	            raiseInvalidRangeException('column count', columnCount, '1', Math_min(srcColumnCount - fromColumn2, destColumnCount - toColumn2));
	        }
	        var fromRow2 = fromRow;
	        if (fromRow < 0) {
	            fromRow2 = 0;
	            rowCount = srcRowCount;
	        }
	        var toRow2 = toRow < 0 ? 0 : toRow;
	        if (rowCount < 1 || fromRow2 + rowCount > srcRowCount || toRow2 + rowCount > destRowCount) {
	            raiseInvalidRangeException('row count', rowCount, '1', Math_min(srcRowCount - fromRow2, destRowCount - toRow2));
	        }
	    }
	
	    function cloneObject(obj) {
	        if (!obj) {
	            return obj;
	        }
	        if (typeof (obj) === 'number' || typeof (obj) === 'string' || typeof (obj) === 'boolean' || isNullOrUndefined(obj)) {
	            return obj;
	        } else if (obj.clone) {
	            return obj.clone();
	        } else if (obj instanceof Date) {
	            return new Date(obj.valueOf());
	        }
	
	        var objClone, key, value;
	        if (obj instanceof Object) {
	            objClone = new obj.constructor();
	        } else {
	            objClone = new obj.constructor(obj.valueOf());
	        }
	        for (key in obj) {
	            if (obj.hasOwnProperty(key)) {
	                value = obj[key];
	                if (obj.hasOwnProperty(key) && objClone[key] !== value) {
	                    if (typeof (value) === 'object') {
	                        objClone[key] = cloneObject(value);
	                    } else {
	                        objClone[key] = value;
	                    }
	                }
	            }
	        }
	        objClone.toString = obj.toString;
	        objClone.valueOf = obj.valueOf;
	        return objClone;
	    }
	
	    function crossSheetCopySpans(srcModelManager, fromRow, fromColumn, destModelManager, toRow, toColumn, rowCount, columnCount, sheetArea) {
	        var srcSpans = srcModelManager.getSpans(keyword_undefined, sheetArea);
	        var destSpans = destModelManager.getSpans(keyword_undefined, sheetArea);
	        var addList = [], i, cs, cs_row, cs_col, cs_rowCount, cs_colCount;
	        if (srcSpans) {
	            for (i = 0; i < srcSpans.length; i++) {
	                cs = srcSpans[i];
	                cs_row = cs.row;
	                cs_col = cs.col;
	                cs_rowCount = cs.rowCount;
	                cs_colCount = cs.colCount;
	                if (fromRow === -1) {
	                    if (fromColumn <= cs_col && cs_col + cs_colCount <= fromColumn + columnCount) {
	                        addList.push(createRange(cs_row, toColumn + cs_col - fromColumn, cs_rowCount, cs_colCount));
	                    }
	                } else if (fromColumn === -1) {
	                    if (fromRow <= cs_row && cs_row + cs_rowCount <= fromRow + rowCount) {
	                        addList.push(createRange(toRow + cs_row - fromRow, cs_col, cs_rowCount, cs_colCount));
	                    }
	                } else if (fromRow <= cs_row && cs_row < fromRow + rowCount && fromColumn <= cs_col && cs_col < fromColumn + columnCount) {
	                    addList.push(createRange(toRow + cs_row - fromRow, toColumn + cs_col - fromColumn, cs_rowCount, cs_colCount));
	                }
	            }
	        }
	        if (destSpans) {
	            for (i = 0; i < destSpans.length; i++) {
	                cs = destSpans[i];
	                cs_row = cs.row;
	                cs_col = cs.col;
	                var contains, containsCol = cs_col >= toColumn && cs_col < toColumn + columnCount,
	                    containsRow = cs_row >= toRow && cs_row < toRow + rowCount;
	                if (fromRow === -1) {
	                    contains = containsCol;
	                } else if (fromColumn === -1) {
	                    contains = containsRow;
	                } else {
	                    contains = containsRow && containsCol;
	                }
	                if (contains) {
	                    var cellSpan = destModelManager.findSpan(cs_row, cs_col, sheetArea);
	                    if (cellSpan && cellSpan.row === cs_row && cellSpan.col === cs_col) {
	                        destModelManager.do('removeSpan', cellSpan, sheetArea);
	                    }
	                }
	            }
	        }
	        for (i = 0; i < addList.length; i++) {
	            destModelManager.do('addSpan', addList[i], sheetArea);
	        }
	    }
	
	
	    function copyOrMoveConditionalFormat(src, fromRow, fromColumn, dest, toRow, toColumn, rowCount, columnCount, isMove) {
	        var cf = src.conditionalFormats, destCf = dest.conditionalFormats;
	        if (cf && destCf) {
	            cf._copyRules(fromRow, fromColumn, destCf, toRow, toColumn, rowCount, columnCount);
	            if (isMove) {
	                cf._onRulesMoved(fromRow, fromColumn, rowCount, columnCount);
	            }
	        }
	    }
	
	    function copyOrMoveSparkline(src, fromRow, fromColumn, dest, toRow, toColumn, rowCount, columnCount, isMove) {
	        if (fromRow < 0) {
	            fromRow = 0;
	            rowCount = Math_min(_getRowCount(src), _getRowCount(dest));
	        }
	        if (toRow < 0) {
	            toRow = 0;
	        }
	        if (fromColumn < 0) {
	            fromColumn = 0;
	            columnCount = Math_min(_getColumnCount(src), _getColumnCount(dest));
	        }
	        if (toColumn < 0) {
	            toColumn = 0;
	        }
	        var crossSheet = !(src === dest && src.name() === dest.name());
	        var sparkline;
	        if (crossSheet) {
	            sparkline = dest._sparklineGroupManager;
	            if (sparkline) {
	                if (isMove) {
	                    if (src._sparklineGroupManager.count() > 0) {
	                        sparkline._exMove(src, fromRow, fromColumn, toRow, toColumn, rowCount, columnCount);
	                    }
	                } else {
	                    sparkline._exCopy(src, fromRow, fromColumn, toRow, toColumn, rowCount, columnCount);
	                }
	            }
	        } else {
	            sparkline = src._sparklineGroupManager;
	            if (sparkline) {
	                if (isMove) {
	                    if (sparkline.count() > 0) {
	                        sparkline._move(fromRow, fromColumn, toRow, toColumn, rowCount, columnCount);
	                    }
	                } else {
	                    sparkline._copy(fromRow, fromColumn, toRow, toColumn, rowCount, columnCount);
	                }
	            }
	        }
	    }
	
	    function copyOrMoveColumnRangeGroup(src, fromColumn, dest, toColumn, columnCount, isMove) {
	        if (fromColumn < 0) {
	            fromColumn = 0;
	            columnCount = Math_min(_getColumnCount(src), _getColumnCount(dest));
	        }
	        if (toColumn < 0) {
	            toColumn = 0;
	        }
	        var src_columnOutlines = src.columnOutlines, dest_columnOutlines = dest.columnOutlines;
	        var crossSheet = !(src === dest && src.name() === dest.name());
	        if (crossSheet) {
	            if (src_columnOutlines && dest_columnOutlines) {
	                dest_columnOutlines._exMoveOrCopy(src_columnOutlines, fromColumn, toColumn, columnCount, isMove);
	            }
	        } else if (src_columnOutlines) {
	            src_columnOutlines._moveOrCopy(fromColumn, toColumn, columnCount, isMove);
	        }
	    }
	
	    function copyOrMoveRowRangeGroup(src, fromRow, dest, toRow, rowCount, isMove) {
	        if (fromRow < 0) {
	            fromRow = 0;
	            rowCount = Math_min(_getRowCount(src), _getRowCount(dest));
	        }
	        if (toRow < 0) {
	            toRow = 0;
	        }
	        var crossSheet = !(src === dest && src.name() === dest.name());
	        var src_rowOutlines = src.rowOutlines, dest_rowOutlines = dest.rowOutlines;
	        if (crossSheet) {
	            if (src_rowOutlines && dest_rowOutlines) {
	                dest_rowOutlines._exMoveOrCopy(src_rowOutlines, fromRow, toRow, rowCount, isMove);
	            }
	        } else if (src_rowOutlines) {
	            src_rowOutlines._moveOrCopy(fromRow, toRow, rowCount, isMove);
	        }
	    }
	
	    function copyOrMoveSpanImp(src, fromRow, fromColumn, dest, toRow, toColumn, rowCount, columnCount, isMove, sheetArea) {
	        var crossSheet = !(src === dest && src.name() === dest.name());
	        var modelManager = src._modelManager;
	        var srcSpanModel = modelManager._getSpanModel(sheetArea);
	        if (crossSheet) {
	            crossSheetCopySpans(modelManager, fromRow, fromColumn, dest._modelManager, toRow, toColumn, rowCount, columnCount, sheetArea);
	            if (isMove && srcSpanModel) {
	                modelManager.do('clearSpan', fromRow, fromColumn, rowCount, columnCount, sheetArea);
	            }
	        } else if (isMove) {
	            modelManager.do('moveSpan', fromRow, fromColumn, toRow, toColumn, rowCount, columnCount, sheetArea);
	        } else {
	            modelManager.do('copySpan', fromRow, fromColumn, toRow, toColumn, rowCount, columnCount, sheetArea);
	        }
	    }
	
	    function copyOrMoveSpan(src, srcRow, srcColumn, dest, toRow, toColumn, rowCount, columnCount, isMove) {
	        var fromRow = srcRow, fromColumn = srcColumn;
	        if (fromRow < 0) {
	            fromRow = 0;
	            rowCount = Math_min(_getRowCount(src), _getRowCount(dest));
	        }
	        if (toRow < 0) {
	            toRow = 0;
	        }
	        if (fromColumn < 0) {
	            fromColumn = 0;
	            columnCount = Math_min(_getColumnCount(src), _getColumnCount(dest));
	        }
	        if (toColumn < 0) {
	            toColumn = 0;
	        }
	       
	        if (srcRow < 0) {
	            copyOrMoveSpanImp(src, -1, fromColumn, dest, -1, toColumn, -1, columnCount, isMove, 1 );
	        }
	       
	        if (srcColumn < 0) {
	            copyOrMoveSpanImp(src, fromRow, -1, dest, toRow, -1, rowCount, -1, isMove, 2 );
	        }
	       
	        copyOrMoveSpanImp(src, fromRow, fromColumn, dest, toRow, toColumn, rowCount, columnCount, isMove);
	    }
	
	    function copyOrMoveColumnAxis(src, fromColumn, dest, toColumn, columnCount, option, isMove) {
	        if (fromColumn < 0) {
	            fromColumn = 0;
	            columnCount = Math_min(_getColumnCount(src), _getColumnCount(dest));
	        }
	        if (toColumn < 0) {
	            toColumn = 0;
	        }
	        var colHeader = 1 ;
	        for (var c = 0; c < columnCount; c++) {
	            if ((option & 64 ) > 0) {
	                var width = getActualColumnWidth(src, c + fromColumn);
	                if (!isNullOrUndefined(width)) {
	                    if (isMove) {
	                        setColumnWidth(src, c + fromColumn, src.defaults.colWidth);
	                    }
	                    setColumnWidth(dest, c + toColumn, width);
	                }
	                var visible = src.getColumnVisible(c + fromColumn);
	                if (!isNullOrUndefined(visible)) {
	                    if (isMove) {
	                        src.setColumnVisible(c + fromColumn, true);
	                    }
	                    dest.setColumnVisible(c + toColumn, visible);
	                }
	                var style = getActualStyle(src, -1, c + fromColumn);
	                if (!style) {
	                    setStyleWithoutLocked(dest, -1, c + toColumn, keyword_null);
	                } else {
	                    setStyleWithoutLocked(dest, -1, c + toColumn, style.clone());
	                    if (isMove) {
	                        setStyleWithoutLocked(src, -1, c + fromColumn, keyword_null);
	                    }
	                }
	                style = getActualStyle(src, -1, c + fromColumn, colHeader);
	                if (!style) {
	                    setStyleWithoutLocked(dest, -1, c + toColumn, keyword_null, colHeader);
	                } else {
	                    setStyleWithoutLocked(dest, -1, c + toColumn, style.clone(), colHeader);
	                    if (isMove) {
	                        setStyleWithoutLocked(src, -1, c + fromColumn, keyword_null, colHeader);
	                    }
	                }
	            }
	            if ((option & 128 ) > 0) {
	                var tag = src.getTag(-1, c + fromColumn);
	                if (!isNullOrUndefined(tag)) {
	                    if (isMove) {
	                        src.setTag(-1, c + fromColumn, keyword_undefined);
	                    }
	                    dest.setTag(-1, c + toColumn, tag);
	                }
	            }
	        }
	        var colHeaderRowCount = Math_min(_getRowCount(src, colHeader), _getRowCount(dest, colHeader));
	        for (var r = 0; r < colHeaderRowCount; r++) {
	            var height = getActualRowHeight(src, r, colHeader);
	            if (!isNullOrUndefined(height)) {
	                if (isMove) {
	                    setRowHeight(src, r, src.defaults.colHeaderRowHeight, colHeader);
	                }
	                setRowHeight(dest, r, height, colHeader);
	            }
	        }
	    }
	
	    function copyOrMoveRowAxis(src, fromRow, dest, toRow, rowCount, option, ignoreFilteredOutRow, isMove) {
	        if (fromRow < 0) {
	            fromRow = 0;
	            rowCount = Math_min(_getRowCount(src), _getRowCount(dest));
	        }
	        if (toRow < 0) {
	            toRow = 0;
	        }
	        var rowHeader = 2 ;
	        for (var r = 0; r < rowCount; r++) {
	            if (!isMove && isRowFilterOut(toRow + r, ignoreFilteredOutRow, dest)) {
	                continue;
	            }
	            if ((option & 64 ) > 0) {
	                var height = getActualRowHeight(src, r + fromRow);
	                if (!isNullOrUndefined(height)) {
	                    if (isMove) {
	                        setRowHeight(src, r + fromRow, src.defaults.rowHeight);
	                    }
	                    setRowHeight(dest, r + toRow, height);
	                }
	                var visible = src.getRowVisible(r + fromRow);
	                if (!isNullOrUndefined(visible)) {
	                    if (isMove) {
	                        src.setRowVisible(r + fromRow, true);
	                    }
	                    dest.setRowVisible(r + toRow, visible);
	                }
	                var style = getActualStyle(src, r + fromRow, -1);
	                if (!style) {
	                    setStyleWithoutLocked(dest, r + toRow, -1, keyword_null);
	                } else {
	                    setStyleWithoutLocked(dest, r + toRow, -1, style.clone());
	                    if (isMove) {
	                        setStyleWithoutLocked(src, r + fromRow, -1, keyword_null);
	                    }
	                }
	                style = getActualStyle(src, r + fromRow, -1, rowHeader);
	                if (!style) {
	                    setStyleWithoutLocked(dest, r + toRow, -1, keyword_null, rowHeader);
	                } else {
	                    setStyleWithoutLocked(dest, r + toRow, -1, style.clone(), rowHeader);
	                    if (isMove) {
	                        setStyleWithoutLocked(src, r + fromRow, -1, keyword_null, rowHeader);
	                    }
	                }
	            }
	            if ((option & 128 ) > 0) {
	                var tag = src.getTag(r + fromRow, -1);
	                if (!isNullOrUndefined(tag)) {
	                    if (isMove) {
	                        src.setTag(r + fromRow, -1, keyword_undefined);
	                    }
	                    dest.setTag(r + toRow, -1, tag);
	                }
	            }
	        }
	        var rowHeaderColCount = Math_min(_getColumnCount(src, rowHeader), _getColumnCount(dest, rowHeader));
	        for (var c = 0; c < rowHeaderColCount; c++) {
	            var width = getActualColumnWidth(src, c, rowHeader);
	            if (!isNullOrUndefined(width)) {
	                if (isMove) {
	                    setColumnWidth(src, c, src.defaults.rowHeaderColWidth, rowHeader);
	                }
	                setColumnWidth(dest, c, width, rowHeader);
	            }
	        }
	    }
	
	    function copyOrMoveSheetInfo(src, dest, option, isMove) {
	        if ((src !== dest) || (src.name() !== dest.name())) {
	            if ((option & 64 ) > 0) {
	                var style = getDefaultStyle(src);
	                setDefaultStyle(dest, isMove ? style : style.clone());
	                style = getDefaultStyle(src, 1 );
	                setDefaultStyle(dest, isMove ? style : style.clone(), 1 );
	                style = getDefaultStyle(src, 2 );
	                setDefaultStyle(dest, isMove ? style : style.clone(), 2 );
	                if (isMove) {
	                    setDefaultStyle(src, keyword_null);
	                    setDefaultStyle(src, keyword_null, 1 );
	                    setDefaultStyle(src, keyword_null, 2 );
	                }
	            }
	            var dest_defaults = dest.defaults, src_defaults = src.defaults;
	            dest_defaults.colWidth = src_defaults.colWidth;
	            dest_defaults.rowHeight = src_defaults.rowHeight;
	            dest_defaults.rowHeaderColWidth = src_defaults.rowHeaderColWidth;
	            dest_defaults.colHeaderRowHeight = src_defaults.colHeaderRowHeight;
	            if (isMove) {
	                src_defaults.colWidth = 62;
	                src_defaults.rowHeight = 20;
	                src_defaults.rowHeaderColWidth = 40;
	                src_defaults.colHeaderRowHeight = 20;
	            }
	        }
	    }
	
	    function copyProperty(src, srcRow, srcColumn, dest, destRow, destColumn, copyRowCount, copyColumnCount, ignoreFilteredOutRow, copyPasteHeaders, getCallback, setCallback) {
	        var crossSheet = !(src === dest && src.name() === dest.name());
	       
	        var hRowCount, hColumnCount, r, c, savedModel, result;
	        if (((copyPasteHeaders & 2)  === 2 ) && srcRow < 0) {
	            var fColumn = srcColumn;
	            var tColumn = destColumn;
	            hRowCount = Math_min(_getRowCount(src, 1 ), _getRowCount(dest, 1 ));
	            hColumnCount = copyColumnCount;
	            if (srcColumn < 0) {
	                fColumn = 0;
	                hColumnCount = _getColumnCount(src);
	            }
	            if (destColumn < 0) {
	                tColumn = 0;
	            }
	
	            if (crossSheet) {
	                for (r = 0; r < hRowCount; r++) {
	                    for (c = 0; c < hColumnCount; c++) {
	                        result = getCallback(src, r, fColumn + c, 1 );
	                        setCallback(dest, r, tColumn + c, cloneObject(result), 1 );
	                    }
	                }
	            } else {
	                savedModel = new _SparseArray();
	                for (r = 0; r < hRowCount; r++) {
	                    for (c = 0; c < hColumnCount; c++) {
	                        result = getCallback(src, r, fColumn + c, 1 );
	                        if (!isNullOrUndefined(result)) {
	                            savedModel.set(r, c, cloneObject(result));
	                        }
	                    }
	                }
	                for (r = 0; r < hRowCount; r++) {
	                    for (c = 0; c < hColumnCount; c++) {
	                        setCallback(dest, r, tColumn + c, savedModel.get(r, c), 1 );
	                    }
	                }
	            }
	        }
	       
	        if (((copyPasteHeaders & 1)  === 1 ) && srcColumn < 0) {
	            var fRow = srcRow;
	            var tRow = destRow;
	            hRowCount = copyRowCount;
	            hColumnCount = Math_min(_getColumnCount(src, 2 ), _getColumnCount(dest, 2 ));
	            if (srcRow < 0) {
	                fRow = 0;
	                hRowCount = _getRowCount(src);
	            }
	            if (destRow < 0) {
	                tRow = 0;
	            }
	
	            if (crossSheet) {
	                for (r = 0; r < hRowCount; r++) {
	                    for (c = 0; c < hColumnCount; c++) {
	                        result = getCallback(src, fRow + r, c, 2 );
	                        setCallback(dest, tRow + r, c, cloneObject(result), 2 );
	                    }
	                }
	            } else {
	                savedModel = new _SparseArray();
	                for (r = 0; r < hRowCount; r++) {
	                    for (c = 0; c < hColumnCount; c++) {
	                        result = getCallback(src, fRow + r, c, 2 );
	                        if (!isNullOrUndefined(result)) {
	                            savedModel.set(r, c, cloneObject(result));
	                        }
	                    }
	                }
	                for (r = 0; r < hRowCount; r++) {
	                    for (c = 0; c < hColumnCount; c++) {
	                        setCallback(dest, tRow + r, c, savedModel.get(r, c), 2 );
	                    }
	                }
	            }
	        }
	       
	        var fromRow = srcRow;
	        var fromColumn = srcColumn;
	        var toRow = destRow;
	        var toColumn = destColumn;
	        var rowCount = copyRowCount;
	        var columnCount = copyColumnCount;
	        if (srcRow < 0) {
	            fromRow = 0;
	            rowCount = Math_min(_getRowCount(src), _getRowCount(dest));
	        }
	        if (srcColumn < 0) {
	            fromColumn = 0;
	            columnCount = Math_min(_getColumnCount(src), _getColumnCount(dest));
	        }
	        if (destRow < 0) {
	            toRow = 0;
	        }
	        if (destColumn < 0) {
	            toColumn = 0;
	        }
	
	        if (crossSheet) {
	            for (r = 0; r < rowCount; r++) {
	                if (isRowFilterOut(toRow + r, ignoreFilteredOutRow, dest)) {
	                    continue;
	                }
	                for (c = 0; c < columnCount; c++) {
	                    result = getCallback(src, fromRow + r, fromColumn + c, 3 );
	                    setCallback(dest, toRow + r, toColumn + c, cloneObject(result), 3 );
	                }
	            }
	        } else {
	            savedModel = new _SparseArray();
	            try {
	                for (r = 0; r < rowCount; r++) {
	                    for (c = 0; c < columnCount; c++) {
	                        result = getCallback(src, fromRow + r, fromColumn + c, 3 );
	                        if (!isNullOrUndefined(result)) {
	                            savedModel.set(r, c, cloneObject(result));
	                        }
	                    }
	                }
	                for (r = 0; r < rowCount; r++) {
	                    if (isRowFilterOut(toRow + r, ignoreFilteredOutRow, dest)) {
	                        continue;
	                    }
	                    for (c = 0; c < columnCount; c++) {
	                        setCallback(dest, toRow + r, toColumn + c, savedModel.get(r, c), 3 );
	                    }
	                }
	            } catch (ex) {
	               
	            }
	        }
	    }
	
	    function copyMoveValue(src, srcRow, srcColumn, dest, destRow, destColumn, copyRowCount, copyColumnCount, ignoreFilteredOutRow, copyPasteHeaders, isMove) {
	        copyProperty(src, srcRow, srcColumn, dest, destRow, destColumn, copyRowCount, copyColumnCount, ignoreFilteredOutRow, copyPasteHeaders, function (sheet, r, c, sheetArea) {
	            var isViewport = sheetArea === 3 , value;
	            if (isViewport) {
	                value = sheet.getValue(r, c, sheetArea, 1 );
	            } else {
	                value = sheet._modelManager.getValue(r, c, sheetArea, true, 1 );
	               
	               
	               
	                if (sheetArea === 1  && isNullOrUndefined(value)) {
	                    var bm = sheet._bindingManager;
	                    if (bm && bm._dataSource) {
	                        var ci = sheet._modelManager._getItem(false, 3 , c),
	                            colHeaderAutoTextIndex = sheet.options.colHeaderAutoTextIndex;
	                        if (ci && ((colHeaderAutoTextIndex >= 0 && r === colHeaderAutoTextIndex) || (colHeaderAutoTextIndex === -1 && r === _getRowCount(sheet, sheetArea) - 1))) {
	                            value = ci.displayName || ci.name;
	                        }
	                    }
	                }
	            }
	            if (isMove) {
	                if (isViewport) {
	                    sheet._setValueInternal(r, c, keyword_null, sheetArea, false);
	                } else {
	                    sheet._modelManager.do('setValue', r, c, keyword_null, sheetArea, true, true);
	                }
	            }
	            return value;
	        }, function (sheet, r, c, value, sheetArea) {
	            if (isNullOrUndefined(value)) {
	                sheet._setValueInternal(r, c, keyword_null, sheetArea, false);
	            } else {
	                sheet._setValueInternal(r, c, value, sheetArea, false);
	            }
	        });
	    }
	
	    function setCacheData(src, range, cache) {
	        var actualRange = src._getActualRange(range);
	        var row = actualRange.row, col = actualRange.col,
	            rowCount = actualRange.rowCount, colCount = actualRange.colCount;
	        for (var r = 0; r < rowCount; r++) {
	            var rowCache = cache[row + r] = cache[row + r] || {};
	            for (var c = 0; c < colCount; c++) {
	                rowCache[col + c] = true;
	            }
	        }
	    }
	
	    function copyMoveStyle(src, srcRow, srcColumn, dest, destRow, destColumn, copyRowCount, copyColumnCount, ignoreFilteredOutRow, copyPasteHeaders, isMove) {
	       
	       
	       
	       
	       
	       
	        var cache = {};
	        if (src.tables) {
	            var srcRange = createRange(srcRow, srcColumn, copyRowCount, copyColumnCount);
	            var destRange = createRange(destRow, destColumn, copyRowCount, copyColumnCount);
	            var allTables = src.tables.all(), tableRange;
	            for (var i = 0, length = allTables.length; i < length; i++) {
	                tableRange = allTables[i].range();
	                if (srcRange.containsRange(tableRange)) {      
	                    setCacheData(src, tableRange, cache);
	                } else if (tableRange.containsRange(srcRange) && tableRange.containsRange(destRange)) { 
	                    setCacheData(src, srcRange, cache);
	                }
	            }
	        }
	        copyProperty(src, srcRow, srcColumn, dest, destRow, destColumn, copyRowCount, copyColumnCount, ignoreFilteredOutRow, copyPasteHeaders, function (sheet, r, c, sheetArea) {
	           
	            var hasTableStyle = (sheetArea === 3  || isNullOrUndefined(sheetArea)) && cache[r] && cache[r][c];
	            var t = sheet._getCompositeStyle(r, c, sheetArea, keyword_undefined, keyword_undefined, keyword_undefined, keyword_undefined, hasTableStyle);
	            if (isMove) {
	                setStyleWithoutLocked(sheet, r, c, keyword_null, sheetArea);
	            }
	
	            return t;
	        }, function (sheet, r, c, style, sheetArea) {
	            setStyleWithoutLocked(sheet, r, c, style, sheetArea);
	        });
	    }
	
	    function copyMoveValidator(src, srcRow, srcColumn, dest, destRow, destColumn, copyRowCount, copyColumnCount, ignoreFilteredOutRow, isMove) {
	       
	       
	        var validations = src._validations;
	        validations._validators.map(function (item) {
	            var condition = item.condition();
	            if (condition) {
	                condition.initExpression();
	            }
	        });
	       
	        copyProperty(src, srcRow, srcColumn, dest, destRow, destColumn, copyRowCount, copyColumnCount, ignoreFilteredOutRow, 0 , function (sheet, r, c) {
	            var validator = sheet.getDataValidator(r, c, 3 );
	            if (validator) {
	                if (isMove) {
	                    sheet.setDataValidator(r, c, keyword_null);
	                }
	               
	                validator._fromCopyMove = true;
	            }
	            return validator;
	        }, function (sheet, r, c, validator) {
	            sheet.setDataValidator(r, c, validator);
	           
	            validator && delete validator._fromCopyMove;
	        });
	    }
	
	    function copyMoveComment(src, srcRow, srcColumn, dest, destRow, destColumn, copyRowCount, copyColumnCount, ignoreFilteredOutRow, isMove) {
	        copyProperty(src, srcRow, srcColumn, dest, destRow, destColumn, copyRowCount, copyColumnCount, ignoreFilteredOutRow, 0 , function (sheet, r, c) {
	            var commentManager = sheet._modelManager._comments;
	            var comment = commentManager && commentManager.get(r, c);
	            if (comment && isMove) {
	                commentManager.remove(r, c);
	            }
	            return comment;
	        }, function (sheet, r, c, comment) {
	            var commentManager = sheet._modelManager._comments;
	            commentManager && commentManager._addInternal(r, c, comment);
	        });
	    }
	
	    function copyMoveTag(src, srcRow, srcColumn, dest, destRow, destColumn, copyRowCount, copyColumnCount, ignoreFilteredOutRow, copyPasteHeaders, isMove) {
	        copyProperty(src, srcRow, srcColumn, dest, destRow, destColumn, copyRowCount, copyColumnCount, ignoreFilteredOutRow, copyPasteHeaders, function (sheet, r, c, sheetArea) {
	            var t = sheet.getTag(r, c, sheetArea);
	            if (!isNullOrUndefined(t) && isMove) {
	                sheet.setTag(r, c, keyword_undefined);
	            }
	            return t;
	        }, function (sheet, r, c, value, sheetArea) {
	            dest.setTag(r, c, value, sheetArea);
	        });
	    }
	
	    function copyMoveBindingPath(src, srcRow, srcColumn, dest, destRow, destColumn, copyRowCount, copyColumnCount, ignoreFilteredOutRow, isMove) {
	        var savedValues = [];
	        copyProperty(src, srcRow, srcColumn, dest, destRow, destColumn, copyRowCount, copyColumnCount, ignoreFilteredOutRow, 0 , function (sheet, r, c) {
	            var path = sheet.getBindingPath && sheet.getBindingPath(r, c);
	            if (path) {
	                savedValues.push({
	                    row: r - Math_max(0, srcRow),
	                    col: c - Math_max(0, srcColumn),
	                    value: sheet.getValue(r, c)
	                });
	            }
	            if (isMove) {
	                src.setBindingPath && src.setBindingPath(r, c, keyword_null);
	            }
	            return path;
	        }, function (sheet, r, c, value) {
	            sheet.setBindingPath && sheet.setBindingPath(r, c, value);
	        });
	
	        return savedValues;
	    }
	
	    function copyOrMoveTo(src, srcRow, srcColumn, dest, destRow, destColumn, rowCount, columnCount, option, ignoreFilteredOutRow, copyPasteHeaders, isMove) {
	        checkArguments(src, srcRow, srcColumn, dest, destRow, destColumn, rowCount, columnCount);
	        var isOpreatingBindingColumns;
	        if (isMove) {            
	            if (srcRow < 0) {
	                var fColumn = srcColumn;
	                var hColumnCount = columnCount;
	                if (srcColumn < 0) {
	                    fColumn = 0;
	                    hColumnCount = Math_min(_getColumnCount(src), _getColumnCount(dest));
	                }
	                var tColumn = destColumn;
	                if (destColumn < 0) {
	                    tColumn = 0;
	                }
	                isOpreatingBindingColumns = true;
	                for (var c = 0; c < hColumnCount; c++) {
	                    var srcItem = src._modelManager._getItem(false, 3 , fColumn + c);
	                    var destItem = src._modelManager._getItem(false, 3 , tColumn + c);
	                    var srcItemName = srcItem && srcItem.name;
	                    var destItemName = destItem && destItem.name;
	                    if (!srcItem || !destItem || !srcItemName || !destItemName) {
	                        isOpreatingBindingColumns = false;
	                    }
	                    destItem = $.extend(true, {}, dest._modelManager._getItem(false, 3 , tColumn + c) || {});
	                    destItem.displayName = srcItem && srcItem.displayName;
	                    destItem.name = srcItem && srcItem.name;
	                    dest._modelManager.do('setItem', false, 3 , tColumn + c, destItem);
	                }
	            }
	        }
	
	        if ((option & 64 ) > 0) {
	            copyMoveStyle(src, srcRow, srcColumn, dest, destRow, destColumn, rowCount, columnCount, ignoreFilteredOutRow, copyPasteHeaders, isMove);
	            src._validations && copyMoveValidator(src, srcRow, srcColumn, dest, destRow, destColumn, rowCount, columnCount, ignoreFilteredOutRow, isMove);
	        }
	       
	        if ((option & 1 ) > 0 && (option & 2 ) > 0) {
	            var srcTableManager = src.tables, savedTables;
	            if (srcTableManager) {
	                savedTables = srcTableManager._onCopyOrMoving(createRange(Math_max(0, srcRow), Math_max(0, srcColumn),
	                    srcRow < 0 ? Math_min(_getRowCount(src), _getRowCount(dest)) : rowCount, srcColumn < 0 ? Math_min(_getColumnCount(src), _getColumnCount(dest)) : columnCount), isMove);
	            }
	        }
	        var hasCalc = exports._supportsCalc;
	        if (hasCalc) {
	            src.suspendCalcService();
	            dest.suspendCalcService();
	        }
	        var savedValues = keyword_null;
	        if ((option & 256 ) > 0) {
	            savedValues = copyMoveBindingPath(src, srcRow, srcColumn, dest, destRow, destColumn, rowCount, columnCount, ignoreFilteredOutRow, isMove);
	        }
	        try {
	            if ((option & 1 ) > 0 && !isOpreatingBindingColumns) {
	                copyMoveValue(src, srcRow, srcColumn, dest, destRow, destColumn, rowCount, columnCount, ignoreFilteredOutRow, copyPasteHeaders, isMove);
	               
	                if (exports._supportsCalc && (option & 2 ) === 0) {
	                    dest.clearFormula(destRow, destColumn, rowCount, columnCount, function (sheet, row) {
	                        return !ignoreFilteredOutRow || !sheet._isRowFilterOut || !sheet._isRowFilterOut(row);
	                    });
	                }
	               
	                if ((option & 256 ) > 0) {
	                    var count = savedValues.length;
	                    var baseRow = destRow < 0 ? 0 : destRow;
	                    var baseCol = destColumn < 0 ? 0 : destColumn;
	                    for (var i = 0; i < count; i++) {
	                        var cv = savedValues[i];
	                        if (!isMove && isRowFilterOut(baseRow + cv.row, ignoreFilteredOutRow, dest)) {
	                            continue;
	                        }
	                        dest.setValue(baseRow + cv.row, baseCol + cv.col, cv.value);
	                    }
	                }
	            }
	
	            var destTableManager = dest.tables;
	           
	            if ((option & 1 ) > 0 && (option & 2 ) > 0 && destTableManager) {
	                destTableManager._onCopyOrMoved(savedTables, Math_max(0, srcRow), Math_max(0, srcColumn), Math_max(0, destRow), Math_max(0, destColumn), isMove);
	            }
	            if (exports._supportsCalc) {
	                if (isMove) {
	                    Worksheet.adjustCustomNameOnMove(src, srcRow, srcColumn, dest, destRow, destColumn, rowCount, columnCount);
	                    if ((option & 2 ) > 0) {
	                        Worksheet.moveFormula(src, srcRow, srcColumn, dest, destRow, destColumn, rowCount, columnCount);
	                    }
	                } else if ((option & 2 ) > 0) {
	                    Worksheet.copyFormula(src, srcRow, srcColumn, dest, destRow, destColumn, rowCount, columnCount, ignoreFilteredOutRow);
	                }
	                if ((option & 1 ) > 0 && (option & 2 ) > 0 && destTableManager) {
	                    destTableManager._syncFormulaInTables(savedTables);
	                }
	            }
	        } finally {
	            if (hasCalc) {
	                src.resumeCalcService(false);
	                dest.resumeCalcService(false);
	            }
	        }
	        if ((option & 512 ) > 0) {
	            copyOrMoveConditionalFormat(src, srcRow, srcColumn, dest, destRow, destColumn, rowCount, columnCount, isMove);
	        }
	        if ((option & 4 ) > 0) {
	            copyMoveComment(src, srcRow, srcColumn, dest, destRow, destColumn, rowCount, columnCount, ignoreFilteredOutRow, isMove);
	        }
	        if ((option & 128 ) > 0) {
	            copyMoveTag(src, srcRow, srcColumn, dest, destRow, destColumn, rowCount, columnCount, ignoreFilteredOutRow, copyPasteHeaders, isMove);
	        }
	        if ((option & 16 ) > 0) {
	            copyOrMoveSparkline(src, srcRow, srcColumn, dest, destRow, destColumn, rowCount, columnCount, isMove);
	        }
	        if ((option & 8 ) > 0) {
	            if (srcRow < 0) {
	                copyOrMoveColumnRangeGroup(src, srcColumn, dest, destColumn, columnCount, isMove);
	            }
	            if (srcColumn < 0) {
	                copyOrMoveRowRangeGroup(src, srcRow, dest, destRow, rowCount, isMove);
	            }
	        }
	        if ((option & 32 ) > 0) {             if (isMove || !(rowCount === 1 && columnCount === 1)) {
	                copyOrMoveSpan(src, srcRow, srcColumn, dest, destRow, destColumn, rowCount, columnCount, isMove);
	            }
	        }
	       
	        if (srcRow < 0 && destRow <= 0) {
	            copyOrMoveColumnAxis(src, srcColumn, dest, destColumn, columnCount, option, isMove);
	        }
	       
	        if (srcColumn < 0 && destColumn <= 0) {
	            copyOrMoveRowAxis(src, srcRow, dest, destRow, rowCount, option, ignoreFilteredOutRow, isMove);
	        }
	       
	        if (srcRow < 0 && destRow <= 0 && srcColumn < 0 && destColumn <= 0) {
	            copyOrMoveSheetInfo(src, dest, option, isMove);
	        }
	
	        if (isMove) {            
	            if (srcRow < 0) {
	                fColumn = srcColumn;
	                hColumnCount = columnCount;
	                if (srcColumn < 0) {
	                    fColumn = 0;
	                    hColumnCount = Math_min(_getColumnCount(src), _getColumnCount(dest));
	                }
	                for (c = 0; c < hColumnCount; c++) {
	                    if (src.getDataColumnName && src.getDataColumnName(fColumn + c)) {
	                       
	                        src._modelManager.do('setItem', false, 3 , fColumn + c, keyword_null);
	                    }
	                }
	            }
	        }
	    }
	
	    exports.staticMembers = {
	        copyTo: function (src, srcRow, srcColumn, dest, destRow, destColumn, copyRowCount, copyColumnCount, option, ignoreFilteredOutRow, copyPasteHeaders) {
	            copyOrMoveTo(src, srcRow, srcColumn, dest, destRow, destColumn, copyRowCount, copyColumnCount, option, ignoreFilteredOutRow, copyPasteHeaders, false);
	        },
	        moveTo: function (src, srcRow, srcColumn, dest, destRow, destColumn, moveRowCount, moveColumnCount, option) {
	            copyOrMoveTo(src, srcRow, srcColumn, dest, destRow, destColumn, moveRowCount, moveColumnCount, option, keyword_undefined, 3 , true);
	        }
	    };
	
	    module.exports = exports;
	
	}());

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var exports = __webpack_require__(1);
	    var $ = __webpack_require__(4).GC$;
	    var util_common = __webpack_require__(3);
	    var isNullOrUndefined = __webpack_require__(5)._Types._isNullOrUndefined;
	    var keyword_null = null;
	    var util_common_util = util_common._util;
	    var browser = util_common_util._browser;
	    var cancelDefault = util_common_util._cancelDefault;
	    var createElement = util_common._util._createElement;
	    var defProperty = util_common._util._defProperty;
	    var DOCUMENT = document;
	    var Math_Round = Math.round, Math_ceil = Math.ceil;
	    var CSS_CLASS_SCROLLCONTAINER = 'gc-scroll-container',
	        CSS_CLASS_SCROLLCONTAINERCORNER = 'gc-scroll-corner-all',
	        CSS_CLASS_SCROLLARROW = 'gc-scroll-arrow', CSS_CLASS_SCROLLBARWRAPPER = 'gc-scrollbar-wrapper',
	        CSS_CLASS_SCROLLBAR = 'gc-scroll-bar', CSS_CLASS_ARROWUP = 'gc-scroll-arrowUp', CSS_CLASS_ARROWDOWN = 'gc-scroll-arrowDown',
	        CSS_CLASS_ARROWLEFT = 'gc-scroll-arrowLeft', CSS_CLASS_ARROWRIGHT = 'gc-scroll-arrowRight',
	        CSS_CLASS_VERTICALSCROLL = 'gc-scrollbar-vertical', CSS_CLASS_HORIZONTALSCROLL = 'gc-scrollbar-horizontal',
	        CSS_CLASS_NONE_USER_SELECT = 'gc-no-user-select', CSS_WIDTH = 'width', CSS_HEIGHT = 'height',
	        CSS_CLASS_SCROLLBAR_STATEACTIVE_UI_STATE_ACTIVE = 'gc-scrollbar-stateActive ui-state-active',
	        CSS_LEFT = 'left', CSS_RIGHT = 'right', CSS_TOP = 'top', CSS_BOTTOM = 'bottom', CSS_MARGINLEFT = 'margin-left',
	        CSS_POSITION = 'position', CSS_BORDER = 'border',
	        CSS_PADDING = 'padding', CSS_MARGIN = 'margin',
	        CSS_OVERFLOW = 'overflow',
	        CSS_DISPLAY = 'display', CSS_OUTLINE = 'outline',
	        CSS_BORDERWIDTH = 'borderWidth', CSS_BOXSIZING = 'boxSizing',
	        CSS_MARGINTOP = 'margin-top', NS_SCROLLBAR = '.gcScrollbar', E_MOUSEDOWN = 'mousedown' + NS_SCROLLBAR,
	        E_MOUSEUP = 'mouseup' + NS_SCROLLBAR, E_MOUSEMOVE = 'mousemove' + NS_SCROLLBAR, E_MOUSEOVER = 'mouseover' + NS_SCROLLBAR,
	        E_MOUSEOUT = 'mouseout' + NS_SCROLLBAR, E_MOUSEWHEEL = 'mousewheel',
	        E_DOMMOUSESCROLL = 'DOMMouseScroll', E_SCROLL = 'scroll' + NS_SCROLLBAR;
	
	    function preventDefault(e) {
	        if (e.preventDefault) {
	            e.preventDefault();
	        } else {
	            e.returnValue = false;
	        }
	    }
	
	    var Scrollbar = (function () {
	       
	       
	       
	       
	       
	       
	       
	       
	       
	        function Scrollbar(isHorizontalScroll, width, height, pageValue, maximum, minimum, scrollType) {
	            var self = this;
	            self._isMousedownInScrollbar = false;
	            self._isMousedownInArrowButton = false;
	            self._scrollTimeOutArrow = keyword_null;
	            self._scrollTimeOutContainer = keyword_null;
	            self._initialDelay = 300;
	            self._trackClickPepeatFreq = 70;
	            self._isHorizontalScroll = isHorizontalScroll;
	            self._width((typeof width === 'number') ? width : 0);
	            self._height((typeof height === 'number') ? height : 0);
	            self._pageValue((typeof pageValue === 'number') ? pageValue : 0);
	            self._maximum((typeof maximum === 'number') ? maximum : 0);
	            self._minimum((typeof minimum === 'number') ? minimum : 0);
	            self._scrollType = (typeof scrollType === 'number') ? scrollType : 1 ;
	            self._isMouseCapture = false;
	            self._scrollPosition = 0;
	            self._value = self._minimum();
	            self._refreshLayout();
	        }
	
	        util_common._defineFeature(Scrollbar);
	        Scrollbar.prototype = {
	            constructor: Scrollbar,
	           
	           
	            _getScrollbar: function () {
	                return this._scrollContainerDiv;
	            },
	           
	           
	           
	            _smallChange: defProperty('smallChange', 1),
	           
	           
	           
	            _largeChange: defProperty('largeChange', 10),
	           
	           
	           
	            _pageValue: defProperty('pageValue', 10, function (value) {
	                if (value <= 0) {
	                    this._pageValue(1);
	                }
	            }),
	           
	           
	           
	            _maximum: defProperty('maximum', 100, function (value) {
	                if (value <= 0) {
	                    this._maximum(0);
	                }
	            }),
	           
	           
	           
	            _minimum: defProperty('minimum', 0, function (value) {
	                if (value <= 0) {
	                    this._minimum(0);
	                }
	            }),
	           
	           
	           
	            value: function (value) {
	                var self = this;
	                if (arguments.length === 0) {
	                    return self._value;
	                }
	                if (typeof value === 'number' && value <= self._maximum() && value >= self._minimum()) {
	                    self._value = value;
	                    var scrollPosition = (value - self._minimum()) * self._scrollUnit;
	                    self.scrollTo(scrollPosition, true);
	                }
	                return self;
	            },
	           
	           
	           
	            _width: defProperty('width', 0),
	           
	           
	           
	            _height: defProperty('height', 0),
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	            _refreshLayout: function () {
	                var self = this;
	
	                var height = self._height(),
	                    width = self._width(),
	                    scrollbarWidth = 0,
	                    scrollbarHeight = 0,
	                    isInitEvent = false,
	                    borderWidth = 2,
	
	                    externalCssClass_PanelDiv = 'ui-widget ui-corner-all';
	               
	                var arrowWidth = height,
	                    scrollbarContainerWidth = width - 2 * height,
	                    scrollbarContainerHeight = arrowWidth,
	                    css_scrollbarContainerPos = CSS_LEFT,
	                    css_scrollbarPos = CSS_RIGHT,
	                    cssClass_startArrow = CSS_CLASS_ARROWLEFT,
	                    cssClass_endArrow = CSS_CLASS_ARROWRIGHT,
	                    cssClass_scrollbar = CSS_CLASS_HORIZONTALSCROLL,
	                    css_scrollSpanMargin = CSS_MARGINLEFT,
	                    externalCssClass_ArrowStartDiv = 'ui-button ui-state-default ui-corner-bl btn btn-default',
	                    externalCssClass_ArrowStartSpan = 'ui-icon ui-icon-triangle-1-w',
	                    externalCssClass_Scroll = 'gc-scroll-handle ui-button ui-state-default ui-corner-all ui-draggable btn btn-default',
	                    externalCssClass_ScrollSpan = 'ui-icon ui-icon-grip-solid-vertical',
	                    externalCssClass_ArrowEndDiv = 'ui-button ui-state-default ui-corner-br btn btn-default',
	                    externalCssClass_ArrowEndSpan = 'ui-icon ui-icon-triangle-1-e';
	
	                self._scrollSize = scrollbarContainerWidth;
	
	                if (!self._isHorizontalScroll) {
	                    arrowWidth = width;
	                    scrollbarContainerWidth = arrowWidth;
	                    scrollbarContainerHeight = height - 2 * width;
	                    css_scrollbarContainerPos = CSS_TOP;
	                    css_scrollbarPos = CSS_BOTTOM;
	                    cssClass_startArrow = CSS_CLASS_ARROWUP;
	                    cssClass_endArrow = CSS_CLASS_ARROWDOWN;
	                    cssClass_scrollbar = CSS_CLASS_VERTICALSCROLL;
	                    css_scrollSpanMargin = CSS_MARGINTOP;
	                    externalCssClass_ArrowStartDiv = 'ui-button ui-state-default ui-corner-tr btn btn-default';
	                    externalCssClass_ArrowStartSpan = 'ui-icon ui-icon-triangle-1-n';
	                    externalCssClass_Scroll = 'gc-scroll-handle ui-button ui-state-default ui-corner-all ui-draggable btn btn-default';
	                    externalCssClass_ScrollSpan = 'ui-icon ui-icon-grip-solid-horizontal';
	                    externalCssClass_ArrowEndDiv = 'ui-button ui-state-default ui-corner-br btn btn-default';
	                    externalCssClass_ArrowEndSpan = 'ui-icon ui-icon-triangle-1-s';
	                    self._scrollSize = scrollbarContainerHeight;
	                }
	
	                function createScrollContainerDiv() {
	                    self._scrollContainerDiv = createElement('div');
	                    self._$scrollContainerDiv = $(self._scrollContainerDiv);
	                    self._$scrollContainerDiv.css(
	                        [CSS_POSITION, CSS_LEFT, CSS_TOP, CSS_OVERFLOW, CSS_OUTLINE, CSS_BORDER, CSS_PADDING, CSS_MARGIN],
	                        ['relative', 0, 0, 'hidden', 'none', 'none', 0, 0]
	                    ).addClass(CSS_CLASS_SCROLLCONTAINER + ' ' + CSS_CLASS_SCROLLCONTAINERCORNER + ' ' + externalCssClass_PanelDiv);
	                }
	
	                function createArrowStartDiv(scrollContainerDiv) {
	                    self._$arrowStartDiv = $._createElement(
	                        'div',
	                        [CSS_POSITION, CSS_DISPLAY, CSS_BORDERWIDTH, CSS_PADDING, CSS_MARGIN, CSS_BOXSIZING],
	                        ['absolute', 'inline-block', '1px', 0, 0, 'content-box'],
	                        CSS_CLASS_SCROLLARROW + ' ' + externalCssClass_ArrowStartDiv,
	                        scrollContainerDiv
	                    );
	                    self._$arrowStartSpan = $._createElement(
	                        'span',
	                        [CSS_DISPLAY, CSS_BORDER, CSS_PADDING, CSS_MARGIN],
	                        ['block', 'none', 0, 0],
	                        cssClass_startArrow + ' ' + externalCssClass_ArrowStartSpan,
	                        self._$arrowStartDiv
	                    );
	                }
	
	                function createScrollBarWrapperDiv(scrollContainerDiv) {
	                    self._$scrollbarWrapperDiv = $._createElement(
	                        'div',
	                        [CSS_POSITION, CSS_DISPLAY, CSS_BOXSIZING, CSS_BORDER, CSS_PADDING, CSS_MARGIN],
	                        ['absolute', 'inline-block', 'content-box', 'none', 0, 0],
	                        CSS_CLASS_SCROLLBARWRAPPER + ' ' + CSS_CLASS_SCROLLBARWRAPPER,
	                        scrollContainerDiv
	                    );
	                }
	
	                function createScrollBarDiv(scrollbarWrapperDiv) {
	                    self._$scrollbarDiv = $._createElement(
	                        'div',
	                        [CSS_POSITION, CSS_BORDERWIDTH, CSS_PADDING, CSS_MARGIN, CSS_BOXSIZING],
	                        ['absolute', '1px', 0, 0, 'content-box'],
	                        CSS_CLASS_SCROLLBAR + ' ' + CSS_CLASS_NONE_USER_SELECT + ' ' + externalCssClass_Scroll,
	                        scrollbarWrapperDiv);
	                    self._$scrollbarSpan = $._createElement(
	                        'span',
	                        [CSS_DISPLAY, CSS_BORDER, CSS_PADDING, CSS_MARGIN],
	                        ['block', 'none', 0, 0],
	                        cssClass_scrollbar + ' ' + externalCssClass_ScrollSpan,
	                        self._$scrollbarDiv
	                    );
	                }
	
	                function createArrowEndDiv(scrollContainerDiv) {
	                    self._$arrowEndDiv = $._createElement(
	                        'div',
	                        [CSS_POSITION, CSS_DISPLAY, CSS_BORDERWIDTH, CSS_PADDING, CSS_MARGIN, CSS_BOXSIZING],
	                        ['absolute', 'inline-block', '1px', 0, 0, 'content-box'],
	                        CSS_CLASS_SCROLLARROW + ' ' + externalCssClass_ArrowEndDiv,
	                        scrollContainerDiv
	                    );
	                    self._$arrowEndSpan = $._createElement(
	                        'span',
	                        [CSS_DISPLAY, CSS_BORDER, CSS_PADDING, CSS_MARGIN],
	                        ['block', 'none', 0, 0],
	                        cssClass_endArrow + ' ' + externalCssClass_ArrowEndSpan,
	                        self._$arrowEndDiv
	                    );
	                }
	
	                var scrollSize = self._scrollSize, valueScope = self._maximum() - self._minimum();
	                self._scrollbarSize = self._pageValue() * scrollSize / (valueScope + self._pageValue());
	                if (self._scrollbarSize > scrollSize) {
	                    self._scrollbarSize = scrollSize;
	                }
	                if (self._scrollbarSize < 10) {
	                    self._scrollbarSize = 10;
	                }
	                var scrollbarSize = self._scrollbarSize;
	                self._scrollUnit = valueScope === 0 ? 1 : (scrollSize - scrollbarSize) / valueScope;
	                if (self._isHorizontalScroll) {
	                    scrollbarWidth = scrollbarSize;
	                    scrollbarHeight = arrowWidth;
	                } else {
	                    scrollbarWidth = arrowWidth;
	                    scrollbarHeight = scrollbarSize;
	                }
	
	               
	                if (!self._$scrollContainerDiv) {
	                    isInitEvent = true;
	                    createScrollContainerDiv();
	                }
	               
	                if (!self._$arrowStartDiv) {
	                    createArrowStartDiv(self._$scrollContainerDiv);
	                }
	               
	                if (!self._$scrollbarWrapperDiv) {
	                    createScrollBarWrapperDiv(self._$scrollContainerDiv);
	                }
	                if (!self._$scrollbarDiv) {
	                    createScrollBarDiv(self._$scrollbarWrapperDiv);
	                }
	               
	                if (!self._$arrowEndDiv) {
	                    createArrowEndDiv(self._$scrollContainerDiv);
	                }
	
	                self._$scrollContainerDiv.css([CSS_WIDTH, CSS_HEIGHT], [width, height]);
	                self._$arrowStartDiv.css([css_scrollbarContainerPos, CSS_WIDTH, CSS_HEIGHT],
	                    [0, arrowWidth - borderWidth, arrowWidth - borderWidth]);
	                self._$arrowStartSpan.css([CSS_WIDTH, CSS_HEIGHT], ['100%', '100%']);
	                self._$scrollbarWrapperDiv.css([css_scrollbarContainerPos, CSS_WIDTH, CSS_HEIGHT],
	                    [arrowWidth, scrollbarContainerWidth, scrollbarContainerHeight]);
	                self._$scrollbarDiv.css([css_scrollbarContainerPos, CSS_WIDTH, CSS_HEIGHT],
	                    [self._scrollPosition, Math_Round(scrollbarWidth - borderWidth), Math_Round(scrollbarHeight - borderWidth)]);
	                self._$scrollbarSpan.css([CSS_WIDTH, CSS_HEIGHT, css_scrollSpanMargin],
	                    [arrowWidth - borderWidth, arrowWidth - borderWidth, Math.floor((self._scrollbarSize - arrowWidth) / 2)]);
	                self._$arrowEndDiv.css([css_scrollbarPos, CSS_WIDTH, CSS_HEIGHT],
	                    [0, arrowWidth - borderWidth, arrowWidth - borderWidth]);
	                self._$arrowEndSpan.css([CSS_WIDTH, CSS_HEIGHT], ['100%', '100%']);
	
	                if (isInitEvent) {
	                    self._initEvents();
	                }
	            },
	            _initEvents: function () {
	                var self = this;
	
	                function bindToArrowDiv($div, isStart) {
	                    $div.bind(E_MOUSEDOWN, function (e) {
	                        self._arrowMousedown(e, isStart);
	                    }).bind(E_MOUSEUP, function (e) {
	                        self._arrowMouseup(e, isStart);
	                    }).bind(E_MOUSEOVER, function (e) {
	                        self._arrowMouseover(e, isStart);
	                    }).bind(E_MOUSEOUT, function (e) {
	                        self._arrowMouseout(e, isStart);
	                    });
	                }
	
	                bindToArrowDiv(self._$arrowStartDiv, true);
	                bindToArrowDiv(self._$arrowEndDiv, false);
	
	                self._$scrollbarDiv.bind(E_MOUSEDOWN, function (e) {
	                    self._scrollbarMousedown(e);
	                }).bind(E_MOUSEMOVE, function (e) {
	                    self._scrollbarMousemove(e);
	                }).bind(E_MOUSEUP, function (e) {
	                    self._scrollbarMouseup(e);
	                }).bind(E_MOUSEOVER, function (e) {
	                    self._scrollbarMouseover(e);
	                }).bind(E_MOUSEOUT, function (e) {
	                    self._scrollbarMouseout(e);
	                });
	                self._$scrollbarWrapperDiv.bind(E_MOUSEDOWN, function (e) {
	                   
	                   
	                    var isFirefox = browser && browser.mozilla;
	                    if (isFirefox) {
	                        var thisMouseDownTime = new Date().valueOf();
	                        var lastMouseDownTime = self._lastMouseDownTime;
	                        self._lastMouseDownTime = thisMouseDownTime;
	                        if (lastMouseDownTime && (thisMouseDownTime - lastMouseDownTime < 100)) {
	                            return;
	                        }
	                    }
	                    self._scrollbarContainerMousedown(e);
	                }).bind(E_MOUSEUP, function (e) {
	                    self._scrollbarContainerMouseup(e);
	                });
	                self._mousewheelHandler = function (event) {
	                    self._scrollContainerMousewheel(event);
	                };
	                self._$scrollContainerDiv.bind(E_MOUSEWHEEL, self._mousewheelHandler);
	                self._$scrollContainerDiv.bind(E_DOMMOUSESCROLL, self._mousewheelHandler);
	
	                Scrollbar._callFeatureHandler(self, 'initEvents', self._scrollContainerDiv);
	            },
	            dispose: function () {
	                var self = this;
	
	                function unbindScrollbar($div) {
	                    if ($div) {
	                        $div.unbind(NS_SCROLLBAR);
	                    }
	                }
	
	                unbindScrollbar(self._$arrowEndDiv);
	                unbindScrollbar(self._$scrollbarDiv);
	                unbindScrollbar(self._$arrowStartDiv);
	                unbindScrollbar(self._$scrollbarWrapperDiv);
	
	                if (self._$scrollContainerDiv) {
	                    if (self._mousewheelHandler) {
	                        self._$scrollContainerDiv.unbind(E_MOUSEWHEEL, self._mousewheelHandler);
	                        self._$scrollContainerDiv.unbind(E_DOMMOUSESCROLL, self._mousewheelHandler);
	                    }
	                    Scrollbar._callFeatureHandler(self, 'dispose', self._scrollContainerDiv);
	                    self._$scrollContainerDiv.unbind(NS_SCROLLBAR).remove();
	                }
	            },
	           
	            _handleDocumentMouseMove: function () {
	                var self = this;
	                if (!self._isMouseCapture) {
	                    $(DOCUMENT).bind(E_MOUSEMOVE, function (e) {
	                        self._scrollbarMousemove(e);
	                    }).bind(E_MOUSEUP, function (e) {
	                        self._scrollbarMouseup(e);
	                    });
	                    self._isMouseCapture = true;
	                }
	            },
	            _unhandleDocumentMouseMove: function () {
	                if (this._isMouseCapture) {
	                    this._isMouseCapture = false;
	                    $(DOCUMENT).unbind(E_MOUSEMOVE).unbind(E_MOUSEUP);
	                }
	            },
	            _arrowMousedown: function (e, isStart) {
	                var scrollValue = 0, self = this, isFirst = true;
	                self._isMousedownInArrowButton = true;
	                if (self._scrollTimeOutArrow !== null) {
	                    return;
	                }
	                if (isStart) {
	                    self._$arrowStartDiv.addClass(CSS_CLASS_SCROLLBAR_STATEACTIVE_UI_STATE_ACTIVE);
	                    scrollValue = 0 - self._smallChange();
	                    self._scrollEventType = 0 ;
	                } else {
	                    self._$arrowEndDiv.addClass(CSS_CLASS_SCROLLBAR_STATEACTIVE_UI_STATE_ACTIVE);
	                    scrollValue = self._smallChange();
	                    self._scrollEventType = 1 ;
	                }
	                var doScroll = function () {
	                    self.scrollTo(self._scrollPosition + scrollValue * self._scrollUnit, false);
	                    if (self._scrollType === 1 ) {
	                        self._scrollTimeOutArrow = setTimeout(doScroll, isFirst ? self._initialDelay : self._trackClickPepeatFreq);
	                    }
	                    isFirst = false;
	                };
	                doScroll();
	                preventDefault(e);
	            },
	            _arrowMouseup: function (e, isStart) {
	                var self = this;
	                var $arrowDiv = isStart ? self._$arrowStartDiv : self._$arrowEndDiv;
	                $arrowDiv.removeClass(CSS_CLASS_SCROLLBAR_STATEACTIVE_UI_STATE_ACTIVE);
	                self._endArrowScroll();
	                preventDefault(e);
	            },
	            _arrowMouseover: function (e, isStart) {
	                var self = this;
	                var $arrowDiv = isStart ? self._$arrowStartDiv : self._$arrowEndDiv;
	                $arrowDiv.addClass('gc-scroll-arrow-hover ui-state-hover');
	                preventDefault(e);
	            },
	            _arrowMouseout: function (e, isStart) {
	                var self = this;
	                var $arrowDiv = isStart ? self._$arrowStartDiv : self._$arrowEndDiv;
	                $arrowDiv.removeClass('gc-scroll-arrow-hover gc-scrollbar-stateActive ui-state-hover ui-state-active');
	                self._endArrowScroll();
	                preventDefault(e);
	            },
	            _scrollbarMousedown: function (e) {
	                var self = this;
	                if (e.button === 0) {
	                    self._isMousedownInScrollbar = true;
	                    self._oldPosition = {x: e.pageX, y: e.pageY};
	                    self._handleDocumentMouseMove();
	                    self._$scrollbarDiv.addClass(CSS_CLASS_SCROLLBAR_STATEACTIVE_UI_STATE_ACTIVE);
	                    var scrollbarOffset = self._$scrollbarDiv.offset(),
	                        scrollbarWidth = self._$scrollbarDiv.outerWidth(true),
	                        scrollbarHeight = self._$scrollbarDiv.outerHeight(true),
	                        scrollbarWrapperOffset = self._$scrollbarWrapperDiv.offset(),
	                        scrollbarWrapperWidth = self._$scrollbarWrapperDiv.outerWidth(true),
	                        scrollbarWrapperHeight = self._$scrollbarWrapperDiv.outerHeight(true);
	                    self._edgePosition = {
	                        isBeyondEdge: false,
	                        startEdgePosition: {
	                            x: scrollbarWrapperOffset.left + e.pageX - scrollbarOffset.left,
	                            y: scrollbarWrapperOffset.top + e.pageY - scrollbarOffset.top
	                        },
	                        endEdgePosition: {
	                            x: scrollbarWrapperOffset.left + scrollbarWrapperWidth - (scrollbarWidth - e.pageX + scrollbarOffset.left),
	                            y: scrollbarWrapperOffset.top + scrollbarWrapperHeight - (scrollbarHeight - e.pageY + scrollbarOffset.top)
	                        }
	                    };
	                }
	                preventDefault(e);
	            },
	            _scrollbarMousemove: function (e) {
	                var self = this;
	                if (self._isMousedownInScrollbar) {
	                    self._currentPosition = {x: e.pageX, y: e.pageY};
	                    self._scrollbarDrag();
	                    self._oldPosition = self._currentPosition;
	                    $(DOCUMENT.body).attr('unselectable', 'on')
	                        .addClass(CSS_CLASS_NONE_USER_SELECT);
	                }
	                preventDefault(e);
	            },
	            _scrollbarMouseup: function (e) {
	                var self = this;
	                self._isMousedownInScrollbar = false;
	                self._scrollEventType = 4 ;
	                self._edgePosition = null;
	                self._$scrollContainerDiv.trigger(E_SCROLL, {
	                    newValue: self._value,
	                    oldValue: self._value,
	                    scrollOrientation: self._isHorizontalScroll ? 0  : 1 ,
	                    scrollEventType: self._scrollEventType
	                });
	                var value = self._value, fixScrollPosition = (value - self._minimum()) * self._scrollUnit, css_direction = 'left';
	                if (!self._isHorizontalScroll) {
	                    css_direction = 'top';
	                }
	                self._scrollPosition = fixScrollPosition;
	                self._$scrollbarDiv.css(css_direction, fixScrollPosition);
	                self._unhandleDocumentMouseMove();
	                $(DOCUMENT.body).removeClass(CSS_CLASS_NONE_USER_SELECT);
	                if ($(DOCUMENT.body).attr('unselectable')) {
	                    $(DOCUMENT.body).removeAttr('unselectable');
	                }
	                self._$scrollbarDiv.removeClass(CSS_CLASS_SCROLLBAR_STATEACTIVE_UI_STATE_ACTIVE);
	                self._scrollEventType = 6 ;
	                self._$scrollContainerDiv.trigger(E_SCROLL, {
	                    newValue: self._value,
	                    oldValue: self._value,
	                    scrollOrientation: self._isHorizontalScroll ? 0  : 1 ,
	                    scrollEventType: self._scrollEventType
	                });
	                preventDefault(e);
	            },
	            _scrollbarMouseover: function (e) {
	                this._$scrollbarDiv.addClass('gc-scrollbar-stateHover ui-state-hover');
	                preventDefault(e);
	            },
	            _scrollbarMouseout: function (e) {
	                this._$scrollbarDiv.removeClass('gc-scrollbar-stateHover ui-state-hover');
	                preventDefault(e);
	            },
	            _scrollContainerMousewheel: function (e) {
	               
	                var self = this;
	                if (isNullOrUndefined(e.wheelDelta) && isNullOrUndefined(e.detail)) {
	                    e.wheelDelta = e.originalEvent.wheelDelta;
	                    e.detail = e.originalEvent.detail;
	                }
	                var wheelData = e.detail ? e.detail : e.wheelDelta / -40, dragOffset = wheelData / 3 * self._smallChange() * self._scrollUnit;
	                self._scrollEventType = dragOffset >= 0 ? 1  : 0 ;
	                self.scrollTo(self._scrollPosition + dragOffset, false);
	                self._scrollEventType = 6 ;
	                var args = {
	                    newValue: self._value,
	                    oldValue: self._value,
	                    scrollOrientation: self._isHorizontalScroll ? 0  : 1 ,
	                    scrollEventType: self._scrollEventType
	                };
	                self._$scrollContainerDiv.trigger(E_SCROLL, args);
	                preventDefault(e);
	            },
	            _scrollbarContainerMousedown: function (e) {
	                var self = this, isFirst = true, pageX = e.pageX, pageY = e.pageY,
	                    direction = 0, offset = self._$scrollbarWrapperDiv.offset(), largetStepValue = self._largeChange();
	                if (self._scrollTimeOutContainer !== null) {
	                    return;
	                }
	                if (self._isHorizontalScroll) {
	                    direction = pageX - offset.left - self._scrollPosition;
	                } else {
	                    direction = pageY - offset.top - self._scrollPosition;
	                }
	                var doScroll = function () {
	                    var pos = 0, scrollPosition = self._scrollPosition;
	                    if (self._isHorizontalScroll) {
	                        pos = pageX - offset.left - scrollPosition;
	                    } else {
	                        pos = pageY - offset.top - scrollPosition;
	                    }
	                    if (pos * direction < 0 || pos >= 0 && pos < self._scrollbarSize) {
	                        self._endContainerScroll();
	                        return;
	                    }
	                    if (direction < 0) {
	                        self._scrollEventType = 2 ;
	                        self.scrollTo(scrollPosition - largetStepValue * self._scrollUnit, false);
	                    } else if (direction > 0) {
	                        self._scrollEventType = 3 ;
	                        self.scrollTo(scrollPosition + largetStepValue * self._scrollUnit, false);
	                    } else {
	                        self._endContainerScroll();
	                        return;
	                    }
	                    if (self._scrollType === 1 ) {
	                        self._scrollTimeOutContainer = setTimeout(doScroll, isFirst ? self._initialDelay : self._trackClickPepeatFreq);
	                    }
	                    isFirst = false;
	                };
	                doScroll();
	                preventDefault(e);
	            },
	            _scrollbarContainerMouseup: function (e) {
	                this._endContainerScroll();
	                preventDefault(e);
	            },
	           
	            _endContainerScroll: function () {
	                var self = this;
	                self._scrollTimeOutContainer && clearTimeout(self._scrollTimeOutContainer);
	                self._scrollTimeOutContainer = keyword_null;
	                self._scrollEventType = 6 ;
	                var args = {
	                    newValue: self._value,
	                    oldValue: self._value,
	                    scrollOrientation: self._isHorizontalScroll ? 0  : 1 ,
	                    scrollEventType: self._scrollEventType
	                };
	                self._$scrollContainerDiv.trigger(E_SCROLL, args);
	            },
	            _endArrowScroll: function () {
	                var self = this;
	                if (self._isMousedownInArrowButton) {
	                    self._isMousedownInArrowButton = false;
	                    self._scrollTimeOutArrow && clearTimeout(self._scrollTimeOutArrow);
	                    self._scrollTimeOutArrow = keyword_null;
	                    self._scrollEventType = 6 ;
	                    var args = {
	                        newValue: self._value,
	                        oldValue: self._value,
	                        scrollOrientation: self._isHorizontalScroll ? 0  : 1 ,
	                        scrollEventType: self._scrollEventType
	                    };
	                    self._$scrollContainerDiv.trigger(E_SCROLL, args);
	                }
	            },
	            _scrollbarDrag: function () {
	                var self = this;
	                var scrollPosition = self._scrollPosition, currentPosition = self._currentPosition, edgePosition = self._edgePosition;
	                var isBeyondStart, isBeyondEnd;
	
	                function getXY(position) {
	                    return self._isHorizontalScroll ? position.x : position.y;
	                }
	
	                function setXY(position, value) {
	                    if (self._isHorizontalScroll) {
	                        position.x = value;
	                    } else {
	                        position.y = value;
	                    }
	                }
	
	                var currentPositionXY = getXY(currentPosition);
	                var oldPositionXY = getXY(self._oldPosition);
	                if (edgePosition && edgePosition.isBeyondEdge) {
	                    var startEdgePositionXY = getXY(edgePosition.startEdgePosition);
	                    var endEdgePositionXY = getXY(edgePosition.endEdgePosition);
	                    isBeyondStart = currentPositionXY < startEdgePositionXY;
	                    isBeyondEnd = currentPositionXY > endEdgePositionXY;
	                    if (isBeyondStart || isBeyondEnd) {
	                        return;
	                    }
	                    if (oldPositionXY < startEdgePositionXY) {
	                        setXY(self._oldPosition, startEdgePositionXY);
	                    }
	                    if (oldPositionXY > endEdgePositionXY) {
	                        setXY(self._oldPosition, endEdgePositionXY);
	                    }
	                }
	                var dragOffsetHV = currentPositionXY - oldPositionXY;
	                var destPosition = scrollPosition + dragOffsetHV;
	
	                if (destPosition !== scrollPosition) {
	                    self._scrollEventType = 5 ;
	                    self.scrollTo(destPosition, false);
	                }
	            },
	            scrollTo: function (destPosition, notTriggerEvent) {
	                var self = this;
	                var css_direction = CSS_TOP, scrollScope = self._scrollSize - self._scrollbarSize;
	                if (self._isHorizontalScroll) {
	                    css_direction = CSS_LEFT;
	                }
	                var isBeyondEdge = false;
	                if (destPosition > scrollScope) {
	                    destPosition = scrollScope;
	                    isBeyondEdge = true;
	                }
	                if (destPosition < 0) {
	                    destPosition = 0;
	                    isBeyondEdge = true;
	                }
	                if (self._edgePosition) {
	                    self._edgePosition.isBeyondEdge = isBeyondEdge;
	                }
	                var newValue = Math_Round(destPosition / self._scrollUnit) + self._minimum(), oldValue = self._value, ignoreUpdatePosition = false;
	                if (!notTriggerEvent) {
	                    var args = {
	                        newValue: newValue,
	                        oldValue: oldValue,
	                        scrollOrientation: self._isHorizontalScroll ? 0  : 1 ,
	                        scrollEventType: self._scrollEventType
	                    };
	                    self._$scrollContainerDiv.trigger(E_SCROLL, args);
	                    ignoreUpdatePosition = args.ignoreUpdatePosition;
	                    if (args.newValue > self._maximum()) {
	                        args.newValue = self._maximum();
	                    }
	                    newValue = args.newValue;
	                }
	                self._value = newValue;
	                if (self._scrollEventType !== 5 ) {
	                    destPosition = (newValue - self._minimum()) * self._scrollUnit;
	                }
	                self._scrollPosition = destPosition;
	                if (!ignoreUpdatePosition) {
	                    self._$scrollbarDiv.css(css_direction, destPosition);
	                }
	            },
	
	            hitTest: function (x, y) {
	                var self = this, scrollbarX = 0, scrollbarY = 0;
	                var scrollbarWidth = self._$scrollbarDiv.outerWidth();
	                var scrollbarStartWidth = self._$arrowStartDiv.outerWidth();
	                var scrollbarWrapperWidth = self._$scrollbarWrapperDiv.outerWidth();
	                var scrollbarDivOffset = self._$scrollbarDiv.offset();
	                var scrollbarOffset = $(self._getScrollbar()).offset();
	                var scrollbarTrackX = scrollbarDivOffset.left - scrollbarOffset.left - 18;
	                if (self._isHorizontalScroll) {
	                    if (x < scrollbarX + scrollbarWrapperWidth + scrollbarStartWidth && x > scrollbarX + scrollbarStartWidth) {
	                        if (x < scrollbarX + scrollbarTrackX + scrollbarWidth + scrollbarStartWidth && x > scrollbarTrackX) {
	                            return {'element': "thumbButton", x: x, y: y};
	                        }
	                        return {'element': "trackButton"};
	                    } else if (x <= scrollbarX + scrollbarStartWidth && x > scrollbarX) {
	                        return {'element': "leftButton", x: x, y: y};
	                    }
	                    return {'element': "rightButton", x: x, y: y};
	                }
	                var scrollbarHeight = self._$scrollbarDiv.outerHeight();
	                var scrollbarStartHeight = self._$arrowStartDiv.outerHeight();
	                var scrollbarWrapperHeight = self._$scrollbarWrapperDiv.outerHeight();
	                var scrollbarTrackY = scrollbarDivOffset.top - scrollbarOffset.top - 18;
	                if (y < scrollbarY + scrollbarWrapperHeight + scrollbarStartHeight && y > scrollbarY + scrollbarStartHeight) {
	                    if (y < scrollbarY + scrollbarTrackY + scrollbarHeight + scrollbarStartHeight && y > scrollbarTrackY) {
	                        return {'element': "thumbButton", x: x, y: y};
	                    }
	                    return {'element': "trackButton"};
	                } else if (y <= scrollbarY + scrollbarStartHeight && y > scrollbarY) {
	                    return {'element': "upButton", x: x, y: y};
	                }
	                return {'element': "downButton", x: x, y: y};
	            },
	
	            _getScrollbarRect: function () {
	                var self = this;
	                return {x: 0, y: 0, width: self._width(), height: self._height()};
	            }
	        };
	        return Scrollbar;
	    })();
	    exports._Scrollbar = Scrollbar;
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	    var ScrollablePanel = (function () {
	       
	       
	       
	       
	        function ScrollablePanel(superPanel, content) {
	            var self = this;
	            self._showHorizontalScrollbar = true;
	            self._showVerticalScrollbar = true;
	            self._defaultScrollbarSize = 18;
	            self._$superPanel = superPanel && $(superPanel);
	            self._$content = content && $(content);
	            self._refreshLayout(true);
	        }
	
	        ScrollablePanel.prototype = {
	            constructor: ScrollablePanel,
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	            _horizontalSmallChange: defProperty('horizontalSmallChange', 10),
	           
	           
	           
	            _verticalSmallChange: defProperty('verticalSmallChange', 10),
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	            _refreshLayout: function (isNewContent) {
	                var self = this;
	
	                function createDiv() {
	                    return $._createElement(
	                        'div',
	                        [CSS_POSITION, CSS_LEFT, CSS_TOP, CSS_BORDER, CSS_PADDING, CSS_MARGIN],
	                        ['absolute', 0, 0, 'none', 0, 0]
	                    );
	                }
	
	                function createScrollBar($container, isHorizontalScroll) {
	                    var oriScrollBar = isHorizontalScroll ? self._horizontalScrollbar : self._verticalScrollbar;
	                    if (!oriScrollBar) {
	                        var scrollBar = new Scrollbar(isHorizontalScroll);
	                        var $barContainer = $._createElement('div');
	                        if (isHorizontalScroll) {
	                            self._$horizontalBarContainer = $barContainer;
	                            self._horizontalScrollbar = scrollBar;
	                            $barContainer.css([CSS_POSITION, CSS_LEFT, CSS_BOTTOM, CSS_BORDER, CSS_PADDING, CSS_MARGIN],
	                                ['absolute', 0, 0, 'none', 0, 0]);
	                        } else {
	                            self._$verticalBarContainer = $barContainer;
	                            self._verticalScrollbar = scrollBar;
	                            $barContainer.css([CSS_POSITION, CSS_RIGHT, CSS_TOP, CSS_BORDER, CSS_PADDING, CSS_MARGIN],
	                                ['absolute', 0, 0, 'none', 0, 0]);
	                        }
	                        var scrollBarElement = (isHorizontalScroll ? self._horizontalScrollbar : self._verticalScrollbar)._getScrollbar();
	                        $barContainer.append(scrollBarElement);
	                        $container.append($barContainer);
	                        return scrollBar;
	                    }
	                    return oriScrollBar;
	                }
	
	                function updateScrollBar(scrollBar, pageValue, $tempContentWrapper, size, contentValue, isHorizontalScroll) {
	                    if (isHorizontalScroll) {
	                        self._$horizontalBarContainer.css([CSS_WIDTH, CSS_HEIGHT], [pageValue, size]);
	                        scrollBar._width(pageValue);
	                        scrollBar._height(size);
	                    } else {
	                        self._$verticalBarContainer.css([CSS_WIDTH, CSS_HEIGHT], [size, pageValue]);
	                        scrollBar._width(size);
	                        scrollBar._height(pageValue);
	                    }
	                    scrollBar._minimum(0);
	                    scrollBar._maximum(contentValue - pageValue);
	                    scrollBar._pageValue(pageValue);
	                    scrollBar._smallChange(isHorizontalScroll ? self._horizontalSmallChange() : self._verticalSmallChange());
	                    scrollBar._largeChange(pageValue);
	                    scrollBar._refreshLayout();
	                    $(scrollBar._getScrollbar()).bind(E_SCROLL, function (e, args) {
	                        $tempContentWrapper.css(isHorizontalScroll ? CSS_LEFT : CSS_TOP, 0 - args.newValue);
	                    });
	                    if (isHorizontalScroll) {
	                        self._$horizontalBarContainer.show();
	                    } else {
	                        self._$verticalBarContainer.show();
	                    }
	                }
	
	                function createContentWrapper($container) {
	                    if (!self._$contentWrapper) {
	                        self._$contentWrapper = createDiv();
	                        self._$contentWrapper.css([CSS_OVERFLOW, CSS_DISPLAY], ['hidden', 'inline-block']);
	                        $container.append(self._$contentWrapper);
	                    }
	                }
	
	                function createTempContentWrapper(contentWrapper) {
	                    if (!self._$tempContentWrapper) {
	                        self._$tempContentWrapper = $._createElement('div', CSS_POSITION, 'relative', keyword_null, contentWrapper);
	                    }
	                }
	
	
	                if (!self._$superPanel || !self._$content) {
	                    return;
	                }
	                var scrollbarSize = self._defaultScrollbarSize,
	                    contentWidth = self._$content.width(), contentHeight = self._$content.height(),
	                    superPanelWidth = self._$superPanel.width(), superPanelHeight = self._$superPanel.height(),
	                    pageWidth = superPanelWidth - scrollbarSize, pageHeight = superPanelHeight - scrollbarSize,
	                    isNeedInitEvent = false;
	                if (!self._$container) {
	                    self._$container = createDiv();
	                    self._$container.css([CSS_POSITION, CSS_OVERFLOW], ['relative', 'hidden']);
	                    isNeedInitEvent = true;
	                }
	                self._$container.css([CSS_WIDTH, CSS_HEIGHT], [superPanelWidth, superPanelHeight]);
	                createContentWrapper(self._$container);
	
	                createTempContentWrapper(self._$contentWrapper);
	
	                if (isNewContent) {
	                    self._$tempContentWrapper.append(self._$content).css([CSS_TOP, CSS_LEFT], [0, 0]);
	                }
	                if (browser.chrome) {
	                    contentWidth = Math_Round(contentWidth);
	                    contentHeight = Math_Round(contentHeight);
	                    superPanelWidth = Math_ceil(superPanelWidth);
	                    superPanelHeight = Math_ceil(superPanelHeight);
	                }
	
	
	                var result = self._isNeedScrollbars(contentWidth, contentHeight, superPanelWidth, superPanelHeight);
	                var isNeedVScroll = result._isNeedVScroll, isNeedHScroll = result._isNeedHScroll;
	                if (isNeedHScroll) {
	                    if (!isNeedVScroll) {
	                        pageWidth += scrollbarSize;
	                    }
	                    var scrollH = createScrollBar(self._$container, true);
	                    updateScrollBar(scrollH, pageWidth, self._$tempContentWrapper, scrollbarSize, contentWidth, true);
	                } else {
	                    self._$horizontalBarContainer && self._$horizontalBarContainer.hide();
	                }
	
	                if (isNeedVScroll) {
	                    if (!isNeedHScroll) {
	                        pageHeight += scrollbarSize;
	                    }
	                    var scrollV = createScrollBar(self._$container, false);
	                    updateScrollBar(scrollV, pageHeight, self._$tempContentWrapper, scrollbarSize, contentHeight, false);
	                } else {
	                    self._$verticalBarContainer && self._$verticalBarContainer.hide();
	                }
	
	                if (!isNeedHScroll && !isNeedVScroll) {
	                    pageWidth += scrollbarSize;
	                    pageHeight += scrollbarSize;
	                }
	                self._showHorizontalScrollbar = isNeedHScroll;
	                self._showVerticalScrollbar = isNeedVScroll;
	                self._pageWidth = pageWidth;
	                self._pageHeight = pageHeight;
	                self._$contentWrapper.css([CSS_WIDTH, CSS_HEIGHT], [pageWidth, pageHeight]);
	
	                if (isNeedInitEvent) {
	                    self._$superPanel.append(self._$container);
	                    self._initEvent();
	                }
	            },
	           
	           
	            _scrollChildIntoView: function (item) {
	                var self = this;
	                var offset = self._getScrollOffset(item), left = offset._left, top = offset._top;
	                if (!isNullOrUndefined(left) && self._horizontalScrollbar) {
	                    self._hScrollTo(left);
	                }
	                if (!isNullOrUndefined(top) && self._verticalScrollbar) {
	                    self._vScrollTo(top);
	                }
	            },
	           
	           
	            _hScrollTo: function (left) {
	                var self = this;
	                self._horizontalScrollbar.value(left);
	                var pageWidth = self._pageWidth, contentHeight = self._$content.width();
	                if (left >= 0 && left <= contentHeight - pageWidth) {
	                    self._$tempContentWrapper.css(CSS_LEFT, 0 - left);
	                }
	            },
	           
	           
	            _vScrollTo: function (top) {
	                var self = this;
	                self._verticalScrollbar.value(top);
	                var pageHeight = self._pageHeight, contentHeight = self._$content.height();
	                if (top >= 0 && top <= contentHeight - pageHeight) {
	                    self._$tempContentWrapper.css(CSS_TOP, 0 - top);
	                }
	            },
	            _isNeedScrollbars: function (contentWidth, contentHeight, superPanelWidth, superPanelHeight) {
	                var scrollbarSize = this._defaultScrollbarSize, pageWidth = superPanelWidth - scrollbarSize,
	                    pageHeight = superPanelHeight - scrollbarSize,
	                    result = {
	                        _isNeedHScroll: false,
	                        _isNeedVScroll: false
	                    };
	                if (contentWidth > superPanelWidth) {
	                    result._isNeedHScroll = true;
	                    result._isNeedVScroll = contentHeight > pageHeight;
	                }
	                if (contentHeight > superPanelHeight) {
	                    result._isNeedVScroll = true;
	                    result._isNeedHScroll = contentWidth > pageWidth;
	                }
	                return result;
	            },
	            _getScrollOffset: function (item) {
	                var $child = $(item), $contentWrapper = this._$contentWrapper,
	                    $tempContentWrapper = this._$tempContentWrapper,
	                    childOffset, tempContentWrapperOffset, contentWrapperOffset,
	                    leftDistance, rightDistance, topDistance, bottomDistance,
	                    result = {
	                        _left: keyword_null,
	                        _top: keyword_null
	                    };
	                if (!item) {
	                    return result;
	                }
	                childOffset = $child.offset();
	                tempContentWrapperOffset = $tempContentWrapper.offset();
	                contentWrapperOffset = $contentWrapper.offset();
	                childOffset.leftWidth = childOffset.left + $child.outerWidth();
	                childOffset.topHeight = childOffset.top + $child.outerHeight();
	                contentWrapperOffset.leftWidth = contentWrapperOffset.left + $contentWrapper.outerWidth();
	                contentWrapperOffset.topHeight = contentWrapperOffset.top + $contentWrapper.outerHeight();
	                leftDistance = childOffset.left - tempContentWrapperOffset.left;
	                if (childOffset.left < contentWrapperOffset.left) {
	                    result._left = leftDistance;
	                } else if (childOffset.leftWidth > contentWrapperOffset.leftWidth) {
	                    rightDistance = childOffset.leftWidth - tempContentWrapperOffset.left - $contentWrapper.innerWidth();
	                    if (leftDistance < rightDistance) {
	                        result._left = leftDistance;
	                    } else {
	                        result._left = rightDistance;
	                    }
	                }
	                topDistance = childOffset.top - tempContentWrapperOffset.top;
	                if (childOffset.top < contentWrapperOffset.top) {
	                    result._top = topDistance;
	                } else if (childOffset.topHeight > contentWrapperOffset.topHeight) {
	                    bottomDistance = childOffset.topHeight - tempContentWrapperOffset.top - $contentWrapper.innerHeight();
	                    if (topDistance < bottomDistance) {
	                        result._top = topDistance;
	                    } else {
	                        result._top = bottomDistance;
	                    }
	                }
	                return result;
	            },
	            _initEvent: function () {
	                var self = this;
	                if (this._$tempContentWrapper) {
	                    self._mousewheelHandler = function (event) {
	                        self._contentContainerMousewheel(event);
	                    };
	                    self._$tempContentWrapper.bind(E_MOUSEWHEEL, self._mousewheelHandler);
	                    self._$tempContentWrapper.bind(E_DOMMOUSESCROLL, self._mousewheelHandler);
	                }
	            },
	            _contentContainerMousewheel: function (e) {
	               
	                var self = this;
	                if (isNullOrUndefined(e.wheelDelta) && isNullOrUndefined(e.detail)) {
	                    e.wheelDelta = e.originalEvent.wheelDelta;
	                    e.detail = e.originalEvent.detail;
	                }
	                var wheelData = e.detail ? e.detail : e.wheelDelta / -40, dragOffset = wheelData;
	                var vScrollbar = self._verticalScrollbar,
	                    topOffset = parseInt(self._$tempContentWrapper.css(CSS_TOP)),
	                    pageHeight = self._pageHeight, contentHeight = self._$content.height();
	                if (contentHeight < pageHeight) {
	                    contentHeight = pageHeight;
	                }
	                if (isNaN(topOffset)) {
	                    topOffset = 0;
	                }
	                var posOffset = topOffset - dragOffset * self._verticalSmallChange();
	                if (posOffset >= 0) {
	                    posOffset = 0;
	                }
	                if (posOffset < 0 && 0 - posOffset > contentHeight - pageHeight) {
	                    posOffset = 0 - (contentHeight - pageHeight);
	                }
	                if (posOffset !== topOffset) {
	                    self._$tempContentWrapper.css(CSS_TOP, posOffset);
	                    if (self._showVerticalScrollbar) {
	                        vScrollbar.value(0 - posOffset);
	                    }
	                }
	                cancelDefault(e);
	            },
	            dispose: function () {
	               var self = this;
	               if (self._$container) {
	                   if (self._horizontalScrollbar) {
	                       self._horizontalScrollbar.dispose();
	                   }
	                   if (self._verticalScrollbar) {
	                       self._verticalScrollbar.dispose();
	                   }
	                   if (self._$tempContentWrapper && self._mousewheelHandler) {
	                       self._$tempContentWrapper.unbind(E_MOUSEWHEEL, self._mousewheelHandler);
	                       self._$tempContentWrapper.unbind(E_DOMMOUSESCROLL, self._mousewheelHandler);
	                   }
	                   $(self._$container).remove();
	               }
	            }
	        };
	        return ScrollablePanel;
	    })();
	    exports._ScrollablePanel = ScrollablePanel;
	
	    module.exports = exports;
	
	
	}());

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var exports = __webpack_require__(1);
	
	    var _ColorHelper = __webpack_require__(5)._ColorHelper;
	    var $$ = __webpack_require__(4).GC$;
	    var util_common = __webpack_require__(3);
	    var StyleHelper = __webpack_require__(11)._StyleHelper;
	    var _SheetTabBase = __webpack_require__(28)._SheetTabBase;
	
	    var _Color_invertColor = _ColorHelper._invertColor, _Color_parse = _ColorHelper._fromString;
	    var _ThemeStyleHelper = util_common._ThemeStyleHelper;
	
	    var keyword_null = null;
	    var hit_element_blankArea = 'blank', hit_element_nextButton = 'nextButton';
	
	    $$.inherit(SheetTab, _SheetTabBase);
	    function SheetTab(name) {
	        _SheetTabBase.call(this, name);
	        var self = this;
	        self._tabLeftPadding = 13;
	        self._tabRightPadding = 12;
	        self._tabSpace = 0;
	        self._resizeBarWidth = 30;
	        self._itemWidth = 28;
	        self._moreTabWidth = 28;
	        self._newTabSize = 28;
	        self._firstTabSpace = 0;
	        self._font = '10pt Segoe UI';
	    }
	
	    $$.extend(SheetTab.prototype, {
	        _getNavigationButtonWidth: function () {
	            var workbook = this._workbook;
	            if (!workbook || !workbook.options.tabNavigationVisible) {
	                return 0;
	            }
	            return this._itemWidth;
	        },
	        _getNavigationButtonHeight: function () {
	            var workbook = this._workbook;
	            if (!workbook || !workbook.options.tabNavigationVisible) {
	                return 0;
	            }
	            return workbook._getTabStripHeight();
	        },
	        _getFirstMoreTabWidth: function () {
	            return this._moreTabWidth;
	        },
	        _getSecondMoreTabWidth: function () {
	            return this._hideNewTabSecondMoreTab ? 0 : this._moreTabWidth;
	        },
	        _getNewTabSize: function () {
	            return this._hideNewTabSecondMoreTab ? 0 : this._newTabSize;
	        },
	        _getTabEndPosition: function () {
	            var self = this, sheets = self._workbook.sheets, tabEndPosition = self._getTabStartPosition(),
	                tabSizes = self._tabSizes;
	            var rect = self._getBounds(),
	                max = rect.x + rect.width - self._resizeBarWidth - self._getNewTabSize() - self._getSecondMoreTabWidth();
	            for (var i = self._firstTab, length = sheets.length; i < length; i++) {
	                if (sheets[i].visible()) {
	                    tabEndPosition += tabSizes[i];
	                }
	                if (tabEndPosition > max) {
	                    tabEndPosition = max;
	                    break;
	                }
	            }
	            return tabEndPosition;
	        },
	        _getTabStartPosition: function () {
	            var self = this;
	            return self._getNavigationButtonWidth() * 2 + self._getFirstMoreTabWidth() + self._getNavigationMarginLeft();
	        },
	        _getNavigationMarginLeft: function () {
	            var self = this, workbook = self._workbook;
	            if (!workbook || !workbook.options.tabNavigationVisible) {
	                return 0;
	            }
	            return self._resizeBarWidth / 2;
	        },
	
	        getResizeBarBounds: function () {
	            var self = this;
	            var rect = self._getBounds();
	            return {
	                x: rect.x + rect.width - self._resizeBarWidth,
	                y: keyword_null,
	                width: self._resizeBarWidth,
	                height: keyword_null
	            };
	        },
	
	        getNavButtonBounds: function () {
	            var self = this;
	            return {
	                x: self._resizeBarWidth / 2,
	                y: keyword_null,
	                width: self._getNavigationButtonWidth(),
	                height: keyword_null,
	                endIndex: 3,
	                startIndex: 1
	            };
	        },
	
	        getSheetTabBounds: function () {
	            var self = this;
	            var rect = self._getBounds();
	            var secondMoreTabWidth = self._getSecondMoreTabWidth();
	            return {
	                x: self._getTabStartPosition(),
	                y: keyword_null,
	                height: keyword_null,
	                secondMoreTabWidth: self._getSecondMoreTabWidth(),
	                moreTabPos: rect.x + rect.width - self._resizeBarWidth - self._getNewTabSize() - secondMoreTabWidth
	            };
	        },
	
	        getPreMoreTabBounds: function () {
	            var self = this;
	            return {
	                x: self._getTabStartPosition() - self._getFirstMoreTabWidth(),
	                width: self._getFirstMoreTabWidth()
	            };
	        },
	
	        _isCoverSheetTab: function () {
	            var self = this;
	            return self._activePos + self._tabSizes[self._activeIndex] > self._getCoverPosition();
	        },
	        _getCoverPosition: function () {
	            var self = this;
	            return self._getBounds().width - self._resizeBarWidth - self._getNewTabSize() - self._getSecondMoreTabWidth();
	        },
	        _getInputTopPosition: function () {
	            return 6;
	        },
	        _getTabIndicatorEdgeElements: function () {
	            return [hit_element_blankArea, hit_element_nextButton];
	        },
	        _getBasicWidth: function () {
	            return this._getTabStartPosition();
	        },
	        _paintBackground: function (ctx, rect) {
	           
	            ctx.save();
	            ctx.beginPath();
	            var themeStyle = _ThemeStyleHelper._getVisualStateThemeStyle(0 , 'gc-tabStripBackground');
	            this._backgroundColor = _Color_parse(themeStyle.backgroundColor);
	            ctx.fillStyle = themeStyle.backgroundColor;
	            ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
	           
	            ctx.beginPath();
	            ctx.strokeStyle = themeStyle.borderTopColor;
	            ctx.moveTo(rect.x, rect.y + 0.5);
	            ctx.lineTo(rect.x + rect.width, rect.y + 0.5);
	            ctx.stroke();
	            ctx.restore();
	        },
	        _paintNewSheetTab: function (ctx, rect, pos, tabStartPosition) {
	            var self = this, newTabVisible = self._workbook.options.newTabVisible, itemWidth = self._itemWidth,
	                moreTabWidth = self._getSecondMoreTabWidth();
	            pos += moreTabWidth;
	            if (newTabVisible) {
	                self._newTabSize = itemWidth;
	            } else {
	                self._newTabSize = 0;
	            }
	            var maxNewTabPos = rect.x + rect.width - self._resizeBarWidth - self._getNewTabSize();
	            if (pos > maxNewTabPos) {
	                pos = maxNewTabPos;
	                var moreTabPos = maxNewTabPos - moreTabWidth;
	                if (moreTabPos < tabStartPosition) {
	                    moreTabPos = tabStartPosition;
	                    pos = moreTabPos + itemWidth;
	                }
	                self._drawMoreTab(ctx, moreTabPos, 0, moreTabWidth, rect.height);
	            }
	            if (newTabVisible) {
	                self._drawNewSheetTab(ctx, pos, 0, itemWidth, rect.height, self._hoverTab === -2);
	            }
	        },
	        _paintTabBeforeFirstTab: function (ctx, rect, firstTab, tabStartPosition) {
	            var moreTabWidth = this._getFirstMoreTabWidth();
	            this._drawMoreTab(ctx, tabStartPosition - moreTabWidth, 0, moreTabWidth, rect.height);
	        },
	        _paintNavigationButtons: function (ctx, rect, tabStartPosition) { 
	            var self = this;
	           
	            var triangleSize = 5, navigationButtonWidth = self._getNavigationButtonWidth(),
	                navigationButtonHeight = self._getNavigationButtonHeight();
	            var x = self._resizeBarWidth / 2 + navigationButtonWidth / 2;
	            var y = navigationButtonHeight / 2;
	            var hoverNavButton = self._hoverNavButton;
	           
	            self._drawNavButton(ctx, x, y, x + triangleSize, y + triangleSize, x + triangleSize, y - triangleSize, true, keyword_null, (hoverNavButton === 1));
	           
	            x += navigationButtonWidth;
	            self._drawNavButton(ctx, x, y, x - triangleSize, y + triangleSize, x - triangleSize, y - triangleSize, false, keyword_null, (hoverNavButton === 2));
	        },
	        _paintResizeBar: function (ctx, rect) {
	            var self = this, x, y, resizeBarWidth = self._resizeBarWidth;
	            var themeStyle = _ThemeStyleHelper._getVisualStateThemeStyle(0 , 'gc-tabStripResizeBarInner');
	            if (self._workbook.options.showHorizontalScrollbar) {
	                ctx.beginPath();
	                ctx.rect(rect.x + rect.width - resizeBarWidth, 0, resizeBarWidth, rect.height);
	                ctx.clip();
	                x = rect.x + rect.width - resizeBarWidth / 2;
	                y = rect.y + rect.height / 2;
	                ctx.fillStyle = themeStyle.color;
	                ctx.fillRect(x, y, 2, 2);
	                ctx.fillRect(x, y - 4, 2, 2);
	                ctx.fillRect(x, y + 4, 2, 2);
	            }
	        },
	        _drawTab: function (ctx, x, y, width, height, cornerRadius, isActive, isHover, text) {
	           
	            var self = this;
	            var visualState = 0 ;
	            if (isHover) {
	                visualState = 4 ;
	            }
	            if (isActive) {
	                visualState = 3 ;
	            }
	            var externalThemeStyle = _ThemeStyleHelper._getVisualStateThemeStyle(visualState, 'gc-tab-' + _ThemeStyleHelper._getString(visualState)),
	                themeStyle = _ThemeStyleHelper._getVisualStateThemeStyle(0 , 'gc-tab-' + _ThemeStyleHelper._getString(0 ));
	            ctx.save();
	            var margin = 4, padding = 3;
	           
	            if (isActive) {
	                ctx.fillStyle = 'white';
	                ctx.fillRect(x, y, width, height - margin);
	            }
	           
	            var backColor = self._getTabBackColor(ctx, isActive, text, externalThemeStyle);
	            ctx.fillStyle = backColor;
	            ctx.fillRect(x + padding, y + padding, width - padding * 2 + 1, height - padding * 2);
	           
	            ctx.beginPath();
	            ctx.lineWidth = 1;
	            ctx.strokeStyle = themeStyle && themeStyle.borderLeftColor;
	            if (!isActive) {
	                ctx.moveTo(x + 0.5, y + margin);
	                ctx.lineTo(x + 0.5, y + height - margin);
	                ctx.moveTo(x + width + 0.5, y + margin);
	                ctx.lineTo(x + width + 0.5, y + height - margin);
	            } else {
	                ctx.moveTo(x + 0.5, y);
	                ctx.lineTo(x + 0.5, y + height - margin);
	                ctx.moveTo(x + width + 0.5, y);
	                ctx.lineTo(x + width + 0.5, y + height - margin);
	            }
	            ctx.stroke();
	           
	            if (isActive) {
	                ctx.beginPath();
	                ctx.strokeStyle = externalThemeStyle && externalThemeStyle.borderBottomColor;
	                ctx.lineWidth = 2;
	                ctx.moveTo(x, y + height - margin);
	                ctx.lineTo(x + width + 1, y + height - margin);
	                ctx.stroke();
	            }
	            ctx.textBaseline = 'top';
	            var solidBackColor;
	            if (typeof (backColor) === 'string') {
	                solidBackColor = backColor;
	            }
	            ctx.fillStyle = self._getTabForeColor(externalThemeStyle, solidBackColor);
	            if (isHover || isActive) {
	                ctx.font = StyleHelper._setStringFont(ctx.font, 'bold');
	            }
	            var adjX = self._tabLeftPadding;
	            ctx.textBaseline = 'middle';
	            ctx.fillText(text, x + adjX, y + height / 2 - 1);
	            ctx.restore();
	        },
	        _drawNavButton: function (ctx, x1, y1, x2, y2, x3, y3, left, linePosition, isHover) {
	           
	            ctx.save();
	            var self = this;
	            var visualState = 1 ;
	            if (isHover) {
	                visualState = 4 ;
	            }
	            if (left) {
	                x1 -= 2;
	                x2 -= 2;
	                x3 -= 2;
	                var preVisibleIndex = self._getPreVisibleIndex(self._firstTab);
	                if (preVisibleIndex === -1) {
	                    visualState = 0 ;
	                }
	            } else {
	                x1 += 2;
	                x2 += 2;
	                x3 += 2;
	                var currTabIndex = self._reCalculateFirstTabIndex(self._getVisibleTabs());
	                if (currTabIndex === -1) {
	                    visualState = 0 ;
	                }
	            }
	           
	            var themeStyle = _ThemeStyleHelper._getVisualStateThemeStyle(visualState, 'gc-navButton-' + _ThemeStyleHelper._getString(visualState));
	            ctx.strokeStyle = this._getVisibleForeColor(themeStyle.borderTopColor);
	           
	            ctx.beginPath();
	           
	            var leftToRight = 1;
	            if (x1 > x2) {
	                leftToRight = -1;
	            }
	            ctx.moveTo(x1 - 0.5, y1);
	            ctx.lineTo(x1 - 0.5, y1 + 1);
	            ctx.moveTo(x1 + leftToRight - 0.5, y1 - 1);
	            ctx.lineTo(x1 + leftToRight - 0.5, y1 + 2);
	            ctx.moveTo(x1 + leftToRight * 2 - 0.5, y1 - 2);
	            ctx.lineTo(x1 + leftToRight * 2 - 0.5, y1 + 3);
	            ctx.moveTo(x1 + leftToRight * 3 - 0.5, y1 - 3);
	            ctx.lineTo(x1 + leftToRight * 3 - 0.5, y1 + 4);
	            ctx.stroke();
	            ctx.restore();
	        },
	        _drawNewSheetTab: function (ctx, x, y, width, height, isHover) {
	            ctx.save();
	            ctx.beginPath();
	            var radius = (height - 7 * 2) / 2;
	            var visualState = 1 ;
	            if (isHover) {
	                visualState = 4 ;
	            }
	            var themeStyle = _ThemeStyleHelper._getVisualStateThemeStyle(visualState, 'gc-tabStripNewTab-' + _ThemeStyleHelper._getString(visualState));
	            ctx.lineWidth = 1.5;
	            ctx.strokeStyle = this._getVisibleForeColor(themeStyle.borderTopColor);
	            ctx.arc(x + width / 2, y + height / 2, radius, 0, 2 * Math.PI);
	            ctx.stroke();
	            ctx.beginPath();
	            ctx.lineWidth = 2;
	            ctx.moveTo(x + width / 2 - 4, y + height / 2);
	            ctx.lineTo(x + width / 2 + 4, y + height / 2);
	            ctx.moveTo(x + width / 2, y + height / 2 - 4);
	            ctx.lineTo(x + width / 2, y + height / 2 + 4);
	            ctx.stroke();
	            ctx.restore();
	        },
	        _drawMoreTab: function (ctx, x, y, width, height) {
	            ctx.save();
	            ctx.beginPath();
	            var visualState = 1 , hoverNavButton = this._hoverNavButton;
	            if (hoverNavButton === 5 || hoverNavButton === 6) {
	                visualState = 4 ;
	            }
	            var themeStyle = _ThemeStyleHelper._getVisualStateThemeStyle(visualState, 'gc-navMoreButton-' + _ThemeStyleHelper._getString(visualState));
	            ctx.fillStyle = this._getVisibleForeColor(themeStyle.borderTopColor);
	            ctx.fillRect(x + width / 2, y + height / 2, 2, 2);
	            ctx.fillRect(x + width / 2 - 4, y + height / 2, 2, 2);
	            ctx.fillRect(x + width / 2 + 4, y + height / 2, 2, 2);
	            ctx.restore();
	        },
	        _getVisibleForeColor: function (value) {
	            var color = _Color_parse(value), backgroundColor = this._backgroundColor;
	            if (color.a <= 0.01) {
	                return _Color_invertColor(backgroundColor);
	            } else if (_ColorHelper._isTwoColorSimilar(backgroundColor, color)) {
	                return _Color_invertColor(color);
	            }
	            return value;
	        }
	    });
	
	    exports._SheetTab = SheetTab;
	
	    module.exports = exports;
	
	}());

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var exports = __webpack_require__(1);
	
	    var Common = __webpack_require__(5);
	    var $$ = __webpack_require__(4).GC$;
	    var util_common = __webpack_require__(3);
	    var StyleHelper = __webpack_require__(11)._StyleHelper;
	
	    var _ColorHelper = Common._ColorHelper;
	    var util_common_util = util_common._util;
	    var getLinearGradientColors = util_common_util._getLinearGradientColors;
	    var isValidSheetName = util_common_util._isValidSheetName;
	    var _DPIHelper = util_common._DPIHelper;
	    var Events = util_common.Events;
	    var _FocusHelper = util_common._FocusHelper;
	    var Rect = util_common.Rect;
	    var _ThemeStyleHelper = util_common._ThemeStyleHelper;
	    var isNullOrUndefined = Common._Types._isNullOrUndefined;
	    var createElement = util_common._util._createElement;
	    var setContextFont = util_common._util._setContextFont;
	    var CanvasHelper = exports._CanvasHelper;
	
	    var DOCUMENT = document, keyword_null = null, Math_max = Math.max,
	        Math_min = Math.min, Math_pow = Math.pow,
	        pixel = 'px', cssNone = 'none';
	    var gcTab_ns = '.gcTab', gcTab_mousedown = 'mousedown' + gcTab_ns, gcTab_mousemove = 'mousemove' + gcTab_ns,
	        gcTab_mouseup = 'mouseup' + gcTab_ns, gcTab_mouseout = 'mouseout' + gcTab_ns,
	        gcTab_dbclick = 'dblclick' + gcTab_ns;
	    var spliter_ns = '.spliter', spliter_mousemove = 'mousemove' + spliter_ns, spliter_mouseup = 'mouseup' + spliter_ns;
	    var tabNameEditor_ns = '.tabNameEditor', tabNameEditor_keydown = 'keydown' + tabNameEditor_ns,
	        tabNameEditor_focus = 'focus' + tabNameEditor_ns, tabNameEditor_blur = 'blur' + tabNameEditor_ns;
	    var tag_canvas = 'canvas', str_2d = '2d';
	    var hit_element_resize = 'resize', hit_element_navButton = 'navButton', hit_element_tab = 'tab',
	        hit_element_newSheet = 'newSheet', hit_element_blank = 'blank';
	    var color_black = 'black', color_white = 'white';
	    var TAB_INDICATOR_HEIGHT = 4, REORDER_MAX_DISTANCE = 10;
	    var HIT_TYPE_NAVBUTTON = 'navButton', HIT_TYPE_SHEETTAB = 'sheetTab';
	
	
	    function sR() {
	        return Common._getResource(exports.SR)();
	    }
	
	    function triggerSheetTabClick(spread, sheet, sheetTabIndex) {
	        spread._trigger(Events.SheetTabClick, {
	            sheet: sheet,
	            sheetName: sheet ? sheet.name() : keyword_null,
	            sheetTabIndex: isNullOrUndefined(sheetTabIndex) ? -1 : sheetTabIndex
	        });
	    }
	
	    function triggerSheetMoving(spread, data) {
	        spread._trigger(Events.SheetMoving, data);
	    }
	
	    function triggerSheetMoved(spread, sheet, oldIndex, newIndex) {
	        spread._trigger(Events.SheetMoved, {
	            sheet: sheet,
	            sheetName: sheet ? sheet.name() : keyword_null,
	            oldIndex: oldIndex,
	            newIndex: newIndex
	        });
	    }
	
	    function SheetTabBase(name) {
	        var self = this;
	        self._workbook = keyword_null;
	        self._activeIndex = 0;
	        self._firstTab = 0;
	        self._activePos = 70;
	        self._hoverNavButton = -1;
	        self._hoverTab = -1;
	        self._font = '';
	        self._tabSizes = [];
	        self._targetTabIndex = -1;
	        self._sourceTabIndex = -1;
	        self._reorderSpeedTimeout = keyword_null;
	        self._paintSuspended = 0;
	
	        self._setBounds(new Rect(0, 0, 200, 28));
	        self._name = name;
	    }
	
	    util_common._defineFeature(SheetTabBase);
	    SheetTabBase.prototype = {
	       
	        _setHost: function (host) {
	            var self = this;
	            var oldCanvas = self._canvas;
	            if (oldCanvas) {
	                self._dispose(true);
	            }
	
	            var canvas = createElement(tag_canvas);
	            _DPIHelper._adjustDevicePixel(canvas, self._workbook);
	            canvas.setAttribute('id', self._name);
	            self._tabIndicator = self._getTabIndicator();
	            host.appendChild(self._tabIndicator[0]);
	            host.appendChild(canvas);
	            self._canvas = canvas;
	            $$(canvas).bind(gcTab_mousedown, function (e) {
	                return self._doMouseDown(e);
	            })
	                .bind(gcTab_mousemove, function (e) {
	                    return self._doMouseMove(e);
	                })
	                .bind(gcTab_mouseup, function (e) {
	                    return self._doMouseUp(e);
	                })
	                .bind(gcTab_mouseout, function (e) {
	                    return self._doMouseOut(e);
	                })
	                .bind(gcTab_dbclick, function (e) {
	                    return self._doMouseDbClick(e);
	                });
	            self._doResize();
	
	            SheetTabBase._callFeatureHandler(self, 'setHost');
	        },
	        _setOwner: function (owner) {
	            var self = this, font = owner.options.font;
	            self._workbook = owner;
	            if (owner && font && font.length > 0) {
	                self._font = font;
	            }
	        },
	        _getBounds: function () {
	            var bounds = this._bounds;
	            return new Rect(bounds.x, bounds.y, bounds.width, bounds.height);
	        },
	        _setBounds: function (rect) {
	           
	            var bounds = this._bounds = new Rect(0, 0, 0, 0);
	            bounds.x = rect.x;
	            bounds.y = rect.y;
	            bounds.width = rect.width;
	            bounds.height = rect.height;
	        },
	        _getNewTabSize: function () {
	            return this._newTabSize;
	        },
	        _getTabEndPosition: function () {
	            var rect = this._getBounds();
	            return rect.x + rect.width - this._resizeBarWidth;
	        },
	        _getTabStartPosition: function () {
	            return 0;
	        },
	        _doResize: function () {
	           
	            var self = this;
	            var canvas = self._getCanvas();
	            if (!canvas || !canvas.parentNode) {
	                return;
	            }
	            var $parent = $$(canvas.parentNode);
	            if ($parent.width() === 0 || $parent.height() === 0) {
	                return;
	            }
	            var width = Math_max($parent.width(), 0), height = Math_max($parent.height(), 0);
	            canvas.style.display = cssNone;
	            canvas.width = width;
	            canvas.height = height;
	            canvas.style.display = '';
	            canvas.style.width = width + pixel;
	            canvas.style.height = height + pixel;
	            width = canvas.clientWidth || canvas.width;
	            height = canvas.clientHeight || canvas.height;
	            var oldBounds = self._getBounds();
	            self._setBounds(new Rect(oldBounds.x, oldBounds.y, width, height));
	            _DPIHelper._setSize(canvas, width, height);
	            self.repaint();
	        },
	        _isCoverSheetTab: function () {
	            return false;
	        },
	        _getCoverPosition: function () {
	            return 0;
	        },
	        _getInputTopPosition: function () {
	            return 0;
	        },
	        _getTabIndicatorEdgeElements: function () {
	            return [];
	        },
	        _getBasicWidth: function () {
	            return 0;
	        },
	        _getTabIndicator: function () {
	            var TRANSPARENT = 'transparent';
	            return $$(createElement('div')).css({
	                'position': 'absolute',
	                'border-style': 'solid',
	                'border-color': color_black,
	                'border-width': TAB_INDICATOR_HEIGHT + pixel,
	                'display': 'none',
	                'width': 0,
	                'border-bottom': 0,
	                'border-left-color': TRANSPARENT,
	                'border-right-color': TRANSPARENT
	            });
	        },
	       
	        _dispose: function (keepWorkbook) {
	            var self = this;
	            var canvas = self._canvas, parentNode;
	            if (canvas) {
	                parentNode = canvas.parentNode;
	                $$(canvas).unbind(gcTab_mousedown).unbind(gcTab_mousemove).unbind(gcTab_mouseup).unbind(gcTab_dbclick).unbind(gcTab_mouseout);
	                if (parentNode) {
	                    parentNode.removeChild(canvas);
	                }
	            }
	            $$(self._tabIndicator).remove();
	
	            SheetTabBase._callFeatureHandler(self, 'dispose');
	
	            if (!keepWorkbook) {
	                self._workbook = keyword_null;
	            }
	        },
	        hitTest: function (left, top) { 
	            var self = this;
	            var workbook = self._workbook;
	            var rect = self._getBounds();
	           
	            var resizeBarRect = self.getResizeBarBounds();
	            if (workbook.options.showHorizontalScrollbar && left > resizeBarRect.x && left < rect.x + rect.width) {
	                return {type: "resize", 'element': hit_element_resize};
	            }
	           
	           
	           
	            var navButtonRect = self.getNavButtonBounds();
	            var navButton = -1;
	            var startIndex = navButtonRect.startIndex;
	            var x = navButtonRect.x;
	            var endIndex = navButtonRect.endIndex;
	            var navbuttonStr = ["first", "prevArrow", "nextArrow", "last", "", "prevButton", "nextButton"];
	            for (var i = startIndex; i < endIndex; i++) {
	                if (x < left && left < x + navButtonRect.width) {
	                    navButton = i;
	                    hit_element_navButton = navbuttonStr[i];
	                    break;
	                }
	                x += navButtonRect.width;
	            }
	            if (navButton !== -1) {
	                return {
	                    type: HIT_TYPE_NAVBUTTON,
	                    'element': hit_element_navButton,
	                    'index': i
	                };
	            }
	           
	           
	            var preMoreTabRect = self.getPreMoreTabBounds();
	            x = preMoreTabRect.x;
	            var step = 0;
	
	            var preTabIndex = self._getPreVisibleIndex(self._firstTab);
	            if (preTabIndex !== -1) {
	                if (x <= left && left < x + preMoreTabRect.width) {
	                    hit_element_navButton = navbuttonStr[5];
	                    return {
	                        type: HIT_TYPE_NAVBUTTON,
	                        'element': hit_element_navButton,
	                        'index': 5,
	                        position: x
	                    };
	                }
	                step = self._firstTabSpace;
	            }
	           
	            var sheetTabRect = self.getSheetTabBounds();
	            var sheets = workbook.sheets, tabSizes = self._tabSizes, tabSpace = self._tabSpace;
	            var tabSize = 0;
	            x = sheetTabRect.x + step;
	            if (self._firstTab > -1) {
	                for (i = self._firstTab; i < sheets.length && i < tabSizes.length; i++) {
	                    if (sheets[i].visible()) {
	                        tabSize = tabSizes[i];
	                        if (x < left && left < x + tabSize + tabSpace) {
	                            if (sheetTabRect.moreTabPos > 0 && left < sheetTabRect.moreTabPos) {
	                                return {type: HIT_TYPE_SHEETTAB, element: hit_element_tab, index: i, position: x};
	                            } else if (sheetTabRect.moreTabPos === 0) {
	                                return {type: HIT_TYPE_SHEETTAB, element: hit_element_tab, index: i, position: x};
	                            }
	
	                        }
	                        x += (tabSize + tabSpace);
	                    }
	                }
	            }
	           
	           
	            if (x > sheetTabRect.moreTabPos && sheetTabRect.moreTabPos > 0) {
	                x = sheetTabRect.moreTabPos;
	            }
	            if (self._reCalculateFirstTabIndex(self._getVisibleTabs()) !== -1) {
	                if (x < left && left < x + sheetTabRect.secondMoreTabWidth) {
	                    hit_element_navButton = navbuttonStr[6];
	                    return {
	                        type: HIT_TYPE_NAVBUTTON,
	                        'element': hit_element_navButton,
	                        'index': 6,
	                        position: x
	                    };
	                }
	            } else if (x < left && left < x + sheetTabRect.secondMoreTabWidth) {
	                return {
	                    'element': hit_element_blank,
	                    position: x
	                };
	            }
	            x += sheetTabRect.secondMoreTabWidth;
	           
	           
	            if (workbook.options.newTabVisible && x < left && left < x + self._getNewTabSize()) {
	                return {
	                    type: HIT_TYPE_SHEETTAB,
	                    'element': hit_element_newSheet,
	                    'position': x,
	                    index: -1
	                };
	            }
	            return {
	                'element': hit_element_blank
	            };
	        },
	        _doMouseDown: function (e) {
	           
	            var self = this;
	
	            var argObj = {e: e, r: keyword_null}, returnValue;
	            SheetTabBase._callFeatureHandler(self, 'preProcessMouseDown', argObj);
	            returnValue = argObj.r;
	            if (!isNullOrUndefined(returnValue)) {
	                return returnValue;
	            }
	
	            var t = $$(self._getCanvas()).offset();
	            var left = e.pageX - t.left;
	            var top = e.pageY - t.top;
	            var activeSheet = self._workbook.getActiveSheet();
	            if (self._tabNameEditor) {
	               
	                self._endSheetTabEditing(activeSheet, false);
	            }
	            var hitTestInfo = self.hitTest(left, top);
	            var hitTestInfo_element = hitTestInfo.element;
	            if (e.button === 0) {
	                if (hitTestInfo_element === hit_element_resize) {
	                    self._resizeTab = true;
	                    self._activeX = e.pageX;
	                    self._handleDocumentMouseMove();
	                } else if (hitTestInfo_element === hit_element_navButton) {
	                    self._doNavButtonClick(hitTestInfo.index);
	                } else if (hitTestInfo_element === hit_element_tab) {
	                    self._doSheetTabClick(hitTestInfo.index, hitTestInfo.position);
	                    self._initTabReorder(e, hitTestInfo);
	                } else if (hitTestInfo_element === hit_element_newSheet) {
	                    self._doNewTabClick(hitTestInfo.position);
	                }
	                activeSheet = self._workbook.getActiveSheet();
	                var eventHandler = activeSheet && activeSheet._eventHandler;
	                if (eventHandler && !activeSheet.isEditing()) {
	                    activeSheet._setFocus();
	                }
	            }
	            self._isMouseDownInTab = true;
	            return false;
	        },
	        _doMouseMove: function (e) {
	           
	            var self = this;
	
	            var argObj = {e: e, r: keyword_null}, returnValue;
	            SheetTabBase._callFeatureHandler(self, 'preProcessMouseMove', argObj);
	            returnValue = argObj.r;
	            if (!isNullOrUndefined(returnValue)) {
	                return returnValue;
	            }
	
	            var canvasStyle = self._canvas.style;
	            var cursor_default = 'default', cursor_wresize = 'w-resize';
	            if (self._tabStartPos && !self._reorderSheet) {
	                var mousemoveDistance = Math.sqrt(Math_pow(self._tabStartPos.x - e.pageX, 2) + Math_pow(self._tabStartPos.y - e.pageY, 2));
	                if (mousemoveDistance > REORDER_MAX_DISTANCE) {
	                    self._reorderSheet = true;
	                }
	            }
	            if (self._resizeTab) {
	                canvasStyle.cursor = cursor_wresize;
	                var d = e.pageX - self._activeX;
	                var totalWidth = self._workbook._vp.clientWidth;
	                var ss = self._workbook;
	                ss.options.tabStripRatio = ss._getActualTabStripRatio() + d / totalWidth;
	                var minRatio = self._resizeBarWidth / totalWidth;
	                var maxRatio = 1;
	                if (ss._getActualTabStripRatio() < minRatio) {
	                    ss.options.tabStripRatio = minRatio;
	                    self._activeX = self._resizeBarWidth;
	                } else if (ss._getActualTabStripRatio() >= maxRatio) {
	                    ss.options.tabStripRatio = maxRatio;
	                    self._activeX = totalWidth;
	                } else {
	                    self._activeX = e.pageX;
	                }
	
	                ss._doTabHSResize();
	            } else if (self._reorderSheet) {
	                self._showTabTip(e.pageX, e.pageY);
	                self._setTabIndicator(e);
	            } else {
	                self._hoverNavButton = -1;
	                self._hoverTab = -1;
	                var t = $$(self._getCanvas()).offset();
	                var left = e.pageX - t.left;
	                var top = e.pageY - t.top;
	                var hitTestInfo = self.hitTest(left, top);
	                var hitTestInfo_element = hitTestInfo.element;
	                if (hitTestInfo_element === '') {
	                    canvasStyle.cursor = cursor_default;
	                    self.repaint();
	                    return false;
	                } else if (hitTestInfo_element === hit_element_resize) {
	                    canvasStyle.cursor = cursor_wresize;
	                } else {
	                    canvasStyle.cursor = cursor_default;
	                    if (hitTestInfo_element === hit_element_navButton) {
	                        self._hoverNavButton = hitTestInfo.index;
	                    } else if (hitTestInfo_element === hit_element_tab) {
	                        self._hoverTab = hitTestInfo.index;
	                    } else if (hitTestInfo_element === hit_element_newSheet) {
	                        self._hoverTab = -2;
	                    }
	                }
	                self.repaint();
	            }
	            return false;
	        },
	        _doMouseUp: function (e) {
	           
	            var self = this;
	
	            var argObj = {e: e, r: keyword_null}, returnValue;
	            SheetTabBase._callFeatureHandler(self, 'preProcessMouseUp', argObj);
	            returnValue = argObj.r;
	            if (!isNullOrUndefined(returnValue)) {
	                return returnValue;
	            }
	
	            if (self._resizeTab) {
	                self._resizeTab = false;
	                self._workbook._doTabHSResize();
	            }
	            self._clearSpeedTimeout();
	            if (self._reorderSheet) {
	                self._reorderSheet = false;
	                self._tabTip.remove();
	                self._reorderTab();
	                self._tabIndicator.hide();
	            }
	            self._tabStartPos = keyword_null;
	            self._clearRepeatDown();
	            self._unhandleDocumentMouseMove();
	           
	            if (!self._isMouseDownInTab) {
	                return true;
	            }
	            self._isMouseDownInTab = false;
	            return false;
	        },
	        _doMouseOut: function (e) {
	            var self = this;
	
	            var argObj = {e: e, r: keyword_null}, returnValue;
	            SheetTabBase._callFeatureHandler(self, 'preProcessMouseOut', argObj);
	            returnValue = argObj.r;
	            if (!isNullOrUndefined(returnValue)) {
	                return returnValue;
	            }
	
	            self._clearRepeatDown();
	            var oldNav = self._hoverNavButton;
	            self._hoverNavButton = -1;
	            var oldTab = self._hoverTab;
	            self._hoverTab = -1;
	            if (self._hoverNavButton !== oldNav || self._hoverTab !== oldTab) {
	                self.repaint();
	            }
	            return false;
	        },
	        _handleDocumentMouseMove: function () {
	           
	            var self = this;
	            if (!self._isCapture) {
	                $$(DOCUMENT).bind(spliter_mousemove, function (e) {
	                    self._doMouseMove(e);
	                }).bind(spliter_mouseup, function (e) {
	                    self._doMouseUp(e);
	                });
	                var sheet = self._workbook.getActiveSheet();
	                if (sheet) {
	                    sheet._continueMouseUpBubble = true;
	                }
	                self._isCapture = true;
	            }
	        },
	        _unhandleDocumentMouseMove: function () {
	           
	            if (this._isCapture) {
	                this._isCapture = false;
	                $$(DOCUMENT).unbind(spliter_mousemove).unbind(spliter_mouseup);
	                var sheet = this._workbook.getActiveSheet();
	                if (sheet) {
	                    delete sheet._continueMouseUpBubble;
	                }
	            }
	        },
	        _doNavButtonClick: function (btnClicked, ignoreRepeat) {
	            var self = this;
	            self._clearRepeatDown();
	            var visibleTabs = self._getVisibleTabs();
	            if (visibleTabs.length <= 0) {
	                return;
	            }
	            var repeatClickIntevel = 200;
	            btnClicked = btnClicked % 4;
	            if (btnClicked === 0) {
	               
	                self._navigateToFirst(visibleTabs);
	
	            } else if (btnClicked === 1) {
	               
	                if (!ignoreRepeat) {
	                    self._repeatDown = setTimeout(function () {
	                        self._doNavButtonClick(1);
	                    }, repeatClickIntevel);
	                }
	                self._navigateToPrevious(visibleTabs);
	            } else if (btnClicked === 2) {
	               
	                if (!ignoreRepeat) {
	                    self._repeatDown = setTimeout(function () {
	                        self._doNavButtonClick(2);
	                    }, repeatClickIntevel);
	                }
	                self._navigateToNext(visibleTabs);
	            } else if (btnClicked === 3) {
	               
	                self._navigateToLast(visibleTabs);
	            }
	        },
	        _doSheetTabClick: function (index, position) {
	            var self = this, workbook = self._workbook;
	
	            self._activeIndex = index;
	            self._activePos = position;
	            workbook.suspendPaint();
	            var activeSheet = workbook.getActiveSheet();
	            var sheet = workbook.getSheet(index);
	            if (sheet && sheet.isEditing() && sheet !== activeSheet) {
	                var ignoreFormulaTextBox = activeSheet && activeSheet._formulaTextBox && activeSheet._formulaTextBox._isSelectMode;
	                if (!sheet._endEditImp(undefined, undefined, ignoreFormulaTextBox)) {
	                    return;
	                }
	            }
	            triggerSheetTabClick(workbook, sheet, index);
	            self._doSheetTabClickChange(index);
	            workbook.resumePaint();
	            self.repaint();
	        },
	        _doNewTabClick: function (position) {
	            var self = this;
	
	            var workbook = self._workbook;
	            var activeSheet = workbook.getActiveSheet();
	            if (self._canCreateNewTab && !self._canCreateNewTab(activeSheet)) {
	                return;
	            }
	            triggerSheetTabClick(workbook, keyword_null, keyword_null);
	            var index = workbook.sheets.length;
	            var sheet = workbook._createSheet(workbook._getDefaultSheetName(index));
	            workbook._addSheetImp(index, 1 , sheet);
	            self._activeIndex = index;
	            self._activePos = position;
	            workbook._setActiveSheetIndexImp(index, 1 , false, true);
	            while (self._activeIndex > self._firstTab && (self._isCoverSheetTab() || self._firstTab < self._getNextVisibleIndex(-1))) {
	                if (self._tabVisible(self._firstTab)) {
	                    self._activePos -= self._tabSizes[self._firstTab];
	                }
	                self._firstTab++;
	            }
	            self.repaint();
	        },
	        _doSheetTabClickChange: function (index, saveValue) {
	            if (saveValue === void 0) {
	                saveValue = true;
	            }
	            var self = this, workbook = self._workbook;
	            var activeSheet = workbook.getActiveSheet();
	            var doNotGetCellTypeFocus = false;
	            if (activeSheet && activeSheet._formulaTextBox && activeSheet._formulaTextBox._isSelectMode) {
	                doNotGetCellTypeFocus = true;
	            }
	            if (index !== workbook._activeSheetIndex) {
	                workbook._setActiveSheetIndexImp(index, 1 , doNotGetCellTypeFocus, true);
	                var nextIndex = self._getNextVisibleIndex(self._firstTab);
	                if (self._activeIndex > self._firstTab && self._activePos + self._tabSizes[self._activeIndex] > self._getCoverPosition() && nextIndex !== -1) {
	                    self._firstTab = nextIndex;
	                }
	            }
	            if (self._activeIndex < self._firstTab) {
	                self._firstTab = self._getPreVisibleIndex(self._firstTab);
	            }
	        },
	        _doMouseDbClickImp: function (left, top) {
	           
	            var self = this, workbook = self._workbook;
	            var hitTestInfo = self.hitTest(left, top);
	            if (hitTestInfo.element === hit_element_tab) {
	               
	                var tabIndex = self._activeIndex;
	                var currentSheet = workbook.sheets[tabIndex];
	               
	                if (hitTestInfo.index !== tabIndex) {
	                    return;
	                }
	                workbook._trigger(Events.SheetTabDoubleClick, {
	                    sheet: currentSheet,
	                    sheetName: currentSheet.name(),
	                    sheetTabIndex: tabIndex
	                });
	                if (!workbook.options.tabEditable) {
	                    return false;
	                }
	               
	               
	                var element = _FocusHelper._getActiveElement();
	                if (element && element.endEdit && !element.endEdit()) {
	                    return;
	                }
	                _FocusHelper._setActiveElement(keyword_null);
	                var currentTabSize = self._tabSizes[tabIndex];
	                var canvasOffset = $$(self._getCanvas()).offset();
	                var container = workbook._getContainerDiv(), containerOffset = $$(container).offset();
	                var t = createElement('input'), tStyle = t.style;
	                t.type = 'text';
	                t.value = currentSheet.name();
	                t.setAttribute('contentEditable', 'true');
	                t.setAttribute('autocomplete', 'off');
	                tStyle.position = 'absolute';
	                tStyle.margin = 0;
	                tStyle.padding = 0;
	                tStyle.left = canvasOffset.left - containerOffset.left + self._activePos + self._tabLeftPadding + pixel;
	                tStyle.top = canvasOffset.top - containerOffset.top + self._getInputTopPosition() + pixel;
	                tStyle.width = currentTabSize - self._tabLeftPadding - self._tabRightPadding + 2 + pixel;
	                tStyle.backgroundColor = color_white;
	                tStyle.borderWidth = '0px';
	                tStyle.outline = cssNone;
	                $$(t).appendTo(container);
	                self._tabNameEditor = t;
	                $$(t).addClass('gc-sheetTabEditor').bind(tabNameEditor_keydown, function (e) {
	                    if (e.keyCode === 13 ) {
	                        self._endSheetTabEditing(currentSheet, false);
	                        return false;
	                    } else if (e.keyCode === 27 ) {
	                        self._endSheetTabEditing(currentSheet, true);
	                        return false;
	                    }
	                }).bind(tabNameEditor_focus, function () {
	                    t.selectionStart = 0;
	                    t.selectionEnd = t.value.length;
	                }).bind(tabNameEditor_blur, function () {
	                    self._endSheetTabEditing(currentSheet, false);
	                });
	                t.focus();
	            }
	            return false;
	        },
	        _doMouseDbClick: function (e) {
	            var self = this;
	
	            var argObj = {e: e, r: keyword_null}, returnValue;
	            SheetTabBase._callFeatureHandler(self, 'preProcessMouseDbClick', argObj);
	            returnValue = argObj.r;
	            if (!isNullOrUndefined(returnValue)) {
	                return returnValue;
	            }
	
	            var offset = $$(self._getCanvas()).offset();
	            var left = e.pageX - offset.left;
	            var top = e.pageY - offset.top;
	            return self._doMouseDbClickImp(left, top);
	        },
	       
	       
	        _endSheetTabEditing: function (sheet, cancel) {
	           
	            var self = this, tabNameEditor = self._tabNameEditor;
	            if (tabNameEditor) {
	                $$(tabNameEditor).unbind(tabNameEditor_keydown).unbind(tabNameEditor_focus).unbind(tabNameEditor_blur);
	                var newName = tabNameEditor.value;
	                if (cancel === false) {
	                    var oldName = sheet.name();
	                    if (newName !== oldName) {
	                        if (!isNullOrUndefined(newName) && newName !== '' && isValidSheetName(newName, self._workbook.sheets, sheet)) {
	                            var args = {
	                                sheet: sheet,
	                                oldValue: oldName,
	                                newValue: newName,
	                                cancel: false
	                            };
	                            sheet._trigger(Events.SheetNameChanging, args);
	                            if (args.cancel === false) {
	                                sheet._commandManager().execute({
	                                    cmd: 'renameSheet',
	                                    sheetName: oldName,
	                                    name: newName
	                                });
	                                var argsEdited = {
	                                    sheet: sheet,
	                                    oldValue: oldName,
	                                    newValue: newName
	                                };
	                                sheet._trigger(Events.SheetNameChanged, argsEdited);
	                            }
	                        } else {
	                            sheet._trigger(Events.InvalidOperation, {
	                                sheet: sheet,
	                                sheetName: sheet.name(),
	                                invalidType: 5 ,
	                                message: sR().Exp_SheetNameInvalid
	                            });
	                        }
	                    }
	                }
	                tabNameEditor.parentNode.removeChild(tabNameEditor);
	                delete self._tabNameEditor;
	            }
	        },
	        _allowSheetReorder: function () {
	            return this._workbook.options.allowSheetReorder;
	        },
	        _initTabReorder: function (e, hitTestInfo) {
	            var self = this;
	            if (self._allowSheetReorder()) {
	                self._sourceTabIndex = hitTestInfo.index;
	                self._tabTip = self._getTabTip(self._sourceTabIndex);
	                self._tabStartPos = new util_common.Point(e.pageX, e.pageY);
	                self._handleDocumentMouseMove();
	            } else {
	                self._reorderSheet = false;
	            }
	        },
	        _getTabTip: function (index) {
	            var sheets = this._workbook.sheets;
	            var len = sheets.length;
	            if (index >= len || index < 0) {
	                return;
	            }
	            var name = sheets[index].name();
	            if (!name) {
	                name = 'sheet';
	            }
	            var tip = $$(createElement('span')).text(name).css({
	                'position': 'absolute',
	                'cursor': 'default',
	                'border-radius': '5px',
	                'opacity': '.7'
	            });
	            tip.addClass('ui-widget-header gc-tab-tip-span btn-primary');
	            return tip;
	        },
	        _clearRepeatDown: function () {
	            var repeatDown = this._repeatDown;
	            if (repeatDown) {
	                clearTimeout(repeatDown);
	                this._repeatDown = keyword_null;
	            }
	        },
	        _showTabTip: function (x, y) {
	            var self = this;
	            var tip = self._tabTip;
	            if (tip && $$('.gc-tab-tip-span').length === 0) {
	                tip.appendTo(DOCUMENT.body);
	                tip.hide();
	            }
	            var tipWidth = tip.width();
	            var tipHeight = tip.height();
	            tip.css({
	                'left': x - tipWidth / 2,
	                'top': y - tipHeight / 2
	            });
	            tip.show();
	        },
	        _setTabIndicator: function (e) {
	            var self = this;
	            var $canvas = $$(self._getCanvas());
	            var t = $canvas.position();
	            var offset = $canvas.offset();
	            var left = e.pageX - offset.left, top = e.pageY - offset.top;
	            var hitTestInfo = self.hitTest(left, top);
	            var hitTestInfo_element = hitTestInfo.element;
	            var rect = self._getBounds();
	            var tabStartPosition = self._getTabStartPosition();
	            var sheetLength = self._workbook.sheets.length;
	            var timeInterval = 100;
	            var tabEndPosition = rect.x + self._getCoverPosition();
	
	            var indicator = self._tabIndicator;
	            if (left > tabEndPosition) {
	                if (self._reorderSpeedTimeout === keyword_null && self._targetTabIndex < sheetLength) {
	                    self._reorderSpeedTimeout = setInterval(function () {
	                        self._navigateToNext(self._getVisibleTabs());
	                        if (self._targetTabIndex === sheetLength) {
	                            self._clearSpeedTimeout();
	                            indicator.css({
	                                'left': t.left + self._getLastTabPos() - TAB_INDICATOR_HEIGHT,
	                                'top': t.top - TAB_INDICATOR_HEIGHT
	                            });
	                            indicator.show();
	                        } else {
	                            self._targetTabIndex++;
	                            indicator.hide();
	                        }
	                    }, timeInterval);
	                }
	            } else if (left < tabStartPosition) {
	                if (self._reorderSpeedTimeout === keyword_null && self._targetTabIndex > 0) {
	                    self._reorderSpeedTimeout = setInterval(function () {
	                        self._navigateToPrevious(self._getVisibleTabs());
	                        if (self._targetTabIndex === 0) {
	                            self._clearSpeedTimeout();
	                            indicator.css({
	                                'left': t.left + tabStartPosition - TAB_INDICATOR_HEIGHT,
	                                'top': t.top - TAB_INDICATOR_HEIGHT
	                            });
	                            indicator.show();
	                        } else {
	                            self._targetTabIndex--;
	                            indicator.hide();
	                        }
	                    }, timeInterval);
	                }
	            } else {
	                self._clearSpeedTimeout();
	                if (hitTestInfo_element === hit_element_tab || self._getTabIndicatorEdgeElements().indexOf(hitTestInfo_element) !== -1) {
	                    if (hitTestInfo_element === hit_element_tab && !isNullOrUndefined(hitTestInfo.index)) {
	                        self._targetTabIndex = hitTestInfo.index;
	                    } else {
	                        self._targetTabIndex = self._workbook.sheets.length;
	                    }
	                    indicator.css({
	                        'left': t.left + hitTestInfo.position - TAB_INDICATOR_HEIGHT,
	                        'top': t.top - TAB_INDICATOR_HEIGHT
	                    });
	                    indicator.show();
	                }
	            }
	        },
	        _getLastTabPos: function () {
	            var self = this;
	            var tabsWidth = self._tabSizes;
	            var visibleTabs = self._getVisibleTabs();
	            var startIndex = self._getVisibleTabIndex(self._firstTab, visibleTabs);
	            var index = 0;
	            var tabSumWidth = self._getTabStartPosition() + self._firstTabSpace;
	            for (var i = startIndex; i < visibleTabs.length; i++) {
	                index = visibleTabs[i];
	                tabSumWidth += tabsWidth[index];
	                tabSumWidth += self._tabSpace;
	            }
	            return tabSumWidth;
	        },
	        _clearSpeedTimeout: function () {
	            var reorderSpeedTimeout = this._reorderSpeedTimeout;
	            if (reorderSpeedTimeout) {
	                clearInterval(reorderSpeedTimeout);
	                this._reorderSpeedTimeout = keyword_null;
	            }
	        },
	        _reorderTab: function () {
	            var self = this, workbook = self._workbook;
	            var tarIndex = self._targetTabIndex;
	            var sourIndex = self._sourceTabIndex;
	            var activeSheetIndex = -1;
	            var sheet = workbook.getActiveSheet();
	            var oldIndex = sourIndex, newIndex = tarIndex;
	            if (sourIndex < tarIndex - 1) {
	                newIndex = tarIndex - 1;
	            }
	            if (tarIndex !== -1 && sourIndex !== -1 && sourIndex !== tarIndex
	                && sourIndex !== tarIndex - 1 && self._tabIndicator.isVisible()) {
	                var sheetMovingData = {
	                    sheet: sheet,
	                    sheetName: sheet.name(),
	                    oldIndex: oldIndex,
	                    newIndex: newIndex,
	                    cancel: false
	                };
	                triggerSheetMoving(workbook, sheetMovingData);
	                if (sheetMovingData.cancel) {
	                    return;
	                }
	                var sheets = workbook.sheets, i;
	                var sourceSheet = sheets[sourIndex];
	                if (sourIndex > tarIndex) {
	                    for (i = sourIndex; i > tarIndex; i--) {
	                        sheets[i] = sheets[i - 1];
	                    }
	                    sheets[tarIndex] = sourceSheet;
	                    activeSheetIndex = tarIndex;
	                } else if (sourIndex < tarIndex - 1) {
	                    for (i = sourIndex; i < tarIndex - 1; i++) {
	                        sheets[i] = sheets[i + 1];
	                    }
	                    sheets[tarIndex - 1] = sourceSheet;
	                    activeSheetIndex = tarIndex - 1;
	                }
	                workbook._activeSheetIndex = activeSheetIndex;
	                self._doResize();
	                triggerSheetMoved(workbook, sheet, oldIndex, newIndex);
	            }
	        },
	        _getVisibleTabs: function () {
	            var visibleTabs = [], index;
	            for (index = 0; index < this._workbook.sheets.length; index++) {
	                if (this._tabVisible(index)) {
	                    visibleTabs.push(index);
	                }
	            }
	            return visibleTabs;
	        },
	       
	        _navigateToFirst: function (visibleTabs) {
	            if (visibleTabs.length > 0 && this._firstTab !== visibleTabs[0]) {
	                this._workbook.startSheetIndex(visibleTabs[0]);
	            }
	        },
	       
	        _navigateToPrevious: function (visibleTabs) {
	            if (visibleTabs.length > 0) {
	                var self = this;
	                if (self._firstTab > visibleTabs[0]) {
	                    var preVisibleIndex = self._getPreVisibleIndex(self._firstTab);
	                    if (preVisibleIndex !== -1) {
	                        self._workbook.startSheetIndex(preVisibleIndex);
	                    }
	                }
	            }
	        },
	       
	        _navigateToNext: function (visibleTabs) {
	            if (visibleTabs.length > 0) {
	                var self = this;
	                if (self._firstTab < visibleTabs[visibleTabs.length - 1]) {
	                    var currTabIndex = self._reCalculateFirstTabIndex(visibleTabs);
	                    if (currTabIndex !== -1) {
	                        self._workbook.startSheetIndex(self._getNextVisibleIndex(self._firstTab));
	                    }
	                }
	            }
	        },
	       
	        _navigateToLast: function (visibleTabs) {
	            if (visibleTabs.length > 0 && this._firstTab < visibleTabs[visibleTabs.length - 1]) {
	                var currTabIndex = this._reCalculateFirstTabIndex(visibleTabs);
	                if (currTabIndex !== -1) {
	                    this._workbook.startSheetIndex(currTabIndex);
	                }
	            }
	        },
	       
	       
	       
	        _reCalculateFirstTabIndex: function (visibleTabs) {
	            if (visibleTabs.length > 0) {
	                var self = this;
	                var availableWidth = self._getCoverPosition();
	                var tabSumWidth = 0;
	                var tabsWidth = self._tabSizes, i, index;
	                var basicWidth = self._getBasicWidth();
	                var startIndex = self._getVisibleTabIndex(self._firstTab, visibleTabs);
	                if (startIndex === -1) {
	                    startIndex = 0;
	                }
	                for (i = visibleTabs.length - 1; i >= startIndex; i--) {
	                    index = visibleTabs[i];
	                    var itemWidth = tabsWidth[index];
	                    tabSumWidth += itemWidth;
	                    if (i !== visibleTabs.length - 1) {
	                        tabSumWidth += self._tabSpace;
	                    }
	                   
	                    var totalWidth = basicWidth + tabSumWidth;
	                    if (i !== 0) {
	                        totalWidth += self._firstTabSpace;
	                    }
	                   
	                    if (totalWidth > availableWidth) {
	                        var currIndex;
	                        if (i + 1 < visibleTabs.length) {
	                            currIndex = visibleTabs[i + 1];
	                        } else {
	                            currIndex = visibleTabs[visibleTabs.length - 1];
	                        }
	                        if (self._firstTab < currIndex) {
	                            return currIndex;
	                        }
	                        return -1;
	                    }
	                }
	            }
	            return -1;
	        },
	        _getPreVisibleIndex: function (tabIndex) {
	            var index;
	            for (index = tabIndex - 1; index >= 0; index--) {
	                if (this._tabVisible(index)) {
	                    return index;
	                }
	            }
	            return -1;
	        },
	        _getNextVisibleIndex: function (tabIndex) {
	            var tabCount = this._workbook.sheets.length;
	            var index;
	            for (index = tabIndex + 1; index < tabCount; index++) {
	                if (this._tabVisible(index)) {
	                    return index;
	                }
	            }
	            return -1;
	        },
	        _getVisibleTabIndex: function (tabIndex, visibleTabs) {
	            var index;
	            for (index = 0; index <= visibleTabs.length - 1; index++) {
	                if (tabIndex === visibleTabs[index]) {
	                    return index;
	                }
	            }
	            return -1;
	        },
	        _tabVisible: function (tabIndex) {
	            var sheet = this._workbook.sheets[tabIndex];
	            return sheet && sheet.visible();
	        },
	       
	       
	        _suspendPaint: function () {
	            this._paintSuspended++;
	        },
	        _resumePaint: function () {
	            var self = this;
	            self._paintSuspended--;
	            if (self._paintSuspended <= 0) {
	                self._paintSuspended = 0;
	                self.repaint();
	            }
	        },
	        repaint: function (clipRect) {
	           
	            var c = this._getCanvas();
	            if (c && c.getContext) {
	                this._paint(c.getContext(str_2d), clipRect);
	            }
	        },
	        _paint: function (ctx, clipRect) {
	            var self = this;
	            if (self._paintSuspended > 0) {
	                return;
	            }
	           
	            var rect = self._getBounds(), canvas = self._canvas;
	            if (clipRect) {
	                if (clipRect.x >= rect.x + rect.width) {
	                    return;
	                }
	                if (clipRect.y >= rect.y + rect.height) {
	                    return;
	                }
	                if (clipRect.x + clipRect.width > rect.width) {
	                    clipRect.width = rect.width - clipRect.x;
	                    if (clipRect.width <= 0) {
	                        return;
	                    }
	                }
	                if (clipRect.y + clipRect.height > rect.height) {
	                    clipRect.height = rect.height - clipRect.y;
	                    if (clipRect.height <= 0) {
	                        return;
	                    }
	                }
	                if (clipRect.width <= 0 || clipRect.height <= 0) {
	                    return;
	                }
	            }
	            var bufferCtx;
	            var buffer = self.buffer;
	            if (!buffer || buffer && (buffer.width !== canvas.width || buffer.height !== canvas.height) || !buffer && (buffer.width !== rect.width || buffer.height !== rect.height)) {
	                if (buffer) {
	                    _DPIHelper._disposeCanvasForSpread(self._workbook, buffer);
	                }
	                self.buffer = buffer = createElement(tag_canvas);
	                _DPIHelper._adjustDevicePixel(buffer, self._workbook);
	                _DPIHelper._setSize(buffer, rect.width, rect.height);
	            }
	
	            if (rect.width <= 0 || rect.height <= 0 || clipRect && (clipRect.width <= 0 || clipRect.height <= 0)) {
	                return;
	            }
	            bufferCtx = self.buffer.getContext(str_2d);
	            bufferCtx.clearRect(0, 0, rect.width, rect.height);
	            CanvasHelper._translate(bufferCtx, -rect.x, -rect.y);
	            self._paintTabs(bufferCtx, clipRect);
	            CanvasHelper._translate(bufferCtx, rect.x, rect.y);
	
	            var targX = (rect.x >= 0) ? 0 : -rect.x;
	            var targY = (rect.y >= 0) ? 0 : -rect.y;
	            var srcX = targX, srcY = targY;
	            var width, height;
	            if (clipRect) {
	                srcX = rect.x + clipRect.x;
	                srcY = rect.y + clipRect.y;
	                rect = new Rect(srcX, srcY, clipRect.width, clipRect.height);
	            }
	            targX = (rect.x >= 0) ? rect.x : 0;
	            targY = (rect.y >= 0) ? rect.y : 0;
	            var imgData = keyword_null;
	            var ratioX = _DPIHelper._getScaleX(canvas), ratioY = _DPIHelper._getScaleY(canvas);
	            if (canvas && ratioX !== 1) {
	                srcX *= ratioX;
	                srcY *= ratioY;
	                rect.x *= ratioX;
	                rect.y *= ratioY;
	                rect.width *= ratioX;
	                rect.height *= ratioY;
	            }
	            try {
	                if (canvas) {
	                    if (!clipRect) {
	                        width = Math_min(rect.width - srcX, Math_max(canvas.width - rect.x, 3));
	                        height = Math_min(rect.height - srcY, Math_max(canvas.height - rect.y, 3));
	                    } else {
	                        width = Math_max(rect.width - srcX, 0);
	                        height = Math_max(rect.height - srcY, 0);
	                    }
	                } else {
	                    srcX = clipRect.x;
	                    srcY = clipRect.y;
	                    width = clipRect.width;
	                    height = clipRect.height;
	                }
	                if (canvas) {
	                    CanvasHelper._scaleTo(ctx, 1, 1);
	                   
	                    ctx.clearRect(targX, targY, width, height);
	                    ctx.drawImage(self.buffer, srcX, srcY, width, height, targX, targY, width, height);
	                    CanvasHelper._scaleTo(ctx, ratioX, ratioY);
	                } else {
	                    bufferCtx = self.buffer.getContext(str_2d);
	                    imgData = bufferCtx.getImageData(srcX, srcY, width, height);
	                }
	            } catch (ex) {
	               
	                return;
	            }
	            if (!canvas && imgData && rect.width > 0 && rect.height > 0) {
	                ctx.putImageData(imgData, targX, targY);
	            }
	        },
	        _paintTabs: function (ctx, clipRect) {
	           
	            var self = this, sp = self._workbook;
	            if (!ctx || !sp) {
	                return;
	            }
	            var rect = self._getBounds();
	            ctx.save();
	            setContextFont(ctx, self._font);
	            if (clipRect) {
	                ctx.rect(clipRect.x, clipRect.y, clipRect.width, clipRect.height);
	            } else {
	                ctx.rect(rect.x, rect.y, rect.width, rect.height);
	            }
	            ctx.clip();
	            ctx.beginPath();
	           
	            var tabSize, tabStartPosition = self._getTabStartPosition(), pos = tabStartPosition;
	            ctx.save();
	            ctx.font = StyleHelper._setStringFont(ctx.font, 'bold');
	            self._tabSizes = [];
	            var i, sheets = sp.sheets;
	            for (i = 0; i < sheets.length; i++) {
	                tabSize = Math.round(ctx.measureText(sheets[i].name()).width) + self._tabRightPadding + self._tabLeftPadding;
	                self._tabSizes.push(tabSize);
	            }
	            ctx.restore();
	
	            var tabs = [], firstTab = self._firstTab;
	            if (firstTab > 0 && self._getPreVisibleIndex(firstTab) >= 0) {
	                pos += self._firstTabSpace;
	            }
	            if(firstTab < 0) {
	                firstTab = 0;
	            }
	            for (i = firstTab; i < sheets.length; i++) {
	                var visible = sheets[i].visible();
	                tabSize = self._tabSizes[i];
	               
	                if (pos > rect.x + rect.width) {
	                    break;
	                }
	                    tabs.push({i: i, x: pos, w: tabSize, t: sheets[i].name(), visible: visible});
	                if (visible) {
	                    pos += (tabSize + self._tabSpace);
	                }
	            }
	            self._paintBackground(ctx, rect);
	            self._paintNewSheetTab(ctx, rect, pos, tabStartPosition);
	            self._paintTab(ctx, rect, tabs, firstTab, tabStartPosition);
	            if (self._workbook && self._workbook.options.tabNavigationVisible) {
	                self._paintNavigationButtons(ctx, rect, tabStartPosition);
	            }
	            self._paintResizeBar(ctx, rect);
	           
	            ctx.beginPath();
	            ctx.restore();
	        },
	        _paintBackground: function (ctx, rect) { 
	        },
	        _paintNewSheetTab: function (ctx, rect, pos, tabStartPosition) { 
	        },
	        _paintTab: function (ctx, rect, tabs, firstTab, tabStartPosition) {
	            var self = this, sp = self._workbook, sheets = sp.sheets, hoverTab = self._hoverTab;
	            self._activeIndex = sp.getActiveSheetIndex();
	            var activeIndex = self._activeIndex;
	            if (sheets.length > 0) {
	                ctx.save();
	                ctx.beginPath();
	                var maxNewTabPos = rect.x + self._getCoverPosition();
	                ctx.rect(tabStartPosition, 0, maxNewTabPos - tabStartPosition, rect.height);
	                ctx.clip();
	                for (var i = tabs.length - 1; i >= 0; i--) {
	                    var t = tabs[i];
	                    if (t.i !== activeIndex && t.visible) {
	                        self._drawTab(ctx, t.x, 0, t.w, rect.height, 5, false, t.i === hoverTab, t.t);
	                    }
	                }
	               
	                var at = tabs[activeIndex - firstTab];
	                if (activeIndex >= firstTab && activeIndex < sheets.length && at && at.visible) {
	                    self._drawTab(ctx, at.x, 0, at.w, rect.height, 5, true, false, at.t);
	                }
	                ctx.restore();
	                ctx.save();
	                ctx.beginPath();
	               
	                if (firstTab > 0 && self._getPreVisibleIndex(firstTab) >= 0) {
	                    self._paintTabBeforeFirstTab(ctx, rect, firstTab, tabStartPosition);
	                }
	                ctx.restore();
	            }
	        },
	        _paintTabBeforeFirstTab: function (ctx, rect, firstTab, tabStartPosition) { 
	        },
	        _paintNavigationButtons: function (ctx, rect, tabStartPosition) { 
	        },
	        _paintResizeBar: function (ctx, rect) { 
	        },
	        _drawNavButton: function (ctx, x1, y1, x2, y2, x3, y3, left, linePosition, highlight) { 
	        },
	        _drawTab: function (ctx, x, y, width, height, cornerRadius, isActive, isHover, text) { 
	        },
	        _getCanvas: function () {
	            return this._canvas;
	        },
	        _getTabStripBackColor: function (ctx, rect) {
	            var gradFill = ctx.createLinearGradient(rect.x, rect.y, rect.width, rect.height);
	            var headerStyle = _ThemeStyleHelper._getVisualStateThemeStyle(0 , 'gc-tabStripBackground'),
	                backgroundImg = headerStyle && headerStyle.backgroundImage,
	                backgroundColor = headerStyle && headerStyle.backgroundColor;
	            if (backgroundImg && backgroundImg.indexOf('linear-gradient') !== -1) {
	                var colors = getLinearGradientColors(backgroundImg);
	                for (var i = 0, len = colors.length; i < len; i++) {
	                    var color = colors[i];
	                    gradFill.addColorStop(color.point, color.color);
	                }
	            } else if (backgroundColor) {
	                gradFill.addColorStop(0, '#DDDDDD');
	                gradFill.addColorStop(1, backgroundColor);
	            }
	            return gradFill;
	        },
	        _getTabBackColor: function (ctx, isActiveOrActive, text, externalThemeStyle) {
	            var self = this;
	            var rect = self._getBounds();
	            var fillStyle = ctx.createLinearGradient(rect.x + 0.7 * rect.height, rect.y + 0, 0.7 * rect.height, rect.height);
	            var sheet = self._workbook.getSheetFromName(text);
	           
	            if (text === '' && self._firstTab > 0) {
	                sheet = self._workbook.getSheet(self._firstTab - 1);
	            }
	            var sheetTabColor = sheet && sheet.options.sheetTabColor;
	            if (sheetTabColor) {
	                var transparentColor = 'rgba(0, 0, 0, 0)';
	                ctx.fillStyle = transparentColor;
	                ctx.fillStyle = util_common._ThemeContext._getColor(sheet, sheetTabColor);
	                var currentFillStyle = ctx.fillStyle;
	                if (currentFillStyle !== transparentColor) {
	                    if (isActiveOrActive) {
	                        fillStyle.addColorStop(0, color_white);
	                        fillStyle.addColorStop(0.45, '#F1F6FD');
	                        fillStyle.addColorStop(0.9, currentFillStyle);
	                        fillStyle.addColorStop(1, color_white);
	                    } else {
	                        fillStyle = currentFillStyle;
	                    }
	                }
	            } else if (externalThemeStyle) {
	                var backgroundImg = externalThemeStyle.backgroundImage,
	                    backgroundColor = externalThemeStyle.backgroundColor;
	                if (backgroundImg && backgroundImg.indexOf('linear-gradient') !== -1) {
	                    var colors = getLinearGradientColors(backgroundImg);
	                    for (var i = 0, len = colors.length; i < len; i++) {
	                        var color = colors[i];
	                        fillStyle.addColorStop(color.point, color.color);
	                    }
	                } else if (backgroundColor) {
	                    fillStyle.addColorStop(0, backgroundColor);
	                }
	            }
	            return fillStyle;
	        },
	        _getTabForeColor: function (externalThemeStyle, solidBackColor) {
	            var foreColor = color_black;
	            if (externalThemeStyle) {
	                foreColor = externalThemeStyle.color;
	            }
	            if (solidBackColor && (_ColorHelper._getBrightness(_ColorHelper._fromString(solidBackColor)) < 255 / 2)) {
	                foreColor = color_white;
	            }
	            return foreColor;
	        }
	    };
	
	    exports._SheetTabBase = SheetTabBase;
	
	    module.exports = exports;
	
	}());

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var exports = __webpack_require__(1);
	
	    var Common = __webpack_require__(5);
	    var util_common = __webpack_require__(3);
	    var $ = __webpack_require__(4).GC$;
	    var _SheetTabBase = __webpack_require__(28)._SheetTabBase;
	
	    var _ThemeStyleHelper = util_common._ThemeStyleHelper;
	    var getLinearGradientColors = util_common._util._getLinearGradientColors;
	
	    var keyword_null = null, Math_min = Math.min, color_92A5C7 = '#92A5C7', hit_element_newSheet = 'newSheet';
	
	    function sR() {
	        return Common._getResource(exports.SR)();
	    }
	
	    $.inherit(SheetTab2007, _SheetTabBase);
	    function SheetTab2007(name) {
	        _SheetTabBase.call(this, name);
	        var self = this;
	        self._tabLeftPadding = 12;
	        self._tabRightPadding = 8;
	        self._tabSpace = 3;
	        self._resizeBarWidth = 12;
	        self._newTabSize = 48;
	        self._firstTabSpace = 5;
	        self._font = '10pt Arial';
	    }
	
	    $.extend(SheetTab2007.prototype, {
	        _getNavigationButtonWidth: function () {
	            var workbook = this._workbook, options = workbook && workbook.options;
	            var width = 0;
	            if (!options || !options.tabNavigationVisible) {
	                width = 0;
	            } else {
	                width = workbook._getScrollbarSize() * (options.useTouchLayout ? 2 : 1);
	            }
	            return width;
	        },
	        _getNavigationButtonHeight: function () {
	            var workbook = this._workbook;
	            if (!workbook || !workbook.options.tabNavigationVisible) {
	                return 0;
	            }
	            return workbook._getScrollbarSize();
	        },
	        _getTabStartPosition: function () {
	            return this._getNavigationButtonWidth() * 4 + this._getTabMarginLeft();
	        },
	        _getTabMarginLeft: function () {
	            var self = this, workbook = self._workbook;
	            if (!workbook || !workbook.options.tabNavigationVisible) {
	                return 0;
	            }
	            return 2;
	        },
	
	
	        getResizeBarBounds: function () {
	            var self = this;
	            var rect = self._getBounds();
	            return {
	                x: rect.x + rect.width - self._resizeBarWidth,
	                y: keyword_null,
	                width: self._resizeBarWidth,
	                height: keyword_null
	            };
	        },
	
	        getNavButtonBounds: function () {
	            var self = this;
	            return {
	                x: 0,
	                y: keyword_null,
	                width: self._getNavigationButtonWidth(),
	                height: keyword_null,
	                endIndex: 4,
	                startIndex: 0
	            };
	        },
	
	
	        getSheetTabBounds: function () {
	            var self = this;
	            return {
	                x: self._getTabStartPosition(),
	                y: keyword_null,
	                height: keyword_null,
	                secondMoreTabWidth: 0,
	                moreTabPos: 0
	            };
	        },
	
	        getPreMoreTabBounds: function () {
	            var self = this;
	            return {
	                x: self._getTabStartPosition(),
	                width: self._tabSpace + self._firstTabSpace
	            };
	        },
	
	        _isCoverSheetTab: function () {
	            var self = this;
	            return self._activePos + self._tabSizes[self._activeIndex] + self._getNewTabSize() > self._getCoverPosition();
	        },
	        _getCoverPosition: function () {
	            return this._getBounds().width - this._resizeBarWidth;
	        },
	        _getInputTopPosition: function () {
	            return 1;
	        },
	        _getTabIndicatorEdgeElements: function () {
	            return [hit_element_newSheet];
	        },
	        _getBasicWidth: function () {
	            var self = this;
	            var tabOverlapWidth = self._getBounds().height;
	            var basisWidth = self._getTabStartPosition() + tabOverlapWidth;
	            if (self._workbook.options.newTabVisible) {
	                basisWidth += self._getNewTabSize();
	                basisWidth += self._tabSpace;
	            }
	            return basisWidth;
	        },
	        _paintBackground: function (ctx, rect) {
	           
	            ctx.save();
	            ctx.beginPath();
	            var gradFill = ctx.createLinearGradient(rect.x, rect.y, rect.width, rect.height);
	            var themeStyle = _ThemeStyleHelper._getVisualStateThemeStyle(0 , 'gc-tabStripBackground'),
	                backgroundImg = themeStyle && themeStyle.backgroundImage,
	                backgroundColor = themeStyle && themeStyle.backgroundColor;
	            if (backgroundImg && backgroundImg.indexOf('linear-gradient') !== -1) {
	                var colors = getLinearGradientColors(backgroundImg);
	                for (var i = 0, len = colors.length; i < len; i++) {
	                    var color = colors[i];
	                    gradFill.addColorStop(color.point, color.color);
	                }
	            } else if (backgroundColor) {
	                gradFill.addColorStop(0, '#DDDDDD');
	                gradFill.addColorStop(1, backgroundColor);
	            }
	            ctx.fillStyle = gradFill;
	            ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
	            ctx.restore();
	        },
	        _paintNewSheetTab: function (ctx, rect, pos, tabStartPosition) { 
	            var self = this, sp = self._workbook, NewTab = sR().NewTab;
	            if (sp.options.newTabVisible) {
	                self._newTabSize = ctx.measureText(NewTab).width + self._tabLeftPadding;
	                self._drawTab(ctx, pos, 0, self._getNewTabSize(), rect.height, 5, false, self._hoverTab === -2, NewTab);
	            }
	        },
	        _paintTabBeforeFirstTab: function (ctx, rect, firstTab, tabStartPosition) {
	            var self = this, index = firstTab - 1;
	            var tabSize = self._tabSizes[index];
	            self._drawTab(ctx, tabStartPosition + self._firstTabSpace - tabSize - self._tabSpace, 0, tabSize, rect.height, 5,
	                self._activeIndex === index, self._hoverTab === index, '');
	        },
	        _paintNavigationButtons: function (ctx, rect, tabStartPosition) {
	            var self = this;
	           
	            ctx.fillStyle = color_92A5C7;
	            ctx.fillRect(rect.x, rect.y, tabStartPosition - 1, rect.height);
	            var triangleSize = 5, navigationButtonWidth = self._getNavigationButtonWidth(),
	                navigationButtonHeight = self._getNavigationButtonHeight();
	           
	            var x = navigationButtonWidth / 2;
	            var y = navigationButtonHeight / 2;
	            var hoverNavButton = self._hoverNavButton;
	            self._drawNavButton(ctx, x, y, x + triangleSize, y + triangleSize, x + triangleSize, y - triangleSize, true, x - triangleSize, (hoverNavButton === 0));
	           
	            x += navigationButtonWidth;
	            self._drawNavButton(ctx, x, y, x + triangleSize, y + triangleSize, x + triangleSize, y - triangleSize, true, keyword_null, (hoverNavButton === 1));
	           
	            x += navigationButtonWidth;
	            self._drawNavButton(ctx, x, y, x - triangleSize, y + triangleSize, x - triangleSize, y - triangleSize, false, keyword_null, (hoverNavButton === 2));
	           
	            x += navigationButtonWidth;
	            self._drawNavButton(ctx, x, y, x - triangleSize, y + triangleSize, x - triangleSize, y - triangleSize, false, x + 4, (hoverNavButton === 3));
	        },
	        _paintResizeBar: function (ctx, rect) {
	            var self = this, sp = self._workbook, x, _width = self._resizeBarWidth;
	            var getVisualStateThemeStyle = _ThemeStyleHelper._getVisualStateThemeStyle;
	            var hoverStyle = getVisualStateThemeStyle(4 , 'gc-tabStripResizeBarInner'),
	                headerStyle = getVisualStateThemeStyle(0 , 'gc-tabStripResizeBarOuter');
	            if (sp.options.showHorizontalScrollbar) {
	                x = rect.x + rect.width - _width;
	                ctx.fillStyle = headerStyle.backgroundColor;
	                ctx.fillRect(x, rect.y, _width, rect.height);
	                ctx.fillStyle = hoverStyle.backgroundColor;
	                ctx.fillRect(x + 1, rect.y + 1, _width - 2, rect.height - 2);
	                ctx.fillStyle = hoverStyle.color;
	                ctx.fillRect(x + _width / 2 - 1, rect.y + 4, 2, rect.height - 8);
	            }
	        },
	        _drawTab: function (ctx, x, y, width, height, cornerRadius, isActive, isHover, text) {
	           
	            ctx.save();
	            ctx.beginPath();
	            ctx.moveTo(x, y);
	            ctx.lineTo(x, y + height - cornerRadius);
	            ctx.arcTo(x, y + height, x + width, y + height, cornerRadius);
	            ctx.lineTo(x + width, y + height);
	            ctx.lineTo(x + width + height, y);
	            if (!isActive) {
	                ctx.lineTo(x, y);
	            }
	            var self = this;
	            var visualStata = 0 ;
	            if (isActive || isHover) {
	                visualStata = 4 ;
	            }
	            var externalThemeStyle = _ThemeStyleHelper._getVisualStateThemeStyle(visualStata, 'gc-tab-' + _ThemeStyleHelper._getString(visualStata));
	            var backColor = self._getTabBackColor(ctx, isActive || isHover, text, externalThemeStyle);
	            ctx.fillStyle = backColor;
	            ctx.fill();
	            ctx.strokeStyle = color_92A5C7;
	            ctx.stroke();
	            ctx.textBaseline = 'top';
	            var solidBackColor;
	            if (typeof (backColor) === 'string') {
	                solidBackColor = backColor;
	            }
	            ctx.fillStyle = self._getTabForeColor(externalThemeStyle, solidBackColor);
	            var adjX = self._tabLeftPadding;
	            ctx.textBaseline = 'middle';
	            ctx.fillText(text, x + adjX, y + height / 2);
	            ctx.restore();
	        },
	        _drawNavButton: function (ctx, x1, y1, x2, y2, x3, y3, left, linePosition, highlight) {
	           
	            ctx.save();
	            var self = this;
	           
	            var rect = self._getBounds(), navigationButtonWidth = self._getNavigationButtonWidth();
	            var getVisualStateThemeStyle = _ThemeStyleHelper._getVisualStateThemeStyle;
	            var hoverStyle = getVisualStateThemeStyle(4 , 'gc-navButton-hover');
	            var tmpStyle = getVisualStateThemeStyle(0 , 'gc-navButton-normal'),
	                backgroundColor = tmpStyle && tmpStyle.backgroundColor;
	            if (highlight) {
	                ctx.fillStyle = hoverStyle.backgroundColor;
	                ctx.fillRect(x1 - navigationButtonWidth / 2 + 2, rect.y + 2, navigationButtonWidth - 4, rect.height - 4);
	            } else {
	                var backgroundImg = tmpStyle && tmpStyle.backgroundImage;
	                if (backgroundImg && backgroundImg.indexOf('linear-gradient') !== -1) {
	                    var fill = ctx.createLinearGradient(rect.x + 0.7 * rect.height, rect.y + 0, 0.7 * rect.height, rect.height);
	                    var colors = getLinearGradientColors(backgroundImg);
	                    for (var i = 0, len = colors.length; i < len; i++) {
	                        var color = colors[i];
	                        fill.addColorStop(color.point, color.color);
	                    }
	                    ctx.fillStyle = fill;
	                } else if (backgroundColor) {
	                    ctx.fillStyle = backgroundColor;
	                }
	                ctx.fillRect(x1 - navigationButtonWidth / 2, rect.y + 1, navigationButtonWidth, rect.height - 2);
	            }
	            if (highlight) {
	                ctx.fillStyle = hoverStyle.color;
	            } else {
	                ctx.fillStyle = tmpStyle.color;
	            }
	           
	            if (linePosition !== undefined && linePosition !== keyword_null) {
	                ctx.fillRect(linePosition, Math_min(y2, y3), 1, Math.max(y2, y3) - Math_min(y2, y3));
	            }
	            if (left) {
	                x1 -= 2;
	                x2 -= 2;
	                x3 -= 2;
	            } else {
	                x1 += 2;
	                x2 += 2;
	                x3 += 2;
	            }
	           
	           
	            ctx.beginPath();
	            ctx.moveTo(x1, y1);
	            ctx.lineTo(x2, y2);
	            ctx.lineTo(x3, y3);
	            ctx.lineTo(x1, y1);
	            ctx.fill();
	            ctx.restore();
	        }
	    });
	
	    exports._SheetTab2007 = SheetTab2007;
	
	    module.exports = exports;
	
	
	}());

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	    'use strict';
	
	    var GC$ = __webpack_require__(4).GC$;
	    var Worksheet = __webpack_require__(17).Worksheet;
	    var Style = __webpack_require__(12).Style;
	    var util_common = __webpack_require__(3);
	    GC$.extend(Worksheet.prototype, {
	       
	        
	        getFormatter: function (row, col, sheetArea) {
	            return this._getStyleProperty(row, col, 'formatter', sheetArea);
	        },
	       
	        
	        setFormatter: function (row, col, value, sheetArea) {
	            var style = this._getStyleImp(row, col, sheetArea);
	            if (!style) {
	                style = new Style();
	            }
	            style.formatter = value;
	            this.setStyle(row, col, style, sheetArea);
	        }
	    });
	    
	    Worksheet._registerFeature('formatter', {
	        settingText: function(arg) {
	            var isNumber = util_common._util._isStringNumber(arg.value);
	            var Formatter_module = __webpack_require__(6);
	            var GeneralFormatter = Formatter_module && Formatter_module.GeneralFormatter;
	            if (GeneralFormatter && isNumber) {
	                var aValRef = {};
	                new GeneralFormatter().getPreferredDisplayFormatter(arg.value, aValRef);
	                if (typeof aValRef.value === 'number') {
	                    arg.value = aValRef.value;
	                }
	            }
	        }
	    });
	
	}());

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var exports = __webpack_require__(1);
	    var LineBorder = __webpack_require__(12).LineBorder;
	    var $ = __webpack_require__(4).GC$;
	    var keyword_undefined = void 0;
	    var keyword_null = null, Math_sqrt = Math.sqrt, Math_pow = Math.pow, Math_min = Math.min;
	    var $_inherit = $.inherit, $_isEmptyObject = $.isEmptyObject;
	    var SPAN_POINT_POSITION = {
	        LEFT_TOP: 0,
	        RIGHT_TOP: 1,
	        RIGHT_BOTTOM: 2,
	        LEFT_BOTTOM: 3
	    };
	    var SPAN_BORDER_POSITION = {
	        H_TOP_LEFT: 0,
	        H_TOP_Right: 1,
	        V_RIGHT_TOP: 2,
	        V_RIGHT_BOTTOM: 3,
	        H_BOTTOM_RIGHT: 4,
	        H_BOTTOM_LEFT: 5,
	        V_LEFT_BOTTOM: 6,
	        V_LEFT_TOP: 7
	    };
	    var Line = (function () {
	        function Line() {
	        }
	
	        Line.prototype = {
	            constructor: Line,
	            _adjust: function (opt) {
	                var self = this;
	                if (opt._orientation === 0 ) {
	                    if (opt._offsetEnd) {
	                        self._x2 += opt._offsetEnd;
	                    }
	                    if (opt._offsetStart) {
	                        self._x1 += opt._offsetStart;
	                    }
	                } else {
	                    if (opt._offsetEnd) {
	                        self._y2 += opt._offsetEnd;
	                    }
	                    if (opt._offsetStart) {
	                        self._y1 += opt._offsetStart;
	                    }
	                }
	            },
	            _paint: function (ctx) {
	                var color = (this._color || '#9eb6ce'), lineWidth = this._lineWidth, ctxLineWidth = ctx.lineWidth,
	                    ctxStrokeStyle = ctx.strokeStyle;
	                if (ctxLineWidth !== lineWidth || ctxStrokeStyle !== color) {
	                    if (ctxLineWidth !== lineWidth) {
	                        ctx.lineWidth = lineWidth;
	                    }
	                    if (ctxStrokeStyle !== color) {
	                        ctx.strokeStyle = color;
	                    }
	                }
	                this._paintImp(ctx);
	            },
	            _paintImp: function (ctx) {
	                var self = this;
	                if (self._x1 === self._x2 || self._y1 === self._y2) {
	                    ctx.beginPath();
	                    self._paintLine(ctx);
	                    ctx.stroke();
	                } else {
	                    ctx.save();
	                    var x = Math.min(self._x1, self._x2);
	                    var y = Math.min(self._y1, self._y2);
	                    ctx.rect(x, y, Math.abs(self._x2 - self._x1), Math.abs(self._y2 - self._y1));
	                    ctx.clip();
	                    ctx.beginPath();
	                    self._paintLine(ctx);
	                    ctx.stroke();
	                    ctx.beginPath();
	                    ctx.restore();
	                }
	            },
	            _paintLine: function (ctx) {
	                var self = this;
	                ctx.moveTo(self._x1, self._y1);
	                ctx.lineTo(self._x2, self._y2);
	
	            }
	        };
	
	
	        return Line;
	    })();
	    var SolidLine = (function (_super) {
	        $_inherit(SolidLine, _super);
	
	        function SolidLine(x1, y1, x2, y2, color, width) {
	            _super.call(this);
	            var isSnapToPixel = width % 2;
	            if (!isSnapToPixel) {
	                if (x1 !== x2) {
	                    y1 -= 0.5;
	                    y2 -= 0.5;
	                } else {
	                    x1 -= 0.5;
	                    x2 -= 0.5;
	                }
	            }
	            var self = this;
	            self._x1 = x1;
	            self._y1 = y1;
	            self._x2 = x2;
	            self._y2 = y2;
	            self._color = color;
	            self._lineWidth = width;
	        }
	
	        return SolidLine;
	    })(Line);
	    var DashedLine = (function (_super) {
	        $_inherit(DashedLine, _super);
	
	        function DashedLine(x1, y1, x2, y2, color, width, pattern) {
	            _super.call(this);
	            var isSnapToPixel = width % 2;
	            if (!isSnapToPixel) {
	                if (x1 !== x2) {
	                    y1 -= 0.5;
	                    y2 -= 0.5;
	                } else {
	                    x1 -= 0.5;
	                    x2 -= 0.5;
	                }
	            }
	            var self = this;
	            self._x1 = x1;
	            self._y1 = y1;
	            self._x2 = x2;
	            self._y2 = y2;
	            self._color = color;
	            self._lineWidth = width;
	            self._pattern = pattern;
	        }
	
	        DashedLine.prototype._paintLine = function (ctx) {
	            var self = this;
	            DashedLine._render(ctx, self._x1, self._y1, self._x2, self._y2, self._pattern);
	        };
	        DashedLine._render = function (ctx, x0, y0, x1, y1, pattern) {
	            var length = Math_sqrt(Math_pow(x1 - x0, 2) + Math_pow(y1 - y0, 2));
	            var vector = {
	                x: (x1 - x0) / length,
	                y: (y1 - y0) / length
	            };
	            var dist = 0, i = 0;
	            pattern = pattern && pattern.length ? pattern : [4, 4];
	            while (dist < length) {
	                var dashLength = Math_min(pattern[i++ % pattern.length], length - dist);
	                var draw = (i % 2);
	                dist += dashLength;
	                if (draw) {
	                    ctx.moveTo(x0, y0);
	                }
	                x0 += dashLength * vector.x;
	                y0 += dashLength * vector.y;
	                if (draw) {
	                    ctx.lineTo(x0, y0);
	                }
	            }
	        };
	        return DashedLine;
	    })(Line);
	    var SlantedLine = (function (_super) {
	        $_inherit(SlantedLine, _super);
	
	        function SlantedLine(x1, y1, x2, y2, color, horizontal, pattern1, pattern2) {
	            _super.call(this);
	            if (horizontal) {
	                x1 -= 1;
	                x2 -= 1;
	            } else {
	                y1 -= 1;
	                y2 -= 1;
	            }
	            var self = this;
	            self._x1 = x1;
	            self._y1 = y1;
	            self._x2 = x2;
	            self._y2 = y2;
	            self._color = color;
	            self._horizontal = horizontal;
	            self._lineWidth = 1;
	            self._pattern1 = pattern1;
	            self._pattern2 = pattern2;
	        }
	
	        SlantedLine.prototype._paintLine = function (ctx) {
	            var self = this;
	            var xOff = self._horizontal ? 0 : 1;
	            var yOff = self._horizontal ? 1 : 0;
	            DashedLine._render(ctx, self._x1 - xOff, self._y1 - yOff, self._x2 - xOff, self._y2 - yOff, self._pattern1);
	            DashedLine._render(ctx, self._x1, self._y1, self._x2, self._y2, self._pattern2);
	        };
	        return SlantedLine;
	    })(Line);
	    var DiagonalDoubleLine = (function (_super) {
	        $_inherit(DiagonalDoubleLine, _super);
	
	        function DiagonalDoubleLine(x1, y1, x2, y2, color, isDown) {
	            _super.call(this);
	            var self = this;
	            self._x1 = x1;
	            self._y1 = y1;
	            self._x2 = x2;
	            self._y2 = y2;
	            self._color = color;
	            self._isDown = isDown;
	
	            self._line1 = new SolidLine(self._x1, self._y1, self._x2, self._y2, color, 1);
	            self._line2 = null;
	        }
	
	        DiagonalDoubleLine.prototype._paintImp = function (ctx) {
	           
	            if (this._line1) {
	                this._line1._paintImp(ctx);
	            }
	           
	            if (this._line2) {
	                this._line2._paintImp(ctx);
	            }
	        };
	        DiagonalDoubleLine.prototype._adjust = function (opt) {
	            var self = this;
	            if (self._line2) {
	                if (opt._offsetStart && self._line1) {
	                    self._line1._adjust(opt);
	                }
	                if (opt._offsetEnd) {
	                    self._line2._adjust(opt);
	                }
	            } else if (self._line1) {
	                self._line1._adjust(opt);
	            }
	        };
	        DiagonalDoubleLine.prototype._adjustSever = function (sever) {
	            var self = this;
	            if (sever && sever.severX && sever.severY) {
	                var severX = sever.severX || 0;
	                var severY = sever.severY || 0;
	                severX = self._isDown ? severX : -severX;
	                var middleX = parseInt(self._x1 + ((self._x2 - self._x1) / 2));
	                var middleY = parseInt(self._y1 + ((self._y2 - self._y1) / 2));
	                var firstPartEndX = middleX - severX;
	                var firstPartEndY = middleY - severY;
	                var lastPartBeginX = middleX + severX;
	                var lastPartBeginY = middleY + severY;
	                self._line1 = new SolidLine(self._x1, self._y1, firstPartEndX, firstPartEndY, self._color, 1);
	                self._line2 = new SolidLine(lastPartBeginX, lastPartBeginY, self._x2, self._y2, self._color, 1);
	            } else {
	                self._line1 = new SolidLine(self._x1, self._y1, self._x2, self._y2, self._color, 1);
	                self._line2 = null;
	            }
	        };
	        return DiagonalDoubleLine;
	    })(Line);
	    var DoubleLine = (function (_super) {
	        $_inherit(DoubleLine, _super);
	
	        function DoubleLine(x1, y1, x2, y2, color) {
	            _super.call(this);
	            var self = this;
	            var xOff = 0, yOff = 0;
	            if (x1 === x2) {
	                xOff = 1;
	            }
	            if (y1 === y2) {
	                yOff = 1;
	            }
	            if (xOff === 0 && yOff === 0) {
	                xOff = 2;
	                yOff = 2;
	               
	                if (x1 > x2) {
	                    self._line1 = new DiagonalDoubleLine(x1 - xOff, y1, x2, y2 - yOff, color, false);
	                    self._line2 = new DiagonalDoubleLine(x1, y1 + yOff, x2 + xOff, y2, color, false);
	                } else {
	                    self._line1 = new DiagonalDoubleLine(x1, y1 + yOff, x2 - xOff, y2, color, true);
	                    self._line2 = new DiagonalDoubleLine(x1 + xOff, y1, x2, y2 - yOff, color, true);
	                }
	            } else {
	                self._line1 = new SolidLine(x1 - xOff, y1 - yOff, x2 - xOff, y2 - yOff, color, 1);
	                self._line2 = new SolidLine(x1 + xOff, y1 + yOff, x2 + xOff, y2 + yOff, color, 1);
	            }
	            self._color = color;
	            self._lineWidth = 1;
	        }
	
	        DoubleLine.prototype._paintImp = function (ctx) {
	           
	            this._line1._paintImp(ctx);
	           
	            this._line2._paintImp(ctx);
	        };
	        DoubleLine.prototype._adjust = function (opt) {
	            var self = this;
	            if (!opt._lineSide) {
	                self._line1._adjust(opt);
	                self._line2._adjust(opt);
	            } else if (opt._lineSide === 1 ) {
	                self._line1._adjust(opt);
	            } else if (opt._lineSide === 2 ) {
	                self._line2._adjust(opt);
	            }
	        };
	        DoubleLine.prototype._adjustSever = function () {
	            var self = this;
	            var serve = {severX: 1, severY: 1};
	            self._line1._adjustSever(serve);
	            self._line2._adjustSever(serve);
	        };
	        return DoubleLine;
	    })(Line);
	
	    function createLine(x1, y1, x2, y2, color, lineStyle) {
	        if (lineStyle === keyword_undefined || lineStyle === keyword_null) {
	            lineStyle = 1 ;
	        }
	        switch (lineStyle) {
	            case 1 
	            :
	                return new SolidLine(x1, y1, x2, y2, color, 1);
	            case 2 
	            :
	                return new SolidLine(x1, y1, x2, y2, color, 2);
	            case 5 
	            :
	                return new SolidLine(x1, y1, x2, y2, color, 3);
	            case 3 
	            :
	                return new DashedLine(x1, y1, x2, y2, color, 1, [3, 1]);
	            case 9 
	            :
	                return new DashedLine(x1, y1, x2, y2, color, 1, [8, 2, 2, 2]);
	            case 4 
	            :
	                return new DashedLine(x1, y1, x2, y2, color, 1, [2, 2]);
	            case 11 
	            :
	                return new DashedLine(x1, y1, x2, y2, color, 1, [9, 3, 3, 3, 3, 3]);
	            case 13 
	            :
	                return new SlantedLine(x1, y1, x2, y2, color, x1 !== x2, [11, 1, 5, 1], [10, 2, 4, 2]);
	            case 10 
	            :
	                return new DashedLine(x1, y1, x2, y2, color, 2, [9, 3, 3, 3]);
	            case 12 
	            :
	                return new DashedLine(x1, y1, x2, y2, color, 2, [9, 3, 3, 3, 3, 3]);
	            case 8 
	            :
	                return new DashedLine(x1, y1, x2, y2, color, 2, [9, 3]);
	            case 7 
	            :
	                return new DashedLine(x1, y1, x2, y2, color, 1, [1]);
	            case 6 
	            :
	                return new DoubleLine(x1, y1, x2, y2, color);
	        }
	        return keyword_null;
	    }
	
	   
	   
	   
	   
	
	   
	   
	   
	   
	
	    var BorderLayoutEngine = (function () {
	        function BorderLayoutEngine() {
	        }
	
	        BorderLayoutEngine._compareLineStyle = function (line1, line2) {
	            if (!line1) {
	                if (!line2) {
	                    return 0;
	                }
	                return -1;
	            } else if (!line2) {
	                return 1;
	            }
	            var weightCache = BorderLayoutEngine._styleWeightCache;
	            var result = weightCache[line1.style] - weightCache[line2.style];
	            if (result === 0) {
	                return line2.level - line1.level;
	            }
	            return result;
	        };
	        BorderLayoutEngine._getDrawingThickness = function (lineItem) {
	            if (lineItem) {
	                if (lineItem.isGridLine) {
	                    return 1;
	                }
	                if (lineItem.style) {
	                    return LineBorder._width(lineItem.style);
	                }
	            }
	            return 0;
	        };
	        BorderLayoutEngine._isDoubleLine = function (line) {
	            return (line && line.style === 6 );
	        };
	        BorderLayoutEngine._isSlantedLine = function (line) {
	            return (line && line.style === 13 );
	        };
	        BorderLayoutEngine._getMaxLine = function (line1, line2) {
	            if (!line1) {
	                return line2;
	            } else if (!line2) {
	                return line1;
	            }
	            return BorderLayoutEngine._compareLineStyle(line1.style, line2.style) >= 0 ? line1 : line2;
	        };
	        BorderLayoutEngine._adjustLine = function (lineItem, opt) {
	            if (lineItem && lineItem.line) {
	                lineItem.line._adjust(opt);
	            }
	        };
	        BorderLayoutEngine._compareLine = function (lineItem1, lineItem2) {
	            if (lineItem1 === lineItem2) {
	                return 0;
	            }
	            if (!lineItem1) {
	                return -1;
	            }
	            if (!lineItem2) {
	                return 1;
	            }
	            if (lineItem1.isGridLine) {
	                return lineItem2.isGridLine ? 0 : -1;
	            } else if (lineItem2.isGridLine) {
	                return 1;
	            }
	            return BorderLayoutEngine._compareLineStyle(lineItem1.style, lineItem2.style);
	        };
	        BorderLayoutEngine._isDoubleLineItem = function (lineItem) {
	            return lineItem && lineItem.style && lineItem.style.style === 6 ;
	        };
	        BorderLayoutEngine._isAllowExtend = function (current, line, break1, break2) {
	           
	            if (current.style && current.style.style === 6 ) {
	                return true;
	            }
	            var doubleCnt = 0;
	            doubleCnt += (line && line.style && line.style.style === 6 ) ? 1 : 0;
	            doubleCnt += (break1 && break1.style && break1.style.style === 6 ) ? 1 : 0;
	            doubleCnt += (break2 && break2.style && break2.style.style === 6 ) ? 1 : 0;
	            return doubleCnt < 2;
	        };
	        BorderLayoutEngine._layout4CrossRoad = function (current, line, break1, break2, lineType, vertical) {
	            var opt = {
	                _orientation: (vertical ? 1 : 0),
	                _offsetStart: 0,
	                _offsetEnd: 0
	            };
	            var diff1 = this._compareLine(current, break1), diff2 = this._compareLine(current, break2);
	            if (diff1 >= 0 && diff2 >= 0) {
	                if (diff1 === 0 && diff2 === 0) {
	                    if (lineType !== -1  && lineType === 1 ) {
	                        opt._offsetEnd -= lineType;
	                    }
	                } else if (lineType === -1 ) {
	                    opt._offsetStart -= lineType;
	                } else if (lineType === 1 ) {
	                    opt._offsetEnd -= 2 * lineType;
	                }
	            } else if (diff2 >= 0) {
	                opt._lineSide = 2 ;
	                opt._offsetStart += lineType;
	            } else if (diff1 >= 0) {
	                opt._lineSide = 1 ;
	                opt._offsetStart += lineType;
	            }
	            this._adjustLine(current, opt);
	        };
	        BorderLayoutEngine._layout4TurnRoad = function (current, prevLine, nextLine, break1, break2, type, lineType, vertical, swap) {
	            var optFirst = {
	                _orientation: (vertical ? 1 : 0),
	                _lineSide: (swap ? 2  : 1 ),
	                _offsetStart: 0,
	                _offsetEnd: 0
	            };
	            var optSecond = {
	                _orientation: (vertical ? 1 : 0),
	                _lineSide: (swap ? 1  : 2 ),
	                _offsetStart: 0,
	                _offsetEnd: 0
	            };
	            var breakLine = (type === 1 ? break1 : break2);
	            var neighborLine = (lineType === 1  ? nextLine : prevLine);
	            var hasNeighborDoubleLine = this._isDoubleLineItem(neighborLine);
	            if (!hasNeighborDoubleLine) {
	                if (this._compareLine(current, breakLine) >= 0) {
	                    if (lineType === -1 ) {
	                        optSecond._offsetStart -= 2 * lineType;
	                    } else if (lineType === 1 ) {
	                        optSecond._offsetEnd -= 2 * lineType;
	                    }
	                } else if (lineType === -1 ) {
	                    optFirst._offsetStart += 2 * lineType;
	                } else if (lineType === 1 ) {
	                    optFirst._offsetEnd += 2 * lineType;
	                }
	            } else {
	                var diff = this._compareLine(current, breakLine);
	                if (diff === 0) {
	                    var diff1 = this._compareLine(current, neighborLine);
	                    if (diff1 === 0) {
	                        
	                        if (lineType === 1 ) {
	                            optSecond._offsetEnd -= lineType;
	                        }
	                    } else if (diff1 > 0) {
	                        if (lineType === -1 ) {
	                            optSecond._offsetStart -= 2 * lineType;
	                        } else if (lineType === 1 ) {
	                            optSecond._offsetEnd -= 2 * lineType;
	                        }
	                    }
	                } else if (diff > 0) {
	                    var diff2 = this._compareLine(current, neighborLine);
	                    if (diff2 === 0) {
	                        if (lineType === 1 ) {
	                            optSecond._offsetEnd -= lineType;
	                        }
	                    } else if (diff2 > 0) {
	                        if (lineType === -1 ) {
	                            optSecond._offsetStart -= 2 * lineType;
	                        } else if (lineType === 1 ) {
	                            optSecond._offsetEnd -= 2 * lineType;
	                        }
	                    }
	                } else {
	                    var diff3 = this._compareLine(current, neighborLine);
	                    if (diff3 === 0) {
	                        if (lineType === -1 ) {
	                            optFirst._offsetStart += 2 * lineType;
	                        } else if (lineType === 1 ) {
	                            optFirst._offsetEnd += 2 * lineType;
	                        }
	                    } else if (diff3 > 0) {
	                        if (lineType === -1 ) {
	                            optFirst._offsetStart -= 3 * lineType;
	                        } else if (lineType === 1 ) {
	                            optFirst._offsetEnd -= 3 * lineType;
	                        }
	                    }
	                }
	            }
	           
	            var otherType = (type === 1 ? 2 : 1);
	            var otherBreakLine = (otherType === 1 ? break1 : break2);
	            var needMakeupCorner = false;
	            var thickness = 0;
	            if (this._isDoubleLineItem(otherBreakLine) && this._compareLine(otherBreakLine, current) > 0) {
	                needMakeupCorner = true;
	                var drawThickness = BorderLayoutEngine._getDrawingThickness(otherBreakLine);
	                if (this._compareLine(otherBreakLine, breakLine) > 0) {
	                    if (drawThickness > 0) {
	                        if (lineType === 1  && this._isDoubleLineItem(nextLine)) {
	                            thickness = drawThickness >= 2 ? 2 : 1;
	                        } else if (lineType === -1  && this._isDoubleLineItem(prevLine)) {
	                            thickness = drawThickness >= 3 ? 2 : 1;
	                        } else {
	                            thickness = drawThickness === 3 ? 3 : 2;
	                        }
	                    }
	                } else {
	                    thickness = drawThickness === 3 ? 3 : 2;
	                }
	            }
	            if (!needMakeupCorner && (!this._isDoubleLineItem(neighborLine)) && ((neighborLine && !neighborLine.isGridLine) || (otherBreakLine && !otherBreakLine.isGridLine))) {
	                needMakeupCorner = true;
	                if (lineType === -1 ) {
	                    thickness = 2;
	                } else {
	                    thickness = 1;
	                }
	            }
	            if (needMakeupCorner) {
	                if (lineType === -1 ) {
	                    optFirst._offsetStart += lineType * thickness;
	                    optSecond._offsetStart += lineType * thickness;
	                } else if (lineType === 1 ) {
	                    optFirst._offsetEnd += lineType * thickness;
	                    optSecond._offsetEnd += lineType * thickness;
	                }
	            }
	            if (optFirst._offsetStart || optFirst._offsetEnd) {
	                this._adjustLine(current, optFirst);
	            }
	            if (optSecond._offsetStart || optSecond._offsetEnd) {
	                this._adjustLine(current, optSecond);
	            }
	        };
	        BorderLayoutEngine._layout4TRoad = function (current, line, break1, break2, lineType, vertical) {
	            if (this._compareLine(current, break1) >= 0 && this._compareLine(current, break2) >= 0) {
	                var opt = {_orientation: (vertical ? 1 : 0), _offsetStart: 0, _offsetEnd: 0};
	                if (lineType === -1 ) {
	                    opt._offsetStart -= 2 * lineType;
	                    if (this._isDoubleLineItem(current) && this._compareLine(line, current) > 0) {
	                        opt._offsetStart -= 1;
	                    }
	                } else if (lineType === 1 ) {
	                    opt._offsetEnd -= 2 * lineType;
	                    if (this._isDoubleLineItem(current) && this._compareLine(line, current) > 0) {
	                        opt._offsetEnd += 1;
	                    }
	                }
	                this._adjustLine(current, opt);
	            }
	        };
	        BorderLayoutEngine._layout4Connected = function (current, line, break1, break2, lineType, vertical) {
	            if (this._isDoubleLineItem(current)) {
	                var breakLine = this._getMaxLine(break1, break2);
	                if (breakLine && !breakLine.isGridLine) {
	                    var drawThickness = BorderLayoutEngine._getDrawingThickness(breakLine);
	                    if (drawThickness > 0) {
	                        var opt = {
	                            _orientation: (vertical ? 1 : 0),
	                            _offsetStart: 0,
	                            _offsetEnd: 0
	                        };
	                        if (lineType === -1 ) {
	                            opt._offsetStart += drawThickness * lineType;
	                        } else {
	                            opt._offsetEnd += drawThickness * lineType;
	                        }
	                        if (opt._offsetStart || opt._offsetEnd) {
	                            this._adjustLine(current, opt);
	                        }
	                    }
	                }
	            }
	        };
	        BorderLayoutEngine._calcLayoutHorizontal = function (current, prevLine, prevBreak1, prevBreak2, nextLine, nextBreak1, nextBreak2) {
	            var drawThickness;
	            var diff;
	            var self = BorderLayoutEngine;
	           
	            if (prevLine || prevBreak1 || prevBreak2) {
	                var prevBreak = self._getMaxLine(prevBreak1, prevBreak2);
	                if (!self._isAllowExtend(current, prevLine, prevBreak1, prevBreak2)) {
	                    self._adjustLine(current, {_orientation: 0, _offsetStart: 1});
	                } else if ((diff = self._compareLine(prevBreak, current)) > 0) {
	                    drawThickness = self._getDrawingThickness(prevBreak);
	                    if (!(self._isDoubleLineItem(current) && (self._isDoubleLineItem(prevBreak1) || self._isDoubleLineItem(prevBreak2) || self._isDoubleLineItem(prevLine)))) { 
	                        if (drawThickness === 3) {
	                            self._adjustLine(current, {_orientation: 0, _offsetStart: 1});
	                        }
	                    }
	                } else if (prevBreak && diff < 0) {
	                    if ((diff = self._compareLine(current, prevLine)) > 0) {
	                        drawThickness = self._getDrawingThickness(prevBreak);
	                        if (drawThickness === 3 || drawThickness === 2) {
	                            self._adjustLine(current, {_orientation: 0, _offsetStart: -2});
	                        } else if (drawThickness === 1) {
	                            self._adjustLine(current, {_orientation: 0, _offsetStart: -1});
	                        }
	                    } else if (diff !== 0 && self._compareLine(prevLine, prevBreak) > 0) {
	                        drawThickness = self._getDrawingThickness(prevBreak);
	                        if (drawThickness === 3) {
	                            self._adjustLine(current, {_orientation: 0, _offsetStart: 1});
	                        }
	                    }
	                } else if (diff === 0 && (!prevLine || self._compareLine(current, prevLine) > 0)) {
	                    drawThickness = self._getDrawingThickness(prevBreak);
	                    if (drawThickness === 3 || drawThickness === 2) {
	                        self._adjustLine(current, {_orientation: 0, _offsetStart: -2});
	                    } else if (drawThickness === 1) {
	                        self._adjustLine(current, {_orientation: 0, _offsetStart: -1});
	                    }
	                }
	            }
	           
	            if (nextLine || nextBreak1 || nextBreak2) {
	                var nextBreak = self._getMaxLine(nextBreak1, nextBreak2);
	                if (!self._isAllowExtend(current, nextLine, nextBreak1, nextBreak2)) {
	                    self._adjustLine(current, {_orientation: 0, _offsetEnd: -2});
	                } else if ((diff = self._compareLine(nextBreak, current)) > 0) {
	                    drawThickness = self._getDrawingThickness(nextBreak);
	                    if (!(self._isDoubleLineItem(current) && (self._isDoubleLineItem(nextBreak1) || self._isDoubleLineItem(nextBreak2) || self._isDoubleLineItem(nextLine)))) {
	                        if (drawThickness === 3) {
	                            self._adjustLine(current, {_orientation: 0, _offsetEnd: -2});
	                        } else if (drawThickness === 2 || drawThickness === 1) {
	                            self._adjustLine(current, {_orientation: 0, _offsetEnd: -1});
	                        }
	                    }
	                } else if (diff <= 0) {
	                    if ((diff = self._compareLine(current, nextLine)) > 0) {
	                        drawThickness = self._getDrawingThickness(nextBreak);
	                        if (drawThickness === 3) {
	                            self._adjustLine(current, {_orientation: 0, _offsetEnd: 1});
	                        }
	                    } else if (diff !== 0) {
	                        self._adjustLine(current, {_orientation: 0, _offsetEnd: -1});
	                    }
	                }
	            }
	        };
	        BorderLayoutEngine._calcLayoutVertical = function (current, prevLine, prevBreak1, prevBreak2, nextLine, nextBreak1, nextBreak2) {
	            var drawThickness;
	            var diff;
	            var self = BorderLayoutEngine;
	           
	            if (prevLine || prevBreak1 || prevBreak2) {
	                var prevBreak = self._getMaxLine(prevBreak1, prevBreak2);
	                if (!self._isAllowExtend(current, prevLine, prevBreak1, prevBreak2)) {
	                    self._adjustLine(current, {_orientation: 1, _offsetStart: 1});
	                } else if ((diff = self._compareLine(prevBreak, current)) > 0) {
	                    drawThickness = self._getDrawingThickness(prevBreak);
	                    if (!(self._isDoubleLineItem(current) && (self._isDoubleLineItem(prevBreak1) || self._isDoubleLineItem(prevBreak2) || self._isDoubleLineItem(prevLine)))) { 
	                        if (drawThickness === 3) {
	                            self._adjustLine(current, {_orientation: 1, _offsetStart: 1});
	                        }
	                    }
	                } else if (diff < 0) {
	                    if ((diff = self._compareLine(current, prevLine)) > 0) {
	                        drawThickness = self._getDrawingThickness(prevBreak);
	                        if (drawThickness === 3 || drawThickness === 2) {
	                            self._adjustLine(current, {_orientation: 1, _offsetStart: -2});
	                        } else if (drawThickness === 1) {
	                            self._adjustLine(current, {_orientation: 1, _offsetStart: -1});
	                        }
	                    } else if (diff !== 0 && self._compareLine(prevLine, prevBreak) > 0) {
	                        drawThickness = self._getDrawingThickness(prevBreak);
	                        if (drawThickness === 3) {
	                            self._adjustLine(current, {_orientation: 1, _offsetStart: 1});
	                        }
	                    }
	                } else if (diff === 0 && self._compareLine(current, prevLine) > 0) {
	                    drawThickness = self._getDrawingThickness(prevBreak);
	                    if (drawThickness === 3 || drawThickness === 2) {
	                        self._adjustLine(current, {_orientation: 1, _offsetStart: -2});
	                    } else if (drawThickness === 1) {
	                        self._adjustLine(current, {_orientation: 1, _offsetStart: -1});
	                    }
	                }
	            }
	           
	            if (nextLine || nextBreak1 || nextBreak2) {
	                var nextBreak = self._getMaxLine(nextBreak1, nextBreak2);
	                if (!self._isAllowExtend(current, nextLine, nextBreak1, nextBreak2)) {
	                    self._adjustLine(current, {_orientation: 1, _offsetEnd: -2});
	                } else if ((diff = self._compareLine(current, nextBreak)) < 0) {
	                    drawThickness = self._getDrawingThickness(nextBreak);
	                    if (!(self._isDoubleLineItem(current) && (self._isDoubleLineItem(nextBreak1) || self._isDoubleLineItem(nextBreak2) || self._isDoubleLineItem(nextLine)))) {
	                        if (drawThickness === 3 || drawThickness === 2) {
	                            self._adjustLine(current, {_orientation: 1, _offsetEnd: -2});
	                        } else if (drawThickness === 1) {
	                            self._adjustLine(current, {_orientation: 1, _offsetEnd: -1});
	                        }
	                    }
	                } else if (nextBreak !== keyword_null && diff >= 0) {
	                    if ((diff = self._compareLine(current, nextLine)) > 0) {
	                        drawThickness = self._getDrawingThickness(nextBreak);
	                        if (drawThickness === 3) {
	                            self._adjustLine(current, {_orientation: 1, _offsetEnd: 1});
	                        }
	                    } else if (diff !== 0) {
	                        self._adjustLine(current, {_orientation: 1, _offsetEnd: -1});
	                    }
	                }
	            }
	        };
	
	        BorderLayoutEngine._calcDoubleLayout = function (current, prevLine, prevBreak1, prevBreak2, nextLine, nextBreak1, nextBreak2, vertical) {
	            var self = BorderLayoutEngine;
	            if (vertical) {
	                this._calcLayoutVertical(current, prevLine, prevBreak1, prevBreak2, nextLine, nextBreak1, nextBreak2);
	            } else {
	                this._calcLayoutHorizontal(current, prevLine, prevBreak1, prevBreak2, nextLine, nextBreak1, nextBreak2);
	            }
	           
	            var break1DoubleLine = self._isDoubleLineItem(prevBreak1),
	                break2DoubleLine = self._isDoubleLineItem(prevBreak2),
	                prevDoubleLine = self._isDoubleLineItem(prevLine);
	            if (break1DoubleLine && break2DoubleLine && prevDoubleLine) {
	                self._layout4CrossRoad(current, prevLine, prevBreak1, prevBreak2, -1 , vertical);
	            } else if (break1DoubleLine && !break2DoubleLine) {
	                self._layout4TurnRoad(current, prevLine, nextLine, prevBreak1, prevBreak2, 1, -1 , vertical, true);
	            } else if (!break1DoubleLine && break2DoubleLine) {
	                self._layout4TurnRoad(current, prevLine, nextLine, prevBreak1, prevBreak2, 2, -1 , vertical, false);
	            } else if (break1DoubleLine && break2DoubleLine && !prevDoubleLine) { 
	                self._layout4TRoad(current, prevLine, prevBreak1, prevBreak2, -1 , vertical);
	            } else if (prevDoubleLine) {
	                self._layout4Connected(current, prevLine, prevBreak1, prevBreak2, -1 , vertical);
	            }
	           
	            break1DoubleLine = self._isDoubleLineItem(nextBreak1);
	            break2DoubleLine = self._isDoubleLineItem(nextBreak2);
	            var nextDoubleLine = self._isDoubleLineItem(nextLine);
	            if (break1DoubleLine && break2DoubleLine && nextDoubleLine) {
	                self._layout4CrossRoad(current, nextLine, nextBreak1, nextBreak2, 1 , vertical);
	            } else if (break1DoubleLine && !break2DoubleLine) {
	                self._layout4TurnRoad(current, prevLine, nextLine, nextBreak1, nextBreak2, 1, 1 , vertical, true);
	            } else if (!break1DoubleLine && break2DoubleLine) {
	                self._layout4TurnRoad(current, prevLine, nextLine, nextBreak1, nextBreak2, 2, 1 , vertical, false);
	            } else if (break1DoubleLine && break2DoubleLine && !nextDoubleLine) { 
	                self._layout4TRoad(current, nextLine, nextBreak1, nextBreak2, 1 , vertical);
	            } else if (nextDoubleLine) {
	                self._layout4Connected(current, nextLine, nextBreak1, nextBreak2, 1 , vertical);
	            }
	        };
	        BorderLayoutEngine._styleWeightCache = [
	            0,
	            101,
	            199,
	            100,
	            100,
	            300,
	            90,
	            100,
	            198,
	            100,
	            198,
	            100,
	            198,
	            198
	        ];
	        BorderLayoutEngine._compareTwoLineStyleIsSame = function (lineItem0, lineItem1) {
	            if (lineItem0 && lineItem1 && lineItem0.color === lineItem1.color && lineItem0.level === lineItem1.level && lineItem0.style === lineItem1.style) {
	                return true;
	            }
	            return false;
	        };
	        return BorderLayoutEngine;
	    })();
	   
	   
	   
	    var Borders = (function () {
	        function Borders(sheet, rowViewportIndex, colViewportIndex, sheetArea) {
	           
	           
	           
	           
	           
	           
	           
	           
	            var self = this;
	            self._isInitialized = false;
	            self._isMerged = false;
	            self._sheet = sheet;
	            self._sheetArea = sheetArea;
	            self._rowViewportIndex = rowViewportIndex;
	            self._colViewportIndex = colViewportIndex;
	        }
	
	        Borders.prototype = {
	            constructor: Borders,
	            _initialize: function () {
	               
	                var self = this;
	                self._spanCells = [];
	                self._rowIndecies = [];
	                self._colIndecies = [];
	               
	                self._overflowedCells = [];
	                self._adjustingRanges = [];
	               
	                self._hGridLine = {};
	                self._vGridLine = {};
	                self._hBorders = {};
	                self._vBorders = {};
	                self._downDiagonals = {};
	                self._upDiagonals = {};
	                self._spanCash = {};
	                var sheet = self._sheet, sheetArea = self._sheetArea, colViewportIndex = self._colViewportIndex,
	                    rowViewportIndex = self._rowViewportIndex;
	                var rowLayoutModel = sheet._getRowLayout(rowViewportIndex, sheetArea),
	                    colLayoutModel = sheet._getColumnLayout(colViewportIndex, sheetArea);
	                if (rowLayoutModel && rowLayoutModel.length > 0 && colLayoutModel && colLayoutModel.length > 0) {
	                    var rowIndecies = self._rowIndecies, rowLayoutCount = rowLayoutModel.length, rowLyout;
	                    for (var i = 0; i < rowLayoutCount; i++) {
	                        rowLyout = rowLayoutModel[i];
	                        if (rowLyout.height > 0) {
	                            rowIndecies.push(rowLyout.row);
	                        }
	                    }
	                    rowIndecies.push(rowIndecies[rowIndecies.length - 1] + 1);
	                    var colIndecies = self._colIndecies, colLayoutCount = colLayoutModel.length, colLayout;
	                    for (var j = 0; j < colLayoutCount; j++) {
	                        colLayout = colLayoutModel[j];
	                        if (colLayout.width > 0) {
	                            colIndecies.push(colLayout.col);
	                        }
	                    }
	                    colIndecies.push(colIndecies[colIndecies.length - 1] + 1);
	                }
	                self._isInitialized = true;
	            },
	            _addCellOverlfowLayout: function (row, cellOverflowLayout) {
	                if (cellOverflowLayout) {
	                    var overflowedCell = {
	                        _row: row,
	                        _startCol: cellOverflowLayout.startColumn,
	                        _endCol: cellOverflowLayout.endColumn
	                    };
	                    this._overflowedCells.push(overflowedCell);
	                }
	            },
	            _addCellLines: function (row, col, x, y, width, height, style, spanCellLayout, needTopGridline, needLeftGridline) {
	                var self = this;
	                if (!self._isInitialized) {
	                    self._initialize();
	                }
	                if (spanCellLayout) {
	                    self._spanCells.push(spanCellLayout);
	                } else {
	                    var borderLeft, borderTop, borderRight, borderBottom, diagonalDown, diagonalUp;
	                    var backColor;
	                    if (style) {
	                        borderLeft = style.borderLeft;
	                        borderTop = style.borderTop;
	                        borderRight = style.borderRight;
	                        borderBottom = style.borderBottom;
	                        backColor = style.backColor;
	                        diagonalDown = style.diagonalDown;
	                        diagonalUp = style.diagonalUp;
	                    }
	                    if (backColor && (!borderLeft && !borderRight && !borderTop && !borderBottom)) {
	                        self._adjustingRanges.push({r: row, c: col, rc: 1, cc: 1});
	                    }
	                    self._addCellLineImp(row, col, x, y, width, height, borderLeft, borderTop, borderRight, borderBottom, diagonalDown, diagonalUp, backColor, false, false, needTopGridline, needLeftGridline);
	                }
	            },
	            _addCellLineImp: function (row, col, x, y, width, height, borderLeft, borderTop, borderRight, borderBottom, diagonalDown, diagonalUp, backColor, noHGridLine, noVGridLine, needTopGridline, needLeftGridline) {
	                var self = this;
	                var addTopLineSucceeded = false, addLeftLineSucceeded = false, addBottomLineSucceeded = false,
	                    addRightLineSucceeded = false;
	                if (diagonalDown) {
	                    self._addCellLineSide(row, col, x - 1, y - 1, x + width, y + height, diagonalDown, self._downDiagonals);
	                }
	                if (diagonalUp) {
	                    self._addCellLineSide(row, col, x + width, y - 1, x - 1, y + height, diagonalUp, self._upDiagonals);
	                }
	                if (borderTop) {
	                    addTopLineSucceeded = self._addCellLineSide(row, col, x, y - 0.5, x + width, y - 0.5, borderTop, self._hBorders);
	                }
	                if (borderLeft) {
	                    addLeftLineSucceeded = self._addCellLineSide(row, col, x - 0.5, y, x - 0.5, y + height, borderLeft, self._vBorders);
	                }
	                if (borderBottom) {
	                    addBottomLineSucceeded = self._addCellLineSide(row + 1, col, x, y + height - 0.5, x + width, y + height - 0.5, borderBottom, self._hBorders);
	                }
	                if (borderRight) {
	                    addRightLineSucceeded = self._addCellLineSide(row, col + 1, x + width - 0.5, y, x + width - 0.5, y + height, borderRight, self._vBorders);
	                }
	                var sheet = self._sheet;
	                if (!backColor || sheet._cachePool._getZoomRowHeight(row) === 0 || sheet._cachePool._getZoomColWidth(col) === 0) {
	                    var needRenderBottomGridLine = !addBottomLineSucceeded && !noHGridLine,
	                        needRenderRightGridLine = !addRightLineSucceeded && !noVGridLine,
	                        needRenderTopGridLine = !addTopLineSucceeded && !noHGridLine,
	                        needRenderLeftGridLine = !addLeftLineSucceeded && !noVGridLine;
	                    if (needRenderBottomGridLine || needRenderRightGridLine || needRenderTopGridLine || needRenderLeftGridLine) {
	                        self._addGridLine(row, col, x, y, width, height, needRenderBottomGridLine, needRenderRightGridLine, needTopGridline, needLeftGridline);
	                    }
	                }
	                if (addTopLineSucceeded || backColor) {
	                    self._removeLineItem(row - 1, col, self._hGridLine);
	                }
	                if (addLeftLineSucceeded || backColor) {
	                    self._removeLineItem(row, col - 1, self._vGridLine);
	                }
	
	                if (backColor && (!borderLeft && !borderRight && !borderTop && !borderBottom)) {
	                    self._adjustLineItem(row - 1, col - 1, self._vGridLine, false);
	                    self._adjustLineItem(row - 1, col - 1, self._hGridLine, true);
	                }
	            },
	            _addCellLineSide: function (row, col, x, y, width, height, lineStyle, store) {
	                if (lineStyle) {
	                    var borderLine = this._queryLineItem(row, col, store, true);
	                    if (borderLine) {
	                        if (borderLine.style.style !== 6  && (lineStyle.style === 6  || BorderLayoutEngine._compareLineStyle(lineStyle, borderLine.style) > 0)) {
	                            borderLine.line = createLine(x, y, width, height, lineStyle.color, lineStyle.style);
	                            borderLine.style = lineStyle;
	                        }
	                    } else {
	                        borderLine = this._queryLineItem(row, col, store);
	                        borderLine.line = createLine(x, y, width, height, lineStyle.color, lineStyle.style);
	                        borderLine.style = lineStyle;
	                    }
	                    return borderLine.line !== keyword_null;
	                }
	                return false;
	            },
	            _addGridLine: function (row, col, x, y, width, height, needBottomLine, needRightLine, needTopLine, needLeftLine) {
	                var self = this;
	                var atViewport = (self._sheetArea === 3 );
	                var gridLine = self._sheet.options.gridline;
	                if (atViewport && gridLine) {
	                    var gridLineColor = gridLine.color;
	                    if (gridLine.showHorizontalGridline) {
	                        if (needBottomLine) {
	                            var hGridLineItem = self._queryLineItem(row, col, self._hGridLine);
	                            hGridLineItem.isGridLine = true;
	                            hGridLineItem.line = createLine(x, y + height - 0.5, x + width, y + height - 0.5, gridLineColor);
	                        }
	
	                        if (needTopLine) {
	                            var hGridLineItemForFirstCol = self._queryLineItem(-1, col, self._hGridLine, false, true);
	                            hGridLineItemForFirstCol.isGridLine = true;
	                            hGridLineItemForFirstCol.line = createLine(x, y - 0.5, x + width, y - 0.5, gridLineColor);
	                        }
	                    }
	                    if (gridLine.showVerticalGridline) {
	                        if (needRightLine) {
	                            var vGridLineItem = self._queryLineItem(row, col, self._vGridLine);
	                            vGridLineItem.isGridLine = true;
	                            vGridLineItem.line = createLine(x + width - 0.5, y, x + width - 0.5, y + height, gridLineColor);
	                        }
	
	                        if (needLeftLine) {
	                            var vGridLineItemForFirstRow = self._queryLineItem(row, -1, self._vGridLine, false, true);
	                            vGridLineItemForFirstRow.isGridLine = true;
	                            vGridLineItemForFirstRow.line = createLine(x - 0.5, y, x - 0.5, y + height, gridLineColor);
	                        }
	                    }
	                }
	            },
	            _adjustLineItem: function (r, c, store, h) {
	                var query = this._queryLineItem(r, c, store, true);
	                if (query) {
	                    var lineItem = query;
	                    if (lineItem.line) {
	                        lineItem.line._adjust({_orientation: (h ? 0 : 1), _offsetEnd: -1});
	                    }
	                }
	            },
	            _removeLineItem: function (r, c, store) {
	                if ((r >= 0 && c >= 0) ||
	                    (r === 0 && c === -1) ||   
	                    (r === -1 && c === 0)) {
	                    var firstDim = store[r];
	                    if (firstDim) {
	                        var secondDim = firstDim[c];
	                        if (secondDim) {
	                            delete firstDim[c];
	                        }
	                    }
	                }
	            },
	            _queryLineItem: function (r, c, store, noCreate, isTopLeftGridline) {
	                if (!isTopLeftGridline && (r === -1 || c === -1)) {
	                    return keyword_null;
	                }
	                var firstDim = store[r];
	                if (!firstDim) {
	                    if (noCreate) {
	                        return keyword_null;
	                    }
	                    store[r] = firstDim = {};
	                }
	                var secondDim = firstDim[c];
	                if (!secondDim) {
	                    if (noCreate) {
	                        return keyword_null;
	                    }
	                    firstDim[c] = secondDim = {};
	                }
	                return secondDim;
	            },
	            _processOverflowCells: function () {
	                var self = this;
	                var overflowedCells = self._overflowedCells, overflowedCellsCount = overflowedCells.length,
	                    vBorders = self._vBorders, vGridLine = self._vGridLine;
	                for (var i = 0; i < overflowedCellsCount; i++) {
	                    var overflowCell = overflowedCells[i], r = overflowCell._row, sc = overflowCell._startCol,
	                        ec = overflowCell._endCol, query;
	                    for (var c = sc; c < ec; c++) {
	                        query = self._queryLineItem(r, c + 1, vBorders, true);
	                        if (query) {
	                            self._removeLineItem(r, c + 1, vBorders);
	                        } else {
	                            query = self._queryLineItem(r, c, vGridLine, true);
	                            if (query) {
	                                self._removeLineItem(r, c, vGridLine);
	                            }
	                        }
	                    }
	                }
	            },
	            _processSpans: function () {
	                var spanCells = this._spanCells, spanCellsCount = spanCells.length, spanLayout;
	                if (spanCellsCount > 0) {
	                    for (var i = 0; i < spanCellsCount; i++) {
	                        spanLayout = spanCells[i];
	                        this._processSpanCell(spanLayout);
	                    }
	                }
	            },
	            _createSpanCash: function () {
	                this._spanCash = {};
	                var spanCells = this._spanCells, spanCellsCount = spanCells.length, spanLayout;
	                if (spanCellsCount > 0) {
	                    for (var i = 0; i < spanCellsCount; i++) {
	                        spanLayout = spanCells[i];
	                        for (var row = 0; row < spanLayout.rowCount; row++) {
	                            var rowIndex = row + spanLayout.row;
	                            this._spanCash[rowIndex] = this._spanCash[rowIndex] || {};
	                            for (var col = 0; col < spanLayout.colCount; col++) {
	                                var colIndex = col + spanLayout.col;
	                                this._spanCash[rowIndex][colIndex] = spanLayout;
	                            }
	                        }
	                    }
	                }
	            },
	            _processSpanCell: function (spanCellLayout) {
	                var self = this;
	               
	                var row = spanCellLayout.row, col = spanCellLayout.col;
	                var x = spanCellLayout.x, y = spanCellLayout.y;
	                var borderLeft, borderTop, borderRight, borderBottom;
	               
	                var spanCellStyle = self._sheet.getActualStyle(row, col, self._sheetArea);
	                var backColor = spanCellStyle ? spanCellStyle.backColor : keyword_null;
	                var i, r, c, rowHeight, colWidth, firstCol, firstRow, lastCol, lastRow, cellStyle;
	                var ix = x, iy = y;
	                var diagonalDownStyle = null, isNeedCompareDiagonalDownStyle = true;
	                var diagonalUpStyle = null, isNeedCompareDiagonalUpStyle = true;
	                var beginCellStyle;
	               
	                if (spanCellLayout.rowCount === 1) {
	                    r = row;
	                    rowHeight = self._sheet._getZoomRowHeight(r, self._sheetArea);
	                    for (i = 0; i < spanCellLayout.colCount; i++) {
	                        firstCol = (i === 0);
	                        lastCol = (i === spanCellLayout.colCount - 1);
	                        c = col + i;
	                        colWidth = self._sheet._getZoomColumnWidth(c, self._sheetArea);
	                        cellStyle = self._sheet.getActualStyle(r, c, self._sheetArea);
	                        if (r === spanCellLayout.row && c === spanCellLayout.col) {
	                            beginCellStyle = cellStyle;
	                            diagonalDownStyle = beginCellStyle.diagonalDown;
	                            diagonalUpStyle = beginCellStyle.diagonalUp;
	                        }
	                        if (cellStyle) {
	                            borderLeft = cellStyle.borderLeft;
	                            borderTop = cellStyle.borderTop;
	                            borderRight = cellStyle.borderRight;
	                            borderBottom = cellStyle.borderBottom;
	                            if (isNeedCompareDiagonalDownStyle) {
	                                isNeedCompareDiagonalDownStyle = BorderLayoutEngine._compareTwoLineStyleIsSame(diagonalDownStyle, cellStyle.diagonalDown);
	                            }
	                            if (isNeedCompareDiagonalUpStyle) {
	                                isNeedCompareDiagonalUpStyle = BorderLayoutEngine._compareTwoLineStyleIsSame(diagonalUpStyle, cellStyle.diagonalUp);
	                            }
	                        } else {
	                            borderLeft = borderTop = borderRight = borderBottom = keyword_null;
	                        }
	                        if (firstCol) {
	                            self._addCellLineImp(r, c, ix, iy, colWidth, rowHeight, borderLeft, borderTop, keyword_null, borderBottom, keyword_null, keyword_null, backColor, false, true);
	                        } else if (lastCol) {
	                            self._addCellLineImp(r, c, ix, iy, colWidth, rowHeight, keyword_null, borderTop, borderRight, borderBottom, keyword_null, keyword_null, backColor, false, false);
	                        } else {
	                            self._addCellLineImp(r, c, ix, iy, colWidth, rowHeight, keyword_null, borderTop, keyword_null, borderBottom, keyword_null, keyword_null, backColor, false, true);
	                        }
	                        ix += colWidth;
	                    }
	                    diagonalDownStyle = isNeedCompareDiagonalDownStyle ? diagonalDownStyle : null;
	                    diagonalUpStyle = isNeedCompareDiagonalUpStyle ? diagonalUpStyle : null;
	                    self._addCellLineImp(spanCellLayout.row, spanCellLayout.col, spanCellLayout.x, spanCellLayout.y, spanCellLayout.width, spanCellLayout.height, keyword_null, keyword_null, keyword_null, keyword_null, diagonalDownStyle, diagonalUpStyle, keyword_null, true, true);
	                } else if (spanCellLayout.colCount === 1) {
	                    c = col;
	                    colWidth = self._sheet._getZoomColumnWidth(c, self._sheetArea);
	                    for (i = 0; i < spanCellLayout.rowCount; i++) {
	                        firstRow = (i === 0);
	                        lastRow = (i === spanCellLayout.rowCount - 1);
	                        r = row + i;
	                        rowHeight = self._sheet._getZoomRowHeight(r, self._sheetArea);
	                        cellStyle = self._sheet.getActualStyle(r, c, self._sheetArea);
	                        if (r === spanCellLayout.row && c === spanCellLayout.col) {
	                            beginCellStyle = cellStyle;
	                            diagonalDownStyle = beginCellStyle.diagonalDown;
	                            diagonalUpStyle = beginCellStyle.diagonalUp;
	                        }
	                        if (cellStyle) {
	                            borderLeft = cellStyle.borderLeft;
	                            borderTop = cellStyle.borderTop;
	                            borderRight = cellStyle.borderRight;
	                            borderBottom = cellStyle.borderBottom;
	                            if (isNeedCompareDiagonalDownStyle) {
	                                isNeedCompareDiagonalDownStyle = BorderLayoutEngine._compareTwoLineStyleIsSame(diagonalDownStyle, cellStyle.diagonalDown);
	                            }
	                            if (isNeedCompareDiagonalUpStyle) {
	                                isNeedCompareDiagonalUpStyle = BorderLayoutEngine._compareTwoLineStyleIsSame(diagonalUpStyle, cellStyle.diagonalUp);
	                            }
	                        } else {
	                            borderLeft = borderTop = borderRight = borderBottom = keyword_null;
	                        }
	                        if (firstRow) {
	                            self._addCellLineImp(r, c, ix, iy, colWidth, rowHeight, borderLeft, borderTop, borderRight, keyword_null, keyword_null, keyword_null, backColor, true, false);
	                        } else if (lastRow) {
	                            self._addCellLineImp(r, c, ix, iy, colWidth, rowHeight, borderLeft, keyword_null, borderRight, borderBottom, keyword_null, keyword_null, backColor, false, false);
	                        } else {
	                            self._addCellLineImp(r, c, ix, iy, colWidth, rowHeight, borderLeft, keyword_null, borderRight, keyword_null, keyword_null, keyword_null, backColor, true, false);
	                        }
	                        iy += rowHeight;
	                    }
	                    diagonalDownStyle = isNeedCompareDiagonalDownStyle ? diagonalDownStyle : null;
	                    diagonalUpStyle = isNeedCompareDiagonalUpStyle ? diagonalUpStyle : null;
	                    self._addCellLineImp(spanCellLayout.row, spanCellLayout.col, spanCellLayout.x, spanCellLayout.y, spanCellLayout.width, spanCellLayout.height, keyword_null, keyword_null, keyword_null, keyword_null, diagonalDownStyle, diagonalUpStyle, keyword_null, true, true);
	                } else {
	                    for (i = 0; i < spanCellLayout.rowCount; i++) {
	                        r = row + i;
	                        firstRow = (i === 0);
	                        lastRow = (i === spanCellLayout.rowCount - 1);
	                        rowHeight = self._sheet._getZoomRowHeight(r, self._sheetArea);
	                        for (var j = 0; j < spanCellLayout.colCount; j++) {
	                            c = col + j;
	                            firstCol = (j === 0);
	                            lastCol = (j === spanCellLayout.colCount - 1);
	                            colWidth = self._sheet._getZoomColumnWidth(c, self._sheetArea);
	                            cellStyle = self._sheet.getActualStyle(r, c, self._sheetArea);
	                            if (r === spanCellLayout.row && c === spanCellLayout.col) {
	                                beginCellStyle = cellStyle;
	                                diagonalDownStyle = beginCellStyle.diagonalDown;
	                                diagonalUpStyle = beginCellStyle.diagonalUp;
	                            }
	                            if (cellStyle) {
	                                borderLeft = cellStyle.borderLeft;
	                                borderTop = cellStyle.borderTop;
	                                borderRight = cellStyle.borderRight;
	                                borderBottom = cellStyle.borderBottom;
	                                if (isNeedCompareDiagonalDownStyle) {
	                                    isNeedCompareDiagonalDownStyle = BorderLayoutEngine._compareTwoLineStyleIsSame(diagonalDownStyle, cellStyle.diagonalDown);
	                                }
	                                if (isNeedCompareDiagonalUpStyle) {
	                                    isNeedCompareDiagonalUpStyle = BorderLayoutEngine._compareTwoLineStyleIsSame(diagonalUpStyle, cellStyle.diagonalUp);
	                                }
	                            } else {
	                                borderLeft = borderTop = borderRight = borderBottom = keyword_null;
	                            }
	                            if (firstRow) {
	                                if (firstCol) {
	                                    self._addCellLineImp(r, c, ix, iy, colWidth, rowHeight, borderLeft, borderTop, keyword_null, keyword_null, keyword_null, keyword_null, backColor, true, true);
	                                } else if (lastCol) {
	                                    self._addCellLineImp(r, c, ix, iy, colWidth, rowHeight, keyword_null, borderTop, borderRight, keyword_null, keyword_null, keyword_null, backColor, true, false);
	                                } else {
	                                    self._addCellLineImp(r, c, ix, iy, colWidth, rowHeight, keyword_null, borderTop, keyword_null, keyword_null, keyword_null, keyword_null, backColor, true, true);
	                                }
	                            } else if (lastRow) {
	                                if (firstCol) {
	                                    self._addCellLineImp(r, c, ix, iy, colWidth, rowHeight, borderLeft, keyword_null, keyword_null, borderBottom, keyword_null, keyword_null, backColor, false, true);
	                                } else if (lastCol) {
	                                    self._addCellLineImp(r, c, ix, iy, colWidth, rowHeight, keyword_null, keyword_null, borderRight, borderBottom, keyword_null, keyword_null, backColor, false, false);
	                                } else {
	                                    self._addCellLineImp(r, c, ix, iy, colWidth, rowHeight, keyword_null, keyword_null, keyword_null, borderBottom, keyword_null, keyword_null, backColor, false, true);
	                                }
	                            } else if (firstCol) {
	                                self._addCellLineImp(r, c, ix, iy, colWidth, rowHeight, borderLeft, keyword_null, keyword_null, keyword_null, keyword_null, keyword_null, backColor, true, true);
	                            } else if (lastCol) {
	                                self._addCellLineImp(r, c, ix, iy, colWidth, rowHeight, keyword_null, keyword_null, borderRight, keyword_null, keyword_null, keyword_null, backColor, true, false);
	                            }
	                            ix += colWidth;
	                        }
	                        ix = x;
	                        iy += rowHeight;
	                    }
	                    diagonalDownStyle = isNeedCompareDiagonalDownStyle ? diagonalDownStyle : null;
	                    diagonalUpStyle = isNeedCompareDiagonalUpStyle ? diagonalUpStyle : null;
	                    self._addCellLineImp(spanCellLayout.row, spanCellLayout.col, spanCellLayout.x, spanCellLayout.y, spanCellLayout.width, spanCellLayout.height, keyword_null, keyword_null, keyword_null, keyword_null, diagonalDownStyle, diagonalUpStyle, keyword_null, true, true);
	                }
	                if (backColor && (!borderLeft && !borderRight && !borderTop && !borderBottom)) {
	                    self._adjustingRanges.push({
	                        r: row,
	                        c: col,
	                        rc: spanCellLayout.rowCount,
	                        cc: spanCellLayout.colCount
	                    });
	                }
	            },
	            _adjust: function () {
	               
	                var self = this;
	                var hasVBorders = false, hasHBorders = false;
	                var hasDownDiagonals = false, hasUpDiagonals = false;
	                if (!$_isEmptyObject(self._vBorders)) {
	                    hasVBorders = true;
	                }
	                if (!$_isEmptyObject(self._hBorders)) {
	                    hasHBorders = true;
	                }
	                if (hasVBorders || hasHBorders) {
	                    self._adjustBorders();
	                   
	                    self._adjustDoubleLineBordersWithDiagonalDoubleLine();
	                }
	                if (!$_isEmptyObject(self._downDiagonals)) {
	                    hasDownDiagonals = true;
	                }
	                if (!$_isEmptyObject(self._upDiagonals)) {
	                    hasUpDiagonals = true;
	                }
	                if (hasDownDiagonals || hasUpDiagonals) {
	                    self._adjustDiagonal();
	                }
	                if (self._adjustingRanges.length > 0) {
	                    self._adjustGridlines();
	                }
	            },
	            
	            _getSpanBorderLineWith: function (row, col, vertical, cache, borderPosition) {
	                var self = this;
	                var span = this._spanCash[row] ? this._spanCash[row][col] : null;
	                if (span) {
	                    switch (borderPosition) {
	                        case SPAN_BORDER_POSITION.H_TOP_LEFT:
	                            return self._getLineItem(row, col, vertical, cache);
	                        case SPAN_BORDER_POSITION.H_TOP_Right:
	                            return self._getLineItem(row, col + span.colCount - 1, vertical, cache);
	                        case SPAN_BORDER_POSITION.V_RIGHT_TOP:
	                            return self._getLineItem(row, col + span.colCount, vertical, cache);
	                        case SPAN_BORDER_POSITION.V_RIGHT_BOTTOM:
	                            return self._getLineItem(row + span.rowCount - 1, col + span.colCount, vertical, cache);
	                        case SPAN_BORDER_POSITION.H_BOTTOM_RIGHT:
	                            return self._getLineItem(row + span.rowCount, col + span.colCount - 1, vertical, cache);
	                        case SPAN_BORDER_POSITION.H_BOTTOM_LEFT:
	                            return self._getLineItem(row + span.rowCount, col, vertical, cache);
	                        case SPAN_BORDER_POSITION.V_LEFT_BOTTOM:
	                            return self._getLineItem(row + span.rowCount - 1, col, vertical, cache);
	                        case SPAN_BORDER_POSITION.V_LEFT_TOP:
	                            return self._getLineItem(row, col, vertical, cache);
	                    }
	                }
	                return self._getLineItem(row, col, vertical, cache);
	            },
	            _adjustDiagonal: function () {
	                var self = this;
	                var rowIndecies = self._rowIndecies, colIndecies = self._colIndecies,
	                    rowIndexCount = rowIndecies.length, colIndexCount = colIndecies.length, r, c, row, col,
	                    topLine, leftLine, bottomLine, rightLine, cacheTop = {}, cacheLeft = {},
	                    topLine1, leftLine1, bottomLine1, rightLine1;
	                for (r = 0; r < rowIndexCount; r++) {
	                    row = rowIndecies[r];
	                    for (c = 0; c < colIndexCount; c++) {
	                       
	                        col = colIndecies[c];
	                        var diagonalDown = self._queryLineItem(row, col, self._downDiagonals, false);
	                        var diagonalUp = self._queryLineItem(row, col, self._upDiagonals, false);
	                        if (!diagonalDown && !diagonalUp) {
	                            continue;
	                        }
	                        if (BorderLayoutEngine._isDoubleLineItem(diagonalDown) && BorderLayoutEngine._isDoubleLineItem(diagonalUp)) {
	                           
	                            diagonalDown.line._adjustSever();
	                            diagonalUp.line._adjustSever();
	                        }
	                       
	                        var adjustLength = [];
	                        topLine = self._getSpanBorderLineWith(row, col, false, cacheTop, SPAN_BORDER_POSITION.H_TOP_LEFT);
	                        if (topLine && topLine.line && !topLine.isGridLine) {
	                            adjustLength = [1, 1, 2];
	                            self._adjustDiagonalImp(adjustLength, topLine, diagonalDown, true, 1);
	                        }
	                        topLine1 = self._getSpanBorderLineWith(row, col, false, cacheTop, SPAN_BORDER_POSITION.H_TOP_Right);
	                        if (topLine1 && topLine1.line && !topLine1.isGridLine) {
	                            adjustLength = [1, 1, 2];
	                            self._adjustDiagonalImp(adjustLength, topLine1, diagonalUp, true, 1);
	                        }
	                        leftLine = self._getSpanBorderLineWith(row, col, true, cacheLeft, SPAN_BORDER_POSITION.V_LEFT_TOP);
	                        if (leftLine && leftLine.line && !leftLine.isGridLine) {
	                            adjustLength = [1, 1, 2];
	                            self._adjustDiagonalImp(adjustLength, leftLine, diagonalDown, true, 0);
	                        }
	                        leftLine1 = self._getSpanBorderLineWith(row, col, true, cacheLeft, SPAN_BORDER_POSITION.V_LEFT_BOTTOM);
	                        if (leftLine1 && leftLine1.line && !leftLine1.isGridLine) {
	                            adjustLength = [1, 1, 2];
	                            self._adjustDiagonalImp(adjustLength, leftLine1, diagonalUp, false, 0);
	                        }
	                        bottomLine = self._getSpanBorderLineWith(row, col, false, cacheTop, SPAN_BORDER_POSITION.H_BOTTOM_LEFT);
	                        if (bottomLine && bottomLine.line && !bottomLine.isGridLine) {
	                            adjustLength = [-1, -2, -2];
	                            self._adjustDiagonalImp(adjustLength, bottomLine, diagonalUp, false, 1);
	                        }
	                        bottomLine1 = self._getSpanBorderLineWith(row, col, false, cacheTop, SPAN_BORDER_POSITION.H_BOTTOM_RIGHT);
	                        if (bottomLine1 && bottomLine1.line && !bottomLine1.isGridLine) {
	                            adjustLength = [-1, -2, -2];
	                            self._adjustDiagonalImp(adjustLength, bottomLine1, diagonalDown, false, 1);
	                        }
	                        rightLine = self._getSpanBorderLineWith(row, col, true, cacheLeft, SPAN_BORDER_POSITION.V_RIGHT_TOP);
	                        if (rightLine && rightLine.line && !rightLine.isGridLine) {
	                            adjustLength = [-1, -2, -2];
	                            self._adjustDiagonalImp(adjustLength, rightLine, diagonalUp, true, 0);
	                        }
	                        rightLine1 = self._getSpanBorderLineWith(row, col, true, cacheLeft, SPAN_BORDER_POSITION.V_RIGHT_BOTTOM);
	                        if (rightLine1 && rightLine1.line && !rightLine1.isGridLine) {
	                            adjustLength = [-1, -2, -2];
	                            self._adjustDiagonalImp(adjustLength, rightLine1, diagonalDown, false, 0);
	                        }
	                    }
	                }
	            },
	
	            _adjustDiagonalImp: function (lengthArray, compareLine, diagonalLine, diagonalLineIsStart, orientation) {
	                var borderIsDoubleLine = BorderLayoutEngine._isDoubleLineItem(compareLine);
	                var isSlantedLine = BorderLayoutEngine._isSlantedLine(compareLine);
	                var lineWidth = compareLine.line._lineWidth;
	                if (borderIsDoubleLine) {
	                    lineWidth = 3;
	                }
	                if (isSlantedLine) {
	                    lineWidth = 2;
	                }
	               
	                var length = lengthArray[lineWidth - 1];
	                var option;
	                if (diagonalLine && diagonalLine.line) {
	                    option = {_orientation: orientation};
	                    if (diagonalLineIsStart) {
	                        option._offsetStart = length;
	                    } else {
	                        option._offsetEnd = length;
	                    }
	                    diagonalLine.line._adjust(option);
	                }
	            },
	            _adjustGridlines: function () {
	                var self = this;
	                var adjustingRanges = self._adjustingRanges, adjustingRangesCount = adjustingRanges.length;
	                for (var i = 0; i < adjustingRangesCount; i++) {
	                    var range = adjustingRanges[i];
	                    var r = range.r, c = range.c;
	                    var ar1 = r, ar2 = r - 1;
	                    var ac1 = c - 1, ac2 = c;
	                    if (range.rc > 1) {
	                        ar1 += range.rc - 1;
	                    }
	                    if (range.cc > 1) {
	                        ac2 += range.cc - 1;
	                    }
	                    var skipLeftBottom = false, skipRightTop = false;
	                   
	                   
	                    for (var j = i + 1; j < adjustingRangesCount; j++) {
	                        var next = adjustingRanges[j];
	                        if (next.c === ac2 + 1 && next.r === r) {
	                            skipRightTop = true;
	                        }
	                        if (next.r === ar1 + 1 && next.c === c) {
	                            skipLeftBottom = true;
	                        }
	                        if (skipLeftBottom && skipRightTop) {
	                            break;
	                        }
	                        if (next.r > r + 1 && next.c > c + 1) {
	                            break;
	                        }
	                    }
	                    if (!skipLeftBottom) {
	                        self._adjustLineItem(ar1, ac1, self._hGridLine, true);
	                    }
	                    if (!skipRightTop) {
	                        self._adjustLineItem(ar2, ac2, self._vGridLine, false);
	                    }
	                }
	            },
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	            _adjustBorders: function () {
	                var self = this;
	                var rowIndecies = self._rowIndecies, colIndecies = self._colIndecies,
	                    rowIndexCount = rowIndecies.length,
	                    colIndexCount = colIndecies.length, r, c, row, col, cacheH = {}, cacheV = {},
	                    upV, leftH, currentH, currentV, downV, downLeftH, downH, rightH, upRightV, rightV,
	                    borderLineCountV, borderLineCountH;
	                for (r = 0; r < rowIndexCount; r++) {
	                    row = rowIndecies[r];
	                    for (c = 0; c < colIndexCount; c++) {
	                        col = colIndecies[c];
	                        borderLineCountV = 0;
	                        borderLineCountH = 0;
	                        var lineV = self._queryLineItem(row, col, self._vBorders, true);
	                        if (!lineV) {
	                            lineV = self._queryLineItem(row, col - 1, self._vGridLine, true);
	                        } else {
	                            borderLineCountV++;
	                        }
	                        var lineH = self._queryLineItem(row, col, self._hBorders, true);
	                        if (!lineH) {
	                            lineH = self._queryLineItem(row - 1, col, self._hGridLine, true);
	                        } else {
	                            borderLineCountH++;
	                        }
	                        if (!lineV && !lineH) {
	                            continue;
	                        }
	                        upV = r === 0 ? keyword_null : self._getLineItem(rowIndecies[r - 1], col, true, cacheV);
	                        if (upV && upV.line && !upV.isGridLine) {
	                            borderLineCountV++;
	                            borderLineCountH++;
	                        }
	                        leftH = c === 0 ? keyword_null : self._getLineItem(row, colIndecies[c - 1], false, cacheH);
	                        if (leftH && leftH.line && !leftH.isGridLine) {
	                            borderLineCountV++;
	                            borderLineCountH++;
	                        }
	                        if (lineV) {
	                            currentH = self._getLineItem(row, col, false, cacheH);
	                            if (currentH && currentH.line && !currentH.isGridLine) {
	                                borderLineCountV++;
	                            }
	                            if (r !== rowIndexCount - 1) {
	                                downV = self._getLineItem(rowIndecies[r + 1], col, true, cacheV);
	                                if (downV && downV.line && !downV.isGridLine) {
	                                    borderLineCountV++;
	                                }
	                            }
	                            if (c !== 0 && r !== rowIndexCount - 1) {
	                                downLeftH = self._getLineItem(rowIndecies[r + 1], colIndecies[c - 1], false, cacheH);
	                                if (downLeftH && downLeftH.line && !downLeftH.isGridLine) {
	                                    borderLineCountV++;
	                                }
	                            }
	                            if (r !== rowIndexCount - 1) {
	                                downH = self._getLineItem(rowIndecies[r + 1], col, false, cacheH);
	                                if (downH && downH.line && !downH.isGridLine) {
	                                    borderLineCountV++;
	                                }
	                            }
	                            if (borderLineCountV > 0) {
	                                if (BorderLayoutEngine._isDoubleLine(lineV.style)) {
	                                   
	                                    BorderLayoutEngine._calcDoubleLayout(lineV, upV, leftH, currentH, downV, downLeftH, downH, true);
	                                } else if (BorderLayoutEngine._isSlantedLine(lineV.style)) {
	                                   
	                                } else {
	                                   
	                                    BorderLayoutEngine._calcLayoutVertical(lineV, upV, leftH, currentH, downV, downLeftH, downH);
	                                }
	                            }
	                        }
	                        if (lineH) {
	                            currentV = self._getLineItem(row, col, true, cacheV);
	                            if (currentV && currentV.line && !currentV.isGridLine) {
	                                borderLineCountH++;
	                            }
	                            if (c !== colIndexCount - 1) {
	                                rightH = self._getLineItem(row, colIndecies[c + 1], false, cacheH);
	                                if (rightH && rightH.line && !rightH.isGridLine) {
	                                    borderLineCountH++;
	                                }
	                            }
	                            if (r !== 0 && c !== colIndexCount - 1) {
	                                upRightV = self._getLineItem(rowIndecies[r - 1], colIndecies[c + 1], true, cacheV);
	                                if (upRightV && upRightV.line && !upRightV.isGridLine) {
	                                    borderLineCountH++;
	                                }
	                            }
	                            if (c !== colIndexCount - 1) {
	                                rightV = self._getLineItem(row, colIndecies[c + 1], true, cacheV);
	                                if (rightV && rightV.line && !rightV.isGridLine) {
	                                    borderLineCountH++;
	                                }
	                            }
	                            if (borderLineCountH > 0) {
	                                if (BorderLayoutEngine._isDoubleLine(lineH.style)) {
	                                   
	                                    BorderLayoutEngine._calcDoubleLayout(lineH, leftH, upV, currentV, rightH, upRightV, rightV, false);
	                                } else if (BorderLayoutEngine._isSlantedLine(lineH.style)) {
	                                   
	                                } else {
	                                   
	                                    BorderLayoutEngine._calcLayoutHorizontal(lineH, leftH, upV, currentV, rightH, upRightV, rightV);
	                                }
	                            }
	                        }
	                    }
	                }
	            },
	            _getSpanDiagonals: function (row, col, isDiagonalUp, pointPosition) {
	                var self = this;
	                var span = this._spanCash[row] ? this._spanCash[row][col] : null;
	                var store = isDiagonalUp ? self._upDiagonals : self._downDiagonals;
	                if (span) {
	                    if (row === span.row && col === span.col && pointPosition === SPAN_POINT_POSITION.LEFT_TOP) {
	                        return self._queryLineItem(span.row, span.col, store, false);
	                    } else if (row === span.row && col === span.col + span.colCount - 1 && pointPosition === SPAN_POINT_POSITION.RIGHT_TOP) {
	                        return self._queryLineItem(span.row, span.col, store, false);
	                    } else if (row === span.row + span.rowCount - 1 && col === span.col + span.colCount - 1 && pointPosition === SPAN_POINT_POSITION.RIGHT_BOTTOM) {
	                        return self._queryLineItem(span.row, span.col, store, false);
	                    } else if (row === span.row + span.rowCount - 1 && col === span.col && pointPosition === SPAN_POINT_POSITION.LEFT_BOTTOM) {
	                        return self._queryLineItem(span.row, span.col, store, false);
	                    }
	                } else {
	                    return self._queryLineItem(row, col, store, false);
	                }
	            },
	            _adjustDoubleLineBordersWithDiagonalDoubleLine: function () {
	                var self = this;
	                var rowIndecies = self._rowIndecies, colIndecies = self._colIndecies,
	                    rowIndexCount = rowIndecies.length,
	                    colIndexCount = colIndecies.length, r, c, row, col,
	                    diagonalDown, diagonalUp, downDiagonalIsDoubleLine, upDiagonalIsDoubleLine,
	                    beforeDownDiagonal, beforeUpDiagonal, beforeDownDiagonalIsDoubleLine, beforeUpDiagonalIsDoubleLine,
	                    option;
	                for (r = 0; r < rowIndexCount; r++) {
	                    row = rowIndecies[r];
	                    for (c = 0; c < colIndexCount; c++) {
	                        col = colIndecies[c];
	                        var lineV = self._queryLineItem(row, col, self._vBorders, true);
	                        if (lineV && lineV.line && BorderLayoutEngine._isDoubleLineItem(lineV)) {
	                            diagonalDown = self._getSpanDiagonals(row, col, false, SPAN_POINT_POSITION.LEFT_TOP);
	                            diagonalUp = self._getSpanDiagonals(row, col, true, SPAN_POINT_POSITION.LEFT_BOTTOM);
	                            downDiagonalIsDoubleLine = BorderLayoutEngine._isDoubleLineItem(diagonalDown);
	                            upDiagonalIsDoubleLine = BorderLayoutEngine._isDoubleLineItem(diagonalUp);
	
	                            beforeDownDiagonal = self._getSpanDiagonals(row, (col - 1), false, SPAN_POINT_POSITION.RIGHT_BOTTOM);
	                            beforeUpDiagonal = self._getSpanDiagonals(row, (col - 1), true, SPAN_POINT_POSITION.RIGHT_TOP);
	                            beforeDownDiagonalIsDoubleLine = BorderLayoutEngine._isDoubleLineItem(beforeDownDiagonal);
	                            beforeUpDiagonalIsDoubleLine = BorderLayoutEngine._isDoubleLineItem(beforeUpDiagonal);
	                            if (diagonalDown && downDiagonalIsDoubleLine) {
	                                
	                                option = {_lineSide: 2, _orientation: 1, _offsetStart: 2};
	                                lineV.line._adjust(option);
	                            }
	                            if (diagonalUp && upDiagonalIsDoubleLine) {
	                                option = {_lineSide: 2, _orientation: 1, _offsetEnd: -2};
	                                lineV.line._adjust(option);
	                            }
	                            if (beforeDownDiagonal && beforeDownDiagonalIsDoubleLine) {
	                                option = {_lineSide: 1, _orientation: 1, _offsetEnd: -2};
	                                lineV.line._adjust(option);
	                            }
	                            if (beforeUpDiagonal && beforeUpDiagonalIsDoubleLine) {
	                                option = {_lineSide: 1, _orientation: 1, _offsetStart: 2};
	                                lineV.line._adjust(option);
	                            }
	                        }
	                        var lineH = self._queryLineItem(row, col, self._hBorders, true);
	                        if (lineH && lineH.line && BorderLayoutEngine._isDoubleLineItem(lineH)) {
	                            diagonalDown = self._getSpanDiagonals(row, col, false, SPAN_POINT_POSITION.LEFT_TOP);
	                            diagonalUp = self._getSpanDiagonals(row, col, true, SPAN_POINT_POSITION.RIGHT_TOP);
	                            downDiagonalIsDoubleLine = BorderLayoutEngine._isDoubleLineItem(diagonalDown);
	                            upDiagonalIsDoubleLine = BorderLayoutEngine._isDoubleLineItem(diagonalUp);
	
	                            beforeDownDiagonal = self._getSpanDiagonals((row - 1), col, false, SPAN_POINT_POSITION.RIGHT_BOTTOM);
	                            beforeUpDiagonal = self._getSpanDiagonals((row - 1), col, true, SPAN_POINT_POSITION.LEFT_BOTTOM);
	                            beforeDownDiagonalIsDoubleLine = BorderLayoutEngine._isDoubleLineItem(beforeDownDiagonal);
	                            beforeUpDiagonalIsDoubleLine = BorderLayoutEngine._isDoubleLineItem(beforeUpDiagonal);
	                            if (diagonalDown && downDiagonalIsDoubleLine) {
	                                option = {_lineSide: 2, _orientation: 0, _offsetStart: 2};
	                                lineH.line._adjust(option);
	                            }
	                            if (diagonalUp && upDiagonalIsDoubleLine) {
	                                option = {_lineSide: 2, _orientation: 0, _offsetEnd: -2};
	                                lineH.line._adjust(option);
	                            }
	                            if (beforeDownDiagonal && beforeDownDiagonalIsDoubleLine) {
	                                option = {_lineSide: 1, _orientation: 0, _offsetEnd: -2};
	                                lineH.line._adjust(option);
	                            }
	                            if (beforeUpDiagonal && beforeUpDiagonalIsDoubleLine) {
	                                option = {_lineSide: 1, _orientation: 0, _offsetStart: 2};
	                                lineH.line._adjust(option);
	                            }
	                        }
	                    }
	                }
	            },
	            _getLineItem: function (r, c, vertical, cache) {
	                var rowCache = cache[r];
	                if (!rowCache) {
	                    rowCache = cache[r] = {};
	                }
	                var line = rowCache[c];
	                if (line === keyword_undefined) {
	                    line = rowCache[c] = this._getLineItemImp(r, c, vertical);
	                }
	                return line;
	            },
	            _getLineItemImp: function (r, c, vertical) {
	                if (r === keyword_undefined || r < 0 || c === keyword_undefined || c < 0) {
	                    return keyword_null;
	                }
	                var self = this;
	                var store = vertical ? self._vBorders : self._hBorders, query = self._queryLineItem(r, c, store, true);
	                if (query) {
	                    return query;
	                }
	                store = vertical ? self._vGridLine : self._hGridLine;
	                if (vertical) {
	                    if (--c < 0) {
	                        return keyword_null;
	                    }
	                } else if (--r < 0) {
	                    return keyword_null;
	                }
	                query = self._queryLineItem(r, c, store, true);
	                if (query) {
	                    return query;
	                }
	                return keyword_null;
	            },
	            paint: function (context, clipRect) {
	                var self = this;
	                if (!self._isInitialized) {
	                    return;
	                }
	                if (!self._isMerged) {
	                    self._createSpanCash();
	                    self._processSpans();
	                    self._processOverflowCells();
	                    self._adjust();
	                    self._isMerged = true;
	                }
	                context.save();
	                context.beginPath();
	                self._paint(context, clipRect);
	                context.closePath();
	                context.stroke();
	                context.restore();
	            },
	            _paint: function (context) {
	                this._paintGridLine(context);
	                this._paintBorderLines(context);
	            },
	            _paintGridLine: function (context) {
	                var self = this;
	                self._paintLines(context, self._hGridLine);
	                self._paintLines(context, self._vGridLine);
	            },
	            _paintBorderLines: function (context) {
	                var self = this;
	                self._paintLines(context, self._hBorders);
	                self._paintLines(context, self._vBorders);
	                self._paintLines(context, self._downDiagonals);
	                self._paintLines(context, self._upDiagonals);
	            },
	            _paintLines: function (context, store) {
	                var i, j, firstDim, line;
	               
	                for (i in store) {
	                    if (store[i]) {
	                        firstDim = store[i];
	                        for (j in firstDim) {
	                            if (firstDim[j]) {
	                                line = firstDim[j].line;
	                                if (line) {
	                                    line._paint(context);
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        };
	        return Borders;
	    })();
	
	    exports._createLine = createLine;
	    exports._Borders = Borders;
	
	    module.exports = exports;
	
	}());

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var exports = __webpack_require__(1);
	    var Worksheet = __webpack_require__(17).Worksheet;
	    var $ = __webpack_require__(4).GC$;
	    var util_common = __webpack_require__(3);
	    var Common = __webpack_require__(5);
	
	    var util_common_util = util_common._util;
	    var browser = util_common_util._browser;
	    var device = util_common_util._device();
	    var Events = util_common.Events;
	    var isNullOrUndefined = Common._Types._isNullOrUndefined;
	    var _FocusHelper = util_common._FocusHelper;
	
	    var keyword_null = null, keyword_undefined = void 0, const_string = 'string';
	
	   
	   
	   
	   
	   
	
	   
	    
	    exports.EditorStatus = {
	        
	        ready: 0,
	        
	        enter: 1,
	        
	        edit: 2
	    };
	
	    var sheetEx = {
	       
	        
	        startEdit: function (selectAll, defaultText) {
	            var self = this;
	            self._startEditImp(self._getCanvas(), self._activeRowIndex, self._activeColIndex, keyword_null, keyword_null, selectAll, defaultText);
	        },
	       
	        
	        editorStatus: function () {
	            return this._editorStatus || 0 ;
	        },
	       
	        
	        isEditing: function () {
	            var editorStatus = this._editorStatus;
	            return editorStatus === 1  || editorStatus === 2 ;
	        },
	       
	        
	        endEdit: function (ignoreValueChange) {
	            return this._endEditImp(ignoreValueChange);
	        },
	
	        _endEditImp: function (ignoreValueChange, endEditType, ignoreFormulaTextbox, ignoreCorssSheetFormulaTextbox) {
	            var self = this;
	            if (!self.isEditing()) {
	                return true;
	            }
	            self.suspendPaint();
	            try {
	                return self._endEditCore(ignoreValueChange, endEditType, ignoreFormulaTextbox, ignoreCorssSheetFormulaTextbox);
	            } finally {
	                self.resumePaint();
	            }
	        },
	        
	        _endEditCore: function (ignoreValueChange, endEditType, ignoreFormulaTextbox, ignoreCorssSheetFormulaTextbox) {
	            var self = this, eventHandler = self._eventHandler;
	            var editor = self._editor, name = self.name(), activeRowIndex = self._activeRowIndex, activeColIndex = self._activeColIndex;
	            var applyResult;
	            var ct = self.getCellType(activeRowIndex, activeColIndex);
	            var context = {
	                sheet: self,
	                row: activeRowIndex,
	                col: activeColIndex,
	                sheetArea: 3 
	            };
	            if (!ct.isImeAware(context)) {
	                eventHandler._changeFocusHolder();
	            }
	            if (editor && editor.parentNode) {
	                var value = ct.getEditorValue(editor, context);
	                var args = {
	                    sheet: self,
	                    sheetName: name,
	                    row: activeRowIndex,
	                    col: activeColIndex,
	                    editor: editor,
	                    editingText: value,
	                    cancel: false
	                };
	                self._trigger(Events.EditEnd, args);
	                if (args.cancel && !ignoreCorssSheetFormulaTextbox) {
	                    return;
	                }
	                self._trigger(Events.EditEnding, args);
	                if (args.cancel && !ignoreCorssSheetFormulaTextbox) {
	                    return;
	                }
	
	                var parent = self.parent, attachedFbx = parent && parent._attachedFormulaTextBox;
	                if (document.activeElement === (attachedFbx && attachedFbx._host)) {
	                    eventHandler._changeFocusHolder();
	                }
	                if (activeRowIndex >= 0 && activeColIndex >= 0) {
	                    var oldValue = editor._oldValue;
	                    if (ct.isEditingValueChanged(oldValue, value, context) || endEditType === 1 ) {
	                        if (ignoreValueChange) {
	                            ct.setEditorValue(editor, oldValue, context);
	                            ct.selectAll(editor, context);
	                        } else {
	                            var autoFormat = ct._autoFormatValue;
	                            if (isNullOrUndefined(autoFormat)) {
	                                autoFormat = true;
	                            }
	                            var cellEditInfo = {
	                                cmd: 'editCell',
	                                sheetName: name,
	                                row: activeRowIndex,
	                                col: activeColIndex,
	                                newValue: value,
	                                autoFormat: autoFormat,
	                                editingFormatter: editor._editingFormatter
	                            };
	                            if (endEditType === 1 ) {
	                                cellEditInfo.ranges = [self._getActiveSelectedRange()];
	                                cellEditInfo.endEditType = endEditType;
	                            }
	                            self._commandManager().execute(cellEditInfo);
	                            applyResult = cellEditInfo.applyResult;
	                            if (applyResult === 2 ) {
	                                ct.focus(editor, context);
	                                if(!ignoreCorssSheetFormulaTextbox) {
	                                    return false;
	                                }
	                            }
	                        }
	                    }
	                }
	                self._dirty = true;
	                ct.deactivateEditor(editor, context);
	                if (!ct.isImeAware(context)) {
	                    var host = self._getHost();
	                    var element = editor;
	                    while (element) {
	                        if (element.parentNode === host) {
	                            host.removeChild(element);
	                        } else {
	                            element = element.parentNode;
	                        }
	                    }
	                } else if (browser.msie && parseFloat(browser.version) === 9) {
	                    eventHandler._changeFocusHolder();
	                } else {
	                    $(editor.parentNode.parentNode).css({
	                        width: 0,
	                        height: 0,
	                        overflow: 'hidden',
	                        border: 'none'
	                    });
	                }
	            }
	            self._editingTimeValue = false;
	            var editEndedArgs = {
	                sheet: self,
	                sheetName: name,
	                row: activeRowIndex,
	                col: activeColIndex,
	                editingText: value
	            };
	            var formulaTextboxEditEndedArgs = $.extend({}, editEndedArgs);
	            self._trigger(Events.EditEnded, editEndedArgs);
	            self._trigger(Events.FormulatextboxEditEnded, formulaTextboxEditEndedArgs);
	            if (ignoreFormulaTextbox !== true && formulaTextboxEditEndedArgs.ignore && !ignoreCorssSheetFormulaTextbox) {
	               
	                return false;
	            }
	            if (self._editorStatus !== 0 ) {
	                var oldStatus = self._editorStatus;
	                self._editorStatus = 0 ;
	                self._raiseEditorStatusChanged(oldStatus, 0 );
	            }
	
	            Worksheet._callFeatureHandler(self, 'endEdit');
	
	            self._editor = keyword_null;
	
	            if (applyResult === 1 ) {
	                return false;
	            }
	            return true;
	        },
	        _doStartEdit: function (canvas, x, y) {
	            var self = this;
	            var target = self.hitTest(x, y);
	            if (!target || (target.cellTypeHitInfo && target.cellTypeHitInfo.outlineColumnHitInfo)) {
	                return;
	            }
	            var row = target.row, col = target.col;
	            if (row >= 0 && col >= 0 && target.rowViewportIndex >= 0 && target.colViewportIndex >= 0 && !target.resizeInfo && !target.dragInfo && row === self._activeRowIndex && col === self._activeColIndex) {
	                var isEditing = self.isEditing();
	                self._startEditImp(canvas, row, col);
	                if (!isEditing && self.isEditing()) {
	                    var sheetArea = target.hitTestType;
	                    var ct = self.getCellType(row, col);
	                    if (ct._triggerButtonClicked) {
	                        var cellRect = self.getCellRect(row, col, sheetArea === 1  ? -1 : keyword_undefined, sheetArea === 2  ? -1 : keyword_undefined);
	                        var cellStyle = self.getActualStyle(row, col, sheetArea);
	                        var info = ct._getHitInfoWrapper(x, y, cellStyle, cellRect, {
	                            sheet: self,
	                            row: row,
	                            col: col,
	                            sheetArea: sheetArea
	                        });
	                        if (info && info.isReservedLocation) {
	                            ct._triggerButtonClicked(self, row, col, 3 );
	                        }
	                    }
	                }
	            }
	        },
	        _startEditImp: function (canvas, row, col, rowViewportIndex, colViewportIndex, selectAll, defaultText, isImeInput) {
	            if (row < 0 || col < 0) {
	                return;
	            }
	            var self = this, name = self.name(), options = self.options;
	           
	            if (self.isEditing()) {
	                return;
	            }
	
	            var cellRect = self.getCellRect(row, col);
	            if (!cellRect || isNullOrUndefined(cellRect.width) || isNullOrUndefined(cellRect.height) ||
	                 isNullOrUndefined(cellRect.x) || isNullOrUndefined(cellRect.y) || cellRect.width <= 0 || cellRect.height <= 0) {
	                return;
	            }
	            var cellStyle = self.getActualStyle(row, col);
	            if (options.isProtected && cellStyle.locked !== false) {
	                return;
	            }
	            var ct = self.getCellType(row, col);
	            if (!ct) {
	                return;
	            }
	            var eventHandler = self._eventHandler;
	           
	            eventHandler._setFocus();
	            var context = {
	                sheet: self,
	                row: row,
	                col: col,
	                sheetArea: 3 
	            };
	            var cellWrapperElement;
	            if (ct.isImeAware(context)) {
	                cellWrapperElement = eventHandler._cellTypeFocusHolder;
	            } else {
	                cellWrapperElement = ct._createCellTypeElement(context);
	            }
	            var editor;
	            if (cellWrapperElement && cellWrapperElement.firstChild) {
	                editor = cellWrapperElement.firstChild.firstChild;
	            }
	            if (!editor) {
	                return;
	            }
	            self._editor = editor;
	            var args = {
	                sheet: self,
	                sheetName: name,
	                row: row,
	                col: col,
	                cancel: false
	            };
	            self._trigger(Events.EditStarting, args);
	            if (args.cancel) {
	                if (device.ipad) {
	                    eventHandler._changeFocusHolder();
	                }
	                return;
	            }
	            self.showCell(self._activeRowIndex, self._activeColIndex, 3 , 3 );
	            var value = self.getValue(row, col), formula = exports._supportsCalc && self.getFormula(row, col);
	            var oldStatus = self._editorStatus;
	            if (self._startEditByKeydown) {
	                self._editorStatus = 1 ;
	            } else if (isNullOrUndefined(value) && isNullOrUndefined(formula)) {
	                self._editorStatus = 1 ;
	            } else {
	                self._editorStatus = 2 ;
	            }
	            self._raiseEditorStatusChanged(oldStatus, self._editorStatus);
	            var sheetLayout = self._getSheetLayout();
	            cellRect = self.getCellRect(row, col, rowViewportIndex, colViewportIndex);
	            if (ct.isImeAware(context)) {
	                eventHandler._resetFocusHolder();
	            }
	            ct._activateEditorWrapper(cellWrapperElement, cellStyle, cellRect, context);
	            self._setEditorValue(ct, editor, row, col, cellStyle, defaultText, isImeInput);
	            var host = self._getHost();
	            if (!ct.isImeAware(context)) {
	                host.insertBefore(cellWrapperElement, keyword_null);
	            }
	            ct._updateEditorWrapper(cellWrapperElement, cellStyle, cellRect, context);
	            if (!ct.isImeAware(context) || !selectAll) {
	                ct.focus(editor, context);
	            }
	            if (options.allowCellOverflow) {
	                var crect = cellRect.clone();
	                crect.y -= 2;
	                crect.height += 4;
	               
	                crect.x = sheetLayout._frozenX;
	                crect.width = sheetLayout._viewportWidth;
	                self.repaint(crect);
	            }
	            Worksheet._callFeatureHandler(self, 'startEdit', {element: ct.getEditingElement()});
	           
	            if (selectAll) {
	                ct.selectAll(editor, context);
	            }
	            _FocusHelper._setActiveElement(self);
	            var editStartArgs = {
	                sheet: self,
	                sheetName: name,
	                row: row,
	                col: col
	            };
	            self._trigger(Events.EditStarted, editStartArgs);
	            self._trigger(Events.FormulatextboxEditStarted, editStartArgs);
	        },
	        _setEditorValue: function (ct, editor, row, col, cellStyle, defaultText, isImeInput) {
	            var self = this;
	            var t = exports._supportsCalc && self.getFormula(row, col, true);
	            if (t) {
	                t = '=' + t;
	            }
	            var actualValue = t;
	            var context = {
	                sheet: self,
	                row: row,
	                col: col,
	                sheetArea: 3 ,
			isImeInput: isImeInput
	            };
	            if (!t || t.length === 0) {
	                t = self.getValue(row, col);
	               
	                var parent = self.parent, allowUserEditFormula = exports._supportsCalc && parent && parent.options.allowUserEditFormula;
	                if ((typeof t === const_string && cellStyle.quotePrefix) || (t && t.length > 0 && t[0] === "=" && allowUserEditFormula)) {
	                    t = '\'' + t;
	                    actualValue = t;
	                } else {
	                    actualValue = t;
	                    t = ct._formatEditorValue(editor, cellStyle, t, context);
	                }
	            }
	            editor._oldValue = t;
	            if (!isNullOrUndefined(defaultText)) {
	                t = defaultText;
	            }
	            ct.setEditorValue(editor, t, context);
	            editor._originalValue = actualValue;
	        }
	    };
	
	    $.extend(Worksheet.prototype, sheetEx);
	
	    module.exports = exports;
	
	
	}());

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var exports = __webpack_require__(1);
	    var Worksheet = __webpack_require__(17).Worksheet;
	    var Common = __webpack_require__(5);
	    var _LayoutModel = __webpack_require__(16)._LayoutModel;
	    var $ = __webpack_require__(4).GC$;
	    var util_common = __webpack_require__(3);
	    var Range = util_common.Range;
	    var WINDOW = window;
	    var DOCUMENT = document;
	    var $_each = $.each;
	    var util_common_util = util_common._util;
	    var browser = util_common_util._browser;
	    var util_device = util_common_util._device();
	    var cancelDefault = util_common_util._cancelDefault;
	    var createElement = util_common_util._createElement;
	    var stringFormat = Common._StringHelper._format;
	    var createRange = util_common._createRange;
	    var isNullOrUndefined = Common._Types._isNullOrUndefined;
	    var Events = util_common.Events;
	    var _FocusHelper = util_common._FocusHelper;
	    var EVENT_NS = '.handler', MOUSEDOWN_EVENT = 'mousedown' + EVENT_NS,
	        MOUSEUP_EVENT = 'mouseup' + EVENT_NS,
	        MOUSEMOVE_EVENT = 'mousemove' + EVENT_NS,
	        MOUSEWHEEL_EVENT = 'mousewheel' + EVENT_NS,
	        DOMMOUSESCROLL_EVENT = 'DOMMouseScroll' + EVENT_NS,
	        MOUSEOUT_EVENT = 'mouseout' + EVENT_NS,
	        DBLCLICK_EVENT = 'dblclick' + EVENT_NS;
	    var keyword_null = null, keyword_undefined = void 0, isNotANumber = isNaN,
	        convertToInt = parseInt, Math_max = Math.max,
	        Math_min = Math.min, Math_abs = Math.abs, Math_ceil = Math.ceil, const_function = 'function',
	        cssPosition = 'position', cssAbsolute = 'absolute', cssBorder = 'border',
	        cssOverflow = 'overflow', cssTop = 'top', cssLeft = 'left',
	        cssWidth = 'width', cssHeight = 'height', cssResize = 'resize',
	        cssHidden = 'hidden', cssVisible = 'visible', cssNone = 'none',
	        attrTabIndex = 'tabindex', attrGcUIElement = 'gcUIElement',
	        CORNER = 'corner', SIZEHIDDENROW = 'sizeHiddenRow', SIZEROW = 'sizeRow', SIZECOL = 'sizeCol',
	        SIZEHIDDENCOL = 'sizeHiddenCol', DEFAULT = 'default';
	    var IS_MOBILE_DEVICE = util_device.iphone || util_device.ipad || util_device.android;
	
	    var sR = function () {
	        return Common._getResource(exports.SR)();
	    };
	
	    var RESIZETOOLTIP_TOP = 30;
	
	   
	    Worksheet._registerFeature('eventHandler', {
	        dispose: function (clearCache) {
	            var self = this;
	            $(self._getCanvas()).unbind(MOUSEDOWN_EVENT)
	                .unbind(MOUSEUP_EVENT)
	                .unbind(MOUSEMOVE_EVENT)
	                .unbind(MOUSEWHEEL_EVENT)
	                .unbind(DOMMOUSESCROLL_EVENT)
	                .unbind(MOUSEOUT_EVENT)
	                .unbind(DBLCLICK_EVENT);
	
	            var eventHandler = self._eventHandler;
	            if (eventHandler) {
	                eventHandler._dispose();
	                eventHandler._disposeFocusHolders();
	            }
	            var editor = self._editor;
	            if (editor) {
	                $(editor).remove();
	            }
	            var smartTag = self._fillDialog;
	            if (smartTag) {
	                smartTag.close();
	            }
	
	            if (clearCache !== false) {
	                self._mouseDownDelegate = keyword_null;
	                self._mouseMoveDelegate = keyword_null;
	                self._mouseUpDelegate = keyword_null;
	                self._mouseWheelDelegate = keyword_null;
	                self._mouseOutDelegate = keyword_null;
	                self._dblClickDelegate = keyword_null;
	
	                self._eventHandler = keyword_null;
	            }
	
	           
	           
	        },
	        setHost: function (host) {
	            if (!host) {
	                return;
	            }
	
	            var self = this, eventHandler = self._eventHandler;
	           
	           
	           
	           
	            self._mouseDownDelegate = function (event) {
	                var argObj = {e: event, r: keyword_null};
	                Worksheet._callFeatureHandler(self, 'preProcessMouseDown', argObj);
	                if (argObj.r) {
	                    return;
	                }
	
	                return eventHandler._doMouseDown(event);
	            };
	            self._mouseMoveDelegate = function (event) {
	                var argObj = {e: event, r: keyword_null};
	                Worksheet._callFeatureHandler(self, 'preProcessMouseMove', argObj);
	                if (argObj.r) {
	                    return;
	                }
	
	                if (eventHandler._isMouseCapture) {
	                    return;
	                }
	                eventHandler._doMouseMove(event);
	            };
	            self._mouseUpDelegate = function (event) {
	                var argObj = {e: event, r: keyword_null};
	                Worksheet._callFeatureHandler(self, 'preProcessMouseUp', argObj);
	                if (argObj.r) {
	                    return;
	                }
	
	                if (!self._continueMouseUpBubble) {
	                    if (eventHandler._isMouseCapture) {
	                        return;
	                    }
	                    return eventHandler._doMouseUp(event);
	                }
	            };
	            self._mouseWheelDelegate = function (event) {
	                event = event || WINDOW.event;
	                var argObj = {e: event, r: keyword_null};
	                Worksheet._callFeatureHandler(self, 'preProcessMouseWheel', argObj);
	                if (argObj.r) {
	                    return;
	                }
	
	                var detailY = event.detail ? event.detail : event.wheelDelta / -40, detailX = 0;
	                if (util_common_util._isMacOS()) {
	                    var currentMouseWheel = new Date().valueOf();
	
	                    var wheelDeltaY = event.wheelDeltaY;
	                    var wheelDeltaX = event.wheelDeltaX;
	                    if (Math_abs(wheelDeltaY) >= Math_abs(wheelDeltaX)) {
	                        wheelDeltaX = 0;
	                    } else {
	                        wheelDeltaY = 0;
	                    }
	                    var isFirstTime = !self._lastMouseWheel || currentMouseWheel - self._lastMouseWheel > 200;
	                    if (browser.safari || browser.chrome) {
	                        var ratio = browser.safari ? -4 : -40;
	                        if (!isNullOrUndefined(wheelDeltaY)) {
	                            if (isFirstTime) {
	                                detailY = wheelDeltaY / ratio;
	                                detailY = (detailY >= 0 ? 1 : -1) * Math_ceil(Math_abs(detailY));
	                                self._remainedDetailY = 0;
	                            } else {
	                                detailY = wheelDeltaY / ratio;
	                                self._remainedDetailY += detailY;
	                                detailY = (detailY >= 0 ? 1 : -1) * Math.floor(Math_abs(self._remainedDetailY));
	                                self._remainedDetailY -= detailY;
	                            }
	                        }
	                        if (!isNullOrUndefined(wheelDeltaX)) {
	                            if (isFirstTime) {
	                                detailX = wheelDeltaX / ratio;
	                                detailX = (detailX >= 0 ? 1 : -1) * Math_ceil(Math_abs(detailX));
	                                self._remainedDetailX = 0;
	                            } else {
	                                detailX = wheelDeltaX / ratio;
	                                self._remainedDetailX += detailX;
	                                detailX = (detailX >= 0 ? 1 : -1) * Math.floor(Math_abs(self._remainedDetailX));
	                                self._remainedDetailX -= detailX;
	                            }
	                        }
	                    }
	                    self._lastMouseWheel = currentMouseWheel;
	
	                    if (detailY === 0 && detailX === 0) {
	                        return false;
	                    }
	                }
	                var ret = self.parent._scrollService._doMouseWheel(event, convertToInt(detailY, 10) || 0, convertToInt(detailX, 10) || 0);
	                if (!ret) {
	                    return false;
	                }
	            };
	            self._mouseOutDelegate = function (event) {
	                var argObj = {e: event, r: keyword_null};
	                Worksheet._callFeatureHandler(self, 'preProcessMouseOut', argObj);
	                if (argObj.r) {
	                    return;
	                }
	
	                return eventHandler._doMouseOut(event);
	            };
	            function doDblClickViewport(handler, event) {
	                handler._startEdit(event);
	            }
	
	            self._dblClickDelegate = function (event) {
	                var argObj = {e: event, r: keyword_null};
	                Worksheet._callFeatureHandler(self, 'preProcessMouseDbClick', argObj);
	                if (argObj.r) {
	                    return;
	                }
	                var currentTarget = self._currentTarget;
	                if (currentTarget) {
	                    var ret = false;
	                    if (getHitTestType(currentTarget) === 3 ) {
	                        doDblClickViewport(eventHandler, event);
	                    } else {
	                       
	                        ret = doDblClickHeader(eventHandler, currentTarget);
	                    }
	                    if (!ret) {
	                        self._trigger(Events.CellDoubleClick,
	                            createEventArg(self, self.name(), currentTarget.row, currentTarget.col, getHitTestType(currentTarget)));
	                    }
	                }
	
	                function createEventArg(sheet, name, row, col, sheetArea, canCancel) {
	                    var t = {
	                        sheet: sheet,
	                        sheetName: name,
	                        sheetArea: sheetArea,
	                        row: row,
	                        col: col
	                    };
	
	                    if (canCancel) {
	                        t.cancel = false;
	                    }
	                    return t;
	                }
	
	                function doDblClickHeader(handler, target) {
	                    var sheet = handler._sheet;
	                    var resizeInfo = target.resizeInfo;
	                    if (resizeInfo) {
	                        if (resizeInfo.action === SIZEROW || resizeInfo.action === SIZEHIDDENROW) {
	                            var rowList = [];
	                            if (sheet._isRowSelected(resizeInfo.index)) {
	                                $_each(sheet._modelManager.getSelections(), function (i, p) {
	                                    if (p.col === -1) {
	                                        var selectedRange = sheet._getActualRange(p);
	                                        for (var r = 0; r < getRowCount(selectedRange); r++) {
	                                            rowList.push({row: selectedRange.row + r});
	                                        }
	                                    }
	                                });
	                            } else {
	                                rowList.push({row: resizeInfo.index});
	                            }
	                            sheet._commandManager().execute({
	                                cmd: 'autoFitRow',
	                                sheetName: sheet.name(),
	                                rows: rowList,
	                                columnHeader: resizeInfo.sheetArea === 1 
	                            });
	                        } else {
	                            var columnList = [];
	                            if (sheet._isColumnSelected(resizeInfo.index)) {
	                                $_each(sheet._modelManager.getSelections(), function (i, p) {
	                                    if (p.row === -1) {
	                                        var selectedRange = sheet._getActualRange(p);
	                                        for (var c = 0; c < getColCount(selectedRange); c++) {
	                                            columnList.push({col: selectedRange.col + c});
	                                        }
	                                    }
	                                });
	                            } else {
	                                columnList.push({col: resizeInfo.index});
	                            }
	                            sheet._commandManager().execute({
	                                cmd: 'autoFitColumn',
	                                sheetName: sheet.name(),
	                                columns: columnList,
	                                rowHeader: resizeInfo.sheetArea === 2 
	                            });
	                        }
	                        return true;
	                    }
	                    return false;
	                }
	            };
	           
	            host.bind(MOUSEDOWN_EVENT, function (e) {
	                return self._mouseDownDelegate(e);
	            }).bind(MOUSEUP_EVENT, function (e) {
	                return self._mouseUpDelegate(e);
	            }).bind(MOUSEMOVE_EVENT, function (e) {
	                return self._mouseMoveDelegate(e);
	            }).bind(MOUSEWHEEL_EVENT, function (e) {
	                return self._mouseWheelDelegate(e);
	            }).bind(DOMMOUSESCROLL_EVENT, function (e) {
	                return self._mouseWheelDelegate(e);
	            }).bind(MOUSEOUT_EVENT, function (e) {
	                return self._mouseOutDelegate(e);
	            }).bind(DBLCLICK_EVENT, function (e) {
	                return self._dblClickDelegate(e);
	            });
	        }
	    });
	
	    function _isHoverOnHeaderSelection(sheet, target) {
	        var sheetArea = 3 ;
	        if (getRowViewportIndex(target) < 0) {
	            sheetArea = 1 ;
	        }
	        if (getColViewportIndex(target) < 0) {
	            sheetArea = 2 ;
	        }
	        if (sheetArea !== 3  && sheet._isSelected(target.row, target.col, sheetArea, true)) {
	            return true;
	        }
	        return false;
	    }
	
	    function refreshHoverCell(sheet, target, render) {
	        var isNeedRepaintSelection = false;
	        var sheetLayout = sheet._getSheetLayout();
	
	        if (target) {
	            var rowViewportIndex = getRowViewportIndex(target), colViewportIndex = getColViewportIndex(target);
	            if (rowViewportIndex < 0 || colViewportIndex < 0) {
	                var r = sheet.getCellRect(target.row, target.col, rowViewportIndex, colViewportIndex);
	                if (r && r.width > 0 && r.height > 0) {
	                    var adjX = sheetLayout.x;
	                    var adjY = sheetLayout.y;
	                    if (r.x < sheetLayout._rowHeaderWidth + adjX ||
	                        r.y < sheetLayout._colHeaderHeight + adjY ||
	                        r.y >= sheetLayout.height - sheetLayout._footerHeight) {
	                        var clipRect = new util_common.Rect(r.x - 2, r.y - 2, r.width + 4, r.height + 4);
	                        var headerRect;
	                        if (rowViewportIndex < 0 && colViewportIndex < 0) {
	                            headerRect = sheetLayout._headerCornerRect();
	                        } else if (rowViewportIndex < 0) {
	                            headerRect = sheetLayout._colHeaderRect(colViewportIndex);
	                        } else {
	                            headerRect = sheetLayout._rowHeaderRect(rowViewportIndex);
	                        }
	                        clipRect = clipRect.getIntersectRect(headerRect);
	                        render._update(clipRect.x, clipRect.y, clipRect.width, clipRect.height);
	                        isNeedRepaintSelection = _isHoverOnHeaderSelection(sheet, target);
	                    }
	                }
	            }
	        }
	
	        return isNeedRepaintSelection;
	    }
	
	    function isEditing(sheet) {
	        return sheet.isEditing();
	    }
	
	    function endEdit(sheet) {
	        return sheet.endEdit();
	    }
	
	    function getFrozenRowCount(sheet) {
	        return sheet.frozenRowCount();
	    }
	
	    function getFrozenColumnCount(sheet) {
	        return sheet.frozenColumnCount();
	    }
	
	    function getSheetRowCount(sheet, sheetArea) {
	        return sheet.getRowCount(sheetArea);
	    }
	
	    function getSheetColumnCount(sheet, sheetArea) {
	        return sheet.getColumnCount(sheetArea);
	    }
	
	    function getRowViewportIndex(object) {
	        return object.rowViewportIndex;
	    }
	
	    function getColViewportIndex(object) {
	        return object.colViewportIndex;
	    }
	
	    function getHitTestType(object) {
	        return object.hitTestType;
	    }
	
	    function getActiveRowIndex(sheet) {
	        return sheet.getActiveRowIndex();
	    }
	
	    function getActiveColumnIndex(sheet) {
	        return sheet.getActiveColumnIndex();
	    }
	
	    function getKeyCode(e) {
	        return e.keyCode;
	    }
	
	    function getCtrlKey(e) {
	        return e.ctrlKey;
	    }
	
	    function getShiftKey(e) {
	        return e.shiftKey;
	    }
	
	    function getAltKey(e) {
	        return e.altKey;
	    }
	
	    function getMetaKey(e) {
	        return e.metaKey;
	    }
	
	    function getColCount(obj) {
	        return obj.colCount;
	    }
	
	    function getRowCount(obj) {
	        return obj.rowCount;
	    }
	
	    function createOption(action, index, sheetArea) {
	        return {action: action, index: index, sheetArea: sheetArea};
	    }
	
	   
	    
	    exports.ImeMode = {
	        
	        auto: 0x01,
	        
	        active: 0x02,
	        
	        inactive: 0x04,
	        
	        disabled: 0x00
	    };
	
	   
	   
	   
	   
	   
	   
	   
	   
	
	    function createEventArg(sheet, name, row, col, sheetArea, canCancel) {
	        var t = {
	            sheet: sheet,
	            sheetName: name,
	            sheetArea: sheetArea,
	            row: row,
	            col: col
	        };
	
	        if (canCancel) {
	            t.cancel = false;
	        }
	        return t;
	    }
	
	    function changeActiveCell(handler, row, col, rowViewportIndex, colViewportIndex, doNotSetFocus) {
	        var sheet = handler._sheet;
	        var args = createEventArg(sheet, sheet.name(), sheet._activeRowIndex, sheet._activeColIndex, keyword_undefined, true);
	        sheet._trigger(Events.LeaveCell, args);
	        if (args && args.cancel === true) {
	            return true;
	        }
	        sheet._setActiveCellImp(row, col, rowViewportIndex, colViewportIndex, doNotSetFocus);
	        sheet._trigger(Events.EnterCell, createEventArg(sheet, sheet.name(), row, col));
	        sheet._trigger(Events.FormulatextboxEnterCell, createEventArg(sheet, sheet.name(), row, col));
	        handler._updateValidationUI && handler._updateValidationUI(row, col);
	    }
	
	    function getResizeLayout(handler, layoutFn, prevVisualIndexFn, findFn, targetIndex, resizeInfo, resizingRow) {
	        var sheet = handler._sheet;
	        var layoutModel = layoutFn.call(sheet, resizeInfo.sheetArea);
	
	        if ((resizingRow && !sheet.getRowVisible(resizeInfo.index, resizeInfo.sheetArea)) ||
	            (!resizingRow && !sheet.getColumnVisible(resizeInfo.index, resizeInfo.sheetArea))) {
	            resizeInfo.index = prevVisualIndexFn.call(handler, resizeInfo.index, resizeInfo.sheetArea);
	        }
	        var layout = findFn.call(layoutModel, resizeInfo.index);
	        if (!layout) {
	            layout = findFn.call(layoutModel, targetIndex);
	        }
	
	        return layout;
	    }
	
	    function updateResizeInfo(resizeInfo, value, layout, isRow) {
	        var movingKey = isRow ? 'movingY' : 'movingX';
	        var startKey = isRow ? 'startY' : 'startX';
	
	        resizeInfo[movingKey] = value;
	        if (resizeInfo[movingKey] < resizeInfo[startKey]) {
	            resizeInfo[movingKey] = resizeInfo[startKey];
	        }
	        var max = isRow ? layout.y + layout.height : layout.x + layout.width;
	        if (resizeInfo[movingKey] > max) {
	            resizeInfo[movingKey] = max;
	        }
	    }
	
	    function _getRowViewportIndexNearY(sheet, y) {
	       
	        var layout = sheet._getSheetLayout();
	        if (getFrozenRowCount(sheet) > 0 && y < layout._frozenY + layout._frozenHeight) {
	            return 0;
	        } else if (sheet.frozenTrailingRowCount() > 0 && y > layout._frozenTrailingY) {
	            return 2;
	        }
	        return 1;
	    }
	
	    function _getColumnViewportIndexNearX(sheet, x) {
	       
	        var layout = sheet._getSheetLayout();
	        if (getFrozenColumnCount(sheet) > 0 && x < layout._frozenX + layout._frozenWidth) {
	            return 0;
	        } else if (sheet.frozenTrailingColumnCount() > 0 && x > layout._frozenTrailingX) {
	            return 2;
	        }
	        return 1;
	    }
	
	    function _getViewportRowLayoutNearY(sheet, rowViewportIndex, y) {
	        var rowLayoutModel = sheet._getRowLayout(rowViewportIndex);
	        if (rowLayoutModel) {
	            return rowLayoutModel.findNearY(y);
	        }
	        return keyword_null;
	    }
	
	    function _getViewportColumnLayoutNearX(sheet, columnViewportIndex, x) {
	        var colLayoutModel = sheet._getColumnLayout(columnViewportIndex);
	        if (colLayoutModel) {
	            return colLayoutModel.findNearX(x);
	        }
	        return keyword_null;
	    }
	
	    function canDoResizeRows(sheet) {
	        return !sheet.options.isProtected || sheet.options.protectionOptions.allowResizeRows;
	    }
	
	    function canDoResizeColumns(sheet) {
	        return !sheet.options.isProtected || sheet.options.protectionOptions.allowResizeColumns;
	    }
	
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	    function getResizeIndexNextToFrozenLine(sheet, targetIndex, isRow) {
	        var frozenIndex = isRow ? sheet.frozenRowCount() : sheet.frozenColumnCount();
	        var scrollIndex = isRow ? sheet._scrollTopRow : sheet._scrollLeftCol;
	        var hasRowColumnScrollHidden = false, visibility;
	        var lastUnhiddenScrollIndex = scrollIndex - 1;
	        if (frozenIndex > 0 && frozenIndex < scrollIndex) {
	            var tempIndex = scrollIndex;
	            while(--tempIndex >= frozenIndex) {
	                visibility = isRow ? sheet.getRowVisible(tempIndex) : sheet.getColumnVisible(tempIndex);
	                if (visibility) {
	                    var size = isRow ? sheet.getRowHeight(tempIndex) : sheet.getColumnWidth(tempIndex);
	                    if (tempIndex === lastUnhiddenScrollIndex && size === 0) {
	                       
	                        break;
	                    } else if (size > 0) {
	                       
	                       
	                       
	                       
	                        hasRowColumnScrollHidden = true;
	                        break;
	                    }
	                } else {
	                    lastUnhiddenScrollIndex--;
	                }
	            }
	        }
	        var retIndex = hasRowColumnScrollHidden ? frozenIndex : targetIndex;
	        while(--retIndex >= 0) {
	            visibility = isRow ? sheet.getRowVisible(retIndex) : sheet.getColumnVisible(retIndex);
	            if (visibility) {
	                return retIndex;
	            }
	        }
	       
	        return -1;
	    }
	
	    var SheetEventHandler = (function () {
	        function SheetEventHandler(sheet) {
	            var self = this;
	            self._repeatKeyDownTimeoutID = 0;
	            self._focusReleased = false;
	            self._focusSuspended = false;
	            self._dragRect = {};
	            self._sheet = sheet;
	        }
	
	        SheetEventHandler.prototype = {
	            _dispose: function () {
	                var self = this;
	                if (self._hScrollTimer) {
	                    self._hScrollTimer._dispose();
	                }
	                if (self._vScrollTimer) {
	                    self._vScrollTimer._dispose();
	                }
	                self._mousePosition = keyword_null;
	            },
	            _getHScrollTimer: function () {
	                var self = this;
	                if (!self._hScrollTimer) {
	                    self._hScrollTimer = new Timer(self);
	                }
	                return self._hScrollTimer;
	            },
	            _getVScrollTimer: function () {
	                var self = this;
	                if (!self._vScrollTimer) {
	                    self._vScrollTimer = new Timer(self);
	                }
	                return self._vScrollTimer;
	            },
	            _getCanvasOffset: function () {
	                return this._sheet._getCanvasOffset();
	            },
	            _getCanvasPosition: function () {
	                var p = $(this._sheet._getCanvas()).position();
	                if (!p) {
	                    p = {top: 0, left: 0};
	                }
	                return p;
	            },
	            _doMouseDown: function (e) {
	                if (e.button === 2) {
	                    return true;
	                }
	                var self = this;
	                var sheet = self._sheet;
	                self._handleDocumentMouseMove();
	
	               
	               
	               
	               
	                if (browser && browser.msie && e.offsetX !== keyword_undefined && e.offsetY !== keyword_undefined) {
	                    var relativeOffsetLeft = 0, relativeOffsetTop = 0;
	                    if (e.target !== sheet._canvas) {
	                        var relativeOffset = util_common_util._getRelativeOffset(e.target, sheet._canvas);
	                        relativeOffsetLeft = relativeOffset._left;
	                        relativeOffsetTop = relativeOffset._top;
	                    }
	                    var canvasOffsetLeft = e.pageX - (e.offsetX + relativeOffsetLeft), canvasOffsetTop = e.pageY - (e.offsetY + relativeOffsetTop);
	                    sheet._getCanvas().canvasOffset = {top: canvasOffsetTop, left: canvasOffsetLeft};
	                }
	
	                var t = sheet._getCanvasOffset();
	                var ret = self._doMouseDownImp(e, e.pageX - t.left, e.pageY - t.top);
	                if (!isEditing(sheet) && !ret) {
	                    self._setFocus();
	                }
	                sheet._isMouseDownInSheet = true;
	                return false;
	            },
	            _handleDocumentMouseMove: function () {
	                var self = this;
	                if (!self._isMouseCapture) {
	                    $(DOCUMENT).bind('mousemove.gcSheet', function (e) {
	                        self._doMouseMove(e);
	                    }).bind('mouseup.gcSheet', function (e) {
	                        self._doMouseUp(e);
	                    });
	                    self._isMouseCapture = true;
	                }
	            },
	            _unhandleDocumentMouseMove: function () {
	                if (this._isMouseCapture) {
	                    this._isMouseCapture = false;
	                    $(DOCUMENT).unbind('mousemove.gcSheet').unbind('mouseup.gcSheet');
	                }
	            },
	            _doMouseDownImp: function (e, x, y) {
	                var self = this, sheet = self._sheet, target = sheet.hitTest(x, y),
	                    r = target.row, c = target.col, dragInfo = target.dragInfo, frInfo = target.formulaRangeHitInfo,
	                    cellTypeHitInfo = target.cellTypeHitInfo;
	
	                var argObj = {hitInfo: target, e: e, r: keyword_null};
	                Worksheet._callFeatureHandler(sheet, 'processMouseDown', argObj);
	                if (argObj.r) {
	                    return;
	                }
	
	                var layout = sheet._getSheetLayout();
	                if (x >= layout.x && y >= layout.y) {
	                    sheet._currentTarget = target;
	                    self._isMouseDown = true;
	                    if (target.resizeInfo) {
	                        if (!endEdit(sheet)) {
	                            return;
	                        }
	                        self._startResizing(target);
	                    } else if (target.dragMergeInfo) {
	                        if (!endEdit(sheet)) {
	                            return;
	                        }
	                        self._startDragMerge && self._startDragMerge(target);
	                    } else if (dragInfo && dragInfo.side && dragInfo.side !== CORNER) {
	                        if (!endEdit(sheet)) {
	                            return;
	                        }
	                        self._startDragDropping && self._startDragDropping(target);
	                    } else if (dragInfo && dragInfo.side === CORNER) {
	                        if (!endEdit(sheet)) {
	                            return;
	                        }
	                        self._startDragFill && self._startDragFill(target);
	                    } else if (target.filterButtonHitInfo) {
	                        endEdit(sheet);
	                    } else if (frInfo) {
	                        if (frInfo.inBorder) {
	                            self._startFormulaRangeMoving(target);
	                        } else if (frInfo.inTopLeft || frInfo.inTopRight || frInfo.inBottomLeft || frInfo.inBottomRight) {
	                            self._startFormulaRangeResizing(target);
	                        }
	                    } else if (sheet._canSelect(getRowViewportIndex(target) < 0 ? -1 : r, getColViewportIndex(target) < 0 ? -1 : c)) {
	                        if (self._dealMouseDownInFormulatextbox && self._dealMouseDownInFormulatextbox(sheet, target)) {
	                            return;
	                        }
	                        var oldActiveRow = getActiveRowIndex(sheet);
	                        var oldActiveCol = getActiveColumnIndex(sheet);
	                        if (cellTypeHitInfo) {
	                            var ct = sheet.getCellType(cellTypeHitInfo.row, cellTypeHitInfo.col, getHitTestType(target));
	                            if (!cellTypeHitInfo.sheet) {
	                                cellTypeHitInfo.sheet = sheet;
	                            }
	                           
	                           
	                           
	                           
	                           
	                           
	                            if (self._canSetSelectionChange(ct, cellTypeHitInfo)) {
	                                var sheetArea = cellTypeHitInfo.sheetArea;
	                                if ((isNullOrUndefined(sheetArea) || sheetArea === 3 ) &&
	                                    (r !== oldActiveRow || c !== oldActiveCol)) {
	                                    sheet.suspendPaint();
	                                    try {
	                                        if (!endEdit(sheet)) {
	                                            return;
	                                        }
	                                        var args = createEventArg(sheet, sheet.name(), oldActiveRow, oldActiveCol, keyword_undefined, true);
	                                        sheet._trigger(Events.LeaveCell, args);
	                                        if (args && args.cancel === true) {
	                                            return;
	                                        }
	                                        var oldSels = sheet._modelManager.getSelections();
	                                        var span = sheet._modelManager.getSpan(r, c);
	                                        var newSels = [new Range(span.row, span.col, span.rowCount, span.colCount)];
						sheet._trigger(Events.FloatingElementSelected, {type: 'worksheet'});
	                                        sheet._raiseSelectionChanging(oldSels, newSels);
	                                        sheet._setActiveCellAndSelection(r, c, keyword_undefined, keyword_undefined, 1 );
	                                        sheet._trigger(Events.EnterCell, createEventArg(sheet, sheet.name(), r, c));
	                                        sheet._trigger(Events.FormulatextboxEnterCell, createEventArg(sheet, sheet.name(), r, c));
	                                        sheet._raiseSelectionChanged(oldSels);
	                                        sheet._noMoreSelectionChanged = true;  
	                                        self._updateValidationUI && self._updateValidationUI(r, c);
	                                    } finally {
	                                        sheet.resumePaint();
	                                    }
	                                }
	                            }
	                            ct.processCellAndPaddingMouseDown(cellTypeHitInfo);
	                        }
	                        if (cellTypeHitInfo && cellTypeHitInfo.isReservedLocation) {
	                            return true;
	                        }
	                        self._setMetaKeyState(e);
	                        self._changeSelection(sheet, target, r, c);
	                    }
	                }
	            },
	            _changeSelection: function (sheet, target, r, c) {
	                var self = this;
	                try {
	                    self._hitTestResult = target;
	                    if (isEditing(sheet) && !endEdit(sheet)) {
	                        return;
	                    }
	                } finally {
	                    self._hitTestResult = keyword_null;
	                }
	                if (isNullOrUndefined(r) || isNullOrUndefined(c)) {
	                    return;
	                }
	                if (getHitTestType(target) === 3 ) {
	                    self._updateValidationUI && self._updateValidationUI(r, c);
	                }
			sheet._trigger(Events.FloatingElementSelected, {type: 'worksheet'});
	                var oldSelections = sheet._modelManager.getSelections();
	                self._startSelecting(target, oldSelections);
	                var newSelections = sheet._modelManager.getSelections();
	                sheet._raiseSelectionChanging(oldSelections, newSelections);
	            },
	            _canSetSelectionChange: function (cellType, cellTypeHitInfo) {
	                return cellType && cellTypeHitInfo && cellTypeHitInfo.isReservedLocation && (cellType.activeOnClick ? cellType.activeOnClick() : true);
	            },
	            _isInvalidRect: function (rect) {
	                var sheet = this._sheet;
	                if (!sheet) {
	                    return true;
	                }
	                var sheetLayout = sheet._getSheetLayout();
	                return isNullOrUndefined(rect.x) || isNullOrUndefined(rect.y) ||
	                    isNullOrUndefined(rect.width) || isNullOrUndefined(rect.height) ||
	                    rect.x + rect.width > sheetLayout._viewportX + sheetLayout._viewportWidth + sheetLayout._frozenTrailingWidth ||
	                    rect.y + rect.height > sheetLayout._viewportY + sheetLayout._viewportHeight + sheetLayout._frozenTrailingHeight;
	            },
	            _commitSelectValue: function (select, row, col, validList) {
	                var sheet = this._sheet, newValue;
	                for (var i = 0, options = select.options, len = options.length; i < len; i++) {
	                    var op = options[i];
	                    if (op.selected) {
	                        newValue = validList[i].value;
	                        break;
	                    }
	                }
	                var actualLocked = false;
	                if (sheet.options.isProtected) {
	                    var style = sheet.getActualStyle(row, col);
	                    if (style) {
	                        actualLocked = style.locked;
	                    }
	                }
	                if (newValue !== keyword_undefined && !actualLocked) {
	                    var cellEditCmd = {
	                        cmd: 'editCell',
	                        sheetName: sheet.name(),
	                        row: row,
	                        col: col,
	                        newValue: newValue,
	                        autoFormat: true
	                    };
	                    sheet._commandManager().execute(cellEditCmd);
	                }
	                $(select).hide();
	            },
	           
	            _startScroll: function () {
	                var self = this;
	                if (!self._startHitInfo) {
	                    return;
	                }
	                var hitType = self._startHitInfo._hitTestType;
	                if (hitType === 3  || hitType === 2 ) {
	                    self._getVScrollTimer()._setAction(self._processVSScrolled);
	                }
	                if (hitType === 3  || hitType === 1 ) {
	                    self._getHScrollTimer()._setAction(self._processHSScrolled);
	                }
	            },
	            _checkContinueScroll: function () {
	                var self = this;
	                if (self._isSelecting) {
	                    self._continueSelecting();
	                }
	                if (self._isDragMerging) {
	                    self._continueDragMerge && self._continueDragMerge();
	                }
	                if (self._isDragDropping) {
	                    self._continueDragDropping && self._continueDragDropping();
	                }
	                if (self._isDraggingFill) {
	                    self._continueDragFill && self._continueDragFill();
	                }
	                if (self._isFormulaRangeAppending) {
	                    self._continueFormulaRangeAppending();
	                }
	                if (self._isFormulaRangeMoving) {
	                    self._continueFormulaRangeMoving();
	                }
	                if (self._isFormulaRangeResizing) {
	                    self._continueFormulaRangeResizing();
	                }
	            },
	            _processVSScrolled: function (increase) {
	                var self = this;
	                var adjusted = self._adjustScrollRowViewport();
	                if (!adjusted) {
	                    var hi = self._startHitInfo;
	                    var sheet = self._sheet;
	                    var rowViewportIndex = hi._scrollRowViewportIndex;
	                    var topRow = sheet.getViewportTopRow(rowViewportIndex);
	                    var bottomRow = sheet.getViewportBottomRow(rowViewportIndex);
	                    if (increase) {
	                        if (bottomRow < getSheetRowCount(sheet) - sheet.frozenTrailingRowCount() - 1) {
	                            sheet._setTopRow(sheet._getNextVisualRow(topRow));
	                        } else {
	                            var rowLayoutModel = sheet._getRowLayout(rowViewportIndex);
	                            if (rowLayoutModel && rowLayoutModel.length > 0) {
	                                var layout = sheet._getSheetLayout();
	                                var lastRow = rowLayoutModel[rowLayoutModel.length - 1];
	                                if (lastRow.y + lastRow.height >= layout._viewportY + layout._viewportHeight) {
	                                    sheet._setTopRow(sheet._getNextVisualRow(topRow));
	                                }
	                            }
	                        }
	                    } else if (topRow > getFrozenRowCount(sheet)) {
	                        sheet._setTopRow(sheet._getPrevVisualRow(topRow));
	                    }
	                }
	               
	                self._checkContinueScroll();
	            },
	            _processHSScrolled: function (increase) {
	                var self = this;
	                var adjusted = self._adjustScrollColViewport();
	                if (!adjusted) {
	                    var sheet = self._sheet;
	                    var hi = self._startHitInfo;
	                    var colViewportIndex = hi._scrollColViewportIndex;
	                    var leftCol = sheet.getViewportLeftColumn(colViewportIndex);
	                    var rightCol = sheet.getViewportRightColumn(colViewportIndex);
	                    if (increase) {
	                        if (rightCol < getSheetColumnCount(sheet) - sheet.frozenTrailingColumnCount() - 1) {
	                            sheet._setLeftColumn(sheet._getNextVisualColumn(leftCol));
	                        } else {
	                            var colLayoutModel = sheet._getColumnLayout(colViewportIndex);
	                            if (colLayoutModel && colLayoutModel.length > 0) {
	                                var layout = sheet._getSheetLayout();
	                                var lastCol = colLayoutModel[colLayoutModel.length - 1];
	                                if (lastCol.x + lastCol.width >= layout._viewportX + layout._viewportWidth) {
	                                    sheet._setLeftColumn(sheet._getNextVisualColumn(leftCol));
	                                }
	                            }
	                        }
	                    } else if (leftCol > getFrozenColumnCount(sheet)) {
	                        sheet._setLeftColumn(sheet._getPrevVisualColumn(leftCol));
	                    }
	                }
	               
	                self._checkContinueScroll();
	            },
	            _adjustScrollRowViewport: function () {
	               
	               
	                var sheet = this._sheet;
	                var layout = sheet._getSheetLayout();
	                var frozenRowCount = getFrozenRowCount(sheet);
	                var frozenTrailingRowCount = sheet.frozenTrailingRowCount();
	                var mousePosition = this._mousePosition;
	                var hi = this._startHitInfo;
	                var rowViewportIndex = hi._scrollRowViewportIndex;
	                if (rowViewportIndex === 0) {
	                    if (mousePosition.y > layout._viewportY) {
	                        sheet._setTopRow(sheet._getFirstPageTopRow());
	                        hi._scrollRowViewportIndex = 1;
	                        return true;
	                    }
	                } else if (rowViewportIndex === 1) {
	                    var rowLayoutModel = sheet._getRowLayout(1);
	                    if (rowLayoutModel && rowLayoutModel.length > 0) {
	                        var rowLayout = rowLayoutModel[0];
	                        if (frozenRowCount > 0 &&
	                            mousePosition.y < layout._viewportY &&
	                            rowLayout.row <= sheet._getFirstPageTopRow()) {
	                            hi._scrollRowViewportIndex = 0;
	                            return true;
	                        }
	                        rowLayout = rowLayoutModel[rowLayoutModel.length - 1];
	                        if (frozenTrailingRowCount > 0 &&
	                            mousePosition.y > layout._frozenTrailingY &&
	                            rowLayout.row >= sheet._getLastVisualRow() &&
	                            rowLayout.y + rowLayout.height <= layout._frozenTrailingY) {
	                            hi._scrollRowViewportIndex = 2;
	                            return true;
	                        }
	                    }
	                } else if (rowViewportIndex === 2) {
	                    rowLayoutModel = sheet._getRowLayout(1);
	                    if (rowLayoutModel && rowLayoutModel.length > 0 && mousePosition.y < layout._frozenTrailingY) {
	                        rowLayout = rowLayoutModel[rowLayoutModel.length - 1];
	                        if (rowLayout.y + rowLayout.height > layout._frozenTrailingY) {
	                            var viewportHeight = layout._viewportHeight;
	                            var newTopRow = getSheetRowCount(sheet) - frozenTrailingRowCount - 1;
	                            var height = 0;
	                            for (var r = newTopRow; r >= frozenRowCount; r--) {
	                                height += sheet._getZoomRowHeight(r);
	                                if (height > viewportHeight) {
	                                    newTopRow = Math_min(r + 1, newTopRow);
	                                    break;
	                                }
	                            }
	                            sheet._setTopRow(sheet._getNextVisualRow(newTopRow - 1));
	                        }
	                        hi._scrollRowViewportIndex = 1;
	                        return true;
	                    }
	                }
	                return false;
	            },
	            _adjustScrollColViewport: function () {
	               
	               
	                var sheet = this._sheet;
	                var frozenTrailingColCount = sheet.frozenTrailingColumnCount();
	                var frozenColCount = getFrozenColumnCount(sheet);
	                var layout = sheet._getSheetLayout();
	                var mousePosition = this._mousePosition;
	                var hi = this._startHitInfo;
	                var colViewportIndex = hi._scrollColViewportIndex;
	                if (colViewportIndex === 0) {
	                    if (mousePosition.x > layout._viewportX) {
	                        sheet._setLeftColumn(sheet._getFirstPageLeftColumn());
	                        hi._scrollColViewportIndex = 1;
	                        return true;
	                    }
	                } else if (colViewportIndex === 1) {
	                    var colLayoutModel = sheet._getColumnLayout(1);
	                    if (colLayoutModel && colLayoutModel.length > 0) {
	                        var colLayout = colLayoutModel[0];
	                        if (frozenColCount > 0 &&
	                            mousePosition.x < layout._viewportX &&
	                            colLayout.col <= sheet._getFirstPageLeftColumn()) {
	                            hi._scrollColViewportIndex = 0;
	                            return true;
	                        }
	                        colLayout = colLayoutModel[colLayoutModel.length - 1];
	                        if (frozenTrailingColCount > 0 &&
	                            mousePosition.x > layout._frozenTrailingX &&
	                            colLayout.col >= sheet._getLastVisualColumn() &&
	                            colLayout.x + colLayout.width <= layout._frozenTrailingX) {
	                            hi._scrollColViewportIndex = 2;
	                            return true;
	                        }
	                    }
	                } else if (colViewportIndex === 2) {
	                    colLayoutModel = sheet._getColumnLayout(1);
	                    if (colLayoutModel && colLayoutModel.length > 0 && mousePosition.x < layout._frozenTrailingX) {
	                        colLayout = colLayoutModel[colLayoutModel.length - 1];
	                        if (colLayout.x + colLayout.width > layout._frozenTrailingX) {
	                            var viewportWidth = layout._viewportWidth;
	                            var newLeftColumn = getSheetColumnCount(sheet) - frozenTrailingColCount - 1;
	                            var width = 0;
	                            for (var c = newLeftColumn; c >= frozenColCount; c--) {
	                                width += sheet._getZoomColumnWidth(c);
	                                if (width > viewportWidth) {
	                                    newLeftColumn = Math_min(c + 1, newLeftColumn);
	                                    break;
	                                }
	                            }
	                            sheet._setLeftColumn(sheet._getNextVisualColumn(newLeftColumn - 1));
	                        }
	                        hi._scrollColViewportIndex = 1;
	                        return true;
	                    }
	                }
	                return false;
	            },
	            _continueScroll: function () {
	                var self = this;
	                if (!self._isWorking && !self._isFloatingObjectWorking && !self._isCommentWorking) {
	                    return;
	                }
	                var sheet = self._sheet;
	                var layout = sheet._getSheetLayout();
	                var hi = self._startHitInfo;
	                var rowViewportIndex = hi._scrollRowViewportIndex;
	                var colViewportIndex = hi._scrollColViewportIndex;
	                var mousePosition = self._mousePosition;
	               
	                var viewportRect = keyword_null;
	                if (rowViewportIndex >= 0 && colViewportIndex >= 0) {
	                    viewportRect = layout._viewportRect(rowViewportIndex, colViewportIndex);
	                } else if (rowViewportIndex >= 0) {
	                    viewportRect = layout._rowHeaderRect(rowViewportIndex);
	                } else if (colViewportIndex >= 0) {
	                    viewportRect = layout._colHeaderRect(colViewportIndex);
	                }
	                if (viewportRect) {
	                    var distanceX = 0, distanceY = 0;
	                    if (mousePosition.x <= viewportRect.x) {
	                        distanceX = mousePosition.x - viewportRect.x;
	                    } else if (mousePosition.x >= viewportRect.x + viewportRect.width) {
	                        distanceX = mousePosition.x - (viewportRect.x + viewportRect.width);
	                    }
	                    if (mousePosition.y <= viewportRect.y) {
	                        distanceY = mousePosition.y - viewportRect.y;
	                    } else if (mousePosition.y >= viewportRect.y + viewportRect.height) {
	                        distanceY = mousePosition.y - (viewportRect.y + viewportRect.height);
	                    }
	                    self._getHScrollTimer()._setInterval(self._getIntervalFromDistance(distanceX));
	                    self._getVScrollTimer()._setInterval(self._getIntervalFromDistance(distanceY));
	                }
	            },
	            _stopScroll: function () {
	                this._getHScrollTimer()._stop();
	                this._getVScrollTimer()._stop();
	            },
	           
	            _startResizing: function (target) {
	                var self = this;
	                var layoutPrototype = _LayoutModel.prototype;
	                var sheet = self._sheet, resizeInfo = target.resizeInfo, rl, cl;
	                if (resizeInfo.action === SIZEROW || resizeInfo.action === SIZEHIDDENROW) {
	                    rl = getResizeLayout(self, sheet._getAllRowLayout, self._getPreVisualRow,
	                        layoutPrototype.findRow, target.row, resizeInfo, true);
	                    resizeInfo.startY = rl.y;
	                } else {
	                    cl = getResizeLayout(self, sheet._getAllColumnLayout, self._getPreVisualCol,
	                        layoutPrototype.findCol, target.col, resizeInfo, false);
	                    resizeInfo.startX = cl.x;
	                }
	               
	                var workbook = sheet.parent, x = target.x, y = target.y;
	                if (workbook) {
	                    var showResizeTip = workbook.options.showResizeTip;
	                    if ((showResizeTip === 1  &&
	                        (resizeInfo.action === SIZECOL || resizeInfo.action === SIZEHIDDENCOL)) ||
	                        (showResizeTip === 2  &&
	                            (resizeInfo.action === SIZEROW || resizeInfo.action === SIZEHIDDENROW)
	                        ) ||
	                        showResizeTip === 3 ) {
	                        if (y - RESIZETOOLTIP_TOP < 0) {
	                            y = y + RESIZETOOLTIP_TOP / 2;
	                        } else {
	                            y = y - RESIZETOOLTIP_TOP;
	                        }
	                        workbook._showTooltip(self._getMouseDownResizeTooltipContent(), x, y);
	                    }
	                }
	                self.isResizing = true;
	                self._isWorking = true;
	            },
	            _continueResizing: function () {
	                var self = this;
	                var sheet = self._sheet, currentTarget = sheet._currentTarget, resizeInfo = currentTarget.resizeInfo,
	                    mousePosition = self._mousePosition, x = mousePosition.x, y = mousePosition.y, layout = sheet._getSheetLayout();
	                if (!resizeInfo || !self._isWorking || !self.isResizing) {
	                    return;
	                }
	                if (currentTarget.x === x && currentTarget.y === y) {
	                    return;
	                }
	               
	                if (resizeInfo.action === SIZEROW || resizeInfo.action === SIZEHIDDENROW) {
	                    updateResizeInfo(resizeInfo, y, layout, true);
	                } else {
	                    updateResizeInfo(resizeInfo, x, layout, false);
	                }
	               
	               
	                var render = sheet._render, ctx = render._getCtx();
	                render._copyDoubleBuffer(layout.x, layout.y, layout.width, layout.height);
	                render._paintAdornment(ctx);
	               
	               
	                var workbook = sheet.parent;
	                if (workbook) {
	                    var showResizeTip = workbook.options.showResizeTip;
	                    if ((showResizeTip === 1  &&
	                        (resizeInfo.action === SIZECOL || resizeInfo.action === SIZEHIDDENCOL)) ||
	                        (showResizeTip === 2  && (resizeInfo.action === SIZEROW || resizeInfo.action === SIZEHIDDENROW)) ||
	                        showResizeTip === 3 ) {
	                        workbook._refreshTooltip(self._getMouseMoveResizeTooltipContent(resizeInfo));
	                    }
	                }
	            },
	            _stopResizing: function () {
	                var self = this;
	                self.isResizing = false;
	                self._isWorking = false;
	                var needResize = true;
	                var sheet = self._sheet, currentTarget = sheet._currentTarget, resizeInfo = currentTarget.resizeInfo, value;
	                if (!resizeInfo) {
	                    return;
	                }
	                self._removeTooltip();
	                if (resizeInfo.action === SIZEROW || resizeInfo.action === SIZEHIDDENROW) {
	                    if (!isNullOrUndefined(resizeInfo.movingY)) {
	                        value = Math_max(0, (resizeInfo.movingY - resizeInfo.startY) / sheet.zoom());
	                        var rowList = [];
	                        if (sheet._isRowSelected(resizeInfo.index)) {
	                            $.each(sheet._modelManager.getSelections(), function (i, p) {
	                                if (p.col === -1) {
	                                    var selectedRange = sheet._getActualRange(p);
	                                    rowList.push({
	                                        firstRow: selectedRange.row,
	                                        lastRow: selectedRange.row + getRowCount(selectedRange) - 1
	                                    });
	                                }
	                            });
	                        } else {
	                            rowList.push({firstRow: resizeInfo.index, lastRow: resizeInfo.index});
	                        }
	                        var isColHeader = resizeInfo.sheetArea === 1 ;
	                        sheet._commandManager().execute({
	                            cmd: 'resizeRow',
	                            sheetName: sheet.name(),
	                            rows: rowList,
	                            size: value,
	                            columnHeader: isColHeader
	                        });
	                    } else {
	                        needResize = false;
	                    }
	                } else if (!isNullOrUndefined(resizeInfo.movingX)) {
	                    value = Math_max(0, (resizeInfo.movingX - resizeInfo.startX) / sheet.zoom());
	                    var columnList = [];
	                    if (sheet._isColumnSelected(resizeInfo.index)) {
	                        $.each(sheet._modelManager.getSelections(), function (i, p) {
	                            if (p.row === -1) {
	                                var selectedRange = sheet._getActualRange(p);
	                                columnList.push({
	                                    firstCol: selectedRange.col,
	                                    lastCol: selectedRange.col + getColCount(selectedRange) - 1
	                                });
	                            }
	                        });
	                    } else {
	                        columnList.push({firstCol: resizeInfo.index, lastCol: resizeInfo.index});
	                    }
	                    var isRowHeader = resizeInfo.sheetArea === 2 ;
	
	                    sheet._commandManager().execute({
	                        cmd: 'resizeColumn',
	                        sheetName: sheet.name(),
	                        columns: columnList,
	                        size: value,
	                        rowHeader: isRowHeader
	                    });
	                } else {
	                    needResize = false;
	                }
	
	               
	                var target = sheet.hitTest(self._mousePosition.x, self._mousePosition.y);
	                if (target) {
	                    self._updateCanvasCursor(target);
	                }
	
	                if (!needResize) {
	                    sheet.repaint();
	                }
	            },
	           
	            _startSelectingCore: function (target, doNotSetFocus) {
	                var colIndex = 0, rowIndex = 0, rowCount = 0, colCount = 0;
	                var self = this;
	                var sheet = self._sheet;
	                var bm = sheet._bindingManager;
	                var frozenRowCount = getFrozenRowCount(sheet);
	                var frozenColCount = getFrozenColumnCount(sheet);
	                self._oldSelections = self._lastSelections = sheet._modelManager.getSelections();
	                if (!self.ctrl && !self.shift) {
	                    sheet._clearSelectionImp();
	                }
	                var firstRow, cellRange, activeRowChanged;
	                if (getHitTestType(target) === 0 ) {
	                    if (!self.shift) {
	                        firstRow = frozenRowCount ? sheet._getFirstVisualRow() : sheet._scrollTopRow;
	                        var leftCol = frozenColCount ? sheet._getFirstVisualColumn() : sheet._scrollLeftCol;
	                        var cancel = changeActiveCell(self, firstRow, leftCol, 1, 1, doNotSetFocus);
	                        if (cancel) {
	                            return;
	                        }
	                    }
	                    if (!self.ctrl) {
	                        sheet._clearSelectionImp();
	                    }
	                    sheet._setSelectedRange(-1, -1, getSheetRowCount(sheet), getSheetColumnCount(sheet), true);
	                } else if (getHitTestType(target) === 1 ) {
	                   
	                   
	                    if (!self.shift) {
	                        firstRow = frozenRowCount ? sheet._getFirstVisualRow() : sheet._scrollTopRow;
	                        cellRange = self._getAvailableActiveCell(firstRow, target.col, false);
	
	                        cancel = changeActiveCell(self, cellRange.row, cellRange.col, 1, getColViewportIndex(target), doNotSetFocus);
	                        if (cancel) {
	                            return;
	                        }
	                    }
	                    if (self.shift || sheet._isDeselecting) {
	                        colIndex = Math_min(sheet._activeColIndex, target.col);
	                        colCount = Math_abs(sheet._activeColIndex - target.col) + 1;
	                        sheet._replaceActiveSelectedRange(-1, colIndex, getSheetRowCount(sheet), colCount, true);
	                    } else{
	                        sheet._setSelectedRange(-1, sheet._activeColIndex, getSheetRowCount(sheet), 1, true);
	                    }
	                } else if (getHitTestType(target) === 2 ) {
	                    if (!self.shift) {
	                        var firstCol = frozenColCount ? sheet._getFirstVisualColumn() : sheet._scrollLeftCol;
	                        cellRange = self._getAvailableActiveCell(target.row, firstCol, true);
	
	                        activeRowChanged = (sheet._activeRowIndex !== cellRange.row);
	                        cancel = changeActiveCell(self, cellRange.row, cellRange.col, getRowViewportIndex(target), 1, doNotSetFocus);
	                        if (cancel) {
	                            return;
	                        }
	
	                        if (activeRowChanged && bm) {
	                            bm._doDataItemChanged();
	                        }
	                    }
	                    if (self.shift || sheet._isDeselecting) {
	                        rowIndex = Math_min(sheet._activeRowIndex, target.row);
	                        rowCount = Math_abs(sheet._activeRowIndex - target.row) + 1;
	                        sheet._replaceActiveSelectedRange(rowIndex, -1, rowCount, getSheetColumnCount(sheet), true);
	                    } else {
	                        sheet._setSelectedRange(sheet._activeRowIndex, -1, 1, getSheetColumnCount(sheet), true);
	                    }
	                } else if (getHitTestType(target) === 3 ) {
	                    if (!isNotANumber(target.row) && !isNotANumber(target.col)) {
	                        if (!self.shift) { 
	                            if (sheet._activeRowIndex !== target.row || sheet._activeColIndex !== target.col) {
	                                activeRowChanged = (sheet._activeRowIndex !== target.row);
	                                cancel = changeActiveCell(self, target.row, target.col,
	                                    getRowViewportIndex(target), getColViewportIndex(target), doNotSetFocus);
	                                if (cancel) {
	                                    return;
	                                }
	                                if (activeRowChanged && bm) {
	                                    bm._doDataItemChanged();
	                                }
	                            }
	                        }
	                        if (self.shift) {
	                            sheet._extendSelectedRange(target.row, target.col, true);
	                        } else {
	                            var span = sheet._modelManager.getSpan(target.row, target.col);
	                            if(!sheet._isDeselecting) {
	                            sheet._setSelectedRange(span.row, span.col, getRowCount(span), getColCount(span), true);
	                        }
	                        }
	                    } else if (isEditing(sheet)) {
	                       
	                        var rect = sheet.getCellRect(sheet._activeRowIndex, sheet._activeColIndex,
	                            sheet._activeRowViewportIndex, sheet._activeColViewportIndex);
	                        sheet._render._update(rect.x, rect.y, rect.width, rect.height);
	                    }
	                }
	            },
	            _startSelectingScroll: function (target) {
	                if (!target) {
	                    return;
	                }
	                if (getHitTestType(target) === 3  && (isNotANumber(target.row) || isNotANumber(target.col))) {
	                    return;
	                }
	                var self = this;
	                self._isWorking = true;
	                self._isSelecting = true;
	                self._startHitInfo = {
	                    _scrollRowViewportIndex: getRowViewportIndex(target),
	                    _scrollColViewportIndex: getColViewportIndex(target),
	                    _hitTestType: getHitTestType(target)
	                };
	                self._startScroll();
	            },
	            _startSelecting: function (target, selections) {
	                var self = this, sheet = self._sheet;
	                sheet._isDeselecting = self._getIsDeselect(target.row, target.col, selections) && sheet.parent.options.allowUserDeselect;
	                if(sheet._isDeselecting) {
	                    sheet._oldActiveRow = sheet._activeRowIndex;
	                    sheet._oldActiveCol = sheet._activeColIndex;
	                    sheet._deselectRange = new Range(target.row, target.col, 1, 1);
	                }
	                self._startSelectingCore(target);
	                self._startSelectingScroll(target);
	            },
	            _getIsDeselect : function (row, col, selections) {
	                var self = this, sheet = self._sheet;
	                var isStartCellInSelection = self._getIsStartCellInSelection(row, col, selections);
	                return isStartCellInSelection && sheet.selectionPolicy() === 2 ;
	            },
	            _getIsStartCellInSelection: function (row, col, selections) {
	                if(!this.ctrl) {
	                    return false;
	                }
	                var flag = false, len = selections.length;
	                for(var i = 0; i < len;i++) {
	                    if(selections[i].intersect(row, col, 1, 1)) {
	                        flag = true;
	                        break;
	                    }
	                }
	                return flag;
	
	            },
	            _continueSelecting: function () {
	                var self = this;
	                if (!self._startHitInfo || !self._isWorking) {
	                    return;
	                }
	                if (self._forceCancelSelectiong === true) {
	                    return;
	                }
	                var hitTestType = self._startHitInfo._hitTestType;
	                if (hitTestType === 3 ) {
	                    self._continueCellSelecting();
	                } else if (hitTestType === 2 ) {
	                    self._continueRowSelecting();
	                } else if (hitTestType === 1 ) {
	                   
	                    self._continueColumnSelecting();
	                }
	            },
	            _continueCellSelecting: function () {
	                var self = this;
	                var sheet = self._sheet;
	                var hitRow = self._getHitRowIndex();
	                var hitCol = self._getHitColumnIndex();
	                if (hitRow >= 0 && hitCol >= 0 && sheet._canSelect(hitRow, hitCol)) {
	                    var oldSelections = sheet._modelManager.getSelections();
	                   
	                    if (oldSelections.length === 1) {
	                        var extendedRange = sheet._getExtendedRange(hitRow, hitCol, sheet._activeRowIndex, sheet._activeColIndex);
	                        var oldRange = oldSelections[0];
	                       
	                        if (!sheet._isDeselecting && extendedRange.equals(oldRange)) {
	                            return;
	                        }
	                    }
	                    sheet._extendSelectedRange(hitRow, hitCol, true);
	                    var newSelections = sheet._modelManager.getSelections();
	                    sheet._raiseSelectionChanging(oldSelections, newSelections);
	                    self._continueScroll();
	                }
	            },
	            _continueRowSelecting: function () {
	                var self = this;
	                var sheet = self._sheet;
	                var hitRow = self._getHitRowIndex();
	                if (hitRow >= 0 && sheet._canSelect(hitRow, -1)) {
	                    var r = Math_min(sheet._activeRowIndex, hitRow);
	                    var rc = Math_max(sheet._activeRowIndex, hitRow) - r + 1;
	                    var c = -1;
	                    var cc = getSheetColumnCount(sheet);
	                    var selectionPolicy = sheet.selectionPolicy();
	                    if (selectionPolicy === 0 ) {
	                        return;
	                    }
	                    var selectionUnit = sheet.selectionUnit();
	                    if (selectionUnit === 2 ) {
	                        r = -1;
	                        rc = -1;
	                    }
	
	                    var oldSelections = sheet._modelManager.getSelections();
	                    sheet._replaceActiveSelectedRange(r, c, rc, cc, true);
	                    var newSelections = sheet._modelManager.getSelections();
	                    sheet._raiseSelectionChanging(oldSelections, newSelections);
	                }
	                self._continueScroll();
	            },
	            _continueColumnSelecting: function () {
	                var self = this;
	                var sheet = self._sheet;
	                var hitCol = self._getHitColumnIndex();
	                if (hitCol >= 0 && sheet._canSelect(-1, hitCol)) {
	                    var c = Math_min(sheet._activeColIndex, hitCol);
	                    var cc = Math_max(sheet._activeColIndex, hitCol) - c + 1;
	                    var r = -1;
	                    var rc = getSheetRowCount(sheet);
	                    var selectionPolicy = sheet.selectionPolicy();
	                    if (selectionPolicy === 0 ) {
	                        return;
	                    }
	                    var selectionUnit = sheet.selectionUnit();
	                    if (selectionUnit === 1 ) {
	                        c = -1;
	                        cc = -1;
	                    }
	
	                    var oldSelections = sheet._modelManager.getSelections();
	                    sheet._replaceActiveSelectedRange(r, c, rc, cc, true);
	                    var newSelections = sheet._modelManager.getSelections();
	                    sheet._raiseSelectionChanging(oldSelections, newSelections);
	                }
	               
	                self._continueScroll();
	            },
	            _stopSelecting: function () {
	                var self = this;
	                self._startHitInfo = keyword_null;
	                self._stopScroll();
	                self._forceCancelSelectiong = keyword_null;
	                self._isWorking = false;
	                self._isSelecting = false;
	                var sheet = self._sheet;
	                if (sheet._modelManager.getSelections().length < 0) {
	                    return;
	                }
	                if(sheet._isDeselecting) {
	                    sheet._isDeselecting = false;
	                    var deselectRange = sheet._deselectRange;
	                    sheet._deselectRange = null;
	                    sheet._deselectSelections(sheet._modelManager.getSelections(), deselectRange, sheet._oldActiveRow, sheet._oldActiveCol);
	                    delete sheet._oldActiveRow;
	                    delete sheet._oldActiveCol;
	                }
	
	                if (sheet._noMoreSelectionChanged) {
	                   
	                    delete sheet._noMoreSelectionChanged;
	                } else {
	                    var needRaiseChangedEvent = !self._lastSelections;
	                    if (!needRaiseChangedEvent) {
	                    var currentSelections = sheet._modelManager.getSelections();
	                        needRaiseChangedEvent = self._notEqualSelecions(self._lastSelections, currentSelections);
	                    }
	                    if (needRaiseChangedEvent) {
	                        sheet._raiseSelectionChanged(self._oldSelections);
	                    }
	                }
	                self._lastSelections = sheet._modelManager.getSelections();
	            },
	           
	            _getHitRowViewportIndex: function () {
	                var sheet = this._sheet;
	                var rowViewportIndex = _getRowViewportIndexNearY(sheet, this._mousePosition.y);
	                var scrollRowViewportIndex = this._startHitInfo._scrollRowViewportIndex;
	                var rowLayoutModel = sheet._getRowLayout(1);
	                if (rowViewportIndex === 0 &&
	                    scrollRowViewportIndex > 0 &&
	                    rowLayoutModel.length > 0 &&
	                    rowLayoutModel[0].row > sheet._getFirstPageTopRow()) {
	                    rowViewportIndex = 1;
	                } else if (rowViewportIndex === 2 &&
	                    scrollRowViewportIndex < 2 &&
	                    rowLayoutModel.length > 0 &&
	                    rowLayoutModel[rowLayoutModel.length - 1].row < sheet._getLastVisualRow()) {
	                    rowViewportIndex = 1;
	                }
	                return rowViewportIndex;
	            },
	            _getHitColumnViewportIndex: function () {
	                var sheet = this._sheet;
	                var colViewportIndex = _getColumnViewportIndexNearX(sheet, this._mousePosition.x);
	                var scrollColViewportIndex = this._startHitInfo._scrollColViewportIndex;
	                var colLayoutModel = sheet._getColumnLayout(1);
	                if (colViewportIndex === 0 && scrollColViewportIndex > 0 && colLayoutModel.length > 0 && colLayoutModel[0].col > sheet._getFirstPageLeftColumn()) {
	                    colViewportIndex = 1;
	                } else if (colViewportIndex === 2 && scrollColViewportIndex < 2 && colLayoutModel.length > 0 &&
	                    colLayoutModel[colLayoutModel.length - 1].col < sheet._getLastVisualColumn()) {
	                    colViewportIndex = 1;
	                }
	                return colViewportIndex;
	            },
	            _getHitRowIndex: function () {
	                var sheet = this._sheet;
	                var y = this._mousePosition.y;
	                var rowViewportIndex = this._getHitRowViewportIndex();
	                var rowLayout = _getViewportRowLayoutNearY(sheet, rowViewportIndex, y);
	                if (rowLayout) {
	                    var layout = sheet._getSheetLayout();
	                    var hitRow = rowLayout.row;
	                    if (rowViewportIndex === 1 && y < layout._viewportY && hitRow > sheet._getFirstPageTopRow()) {
	                        return (sheet._getNextVisualRow(hitRow - 1) || hitRow);
	                    }
	                    if (rowViewportIndex === 1 && y > layout._frozenTrailingY && hitRow > sheet._getLastFullyVisibleRow()) {
	                        return (sheet._getPrevVisualRow(hitRow) || hitRow);
	                    }
	                    return hitRow;
	                }
	                return -1;
	            },
	            _getHitColumnIndex: function () {
	                var sheet = this._sheet;
	                var x = this._mousePosition.x;
	                var colViewportIndex = this._getHitColumnViewportIndex();
	                var colLayout = _getViewportColumnLayoutNearX(sheet, colViewportIndex, x);
	                if (colLayout) {
	                    var layout = sheet._getSheetLayout();
	                    var hitCol = colLayout.col;
	                    if (colViewportIndex === 1 && x < layout._viewportX && hitCol > sheet._getFirstPageLeftColumn()) {
	                        return (sheet._getNextVisualColumn(hitCol - 1) || hitCol);
	                    }
	                    if (colViewportIndex === 1 && x > layout._frozenTrailingX && hitCol > sheet._getLastFullyVisibleColumn()) {
	                        return (sheet._getPrevVisualColumn(hitCol) || hitCol);
	                    }
	                    return hitCol;
	                }
	                return -1;
	            },
	            _getIntervalFromDistance: function (distance) {
	                var interval = 0;
	                if (!isNotANumber(distance) && distance !== 0) {
	                    var isNegative = (distance < 0);
	                    interval = Math_ceil(500 / Math_abs(distance));
	                    interval = Math_max(20, interval * 10);
	                    if (interval > 200) {
	                        interval = 200;
	                    }
	                    if (isNegative) {
	                        interval = -interval;
	                    }
	                }
	                return interval;
	            },
	            _getPreVisualRow: function (row, sheetArea) {
	                var sheet = this._sheet, preVisualRow = sheet._getPrevVisualRow(row, sheetArea);
	                return preVisualRow !== keyword_null ? preVisualRow : row;
	            },
	            _getPreVisualCol: function (col, sheetArea) {
	                var sheet = this._sheet, preVisualCol = sheet._getPrevVisualColumn(col, sheetArea);
	                return preVisualCol !== keyword_null ? preVisualCol : col;
	            },
	            _getPreVisibleRow: function (row, endRow, sheetArea) {
	                var sheet = this._sheet;
	                while (row > endRow) {
	                    row--;
	                    if (sheet.getRowVisible(row, sheetArea)) {
	                        return row;
	                    }
	                }
	                return row;
	            },
	            _getPreVisibleCol: function (col, endCol, sheetArea) {
	                var sheet = this._sheet;
	                while (col > endCol) {
	                    col--;
	                    if (sheet.getColumnVisible(col, sheetArea)) {
	                        return col;
	                    }
	                }
	                return col;
	            },
	            _getResizeRowInfo: function (sheet, target, resizeArea, sheetArea, y) {
	                var op = keyword_null;
	                if (!canDoResizeRows(sheet)) {
	                    return op;
	                }
	                var self = this;
	                var rowLayout = sheet._getRowLayout(getRowViewportIndex(target), sheetArea);
	                if (rowLayout && !isNotANumber(target.row) && !isNotANumber(target.col)) {
	                    if (!sheet.getRowVisible(target.row, sheetArea)) {
	                        target.row = this._getPreVisualRow(target.row, sheetArea);
	                    }
	                    var rl = rowLayout.findRow(target.row);
	                    if (rl) {
	                        if (rl.y + rl.height - resizeArea <= y && y <= rl.y + rl.height + resizeArea) {
	                            op = createOption(SIZEROW, target.row, sheetArea);
	                           
	                            var lastRow = rowLayout[rowLayout.length - 1].row;
	                            if (lastRow >= 0) {
	                                var lastVisibleRow = sheet._getLastVisualRow(sheetArea);
	                                if (op.index === lastVisibleRow && op.index !== lastRow) { 
	                                    if (rl.y + rl.height - resizeArea / 2 <= y) {
	                                        op = createOption(
	                                            self._getResizeRowAction(sheet, lastRow, sheetArea),
	                                            lastRow,
	                                            sheetArea
	                                        );
	                                    }
	                                }
	                            }
	                        } else if (rl.y - resizeArea <= y && y <= rl.y + resizeArea && Common._ArrayHelper._indexOf(rowLayout, rl) > 0) {
	                            var preVisibleRow = self._getPreVisibleRow(target.row, 0, sheetArea);
	                            op = createOption(
	                                self._getResizeRowAction(sheet, preVisibleRow, sheetArea),
	                                preVisibleRow,
	                                sheetArea
	                            );
	                        }
	                    }
	                   
	                    if (!op && getRowViewportIndex(target) === 1 && rowLayout.length > 0) {
	                        rl = rowLayout[0];
	                        if (Math_max(0, rl.y - resizeArea) <= y && y <= rl.y + resizeArea) {
	                            var row = getResizeIndexNextToFrozenLine(sheet, target.row, true);
	                            if (row >= 0) {
	                                op = createOption(
	                                    self._getResizeRowAction(sheet, row, sheetArea),
	                                    row,
	                                    sheetArea
	                                );
	                            }
	                        }
	                    }
	                }
	                if (op && !sheet.getRowResizable(op.index, sheetArea)) {
	                    op = keyword_null;
	                }
	                return op;
	            },
	            _getResizeRowAction: function (sheet, row, sheetArea) {
	                var workbook = sheet.parent;
	                if (workbook && workbook.options.resizeZeroIndicator === 1  &&
	                    sheet.getRowVisible(row) && sheet._getActualRowHeight(row, sheetArea) === 0) {
	                    return SIZEHIDDENROW;
	                }
	                return SIZEROW;
	            },
	            _getResizeColInfo: function (sheet, target, resizeArea, sheetArea, x) {
	                var op = keyword_null;
	                if (!canDoResizeColumns(sheet)) {
	                    return op;
	                }
	                var self = this;
	                var colLayout = sheet._getColumnLayout(getColViewportIndex(target), sheetArea);
	                if (colLayout && !isNotANumber(target.col) && !isNotANumber(target.row)) {
	                    if (!sheet.getColumnVisible(target.col, sheetArea)) {
	                        target.col = this._getPreVisualCol(target.col, sheetArea);
	                    }
	                    var cl = colLayout.findCol(target.col);
	                    if (cl) {
	                        if (cl.x + cl.width - resizeArea <= x && x <= cl.x + cl.width + resizeArea) {
	                            op = createOption(SIZECOL, target.col, sheetArea);
	                           
	                            var lastCol = colLayout[colLayout.length - 1].col;
	                            if (lastCol >= 0) {
	                                var lastVisibleCol = sheet._getLastVisualColumn(sheetArea);
	                                if (op.index === lastVisibleCol && op.index !== lastCol) { 
	                                    if (cl.x + cl.width - resizeArea / 2 <= x) {
	                                        op = createOption(
	                                            self._getResizeColAction(sheet, lastCol, sheetArea),
	                                            lastCol,
	                                            sheetArea
	                                        );
	                                    }
	                                }
	                            }
	                        } else if (cl.x - resizeArea <= x && x <= cl.x + resizeArea && Common._ArrayHelper._indexOf(colLayout, cl) > 0) {
	                            var preVisibleCol = self._getPreVisibleCol(target.col, 0, sheetArea);
	                            op = createOption(
	                                self._getResizeColAction(sheet, preVisibleCol, sheetArea),
	                                preVisibleCol,
	                                sheetArea
	                            );
	                        }
	                    }
	                   
	                    if (!op && getColViewportIndex(target) === 1 && colLayout.length > 0) {
	                        cl = colLayout[0];
	                        if (Math_max(0, cl.x - resizeArea) <= x && x <= cl.x + resizeArea) {
	                            var col = getResizeIndexNextToFrozenLine(sheet, target.col, false);
	                            if (col >= 0) {
	                                op = createOption(
	                                    self._getResizeColAction(sheet, col, sheetArea),
	                                    col,
	                                    sheetArea
	                                );
	                            }
	                        }
	                    }
	                }
	                if (op && !sheet.getColumnResizable(op.index, sheetArea)) {
	                    op = keyword_null;
	                }
	                return op;
	            },
	            _getResizeColAction: function (sheet, col, sheetArea) {
	                var workbook = sheet.parent;
	                if (workbook && workbook.options.resizeZeroIndicator === 1  &&
	                    sheet.getColumnVisible(col) && sheet._getActualColumnWidth(col, sheetArea) === 0) {
	                    return SIZEHIDDENCOL;
	                }
	                return SIZECOL;
	            },
	            _getResizingRowCol: function (target, x, y, resizeArea) {
	                var self = this;
	                var sheet = self._sheet, workbook = sheet.parent, sheet_options = sheet.options,
	                    colHeaderVisible = sheet_options.colHeaderVisible, rowHeaderVisible = sheet_options.rowHeaderVisible;
	                var op = keyword_null, r, c;
	                if (!workbook || workbook.options.allowUserResize) {
	                    var sheetLayout = sheet._getSheetLayout();
	                    if (getRowViewportIndex(target) < 0 && getColViewportIndex(target) >= 0 && colHeaderVisible) {
	                        op = self._getResizeColInfo(sheet, target, resizeArea, 1 , x);
	                        if (!op) {
	                            op = self._getResizeRowInfo(sheet, target, resizeArea, 1 , y);
	                        }
	                    } else if (getRowViewportIndex(target) >= 0 && getColViewportIndex(target) < 0 && rowHeaderVisible) {
	                        op = self._getResizeRowInfo(sheet, target, resizeArea, 2 , y);
	                        if (!op) {
	                            op = self._getResizeColInfo(sheet, target, resizeArea, 2 , x);
	                        }
	                    } else if (getRowViewportIndex(target) < 0 && getColViewportIndex(target) < 0) {
	                       
	                        if ((sheet._getLastVisualRow(2 ) === keyword_null) && (Math_abs(y - sheetLayout._colHeaderHeight) <= resizeArea)) {
	                            var rowLayout = sheet._getRowLayout(1);
	                            if (rowLayout && rowLayout.length > 0) {
	                                r = rowLayout[rowLayout.length - 1].row;
	                                if (r >= 0 && sheet.getRowResizable(r, 2 )) {
	                                    op = createOption(
	                                        self._getResizeRowAction(sheet, r, 2 ),
	                                        r,
	                                        2 
	                                    );
	                                }
	                            }
	                        } else if ((sheet._getLastVisualColumn(1 ) === keyword_null) && (Math_abs(x - sheetLayout._rowHeaderWidth) <= resizeArea)) {
	                            var colLayout = sheet._getColumnLayout(1);
	                            if (colLayout && colLayout.length > 0) {
	                                c = colLayout[colLayout.length - 1].col;
	                                if (c >= 0 && sheet.getColumnResizable(c, 1 )) {
	                                    op = createOption(
	                                        self._getResizeColAction(sheet, c, 1 ),
	                                        c,
	                                        1 
	                                    );
	                                }
	                            }
	                        }
	                    } else if (getRowViewportIndex(target) >= 0 && getColViewportIndex(target) >= 0) {
	                        r = getSheetRowCount(sheet, 1 ) - 1;
	                        c = getSheetColumnCount(sheet, 2 ) - 1;
	                        if (r >= 0 && sheetLayout._colHeaderHeight === 0 && y <= resizeArea && colHeaderVisible) {
	                            op = createOption(
	                                self._getResizeRowAction(sheet, r, 1 ),
	                                r,
	                                1 
	                            );
	                        } else if (c >= 0 && sheetLayout._rowHeaderWidth === 0 && x <= resizeArea && rowHeaderVisible) {
	                            op = createOption(
	                                self._getResizeColAction(sheet, c, 2 ),
	                                c,
	                                2 
	                            );
	                        }
	                    }
	                }
	                return op;
	            },
	            _inGrayArea: function (rowViewportIndex, colViewportIndex, x, y) {
	                var sheet = this._sheet, layout = sheet._getSheetLayout(), viewportRect = layout._viewportRect(1, 1);
	                if (colViewportIndex === 1) {
	                    var colLayoutModel = sheet._getColumnLayout(colViewportIndex);
	                    if (colLayoutModel && colLayoutModel.length > 0) {
	                        var colLayout = colLayoutModel[colLayoutModel.length - 1];
	                        if (colLayout.x + colLayout.width <= x && x < viewportRect.x + viewportRect.width) {
	                            return true;
	                        }
	                    } else if (viewportRect.contains(x, y)) {
	                        return true;
	                    }
	                }
	                if (rowViewportIndex === 1) {
	                    var rowLayoutModel = sheet._getRowLayout(rowViewportIndex);
	                    if (rowLayoutModel && rowLayoutModel.length > 0) {
	                        var rowLayout = rowLayoutModel[rowLayoutModel.length - 1];
	                        if (rowLayout.y + rowLayout.height <= y && y < viewportRect.y + viewportRect.height) {
	                            return true;
	                        }
	                    } else if (viewportRect.contains(x, y)) {
	                        return true;
	                    }
	                }
	                return false;
	            },
	            _doMouseMove: function (e) {
	                var t = this._getCanvasOffset();
	                this._doMouseMoveImp(e, e.pageX - t.left, e.pageY - t.top);
	            },
	            _doMouseOut: function () {
	                var sheet = this._sheet;
	               
	                var oldTarget = sheet._currentTarget;
	                if (oldTarget) {
	                    var cellTypeHitInfo = oldTarget.cellTypeHitInfo;
	                    if (cellTypeHitInfo) {
	                        var celltype = sheet.getCellType(cellTypeHitInfo.row, cellTypeHitInfo.col, getHitTestType(oldTarget));
	                        celltype.processMouseLeave(cellTypeHitInfo);
	                    }
	                }
	                if (this._isWorking) {
	                    return;
	                }
	                var outTarget = {
	                    x: -10000,
	                    y: -10000,
	                    rowViewportIndex: keyword_null,
	                    colViewportIndex: keyword_null,
	                    row: -1,
	                    col: -1,
	                    resizeInfo: keyword_null,
	                    hitTestType: keyword_null
	                };
	                this._setHoverCell(outTarget);
	            },
	            _doMouseMoveImp: function (e, x, y) {
	                var self = this;
	                self._mousePosition = {e: e, x: x, y: y};
	                var sheet = self._sheet;
	                if (self._isMouseDown && !_FocusHelper._isActiveElement(sheet)) {
	                    _FocusHelper._setActiveElement(sheet);
	                }
	               
	                if (self._isMouseDown && self._isWorking) {
	                    if (self.isResizing) {
	                        self._continueResizing();
	                    } else if (self._isDragMerging) {
	                        self._continueDragMerge && self._continueDragMerge();
	                    } else if (self._isDragDropping) {
	                        self._continueDragDropping && self._continueDragDropping();
	                    } else if (self._isDraggingFill) {
	                        self._continueDragFill && self._continueDragFill();
	                    } else if (self._isFormulaRangeAppending) {
	                        self._continueFormulaRangeAppending();
	                    } else if (self._isFormulaRangeMoving) {
	                        self._continueFormulaRangeMoving();
	                    } else if (self._isFormulaRangeResizing) {
	                        self._continueFormulaRangeResizing();
	                    } else if (self._isSelecting) {
	                        self._continueSelecting();
	                    }
	                    return;
	                }
	               
	                var target = sheet.hitTest(x, y);
	                if (!target) {
	                    return;
	                }
	
	                self._updateCanvasCursor(target);
	
	               
	                self._setHoverCell(target);
	            },
	            _updateCanvasCursor: function (target) {
	                var self = this, sheet = self._sheet, canvas = sheet._getCanvas();
	                if (!canvas) {
	                    return;
	                }
	                var oldTarget = sheet._currentTarget;
	                var targetChanged = ((!oldTarget) ||
	                (target.row !== oldTarget.row) ||
	                (target.col !== oldTarget.col) ||
	                (getHitTestType(target) !== getHitTestType(oldTarget)) ||
	                (target.resizeInfo && !oldTarget.resizeInfo) ||
	                (!target.resizeInfo && oldTarget.resizeInfo) ||
	                (target.resizeInfo && target.resizeInfo.action !== oldTarget.resizeInfo.action) ||
	                (target.dragInfo && !oldTarget.dragInfo) ||
	                (!target.dragInfo && oldTarget.dragInfo) ||
	                (target.dragInfo && target.dragInfo.action !== oldTarget.dragInfo.action));
	                if (oldTarget && targetChanged) {
	                    var cellTypeHitInfo = oldTarget.cellTypeHitInfo;
	                    if (cellTypeHitInfo) {
	                        var celltype = sheet.getCellType(cellTypeHitInfo.row, cellTypeHitInfo.col, getHitTestType(oldTarget));
	                        celltype.processMouseLeave(cellTypeHitInfo);
	                    }
	                }
	                var resizeInfo = target.resizeInfo, dragMergeInfo = target.dragMergeInfo,
	                    dragInfo = target.dragInfo, frInfo = target.formulaRangeHitInfo,
	                    cellTypeInfo = target.cellTypeHitInfo, render = sheet._render;
	                if (resizeInfo) {
	                    var CursorResource = util_common.CursorResource;
	                    if (resizeInfo.action === SIZECOL) {
	                        canvas.style.cursor = CursorResource.ResizeCol;
	                    } else if (resizeInfo.action === SIZEROW) {
	                        canvas.style.cursor = CursorResource.ResizeRow;
	                    } else if (resizeInfo.action === SIZEHIDDENCOL) {
	                        canvas.style.cursor = CursorResource.ResizeHiddenCol;
	                    } else if (resizeInfo.action === SIZEHIDDENROW) {
	                        canvas.style.cursor = CursorResource.ResizeHiddenRow;
	                    } else {
	                        canvas.style.cursor = DEFAULT;
	                    }
	                } else if (dragMergeInfo) {
	                    if (dragMergeInfo.left || dragMergeInfo.right) {
	                        canvas.style.cursor = "w-resize";
	                    } else if (dragMergeInfo.top || dragMergeInfo.bottom) {
	                        canvas.style.cursor = "n-resize";
	                    }
	                } else if (dragInfo && dragInfo.action === 'drag') {
	                    if (dragInfo.side === CORNER) {
	                        canvas.style.cursor = 'crosshair';
	                    } else if (dragInfo.side) {
	                        canvas.style.cursor = 'move';
	                    } else {
	                        canvas.style.cursor = DEFAULT;
	                    }
	                } else if (frInfo) {
	                    if (frInfo.inBorder) {
	                        canvas.style.cursor = 'move';
	                    } else if (frInfo.inTopLeft) {
	                        canvas.style.cursor = 'nw-resize';
	                    } else if (frInfo.inTopRight) {
	                        canvas.style.cursor = 'ne-resize';
	                    } else if (frInfo.inBottomLeft) {
	                        canvas.style.cursor = 'sw-resize';
	                    } else if (frInfo.inBottomRight) {
	                        canvas.style.cursor = 'se-resize';
	                    }
	                    var oldFormulaRangeHoving = self.isFormulaRangeHoving, oldFormulRangeHovingInfo = self._formulRangeHovingInfo,
	                        oldParamRange = (oldFormulRangeHovingInfo && oldFormulRangeHovingInfo.paramRange);
	                    var newParamRange = frInfo.paramRange;
	                   
	                    self.isFormulaRangeHoving = true;
	                    self._formulRangeHovingInfo = {paramRange: newParamRange};
	                    if (!oldFormulaRangeHoving || newParamRange.index !== oldParamRange.index) {
	                        render._paintFormulaTextBox();
	                    }
	                } else {
	                    if (cellTypeInfo) {
	                        celltype = sheet.getCellType(cellTypeInfo.row, cellTypeInfo.col, getHitTestType(target));
	                        cellTypeInfo.sheet = sheet;
	                        if (targetChanged) {
	                            celltype.processMouseEnter(cellTypeInfo);
	                        }
	                        celltype.processMouseMove(cellTypeInfo);
	                    }
	                    if (targetChanged || !cellTypeInfo || !cellTypeInfo.isReservedLocation) {
	                        canvas.style.cursor = DEFAULT;
	                    }
	                   
	                    if (self.isFormulaRangeHoving) {
	                        self.isFormulaRangeHoving = false;
	                        self._formulRangeHovingInfo = keyword_null;
	                        render._paintFormulaTextBox();
	                    }
	                }
	            },
	            _doMouseUp: function (e) {
	                var self = this;
	                var sheet = self._sheet;
	                self._unhandleDocumentMouseMove();
	                var t = sheet._getCanvasOffset();
	                if (!sheet._isMouseDownInSheet) {
	                    return true;
	                }
	                sheet._isMouseDownInSheet = false;
	                self._doMouseUpImp(e, e.pageX - t.left, e.pageY - t.top);
	                return false;
	            },
	            _doMouseUpImp: function (e) {
	                var self = this;
	                var sheet = self._sheet;
	                var ae = _FocusHelper._getActiveElement();
	                self._isMouseDown = false;
	                if (ae && ae !== sheet && ae.endEdit) { 
	                    if (!ae._formulaTextBox || !ae._formulaTextBox._isSelectMode) {
	                        ae.endEdit();
	                        ae.repaint();
	                    }
	                }
	                _FocusHelper._setActiveElement(sheet);
	               
	                if (self.isResizing) {
	                    self._stopResizing();
	                } else if (self._isDragMerging) {
	                    self._stopDragMerge && self._stopDragMerge();
	                } else if (self._isDragDropping) {
	                    self._stopDragDrop && self._stopDragDrop();
	                } else if (self._isDraggingFill) {
	                    self._endDragFill && self._endDragFill();
	                } else if (self._isFormulaRangeAppending) {
	                    self._stopFormulaRangeAppending();
	                } else if (self._isFormulaRangeMoving) {
	                    self._stopFormulaRangeMoving();
	                } else if (self._isFormulaRangeResizing) {
	                    self._stopFormulaRangeResizing();
	                } else if (sheet._currentTarget) {
	                    var currentTarget = sheet._currentTarget, cellTypeHitInfo = currentTarget.cellTypeHitInfo;
	                    if (!currentTarget.filterButtonHitInfo && !currentTarget.resizeInfo && 
	                        currentTarget.row >= 0 && currentTarget.col >= 0) {
	                        if (cellTypeHitInfo) {
	                            var ct = sheet.getCellType(cellTypeHitInfo.row, cellTypeHitInfo.col, getHitTestType(currentTarget));
	                            if (!cellTypeHitInfo.sheet) {
	                                cellTypeHitInfo.sheet = sheet;
	                            }
	                            ct.processMouseUp(cellTypeHitInfo);
	                        }
	                        if (!cellTypeHitInfo || !cellTypeHitInfo.isReservedLocation) {
	                            sheet._trigger(Events.CellClick,
	                            createEventArg(sheet, sheet.name(), currentTarget.row, currentTarget.col, getHitTestType(currentTarget)));
	                        }
	                    }
	                }
	               
	               
	                self._stopSelecting();
	                self._setMetaKeyState(e);
	            },
	            _startEdit: function (e) {
	                var sheet = this._sheet;
	                if (!sheet.isEditing) {
	                    return;
	                }
	                var canvas = sheet._getCanvas();
	                var t = sheet._getCanvasOffset();
	                if (!getShiftKey(e) && !getCtrlKey(e)) {
	                    sheet._doStartEdit(canvas, e.pageX - t.left, e.pageY - t.top);
	                }
	            },
	            _doKeyDown: function (event) {
	                var self = this;
	                var sheet = self._sheet;
	                if (sheet) {
	                    var activeRowIndex = getActiveRowIndex(sheet), activeColumnIndex = getActiveColumnIndex(sheet),
	                        cellType = sheet.getCellType(activeRowIndex, activeColumnIndex), context = {
	                            isEditing: isEditing(sheet),
	                            sheet: sheet,
	                            row: activeRowIndex,
	                            col: activeColumnIndex,
	                            sheetArea: 3 
	                        }, context1 = {
	                            sheet: sheet,
	                            row: activeRowIndex,
	                            col: activeColumnIndex,
	                            sheetArea: 3 
	                        };
	                    if (cellType && cellType.isReservedKey(event, context)) {
	                        if (!isEditing(sheet)) {
	                            cellType.processKeyDown(event, context1);
	                        }
	                        return;
	                    }
	                    var fbx = sheet._formulaTextBox;
	                    if (fbx && fbx._isReservedKey(event)) {
	                        return;
	                    }
	                    var attachedFBX = (sheet.parent && sheet.parent._attachedFormulaTextBox);
	                    if (attachedFBX && attachedFBX._isReservedKey(event, context)) {
	                        return;
	                    }
	                }
	                var navKey = (!isEditing(sheet) && !getCtrlKey(event) && !getMetaKey(event) &&
	                    (
	                        getKeyCode(event) === 34  ||
	                        getKeyCode(event) === 33  ||
	                        getKeyCode(event) === 37  ||
	                        getKeyCode(event) === 39  ||
	                        getKeyCode(event) === 9  ||
	                        getKeyCode(event) === 13  ||
	                        getKeyCode(event) === 38  ||
	                        getKeyCode(event) === 40 
	                    )
	                );
	                if (sheet._isTouchMode) {
	                    sheet._isTouchMode = false;
	                    sheet._render._refreshTouchSelectionIndicator();
	                }
	                var keyMapProcessed = self._keyDownImp(event);
	                if (navKey && keyMapProcessed && _FocusHelper._isActiveElement(sheet)) {
	                    self._lastKeyDownTime = new Date();
	                    if (self._keyPressed) {
	                        if (self._keyPressedCount < 25) {
	                            self._keyPressedCount++;
	                        }
	                        cancelDefault(event);
	                        return;
	                    }
	                    self._keyPressed = true;
	                    self._keyPressedCount = 1;
	                    self._repeatKeyDown(event, true);
	                }
	            },
	            _getMouseDownResizeTooltipContent: function () {
	                var sheet = this._sheet;
	                var currentTarget = sheet._currentTarget;
	                var resizeInfo = currentTarget.resizeInfo;
	                if (resizeInfo.action === SIZEROW || resizeInfo.action === SIZEHIDDENROW) {
	                    var rowLayout = sheet._getAllRowLayout(resizeInfo.sheetArea);
	                    if (!sheet.getRowVisible(resizeInfo.index)) {
	                        resizeInfo.index = this._getPreVisualRow(resizeInfo.index, resizeInfo.sheetArea);
	                    }
	                    var rl = rowLayout.findRow(resizeInfo.index);
	                    if (!rl) {
	                        rl = rowLayout.findRow(currentTarget.row);
	                    }
	                    return stringFormat(sR().Tip_Height, [rl.height.toFixed(0)]);
	                }
	                var colLayout = sheet._getAllColumnLayout(resizeInfo.sheetArea);
	                if (!sheet.getColumnVisible(resizeInfo.index)) {
	                    resizeInfo.index = this._getPreVisualCol(resizeInfo.index, resizeInfo.sheetArea);
	                }
	                var cl = colLayout.findCol(resizeInfo.index);
	                if (!cl) {
	                    cl = colLayout.findCol(currentTarget.col);
	                }
	                return stringFormat(sR().Tip_Width, [cl.width.toFixed(0)]);
	            },
	            _getMouseMoveResizeTooltipContent: function (resizeInfo) {
	                if (resizeInfo.action === SIZEROW || resizeInfo.action === SIZEHIDDENROW) {
	                    return stringFormat(sR().Tip_Height, [(resizeInfo.movingY - resizeInfo.startY).toFixed(0)]);
	                }
	                return stringFormat(sR().Tip_Width, [(resizeInfo.movingX - resizeInfo.startX).toFixed(0)]);
	            },
	            _repeatKeyDown: function (event, doNotExecuteImmediately) {
	                var self = this;
	                if (!self._keyPressed) {
	                    return;
	                }
	
	               
		
		
		
	                if (new Date() - self._lastKeyDownTime > 100) {
	                    self._clearRepeatKeyDownTimeout();
	                    return;
	                }
	                if (!doNotExecuteImmediately) {
	                    self._keyDownImp(event);
	                }
	                if (self._keyPressed) {
	                    self._repeatKeyDownTimeoutID = setTimeout(function () {
	                        self._repeatKeyDown(event);
	                    }, 500 / self._keyPressedCount);
	                }
	            },
	            _startEditByKeyboard: function (event, isImeInput) {
	                var sheet = this._sheet;
	                var c = sheet._getCanvas();
	                if (c) {
	                    sheet._startEditByKeydown = true;
	                    try {
	                        var editing = isEditing(sheet);
	                        if (sheet._startEditImp) {
	                            sheet._startEditImp(c, sheet._activeRowIndex, sheet._activeColIndex, keyword_null, keyword_null, true, keyword_null, isImeInput);
	                        }
	                        if (!editing && isEditing(sheet)) {
	                            var ct = sheet.getCellType(sheet._activeRowIndex, sheet._activeColIndex);
	                            if (ct._triggerButtonClicked &&
	                                getKeyCode(event) === 32  && !getCtrlKey(event) && !getShiftKey(event) && !getAltKey(event)) {
	                                ct._triggerButtonClicked(sheet, sheet._activeRowIndex, sheet._activeColIndex, 3 );
	                            }
	                            if (ct._cancelDefaultKeydown) {
	                                ct._cancelDefaultKeydown(event);
	                            }
	                        }
	                    } finally {
	                        sheet._startEditByKeydown = false;
	                    }
	                }
	            },
	            _keyDownImp: function (event) {
	                var self = this;
	                var sheet = self._sheet;
	                self._setMetaKeyState(event);
	                if (!isEditing(sheet) && getKeyCode(event) === 27  && !getAltKey(event) && !getCtrlKey(event) && !getShiftKey(event) && sheet._validationInputMessage) {
	                    $(sheet._validationInputMessage).remove();
	                    sheet._validationInputMessage = keyword_null;
	                }
	                if (!isEditing(sheet) &&
	                    (
	                    getKeyCode(event) === 34  ||
	                    getKeyCode(event) === 33  ||
	                    getKeyCode(event) === 35  ||
	                    getKeyCode(event) === 36  ||
	                    getKeyCode(event) === 38  ||
	                    getKeyCode(event) === 40 )) {
	                    cancelDefault(event);
	                }
	                if (!isEditing(sheet) && (getKeyCode(event) === 37  || getKeyCode(event) === 39 )) {
	                    cancelDefault(event);
	                }
	
	               
	                if (isEditing(sheet) && getCtrlKey(event) && (getKeyCode(event) === 89  || getKeyCode(event) === 90 )) {
	                    cancelDefault(event);
	                    return false;
	                }
	
	               
	               
	               
	               
	
	                var commands = sheet._commandManager();
	                var shortcut = commands.getShortcutKey(getKeyCode(event), getCtrlKey(event), getShiftKey(event), getAltKey(event), getMetaKey(event));
	                var cmds = commands.getCommands(shortcut);
	                if (cmds) {
	                    for (var i = 0; i < cmds.length; i++) {
	                        var returnValue = cmds[i].execute(sheet.parent, {sheetName: sheet.name()});
	                        if (returnValue) {
	                            if (!returnValue.ignoreCancelDefault) {
	                                cancelDefault(event);
	                            }
	                            return true;
	                        }
	                    }
	                }
	
	               
	                var argObj = {e: event, r: keyword_null};
	                Worksheet._callFeatureHandler(sheet, 'processKeyDown', argObj);
	                if (argObj.r) {
	                    return true;
	                }
	
	                if (self._allowEnterEditing(event)) {
	                   
	                    var fbx = sheet._formulaTextBox;
	                    if (fbx && fbx._isAppending) {
	                        fbx._stopAppending();
	                    }
	                    var editing = isEditing(sheet);
	                    var isIme = getKeyCode(event) === 229 || getKeyCode(event) === 0;
	                   
	                    if (!editing && !isIme) {
	                        var hitElement = WINDOW._gcGlobal._getUIElement(event.target);
	                        var isAFBX = (hitElement && hitElement.getAttribute(attrGcUIElement) === 'gcAttachedFormulaTextBox');
	                        if (!isAFBX) {
	                            self._startEditByKeyboard(event);
	                        }
	                    }
	                }
	                return false;
	            },
	            _clearRepeatKeyDownTimeout: function () {
	                var self = this;
	                self._keyPressed = false;
	                if (self._repeatKeyDownTimeoutID > 0) {
	                    clearTimeout(self._repeatKeyDownTimeoutID);
	                    self._repeatKeyDownTimeoutID = 0;
	                }
	            },
	            _doKeyUp: function (event) {
	                var self = this;
	                self._clearRepeatKeyDownTimeout();
	                var sheet = self._sheet;
	                if (sheet) {
	                    var activeRowIndex = getActiveRowIndex(sheet),
	                        activeColumnIndex = getActiveColumnIndex(sheet),
	                        cellType = sheet.getCellType(activeRowIndex, activeColumnIndex),
	                        context = {
	                            isEditing: isEditing(sheet),
	                            sheet: sheet,
	                            row: activeRowIndex,
	                            col: activeColumnIndex,
	                            sheetArea: 3 
	                        }, context1 = {
	                            sheet: sheet,
	                            row: activeRowIndex,
	                            col: activeColumnIndex,
	                            sheetArea: 3 
	                        };
	                    if (cellType && cellType.isReservedKey(event, context)) {
	                        if (!isEditing(sheet)) {
	                            cellType.processKeyUp(event, context1);
	                        }
	                        return;
	                    }
	                    var fbx = sheet._formulaTextBox;
	                    if (fbx && fbx._isReservedKey(event)) {
	                        return;
	                    }
	                    var attachedFBX = (sheet.parent && sheet.parent._attachedFormulaTextBox);
	                    if (attachedFBX && attachedFBX._isReservedKey(event)) {
	                        return;
	                    }
	                }
	                self._setMetaKeyState(event);
	            },
	            _doCompositionStart: function (event) {
	                this._startEditByKeyboard(event, true);
	            },
	            _allowEnterEditing: function (e) {
	                if (getCtrlKey(e) || getAltKey(e) || getMetaKey(e)) {
	                    return false;
	                }
	                return (getKeyCode(e) >= 65 && getKeyCode(e) <= 90) ||
	                    ((getKeyCode(e) >= 48 && getKeyCode(e) <= 57) || (getKeyCode(e) >= 96 && getKeyCode(e) <= 105)) ||
	                    (getKeyCode(e) >= 186 && getKeyCode(e) <= 192) ||
	                    (getKeyCode(e) >= 220 && getKeyCode(e) <= 222 || getKeyCode(e) === 219) ||
	                    (getKeyCode(e) >= 106 && getKeyCode(e) <= 111) ||
	                    (getKeyCode(e) === 32) ||
	                    (getKeyCode(e) === 61) ||
	                    (getKeyCode(e) === 173) ||
	                    (getKeyCode(e) === 229 || getKeyCode(e) === 0) ||
	                    (getKeyCode(e) === 8)
	                    ;
	            },
	            _setMetaKeyState: function (e) {
	                var self = this;
	                var sheet = self._sheet;
	                var isMac = util_common_util._isMacOS(), ctrl = isMac ? getMetaKey(e) : getCtrlKey(e);
	                self.ctrl = ctrl && !getShiftKey(e);
	                self.shift = getShiftKey(e) && !ctrl;
	               
	                sheet._isNavigateInSelection = false;
	                if (getKeyCode(e) === 9 ) {
	                    var selectionCount = sheet._modelManager.getSelections().length;
	                    if (selectionCount > 1) {
	                        sheet._isNavigateInSelection = true;
	                    } else {
	                        var range = sheet._getActiveSelectedRange();
	                        if (range && selectionCount > 0) {
	                           
	                           
	                           
	                            sheet._isNavigateInSelection = !(sheet._activeRowIndex === range.row &&
	                            sheet._activeColIndex === range.col &&
	                            sheet._activeRowCount >= getRowCount(range) && sheet._activeColCount >= getColCount(range));
	                        }
	                    }
	                }
	               
	                if (self._isDragDropping === true) {
	                    var activeSelRange = sheet._getActiveSelectedRange();
	                    var tempInsert = self._isDragInsert;
	                    var tempCopy = self._isDragCopy;
	                    if (activeSelRange.row === -1 || activeSelRange.col === -1) {
	                        self._isDragInsert = getShiftKey(e);
	                    } else {
	                        self._isDragInsert = false;
	                    }
	                    self._isDragCopy = ctrl;
	                    if (tempInsert !== self._isDragInsert || tempCopy !== self._isDragCopy) {
	                        sheet._render._refreshDragDropIndicator && sheet._render._refreshDragDropIndicator();
	                    }
	                }
	               
	                self._isControlPressed = ctrl;
	               
	               
	               
	            },
	            _resetMetaKeyState: function () {
	                var self = this;
	                self.shift = false;
	                self.ctrl = false;
	                self._sheet._isNavigateInSelection = false;
	                self._isDragDropping = false;
	                self._isDragInsert = false;
	                self._isDragCopy = false;
	               
	                self._isControlPressed = false;
	            },
	            _updateEditingEditor: function (eData) {
	                var sheet, editor, canvasOffset;
	                if (eData && eData.sheet) {
	                    sheet = eData.sheet;
	                    editor = eData.editor;
	                    canvasOffset = eData.canvasOffset;
	                } else {
	                    sheet = this._sheet;
	                    editor = sheet._editor;
	                }
	                if (!isEditing(sheet)) {
	                    return;
	                }
	                var activeRow = sheet._activeRowIndex, activeCol = sheet._activeColIndex,
	                    ct = sheet.getCellType(activeRow, activeCol), sheetLayout = sheet._getSheetLayout(),
	                    cellStyle = sheet.getActualStyle(activeRow, activeCol), cellRect = sheet.getCellRect(activeRow, activeCol);
	                if (editor && editor.parentNode) {
	                    var cellWrapperElement = editor.parentNode.parentNode;
	                    if (cellRect && cellRect.width > 0 && cellRect.height > 0 && cellRect.x >= sheetLayout._frozenX &&
	                        cellRect.y >= sheetLayout._frozenY &&
	                        cellRect.x + cellRect.width <= sheetLayout._frozenTrailingX + sheetLayout._frozenTrailingWidth &&
	                        cellRect.y + cellRect.height <= sheetLayout._frozenTrailingY + sheetLayout._frozenTrailingHeight) {
	                        var context = {
	                            sheet: sheet,
	                            row: activeRow,
	                            col: activeCol,
	                            sheetArea: 3 ,
	                            canvasOffset: canvasOffset
	                        };
	                        ct._updateEditorWrapper(cellWrapperElement, cellStyle, cellRect, context, true);
	                    } else {
	                        $(cellWrapperElement).css({top: -10000, left: -10000});
	                    }
	                }
	               
	                var fbx = sheet._formulaTextBox;
	                if (fbx) {
	                    fbx._position();
	                }
	            },
	            _getElementById: function (parent, id) {
	                if (!parent) {
	                    return keyword_null;
	                }
	                var t = parent.firstChild;
	                while (t) {
	                    if (t.id === id || t.name === id) {
	                        return t;
	                    }
	                    var t1 = this._getElementById(t, id);
	                    if (t1) {
	                        return t1;
	                    }
	                    t = t.nextSibling;
	                }
	                return keyword_null;
	            },
	            _notEqualSelecions: function (oldSelections, newSelections) {
	                var notEqual = true;
	                if (oldSelections.length === newSelections.length) {
	                    for (var i = 0; i < oldSelections.length; i++) {
	                        var oldItem = oldSelections[i];
	                        var newItem = newSelections[i];
	                        if (oldItem.row !== newItem.row || oldItem.col !== newItem.col ||
	                            getRowCount(oldItem) !== getRowCount(newItem) || getColCount(oldItem) !== getColCount(newItem)) {
	                            notEqual = true;
	                            break;
	                        } else {
	                            notEqual = false;
	                        }
	                    }
	                }
	                return notEqual;
	            },
	            _createFocusHolder: function (cellType, row, col, changeFocusHolder) {
	                var self = this, sheet = self._sheet, context = {
	                    sheet: sheet,
	                    row: row,
	                    col: col,
	                    sheetArea: 3 
	                };
	                var host = sheet._getHost();
	                var isImeAware = cellType.isImeAware(context);
	                var focusHolder, focusHolderPosition = IS_MOBILE_DEVICE ? cssAbsolute : 'fixed';
	                if (changeFocusHolder) {
	                    self._destroyFocusHolder();
	                }
	                if (isImeAware && !self._cellTypeFocusHolder) {
	                    focusHolder = cellType._createCellTypeElement(context);
	                    if (!self._focusHolderOldCss) {
	                        self._focusHolderOldCss = {overflow: cssVisible, border: cssNone, position: cssAbsolute};
	                    }
	                    self._focusHolderOldCss.overflow = focusHolder.style.overflow;
	                    self._focusHolderOldCss.border = focusHolder.style.border;
	                    self._focusHolderOldCss.position = focusHolder.style.position;
	                    $(focusHolder).css(cssPosition, focusHolderPosition)
	                        .css(cssOverflow, cssHidden)
	                        .css(cssTop, '0px')
	                        .css(cssLeft, '0px')
	                        .css(cssWidth, '0px')
	                        .css(cssHeight, '0px')
	                        .css(cssBorder, cssNone);
	                   
	                    if (sheet._setEditorValue && focusHolder.firstChild) {
	                        var editorContext = focusHolder.firstChild.firstChild;
	                        sheet._setEditorValue(cellType, editorContext, row, col, sheet.getActualStyle(row, col));
	                       
	                        var value = cellType.getEditorValue(editorContext, context);
	                        if (browser.safari && (value === '' || isNullOrUndefined(value))) {
	                            cellType.setEditorValue(editorContext, ' ', context);
	                        }
	                    }
	                   
	                    if (host) {
	                        host.insertBefore(focusHolder, keyword_null);
	                    }
	                    self._cellTypeFocusHolder = focusHolder;
	                }
	                if (!self._originalFocusHolder) {
	                    focusHolder = createElement('div');
	                    $(focusHolder).css(cssPosition, focusHolderPosition)
	                        .css(cssOverflow, cssHidden)
	                        .css(cssTop, '0px')
	                        .css(cssLeft, '0px')
	                        .css(cssWidth, '0px')
	                        .css(cssHeight, '0px');
	                    self._originalFocusHolder = focusHolder;
	                   
	                   
	                   
	                    var focusElem = createElement('textarea');
	                    $(focusElem).attr(attrGcUIElement, 'gcSheetFocusInput')
	                        .attr(attrTabIndex, -1)
	                        .css(cssPosition, cssAbsolute)
	                        .css(cssOverflow, cssHidden)
	                        .css(cssBorder, cssNone)
	                        .css(cssResize, cssNone);
	                   
	                    focusElem.value = ' ';
	                   
	                    focusHolder.insertBefore(focusElem, keyword_null);
	                    self._focusElem = focusElem;
	                    var readonlyFocusElem = createElement('div');
	                    $(readonlyFocusElem).css(cssPosition, cssAbsolute)
	                        .css(cssOverflow, cssHidden)
	                        .attr(attrGcUIElement, 'gcSheetFocusInput')
	                        .attr(attrTabIndex, -1);
	                    focusHolder.insertBefore(readonlyFocusElem, keyword_null);
	                    self._readonlyFocusElem = readonlyFocusElem;
	                    if (host) {
	                        host.insertBefore(focusHolder, keyword_null);
	                    }
	                }
	                if (IS_MOBILE_DEVICE) {
	                    if (self._cellTypeFocusHolder) {
	                        self._setVisibleLocation(sheet, self._cellTypeFocusHolder);
	                    }
	                    self._setVisibleLocation(sheet, self._originalFocusHolder);
	                }
	                if (isImeAware) {
	                    return self._cellTypeFocusHolder;
	                }
	                return self._focusElem;
	            },
	            _resetFocusHolder: function () {
	                var self = this;
	                if (self._cellTypeFocusHolder && self._focusHolderOldCss) {
	                    $(self._cellTypeFocusHolder).css(cssOverflow, self._focusHolderOldCss.overflow)
	                        .css(cssBorder, self._focusHolderOldCss.border)
	                        .css(cssPosition, self._focusHolderOldCss.position);
	                }
	            },
	            _destroyFocusHolder: function () {
	                var self = this;
	                if (self._cellTypeFocusHolder) {
	                    if (self._cellTypeFocusHolder.parentElement) {
	                        self._cellTypeFocusHolder.parentElement.removeChild(self._cellTypeFocusHolder);
	                    }
	                    if (self._cellTypeFocusHolder.comboBox) {
	                        self._cellTypeFocusHolder.comboBox = keyword_null;
	                    }
	                    self._cellTypeFocusHolder = keyword_null;
	                }
	            },
	            _setFocus: function (doNotGetCellTypeFocus) {
	                if (!_FocusHelper._isActiveElement(this._sheet)) {
	                    this._setFocusCore(true, true, doNotGetCellTypeFocus);
	                }
	            },
	            _setFocusToReadonlyFocusElem: function () {
	                var readonlyFocusElem = this._readonlyFocusElem;
	                if (readonlyFocusElem) {
	                    readonlyFocusElem.focus();
	                }
	            },
	            _changeFocusHolder: function () {
	                this._setFocusCore(true, true);
	            },
	            _clearTouchSetFocusTimeout: function () {
	                if (this._touchSetFocusTimeout) {
	                    clearTimeout(this._touchSetFocusTimeout);
	                    this._touchSetFocusTimeout = keyword_null;
	                }
	            },
	            _setFocusCore: function (delay, changeFocusHolder, doNotGetCellTypeFocus) {
	                if (arguments.length === 0) {
	                    delay = true;
	                }
	                var self = this;
	                if (self._focusSuspended) {
	                    return;
	                }
	                self._focusReleased = false;
	                self._clearTouchSetFocusTimeout();
	                var sheet = self._sheet;
	                var activeRow, activeCol;
	                activeRow = getActiveRowIndex(sheet);
	                activeCol = getActiveColumnIndex(sheet);
	               
	               
	                var ct = sheet.getCellType(activeRow, activeCol);
	                self._createFocusHolder(ct, activeRow, activeCol, changeFocusHolder);
	                var context = {
	                    sheet: sheet,
	                    row: activeRow,
	                    col: activeCol,
	                    sheetArea: 3 
	                };
	                var focusElement;
	                if (ct.isImeAware(context) && self._cellTypeFocusHolder.firstChild) {
	                    focusElement = self._cellTypeFocusHolder.firstChild.firstChild;
	                } else {
	                    focusElement = self._focusElem;
	                }
	                var editor = focusElement;
	                if (changeFocusHolder && !browser.msie) {
	                    ct.setImeMode(editor, sheet.getActualStyle(activeRow, activeCol).imeMode, context);
	                }
	               
	               
	               
	                DOCUMENT.body.focus();
	                var setFocusAndIme = function () {
	                    var setFocusToEditor = function () {
	                        try {
	                            if (ct.isImeAware(context)) {
	                                ct.focus(editor, context);
	                                ct.selectAll(editor, context);
	                            } else {
	                                focusElement.focus();
	                                focusElement.select();
	                            }
	                        } catch (ex) {
	                           
	                        }
	                    };
	                    if (changeFocusHolder && browser.msie) {
	                        ct.setImeMode(editor, sheet.getActualStyle(activeRow, activeCol).imeMode, context);
	                    }
	                   
	                    setFocusToEditor();
	                };
	                var device = util_device;
	                if ((sheet._isTouchMode || device.ipad) && (delay || !ct.isImeAware(context))) {
	                    if (!isEditing(sheet) && (browser.metroMode || device.ipad || device.iphone || device.android)) {
	                        if (changeFocusHolder) {
	                            var editorContainer = self._cellTypeFocusHolder && self._cellTypeFocusHolder.firstChild && self._cellTypeFocusHolder.firstChild.firstChild;
	                            ct.setImeMode(editorContainer, sheet.getActualStyle(activeRow, activeCol).imeMode, context);
	                        }
	                    } else {
	                        self._touchSetFocusTimeout = setTimeout(function () {
	                           
	                           
	                           
	                            self._clearTouchSetFocusTimeout();
	                            if (isEditing(sheet)) {
	                                return;
	                            }
	                            if (sheet._enhanceIme !== false && !doNotGetCellTypeFocus) {
	                                setFocusAndIme();
	                            }
	                        }, 200);
	                    }
	                } else if (sheet._enhanceIme !== false && !doNotGetCellTypeFocus) {
	                    setFocusAndIme();
	                }
	                if (!_FocusHelper._isActiveElement(sheet)) {
	                    _FocusHelper._setActiveElement(sheet);
	                }
	                self._updateValidationUI && self._updateValidationUI(sheet._activeRowIndex, sheet._activeColIndex);
	            },
	            _setVisibleLocation: function (sheet, element) {
	                var top, left, activeRow = getActiveRowIndex(sheet), activeCol = getActiveColumnIndex(sheet),
	                    activeRowViewport = sheet._activeRowViewportIndex, activeColViewport = sheet._activeColViewportIndex;
	
	                var activeCellRect = sheet.getCellRect(activeRow, activeCol, activeRowViewport, activeColViewport);
	                var self = this;
	                var canvasOffset = sheet._getCanvasOffset();
	                var canvasPosition = self._getCanvasPosition();
	                var cellTypeFocusHolder = self._cellTypeFocusHolder, cellTypeFocusHolderTop = 0,
	                    cellTypeFocusHolderLeft = 0, cellTypeFocusHolderHeight = 0, cellTypeFocusHolderWidth = 0;
	                if (cellTypeFocusHolder) {
	                    var $cellTypeFocusHolder = $(cellTypeFocusHolder);
	                    cellTypeFocusHolderTop = parseInt($cellTypeFocusHolder.css(cssTop), 10);
	                    cellTypeFocusHolderLeft = parseInt($cellTypeFocusHolder.css(cssLeft), 10);
	                    cellTypeFocusHolderHeight = parseInt($cellTypeFocusHolder.css(cssHeight), 10);
	                    cellTypeFocusHolderWidth = parseInt($cellTypeFocusHolder.css(cssWidth), 10);
	                }
	                if (self._isInvalidRect(activeCellRect)) {
	                    top = cellTypeFocusHolderTop;
	                    left = cellTypeFocusHolderLeft;
	                } else {
	                    top = activeCellRect.y + canvasPosition.top - 2;
	                    left = activeCellRect.x + canvasPosition.left - 2;
	                }
	                var minTop = WINDOW.pageYOffset - canvasOffset.top + canvasPosition.top;
	                var maxTop = WINDOW.innerHeight + minTop - cellTypeFocusHolderHeight;
	                var minLeft = WINDOW.pageXOffset - canvasOffset.left + canvasPosition.left;
	                var maxLeft = WINDOW.innerWidth + minLeft - cellTypeFocusHolderWidth;
	                if (isNotANumber(top) || top < minTop || top > maxTop) {
	                    top = minTop;
	                }
	                if (isNotANumber(left) || left < minLeft || left > maxLeft) {
	                    left = minLeft;
	                }
	                $(element).css(cssTop, top).css(cssLeft, left);
	            },
	            _releaseFocus: function (target) {
	                var self = this;
	                self._clearTouchSetFocusTimeout();
	                if (isEditing(self._sheet) || (self._focusReleased && DOCUMENT.activeElement === self._readonlyFocusElem)) {
	                    return;
	                }
	                var sheet = self._sheet;
	                var activeRow, activeCol;
	                if (target) {
	                    activeRow = target.row;
	                    activeCol = target.col;
	                } else {
	                    activeRow = sheet._activeRowIndex;
	                    activeCol = sheet._activeColIndex;
	                }
	               
	                var ct = sheet.getCellType(activeRow, activeCol);
	                self._createFocusHolder(ct, activeRow, activeCol, false);
	                self._readonlyFocusElem.focus();
	                self._focusReleased = true;
	            },
	            _resumeFocus: function (delay, ignoreSetFocus) {
	                var self = this;
	               
	                if (self._focusReleased) {
	                    self._focusReleased = false;
	                    !ignoreSetFocus && self._setFocusCore(delay);
	                }
	            },
	            _switchFocusForClipboard: function (value) {
	                var sheet = this._sheet;
	                var clipboardHelper = sheet._getClipboardHelper();
	                if (clipboardHelper) {
	                    clipboardHelper._setClipboardData(value);
	                    clipboardHelper._focus();
	                    this._focusSuspended = true;
	                    if (value) {
	                        clipboardHelper._select();
	                    }
	                }
	            },
	            _switchBackFocusAfterClipboard: function () {
	                var self = this;
	               
	               
	               
	                var clipboardHelper = self._sheet._getClipboardHelper();
	                if (clipboardHelper) {
	                    clipboardHelper._setClipboardData('');
	                }
	                self._focusSuspended = false;
	                self._setFocusCore(true, false);
	            },
	            _disposeFocusHolders: function () {
	                var self = this;
	                self._clearTouchSetFocusTimeout();
	                var focusHolder = self._cellTypeFocusHolder;
	                if (focusHolder) {
	                    $(focusHolder).remove();
	                    self._cellTypeFocusHolder = keyword_undefined;
	                }
	                focusHolder = self._originalFocusHolder;
	                if (focusHolder) {
	                    $(focusHolder).remove();
	                    self._focusElem = keyword_undefined;
	                    self._originalFocusHolder = keyword_null;
	                    self._readonlyFocusElem = keyword_null;
	                }
	            },
	            _showTooltip: function (info, left, top, isAbsoluteDistanse) {
	                var workbook = this._sheet.parent;
	                if (workbook) {
	                    workbook._showTooltip(info, left, top, isAbsoluteDistanse);
	                }
	            },
	            _refreshTooltip: function (info, left, top, isAbsoluteDistanse) {
	                var workbook = this._sheet.parent;
	                if (workbook) {
	                    workbook._refreshTooltip(info, left, top, isAbsoluteDistanse);
	                }
	            },
	            _removeTooltip: function () {
	                var workbook = this._sheet.parent;
	                if (workbook) {
	                    workbook._removeTooltip();
	                }
	            },
	            _setHoverCell: function (target) {
	                var self = this;
	                var sheet = self._sheet;
	                var hoveredCellChanged = false;
	                var current = sheet._currentTarget;
	                if (!current) {
	                    hoveredCellChanged = true;
	                }
	                if (!hoveredCellChanged && !target) {
	                    hoveredCellChanged = true;
	                }
	                function isResizeInfoEqual(newResizeInfo, oldResizeInfo) {
	                    var equal = false;
	                    if (!newResizeInfo && !oldResizeInfo) {
	                        equal = true;
	                    } else if (newResizeInfo && oldResizeInfo) {
	                        equal = newResizeInfo.action === oldResizeInfo.action &&
	                            newResizeInfo.index === oldResizeInfo.index &&
	                            newResizeInfo.sheetArea === oldResizeInfo.sheetArea;
	                    }
	                    return equal;
	                }
	
	                if (!hoveredCellChanged) {
	                    hoveredCellChanged = (
	                        target.col !== current.col ||
	                        target.row !== current.row ||
	                        getColViewportIndex(target) !== getColViewportIndex(current) ||
	                        getRowViewportIndex(target) !== getRowViewportIndex(current) ||
	                        getHitTestType(target) !== getHitTestType(current) || !isResizeInfoEqual(target.resizeInfo, current.resizeInfo)
	                    );
	                }
	                sheet._currentTarget = target;
	                if (hoveredCellChanged) {
	                    sheet._hoverCell = true;
	                    var render = sheet._render;
	                    var isNeedRepaintSelection = refreshHoverCell(sheet, current, render);
	                    var needRepaint = refreshHoverCell(sheet, target, render);
	                    isNeedRepaintSelection = isNeedRepaintSelection || needRepaint;
	                    sheet._hoverCell = false;
	                    if (isNeedRepaintSelection) {
	                        render._repaintSelection();
	                    }
	                }
	            },
	            _getAvailableActiveCell: function (row, col, isHorizontal) {
	                var range = this._skipSpanCell(row, col, isHorizontal);
	                return this._skipInvisibleCell(range);
	            },
	            _skipSpanCell: function (row, col, isHorizontal) {
	                var spanCell = this._sheet._modelManager.getSpan(row, col);
	                var spanRowCount = getRowCount(spanCell), spanColCount = getColCount(spanCell);
	                if (spanRowCount === 1 && spanColCount === 1) {
	                    return spanCell;
	                }
	                if ((isHorizontal && spanRowCount === 1) || (!isHorizontal && spanColCount === 1)) {
	                    return spanCell;
	                }
	                if (isHorizontal) {
	                    col++;
	                } else {
	                    row++;
	                }
	                return this._skipSpanCell(row, col, isHorizontal);
	            },
	            _skipInvisibleCell: function (range) {
	                var sheet = this._sheet;
	                var row = range.row, i;
	                var rowCount = getSheetRowCount(sheet);
	                for (i = row; i < rowCount; i++) {
	                    if (sheet.getRowVisible(i) === true) {
	                        break;
	                    }
	                }
	                if (i < rowCount) {
	                    row = i;
	                }
	                var col = range.col;
	                var columnCount = getSheetColumnCount(sheet);
	                for (i = col; i < columnCount; i++) {
	                    if (sheet.getColumnVisible(i) === true) {
	                        break;
	                    }
	                }
	                if (i < columnCount) {
	                    col = i;
	                }
	                return createRange(row, col, getRowCount(range), getColCount(range));
	            }
	        };
	
	        return SheetEventHandler;
	    })();
	    exports._SheetEventHandler = SheetEventHandler;
	
	   
	    function Timer(host) {
	        var self = this;
	        self._host = host;
	        self._interval = keyword_null;
	        self._action = keyword_null;
	        self._intervalId = keyword_null;
	        self._result = keyword_null;
	        self._working = false;
	        self._needIncrease = false;
	    }
	
	    Timer.prototype = {
	        _setAction: function (action) {
	           
	            if (typeof (action) === const_function) {
	                this._action = action;
	            }
	        },
	        _setInterval: function (interval) {
	           
	            var self = this;
	            if (!isNotANumber(interval) && interval !== 0) {
	                self._needIncrease = interval > 0;
	                interval = Math_abs(interval);
	                var oldInterval = self._interval;
	                self._interval = interval;
	                if (oldInterval !== interval) {
	                    self._start();
	                }
	            } else {
	                self._stop();
	            }
	        },
	        _start: function () {
	           
	            var self = this;
	            self._clear();
	            if (!isNotANumber(self._interval)) {
	                self._intervalId = setInterval(function () {
	                    self._run();
	                }, self._interval);
	            }
	        },
	        _run: function () {
	           
	            var self = this, action = self._action;
	            self._working = true;
	            if (typeof (action) === const_function) {
	                self._result = action.call(self._host, self._needIncrease);
	            }
	        },
	        _stop: function () {
	           
	            var self = this;
	            self._clear();
	            self._interval = keyword_null;
	           
	            self._intervalId = keyword_null;
	            self._result = keyword_null;
	            self._working = false;
	        },
	        _clear: function () {
	           
	            var intervalId = this._intervalId;
	            if (intervalId) {
	                clearInterval(intervalId);
	            }
	        },
	        _dispose: function () {
	            this._stop();
	           
	        }
	    };
	   
	
	    module.exports = exports;
	
	}());

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var Common = __webpack_require__(5);
	    var Worksheet = __webpack_require__(17).Worksheet,
	        Style = __webpack_require__(12).Style,
	        util_common = __webpack_require__(3),
	        util_common_theme = __webpack_require__(10),
	        $ = __webpack_require__(4).GC$,
	        StyleHelper = __webpack_require__(11)._StyleHelper,
	        CultureManager = Common.CultureManager;
	
	    var createRange = util_common._createRange;
	
	    var Worksheet_features = Worksheet._features,
	        isDefined = util_common._util._isDefined,
	        $_each = $.each, $_isEmptyObject = $.isEmptyObject, hasOwnProperty = Common._hasOwnProperty,
	        isNullOrUndefined = Common._Types._isNullOrUndefined;
	
	    var CONST_THEME = 'theme',
	        const_string = 'string', convertToInt = parseInt, isNotANumber = isNaN, keyword_undefined = void 0;
	
	    function _moveColumnHeadersAsFrozenRows(sheet, rowShift, columnShift) {
	        var modelManager = sheet._modelManager;
	        var sheetModel = modelManager._getSheetModel(), columnHeaderModel = modelManager._getSheetModel(1 );
	        var rowInfos = modelManager._getAxisModel(true), columnHeaderRowInfos = modelManager._getAxisModel(true, 1 );
	        var sheetSpanModel = modelManager._getSpanModel(), colHeaderSpanModel = modelManager._getSpanModel(1 );
	        var colCount = sheetModel.getColumnCount();
	        for (var r = 0; r < rowShift; r++) {
	            sheetModel.setNode(r, -1, columnHeaderModel._getNode(r, -1));
	            rowInfos._setItem(r, columnHeaderRowInfos._getItem(r));
	            for (var c = columnShift; c < colCount; c++) {
	                sheetModel.setNode(r, c, columnHeaderModel._getNode(r, c));
	            }
	        }
	        colHeaderSpanModel.getSpans().forEach(function (span) {
	            sheetSpanModel.add(span);
	        });
	        sheet.frozenRowCount(rowShift);
	        modelManager._resetSheetModel(Worksheet._defaultColHeaderRowCount, colCount, 1 );
	        modelManager._resetAxisModel(false, 1 );
	        modelManager._resetSpanModel(1 );
	    }
	
	    function _moveRowHeadersAsFrozenColumns(sheet, columnShift, rowShift) {
	        var modelManager = sheet._modelManager;
	        var sheetModel = modelManager._getSheetModel(), rowHeaderModel = modelManager._getSheetModel(2 );
	        var columnInfos = modelManager._getAxisModel(false), rowHeaderColInfos = modelManager._getAxisModel(false, 2 );
	        var sheetSpanModel = modelManager._getSpanModel(), rowHeaderSpanModel = modelManager._getSpanModel(2 );
	        var rowCount = sheetModel.getRowCount();
	        for (var c = 0; c < columnShift; c++) {
	            sheetModel.setNode(-1, c, rowHeaderModel._getNode(-1, c));
	            columnInfos._setItem(c, rowHeaderColInfos._getItem(c));
	            for (var r = rowShift; r < rowCount; r++) {
	                sheetModel.setNode(r, c, rowHeaderModel._getNode(r, c));
	            }
	        }
	        rowHeaderSpanModel.getSpans().forEach(function (span) {
	            sheetSpanModel.add(span);
	        });
	        sheet.frozenColumnCount(columnShift);
	        modelManager._resetSheetModel(rowCount, Worksheet._defaultRowHeaderColumnCount, 2 );
	        modelManager._resetAxisModel(false, 2 );
	        modelManager._resetSpanModel(2 );
	    }
	
	    function _moveFrozenRowsAsColumnHeaders(sheet, rowShift, columnShift) {
	        var modelManager = sheet._modelManager;
	        var sheetModel = modelManager._getSheetModel(), columnHeaderModel = modelManager._getSheetModel(1 );
	        var rowInfos = modelManager._getAxisModel(false), columnHeaderRowInfos = modelManager._getAxisModel(false, 1 );
	        var sheetSpanModel = modelManager._getSpanModel(), colHeaderSpanModel = modelManager._getSpanModel(1 );
	        var colCount = sheetModel.getColumnCount();
	        columnHeaderModel.setRowCount(rowShift);
	        for (var r = 0; r < rowShift; r++) {
	            columnHeaderModel.setNode(r, -1, sheetModel._getNode(r, -1));
	            columnHeaderRowInfos._setItem(r, rowInfos._getItem(r));
	            for (var c = columnShift; c < colCount; c++) {
	                columnHeaderModel.setNode(r, c, sheetModel._getNode(r, c));
	            }
	        }
	        var spans = sheetSpanModel.getSpans(createRange(0, 0, rowShift, colCount));
	        spans.forEach(function (span) {
	            colHeaderSpanModel.add(span);
	        });
	        sheet.frozenRowCount(0);
	    }
	
	    function _moveFrozenColumnsAsRowHeaders(sheet, columnShift, rowShift) {
	        var modelManager = sheet._modelManager;
	        var sheetModel = modelManager._getSheetModel(), rowHeaderModel = modelManager._getSheetModel(2 );
	        var columnInfos = modelManager._getAxisModel(false), rowHeaderColInfos = modelManager._getAxisModel(false, 2 );
	        var sheetSpanModel = modelManager._getSpanModel(), rowHeaderSpanModel = modelManager._getSpanModel(2 );
	        var rowCount = sheetModel.getRowCount();
	        rowHeaderModel.setColumnCount(columnShift);
	        for (var c = 0; c < columnShift; c++) {
	            rowHeaderModel.setNode(-1, c, sheetModel._getNode(-1, c));
	            rowHeaderColInfos._setItem(c, columnInfos._getItem(c));
	            for (var r = rowShift; r < rowCount; r++) {
	                rowHeaderModel.setNode(r, c, sheetModel._getNode(r, c));
	            }
	        }
	        var spans = sheetSpanModel.getSpans(createRange(0, 0, rowCount, columnShift));
	        spans.forEach(function (span) {
	            rowHeaderSpanModel.add(span);
	        });
	        sheet.frozenColumnCount(0);
	    }
	
	    function _isDefaultValue(propertyName, value) {
	        switch (propertyName) {
	            case 'frozenRowCount':
	            case 'frozenColCount':
	            case 'frozenTrailingRowCount':
	            case 'frozenTrailingColCount':
	            case 'activeRow':
	            case 'activeCol':
	                return value === 0;
	            case 'rowCount':
	                return value === 200;
	            case 'columnCount':
	                return value === 20;
	            case 'zoomFactor':
	            case 'rowHeaderColCount':
	            case 'colHeaderRowCount':
	                return value === 1;
	            case 'visible':
	                return value === true;
	        }
	        return false;
	    }
	    function getDefinedValue(value, defaultValue) {
	        return isDefined(value) ? value : defaultValue;
	    }
	    function setFnIfDefined(sheet, fn, value) {
	        if (isDefined(value)) {
	            fn.call(sheet, value, false);
	        }
	    }
	
	    $.extend(Worksheet.prototype, {
	        _setValueToDataTable: function (dataTable, row, col, value) {
	            if (!dataTable[row]) {
	                dataTable[row] = {};
	            }
	            var rowNode = dataTable[row];
	            if (!rowNode[col]) {
	                rowNode[col] = {};
	            }
	            var node = rowNode[col];
	            node.value = value;
	        },
	       
	        
	        toJSON: function (serializationOption) {
	            var sheet = this;
	            var rowShift = sheet.getRowCount(1 );
	            var columnShift = sheet.getColumnCount(2 );
	           
	            var rowHeadersAsFrozenColumns = serializationOption && serializationOption.rowHeadersAsFrozenColumns;
	            var columnHeadersAsFrozenRows = serializationOption && serializationOption.columnHeadersAsFrozenRows;
	            var ignoreStyle = serializationOption && serializationOption.ignoreStyle;
	
	           
	            var colExpand = rowHeadersAsFrozenColumns && columnShift > 0;
	            var rowExpand = columnHeadersAsFrozenRows && rowShift > 0;
	            if (colExpand) {
	                sheet.addColumns(0, columnShift);
	            }
	            if (rowExpand) {
	                sheet.addRows(0, rowShift);
	            }
	            if (colExpand) {
	                _moveRowHeadersAsFrozenColumns(sheet, columnShift, rowExpand ? rowShift : 0);
	            }
	            if (rowExpand) {
	                _moveColumnHeadersAsFrozenRows(sheet, rowShift, colExpand ? columnShift : 0);
	            }
	           
	            var rowCount = sheet.getRowCount(), colCount = sheet.getColumnCount();
	            var colHeaderRowCount = sheet.getRowCount(1 );
	            var rowHeaderColCount = sheet.getColumnCount(2 );
	            var dataDic = {
	                name: sheet.name(),
	                rowCount: rowCount,
	                columnCount: colCount,
	                activeRow: sheet._activeRowIndex,
	                activeCol: sheet._activeColIndex,
	                zoomFactor: sheet.zoom(),
	                rowHeaderColCount: rowHeaderColCount,
	                colHeaderRowCount: colHeaderRowCount,
	                visible: sheet.visible()
	            };
	            if (!ignoreStyle) {
	                dataDic.frozenRowCount = sheet.frozenRowCount();
	                dataDic.frozenColCount = sheet.frozenColumnCount();
	                dataDic.frozenTrailingRowCount = sheet.frozenTrailingRowCount();
	                dataDic.frozenTrailingColCount = sheet.frozenTrailingColumnCount();
	                dataDic[CONST_THEME] = sheet._currentTheme.toJSON();
	            }
	            var modelManager = sheet._modelManager;
	            var modelJson = modelManager.toJSON(serializationOption);
	            for (var prop in modelJson) {
	                dataDic[prop] = modelJson[prop];
	            }
	
	           
	            if (Worksheet_features) {
	                $_each(Worksheet_features, function (n, f) {
	                    if (f.toJson) {
	                        f.toJson.call(sheet, dataDic, serializationOption);
	                    }
	                });
	            }
	
	            var sdata = {};
	            for (var item in dataDic) {
	                if (hasOwnProperty(dataDic, item)) {
	                    var value = dataDic[item];
	                    if (!isNullOrUndefined(value) && !_isDefaultValue(item, value)) {
	                        sdata[item] = value;
	                    }
	                }
	            }
	
	           
	            $_each(sheet.options, function (p, v) {
	                var tmpValue = v;
	                if (p === 'gridline') {
	                    tmpValue = {};
	                    var v_color = v.color, v_showHorizontalGridline = v.showHorizontalGridline,
	                        v_showVerticalGridline = v.showVerticalGridline;
	                    if (v_color && v_color !== util_common._ThemeStyleHelper._getCssClassThemeStyle('gc-gridlineColor').borderTopColor) {
	                        tmpValue.color = v_color;
	                    }
	                    if (v_showHorizontalGridline === false) {
	                        tmpValue.showHorizontalGridline = v_showHorizontalGridline;
	                    }
	                    if (v_showVerticalGridline === false) {
	                        tmpValue.showVerticalGridline = v_showVerticalGridline;
	                    }
	                }
	                if (p === 'sheetAreaOffset') {
	                    tmpValue = {};
	                    if (v.left) {
	                        tmpValue.left = v.left;
	                    }
	                    if (v.top) {
	                        tmpValue.top = v.top;
	                    }
	                }
	                if (p !== '_ps' && !isNullOrUndefined(tmpValue) && Worksheet._defaultOptions[p] !== tmpValue) { 
	                    if (typeof tmpValue !== 'object' || !$_isEmptyObject(tmpValue)) {
	                        sdata[p] = tmpValue;
	                    }
	                }
	            });
	           
	            var namedStyles = [], sheetNamedStyles = sheet._namedStyles;
	            if (sheetNamedStyles) {
	                for (var namedStyle in sheetNamedStyles) {
	                    if (hasOwnProperty(sheetNamedStyles, namedStyle)) {
	                        var style = sheetNamedStyles[namedStyle];
	                        if (style) {
	                            var styleObj = style.toJSON(), styleFont = style.font;
	                            if (!$_isEmptyObject(styleObj)) {
	                               
	                                if (styleFont) {
	                                    styleObj.font = StyleHelper._normalizeFont(styleFont);
	                                }
	                                namedStyles.push(styleObj);
	                            }
	                        }
	                    }
	                }
	                if (namedStyles.length > 0) {
	                    sdata.namedStyles = namedStyles;
	                }
	            }
	            return sdata;
	        },
	       
	        
	        fromJSON: function (sheetSettings, setFormulaDirectly, versionInfo, deserializationOptions, fromWorkbook) {
	            var noSchema;
	            var version;
	            if (versionInfo) {
	                noSchema = versionInfo.noSchema;
	                version = versionInfo.version;
	            }
	            if (!sheetSettings) {
	                return;
	            }
	            var sheet = this;
	            var ignoreStyle = deserializationOptions && deserializationOptions.ignoreStyle;
	            sheet._initOptions();
	           
	            Worksheet._callFeatureHandler(sheet, 'preFromJson');
	
	            sheet.suspendPaint();
	            var oldCulture = CultureManager.culture();
	            CultureManager.culture('');
	            var rowCount = getDefinedValue(sheetSettings.rowCount, Worksheet._defaultRowCount);
	            var columnCount = getDefinedValue(sheetSettings.columnCount, Worksheet._defaultColCount);
	            try {
	                sheet._setNameCore(sheetSettings.name + '', true);
	                sheet.setRowCount(rowCount);
	                sheet.setColumnCount(columnCount);
	
	               
	                sheet._namedStyles = {};
	                var sheetSettings_namedStyles = sheetSettings.namedStyles;
	                if (sheetSettings_namedStyles) {
	                    for (var i = 0; i < sheetSettings_namedStyles.length; i++) {
	                        var item = sheetSettings_namedStyles[i];
	                        var style = new Style();
	                        style.fromJSON(item, noSchema);
	                        sheet._addNamedStyleImp(style);
	                    }
	                }
	               
	                var options = sheet.options;
	                for (var op in options) {
	                    if (hasOwnProperty(options, op)) {
	                        var value = sheetSettings[op];
	                        if (op === 'protectionOptions') {
	                            value = value || sheetSettings.protectionOption;
	                        } else if (op === 'allowCellOverflow') {
	                            if (!isDefined(sheetSettings[op])) {
	                                if (!version || version >= 11) {
	                                    value = true;
	                                } else {
	                                    value = false;
	                                }
	                            } else {
	                                value = sheetSettings[op];
	                            }
	                        }
	                        if (isDefined(value)) {
	                            if (typeof value === 'object') {
	                                for (var p in value) {
	                                    if (hasOwnProperty(value, p)) {
	                                        options[op][p] = value[p];
	                                    }
	                                }
	                            
	                            } else if(op === 'borderWidth') {
	                                options.sheetAreaOffset.left = value;
	                                options.sheetAreaOffset.top = value;
	                            } else {
	                                options[op] = value;
	                            }
	                        }
	                    }
	                }
	                var activeRowIndex = getDefinedValue(sheetSettings.activeRow, sheet._activeRowIndex),
	                    activeColIndex = getDefinedValue(sheetSettings.activeCol, sheet._activeColIndex);
	                sheet._setActiveCellImp(activeRowIndex, activeColIndex, keyword_undefined, keyword_undefined, true);
	                if (!ignoreStyle) {
	                    setFnIfDefined(sheet, sheet.frozenRowCount, sheetSettings.frozenRowCount);
	                    setFnIfDefined(sheet, sheet.frozenColumnCount, sheetSettings.frozenColCount);
	                    setFnIfDefined(sheet, sheet.frozenTrailingRowCount, sheetSettings.frozenTrailingRowCount);
	                    setFnIfDefined(sheet, sheet.frozenTrailingColumnCount, sheetSettings.frozenTrailingColCount);
	                }
	
	                if (!ignoreStyle) {
	                    var sheetSettings_colStyles = sheetSettings.colStyles;
	                    if (sheetSettings_colStyles) {
	                        for (var t in sheetSettings_colStyles) {
	                            if (!isNotANumber(t)) {
	                                sheet.setStyle(-1, convertToInt(t, 10), sheetSettings_colStyles[t], 3 );
	                            }
	                        }
	                    }
	                    var sheetSettings_rowStyles = sheetSettings.rowStyles;
	                    if (sheetSettings_rowStyles) {
	                        for (var rs in sheetSettings_rowStyles) {
	                            if (!isNotANumber(rs)) {
	                                sheet.setStyle(convertToInt(rs, 10), -1, sheetSettings_rowStyles[rs], 3 );
	                            }
	                        }
	                    }
	                }
	                var rowHeaderColCount = getDefinedValue(sheetSettings.rowHeaderColCount, Worksheet._defaultRowHeaderColumnCount);
	                var colHeaderRowCount = getDefinedValue(sheetSettings.colHeaderRowCount, Worksheet._defaultColHeaderRowCount);
	                sheet.setColumnCount(rowHeaderColCount, 2 );
	                sheet.setRowCount(colHeaderRowCount, 1 );
	                sheet._zoomInternal(getDefinedValue(sheetSettings._zoomFactor || sheetSettings.zoomFactor, sheet.zoom()));
	                setFnIfDefined(sheet, sheet.visible, sheetSettings.visible);
	                var validations = sheet._validations;
	                var modelImportOptions = {
	                    sheet: sheet,
	                   
	                    setValidator: function (row, col, validator) {
	                        validations && validations._importValidator(row, col, validator);
	                    },
	                   
	                   
	                   
	                    ignoreStyle: ignoreStyle
	                };
	                var modelManager = sheet._modelManager;
	                modelManager.fromJSON(sheetSettings, noSchema, modelImportOptions);
	                sheet.defaults = modelManager.defaults;
	               
	                validations && validations._resetCache(true);
	
	                var sheetSettings_theme = sheetSettings[CONST_THEME];
	                if (sheetSettings_theme && !ignoreStyle) {
	                    var st = sheetSettings_theme;
	                    if (typeof st !== const_string && isDefined(st)) {
	                       
	                       
	                       
	                        var themeColorWithUnderline = '_themeColor', nameWidthUnderline = '_name';
	                        var tc = st.themeColor || st[themeColorWithUnderline];
	                        var themeColor = new util_common_theme.ColorScheme(tc.name || tc[nameWidthUnderline]);
	                        themeColor.fromJSON(tc, noSchema);
	                        st = new util_common_theme.Theme(st.name || st._name, themeColor, st.headingFont || st._headingFont, st.bodyFont || st._bodyFont);
	                    }
	                    sheet.currentTheme(st);
	                }
	               
	                if (Worksheet_features) {
	                    $_each(Worksheet_features, function (n, f) {
	                        var temp = f.fromJson;
	                        if (temp) {
	                            temp.call(sheet, sheetSettings, noSchema, deserializationOptions, isDefined(setFormulaDirectly) ? setFormulaDirectly : true);
	                        }
	                    });
	                }
	
	               
	                var frozenColumnsAsRowHeaders = deserializationOptions && deserializationOptions.frozenColumnsAsRowHeaders;
	                var frozenRowsAsColumnHeaders = deserializationOptions && deserializationOptions.frozenRowsAsColumnHeaders;
	                var rowShift = frozenRowsAsColumnHeaders ? sheetSettings.frozenRowCount : 0;
	                var columnShift = frozenColumnsAsRowHeaders ? sheetSettings.frozenColCount : 0;
	                if (frozenRowsAsColumnHeaders && rowShift > 0) {
	                    _moveFrozenRowsAsColumnHeaders(sheet, rowShift, columnShift);
	                }
	                if (frozenColumnsAsRowHeaders && columnShift > 0) {
	                    _moveFrozenColumnsAsRowHeaders(sheet, columnShift, rowShift);
	                }
	                if (!fromWorkbook) {
	                    if (rowShift > 0) {
	                        sheet.deleteRows(0, rowShift);
	                    }
	                    if (columnShift > 0) {
	                        sheet.deleteColumns(0, columnShift);
	                    }
	                }
	                sheet.clearPendingChanges();
	            } finally {
	                CultureManager.culture(oldCulture);
	                sheet.resumePaint();
	            }
	        }
	    });
	
	}());

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var ArrayHelper = __webpack_require__(5)._ArrayHelper;
	    var Worksheet = __webpack_require__(17).Worksheet;
	    var util_common = __webpack_require__(3);
	    var STYLE_HELPER_MODULE = __webpack_require__(11);
	    var WORKSHEET_MODEL_MODULE = __webpack_require__(16);
	    var BORDER_MODULE = __webpack_require__(31);
	    var getSparklineModule = function () {
	        return __webpack_require__(14);
	    };
	
	    var exports = __webpack_require__(1);
	    var Common = __webpack_require__(5);
	    var CanvasHelper = exports._CanvasHelper;
	
	    var util_common_util = util_common._util;
	    var _DPIHelper = util_common._DPIHelper;
	    var _CacheMgr = util_common._CacheMgr;
	    var _WordWrapHelper = util_common._WordWrapHelper;
	    var _FocusHelper = util_common._FocusHelper;
	    var Rect = util_common.Rect;
	    var getHAlignByValueType = util_common_util._getHAlignByValueType;
	    var getFontHeight = util_common_util._getFontHeight;
	    var setContextFont = util_common._util._setContextFont;
	    var Events = util_common.Events;
	    var _ThemeContext = util_common._ThemeContext;
	    var createRange = util_common._createRange;
	    var isNullOrUndefined = Common._Types._isNullOrUndefined;
	    var _ThemeStyleHelper = util_common._ThemeStyleHelper;
	    var DefaultFontSize = STYLE_HELPER_MODULE._DefaultFontSize;
	    var StyleHelper_scaleFont = STYLE_HELPER_MODULE._StyleHelper._scaleFont;
	    var _CellOverflowLayout = WORKSHEET_MODEL_MODULE._CellOverflowLayout;
	    var _CellOverflowLayoutModel = WORKSHEET_MODEL_MODULE._CellOverflowLayoutModel;
	    var _Borders = BORDER_MODULE._Borders;
	
	    var keyword_null = null, Math_min = Math.min, Math_max = Math.max, Math_abs = Math.abs,
	        Math_floor = Math.floor,
	        Math_ceil = Math.ceil, parseIntFunc = parseInt;
	    var STR_BLACK = 'black', STR_TRANSPARENT = 'transparent', STR_ROW_HEADER = 'rowHeader',
	        STR_COLUMN_HEADER = 'columnHeader';
	
	    function getHeight(obj) {
	        return obj.height;
	    }
	
	    function getWidth(obj) {
	        return obj.width;
	    }
	    function _strokeLine(ctx, lineWidth, strokeStyle, x1, y1, x2, y2) {
	        ctx.beginPath();
	        ctx.lineWidth = lineWidth;
	        ctx.strokeStyle = strokeStyle;
	        ctx.moveTo(x1, y1);
	        ctx.lineTo(x2, y2);
	        ctx.stroke();
	    }
	
	   
	    Worksheet._registerFeature('render', {
	        init: function () {
	            var self = this;
	            self._render = new _SheetRender(self);
	            self._cutCopyIndicatorManager = new _CutCopyIndicatorManager(self);
	        },
	        dispose: function (clearCache) {
	            var self = this;
	            if (clearCache !== false) {
	                self._render = keyword_null;
	                var cutCopyIndicatorManager = self._cutCopyIndicatorManager;
	                if (cutCopyIndicatorManager) {
	                    cutCopyIndicatorManager._dispose();
	                    self._cutCopyIndicatorManager = keyword_null;
	                }
	            }
	        },
	        onLayoutChanged: function (args) {
	            var self = this;
	            var cutCopyIndicator = self._cutCopyIndicatorManager;
	            if (!cutCopyIndicator) {
	                return;
	            }
	            var changeType = args.changeType;
	            if (changeType === 'addRows') {
	                cutCopyIndicator._onRowsAdded();
	            } else if (changeType === 'deleteRows') {
	                cutCopyIndicator._onRowsDeleted();
	            } else if (changeType === 'addColumns') {
	                cutCopyIndicator._onColumnsAdded();
	            } else if (changeType === 'deleteColumns') {
	                cutCopyIndicator._onColumnsDeleted();
	            }
	        }
	    });
	
	   
	    var DEFAULT_BACKCOLOR = 'white';
	
	    function needPaintSelection(sheet) {
	        var parent = sheet.parent;
	        var args = {nps: true};//need paint selection
	        Worksheet._callFeatureHandler(sheet, 'needPaintSelection', args);
	        return (_FocusHelper._isActiveElement(sheet) || parent && !parent.options.hideSelection) && args.nps;
	    }
	    exports.needPaintSelection = needPaintSelection;
	
	    function getSheetBackColor(sheet) {
	        var parent = sheet.parent;
	        return parent && parent.options.backColor || DEFAULT_BACKCOLOR;
	    }
	
	    function _SheetRender(sheet) {
	        this._init(sheet);
	    }
	    _SheetRender.prototype = {
	        constructor: _SheetRender,
	        _init: function (sheet) {
	            this._sheet = sheet;
	        },
	        _getCtx: function () {
	            var sheet = this._sheet;
	            var ctx = keyword_null;
	            var c = sheet._getCanvas();
	            if (c && c.getContext) {
	                ctx = c.getContext('2d');
	            }
	
	            return ctx;
	        },
	        _getBufferCtx: function () {
	            var self = this;
	            var sheet = self._sheet;
	            var rect = sheet._getBounds();
	            var canvas = sheet._canvas, width = getWidth(canvas), height = getHeight(canvas);
	            var buffer = self._buffer, bufferCtx;
	            if (!buffer || getWidth(buffer) !== width || getHeight(buffer) !== height) {
	                if (buffer) {
	                    _DPIHelper._disposeCanvasForSheet(sheet, buffer);
	                }
	                self._buffer = buffer = util_common._util._createElement('canvas');
	                if (buffer.getContext) {
	                    self._bufferCtx = buffer.getContext('2d');
	                    _DPIHelper._adjustDevicePixel(buffer, keyword_null, sheet);
	                    _DPIHelper._setSize(buffer, getWidth(rect), getHeight(rect));
	                }
	            }
	            bufferCtx = self._bufferCtx;
	            if (bufferCtx) {
	                bufferCtx.beginPath();
	                setContextFont(bufferCtx, self._getZoomFont(self._getDefaultFont()));
	                bufferCtx.name = 'bufferContext';
	            }
	            return bufferCtx;
	        },
	        _getDefaultFont: function () {
	            if (!this._defaultFont) {
	                this._defaultFont = DefaultFontSize + ' ' + this._sheet.currentTheme().bodyFont();
	            }
	            return this._defaultFont;
	        },
	        _resetDefaultFont: function () {
	            this._defaultFont = keyword_null;
	        },
	        _getGrayAreaBackColor: function (isDrawImage) {
	            var sheet = this._sheet;
	            var worbook = sheet.parent;
	            var bkColorString = worbook ? (worbook.options.grayAreaBackColor || _ThemeStyleHelper._getContentThemeStyle('gc-grayArea').backgroundColor) : 'gray';
	            var bkColor = _ThemeContext._getColor(sheet, bkColorString);
	            if (!isDrawImage) {
	                return bkColor;
	            }
	            var bkImg = worbook ? worbook.options.backgroundImage : keyword_null;
	            if (bkImg) {
	                bkColor = STR_TRANSPARENT;
	            }
	            return bkColor;
	        },
	        _getZoomFont: function (font) {
	            var sheet = this._sheet, zoomFactor = sheet.zoom();
	            return zoomFactor === 1 ? font : StyleHelper_scaleFont(font, zoomFactor).font;
	        },
	        _copyDoubleBuffer: function (srcX, srcY, srcW, srcH, clipRect) {
	            var self = this, buffer = self._buffer, ctx = self._getCtx();
	            if (srcW <= 0 || srcH <= 0 || !buffer || !ctx) {
	                return;
	            }
	            if (!clipRect) {
	                clipRect = self._sheet._getBounds();
	            }
	            var ratioX = _DPIHelper._getScaleX(buffer),
	                ratioY = _DPIHelper._getScaleY(buffer);
	            if (ratioX !== 1) {
	                srcX *= ratioX;
	                srcY *= ratioY;
	                srcW *= ratioX;
	                srcH *= ratioY;
	                clipRect = new Rect(clipRect.x * ratioX, clipRect.y * ratioY, getWidth(clipRect) * ratioX, getHeight(clipRect) * ratioY);
	            }
	            var intersectRect = clipRect.getIntersect(srcX, srcY, srcW, srcH);
	            if (!intersectRect) {
	                return;
	            }
	            intersectRect.round();
	            srcX = intersectRect.x;
	            srcY = intersectRect.y;
	            srcW = getWidth(intersectRect);
	            srcH = getHeight(intersectRect);
	            var maxWidth = getWidth(buffer);
	            if (maxWidth && srcX + srcW > maxWidth) {
	                srcX = maxWidth - srcW;
	                if (srcX < 0) {
	                    srcW += srcX;
	                    srcX = 0;
	                }
	            }
	            var maxHeight = getHeight(buffer);
	            if (maxHeight && srcY + srcH > maxHeight) {
	                srcY = maxHeight - srcH;
	                if (srcY < 0) {
	                    srcH += srcY;
	                    srcY = 0;
	                }
	            }
	
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	            CanvasHelper._scaleTo(ctx, 1, 1);
	            ctx.clearRect(srcX, srcY, srcW, srcH);
	            ctx.drawImage(buffer, srcX, srcY, srcW, srcH, srcX, srcY, srcW, srcH);
	            CanvasHelper._scaleTo(ctx, ratioX, ratioY);
	           
	           
	           
	        },
	        _copyDoubleBufferRect: function (rect, clipRect) {
	            if (rect) {
	                this._copyDoubleBuffer(rect.x, rect.y, getWidth(rect), getHeight(rect), clipRect);
	            }
	        },
	        _copyScreen: function (srcX, srcY, srcW, srcH, destX, destY) {
	            if (srcW > 0 && srcH > 0) {
	                try {
	                    var self = this;
	                    var sheet = self._sheet, ctx = self._getCtx(), canvas = sheet._getCanvas(),
	                        bufferCtx = self._getBufferCtx(),
	                        buffer = self._buffer, destW = srcW, destH = srcH, destXE = destX, destYE = destY,
	                        destWE = destW, destHE = destH;
	                    var ratioX = _DPIHelper._getScaleX(canvas), ratioY = _DPIHelper._getScaleY(canvas);
	                    srcX = Math_floor(srcX * ratioX);
	                    srcY = Math_floor(srcY * ratioY);
	                    srcW = Math_ceil(srcW * ratioX);
	                    srcH = Math_ceil(srcH * ratioY);
	                    destXE = Math_floor(destXE * ratioX);
	                    destYE = Math_floor(destYE * ratioY);
	                    destWE = Math_ceil(destWE * ratioX);
	                    destHE = Math_ceil(destHE * ratioY);
	                    var maxWidth = getWidth(buffer);
	                    var maxHeight = getHeight(buffer);
	                    if (maxWidth && srcX + srcW > maxWidth) {
	                        srcX = maxWidth - srcW;
	                        if (srcX < 0) {
	                            srcW += srcX;
	                            srcX = 0;
	                        }
	                    }
	                    if (maxHeight && srcY + srcH > maxHeight) {
	                        srcY = maxHeight - srcH;
	                        if (srcY < 0) {
	                            srcH += srcY;
	                            srcY = 0;
	                        }
	                    }
	                    if (maxWidth && destXE + destWE > maxWidth) {
	                        destXE = maxWidth - destWE;
	                        if (destXE < 0) {
	                            destWE += destXE;
	                            destXE = 0;
	                        }
	                    }
	                    if (maxHeight && destYE + destHE > maxHeight) {
	                        destYE = maxHeight - destHE;
	                        if (destYE < 0) {
	                            destHE += destYE;
	                            destYE = 0;
	                        }
	                    }
	                   
	                   
	                   
	                   
	                    CanvasHelper._scaleTo(ctx, 1, 1);
	                    CanvasHelper._scaleTo(bufferCtx, 1, 1);
	                    ctx.clearRect(destXE, destYE, destWE, destHE);
	                    ctx.drawImage(buffer, srcX, srcY, srcW, srcH, destXE, destYE, destWE, destHE);
	                    bufferCtx.clearRect(destXE, destYE, destWE, destHE);
	                    bufferCtx.drawImage(canvas, destXE, destYE, destWE, destHE, destXE, destYE, destWE, destHE);
	                    CanvasHelper._scaleTo(ctx, ratioX, ratioY);
	                    CanvasHelper._scaleTo(bufferCtx, ratioX, ratioY);
	                } catch (e) {
	                   
	                }
	            }
	        },
	        _repaintSelection: function (range, clipRect, ctx, onlyPaintAdorner) {
	            var self = this;
	            if (!ctx) {
	                ctx = self._getCtx();
	            }
	            var ret = false, sheet = self._sheet, newRange = createRange(-1, -1, -1, -1),
	                isNavigateInSelection = sheet._isNavigateInSelection, modelManager = sheet._modelManager, cr;
	            if (range) {
	                if (sheet.options.allowCellOverflow) {
	                    newRange = createRange(range.row, 0, range.rowCount, sheet.getColumnCount());
	                } else {
	                    newRange = createRange(range.row, range.col, range.rowCount, range.colCount);
	                }
	               
	               
	                if (!isNavigateInSelection) {
	                    if (newRange.col >= 0) {
	                        var startCol = newRange.col, endCol = newRange.col + newRange.colCount - 1,
	                            rCount = sheet.getRowCount(1 );
	                        for (var r = 0; r < rCount; r++) {
	                            cr = modelManager.findSpan(r, newRange.col, 1 );
	                            if (cr) {
	                                startCol = Math_min(cr.col, startCol);
	                            }else if(sheet._deselectRange) {
	                                startCol = Math_min(sheet._deselectRange.col, startCol);
	                            }
	                            cr = modelManager.findSpan(r, newRange.col + newRange.colCount - 1, 1 );
	                            if (cr) {
	                                endCol = Math_max(cr.col + cr.colCount - 1, endCol);
	                            }else if(sheet._deselectRange) {
	                                endCol = Math_max(sheet._deselectRange.col + sheet._deselectRange.colCount - 1, endCol);
	                            }
	                        }
	                        newRange.col = startCol;
	                        newRange.colCount = endCol - startCol + 1;
	                    }
	                    if (newRange.row >= 0) {
	                        var startRow = newRange.row, endRow = newRange.row + newRange.rowCount - 1,
	                            cCount = sheet.getColumnCount(2 );
	                        for (var c = 0; c < cCount; c++) {
	                            cr = modelManager.findSpan(newRange.row, c, 2 );
	                            if (cr) {
	                                startRow = Math_min(cr.row, startRow);
	                            }else if(sheet._deselectRange) {
	                                startRow = Math_min(sheet._deselectRange.row, startRow);
	                            }
	                            cr = modelManager.findSpan(newRange.row + newRange.rowCount - 1, c, 2 );
	                            if (cr) {
	                                endRow = Math_max(cr.row + cr.rowCount - 1, endRow);
	                            }else if(sheet._deselectRange) {
	                                endRow = Math_max(sheet._deselectRange.row + sheet._deselectRange.rowCount - 1, endRow);
	                            }
	                        }
	                        newRange.row = startRow;
	                        newRange.rowCount = endRow - startRow + 1;
	                    }
	                }
	            }
	            var rect = sheet._getRangeWholeRect(newRange);
	            var rangeWidth = getWidth(rect), rangeHeight = getHeight(rect);
	            if (rangeWidth >= 0 || rangeHeight >= 0) {
	               
	                rect.x -= 9;
	                rect.y -= 9;
	                rect.width += 18;
	                rect.height += 30;
	                if (clipRect) {
	                    rect = rect.getIntersectRect(clipRect);
	                    if (!rect) {
	                        return;
	                    }
	                }
	                var layout = sheet._getSheetLayout();
	               
	                if (rangeHeight > 0 && !isNavigateInSelection) {
	                    sheet._dirty = true;
	                    self._paint(ctx, new Rect(layout.x, Math_max(layout._frozenY, rect.y), layout._rowHeaderWidth, getHeight(rect)), onlyPaintAdorner);
	                }
	               
	                if (rangeWidth > 0 && !isNavigateInSelection) {
	                    sheet._dirty = true;
	                    self._paint(ctx, new Rect(Math_max(layout._frozenX, rect.x), layout.y, getWidth(rect), layout._colHeaderHeight), onlyPaintAdorner);
	                }
	               
	                if (newRange.row === -1 && newRange.col === -1 && !isNavigateInSelection) {
	                    sheet._dirty = true;
	                    self._paint(ctx, layout._headerCornerRect(), onlyPaintAdorner);
	                }
	                if (rangeWidth > 0 && rangeHeight > 0) {
	                   
	                    self._paint(ctx, rect);
	                }
	                ret = true;
	            }
	            return ret;
	        },
	        _update: function (x, y, width, height, ignoreDirtyFlag) {
	            var self = this, sheet = self._sheet;
	            if (sheet._layoutSuspended <= 0) {
	                var ctx = self._getCtx();
	                if (ctx) {
	                    if (!ignoreDirtyFlag) {
	                        sheet._dirty = true;
	                    }
	                    self._paint(ctx, new Rect(x, y, width, height));
	                }
	            }
	        },
	        repaint: function (clipRect) {
	            var self = this, sheet = self._sheet;
	            if (sheet._layoutSuspended > 0) {
	                return;
	            }
	            var ctx = self._getCtx();
	            if (ctx) {
	                sheet._dirty = true;
	                self._paint(ctx, clipRect);
	            }
	        },
	        _paint: function (ctx, clipRect, onlyPaintAdorner) {
	            var self = this;
	            if (ctx && self._sheet._layoutSuspended <= 0) {
	                if (!onlyPaintAdorner) {
	                    self._paintBody(ctx, clipRect);
	                }
	                self._paintAdornment(ctx, clipRect);
	            }
	        },
	        _paintBody: function (ctx, clipRect, clipRect2) {
	            var self = this;
	            var sheet = self._sheet;
	            if (ctx && sheet._layoutSuspended <= 0) {
	                var bufferCtx = self._getBufferCtx();
	                var paintContext = bufferCtx ? bufferCtx : ctx;
	                var rect = sheet._getBounds();
	                if (!clipRect) {
	                    clipRect = rect;
	                }
	                if (clipRect) {
	                    clipRect.round();
	                }
	                if (clipRect2) {
	                    clipRect2.round();
	                }
	                if (sheet._dirty) {
	                    sheet._dirty = false;
	                    if (bufferCtx) {
	                        bufferCtx.clearRect(clipRect.x, clipRect.y, getWidth(clipRect), getHeight(clipRect));
	                        if (clipRect2) {
	                            bufferCtx.clearRect(clipRect2.x, clipRect2.y, getWidth(clipRect2), getHeight(clipRect2));
	                        }
	                        CanvasHelper._translate(bufferCtx, -rect.x, -rect.y);
	                    }
	                    self._paintSheet(paintContext, clipRect);
	                    if (clipRect2) {
	                        self._paintSheet(paintContext, clipRect2);
	                    }
	                    if (bufferCtx) {
	                        CanvasHelper._translate(bufferCtx, rect.x, rect.y);
	                    }
	                }
	                if (bufferCtx) {
	                    self._copyDoubleBufferRect(clipRect);
	                    if (clipRect2) {
	                        self._copyDoubleBufferRect(clipRect2);
	                    }
	                }
	            }
	        },
	        _paintAdornment: function (ctx, clipRect) {
	            var self = this, sheet = self._sheet, isTouchMode = sheet._isTouchMode;
	            if (!ctx || sheet._layoutSuspended > 0) {
	                return;
	            }
	            if (clipRect) {
	                clipRect.round();
	            }
	            var layout = sheet._getSheetLayout(), rect, actualClipRect, r, c;
	            if (!sheet._hoverCell) {
	                if (isTouchMode) {
	                    rect = layout._headerCornerRect();
	                    self._copyDoubleBufferRect(rect);
	                    for (r = 0; r <= 2; r++) {
	                        rect = layout._rowHeaderRect(r);
	                        if (!rect || getWidth(rect) === 0 || getHeight(rect) === 0) {
	                            continue;
	                        }
	                        self._copyDoubleBufferRect(rect);
	                    }
	                    for (c = 0; c <= 2; c++) {
	                        rect = layout._colHeaderRect(c);
	                        if (!rect || getWidth(rect) === 0 || getHeight(rect) === 0) {
	                            continue;
	                        }
	                        self._copyDoubleBufferRect(rect);
	                    }
	                }
	                for (r = 0; r <= 2; r++) {
	                    for (c = 0; c <= 2; c++) {
	                        rect = layout._viewportRect(r, c);
	                        if (!rect || getWidth(rect) === 0 || getHeight(rect) === 0) {
	                            continue;
	                        }
	                       
	                        actualClipRect = clipRect;
	                        if ((isTouchMode && (r !== 1 || c !== 1)) || (sheet.parent && sheet.parent.options.allowUserDragMerge)) {
	                            self._copyDoubleBufferRect(rect);
	                            actualClipRect = rect;
	                        }
	                        if (!actualClipRect || rect.intersectRect(actualClipRect)) {
	                            self._paintSelection(ctx, r, c, actualClipRect);
	                        }
	                    }
	                }
	                self._paintResizeLine(ctx);
	
	                Worksheet._callFeatureHandler(sheet, 'paintAdornment', {
	                    ctx: ctx,
	                    clipRect: clipRect
	                });
	            }
	        },
	        _paintBackground: function (ctx, rect) {
	            var sheet = this._sheet;
	            var workbook = sheet.parent, options = workbook ? workbook.options : {};
	            var bkColorString = getSheetBackColor(sheet);
	            var bkColor = _ThemeContext._getColor(sheet, bkColorString);
	            var bkImg = options.backgroundImage;
	            if (bkImg) {
	                bkColor = STR_TRANSPARENT;
	            }
	
	            ctx.save();
	            ctx.fillStyle = bkColor;
	            ctx.fillRect(rect.x, rect.y, getWidth(rect), getHeight(rect));
	            ctx.restore();
	        },
	        _isNeedTopLine: function (row) {
	            var sheet = this._sheet, layout = sheet._getSheetLayout();
	            return (row === sheet._getFirstVisualRow(3 ) && layout._colHeaderHeight === 0);
	        },
	        _isNeedLeftLine: function (col) {
	            var sheet = this._sheet, layout = sheet._getSheetLayout();
	            return (col === sheet._getFirstVisualColumn(3 ) && layout._rowHeaderWidth === 0);
	        },
	        _paintHeadersAndViewport: function (ctx, clipRect, isPrinting) {
	            var self = this;
	            var sheet = self._sheet, options = sheet.options, layout = sheet._getSheetLayout(), offsetTop = options.sheetAreaOffset.top, offsetLeft = options.sheetAreaOffset.left,
	                colHeaderVisible = layout._colHeaderHeight !== 0, rowHeaderVisible = layout._rowHeaderWidth !== 0;
	           
	            var outlineLayout = sheet._getOutlineLayout && sheet._getOutlineLayout() || {x: options.sheetAreaOffset.left, y: options.sheetAreaOffset.top, width: 0, height: 0};
	            var isNotHaveRowOutline = outlineLayout.width === 0, isNotColOutline = outlineLayout.height === 0;
	            var r, c, intersectRect;
	            for (c = 0; c <= 2; c++) {
	                var colHeaderRect = layout._colHeaderRect(c);
	                if (colHeaderRect) {
	                    if(colHeaderVisible && isNotColOutline) {
	                        colHeaderRect.y = colHeaderRect.y - offsetTop;
	                        colHeaderRect.height = colHeaderRect.height + offsetTop;
	                        if(!rowHeaderVisible && isNotHaveRowOutline) {
	                            colHeaderRect.x = colHeaderRect.x - offsetLeft;
	                            colHeaderRect.width = colHeaderRect.width + offsetLeft;
	                        }
	                    }
	                    intersectRect = clipRect ? colHeaderRect.getIntersectRect(clipRect) : colHeaderRect;
	                    if (intersectRect) {
	                        self._paintColHeader(ctx, c, intersectRect, isPrinting);
	                    }
	                }
	            }
	            for (r = 0; r <= 2; r++) {
	                var rowHeaderRect = layout._rowHeaderRect(r);
	                if (rowHeaderRect) {
	                    if(rowHeaderVisible && isNotHaveRowOutline) {
	                        rowHeaderRect.x = rowHeaderRect.x - offsetLeft;
	                        rowHeaderRect.width = rowHeaderRect.width + offsetLeft;
	                        if(!colHeaderVisible && isNotColOutline) {
	                            rowHeaderRect.y = rowHeaderRect.y - offsetTop;
	                            rowHeaderRect.height = rowHeaderRect.height + offsetTop;
	                        }
	                    }
	                    intersectRect = clipRect ? rowHeaderRect.getIntersectRect(clipRect) : rowHeaderRect;
	                    if (intersectRect) {
	                        self._paintRowHeader(ctx, r, intersectRect, isPrinting);
	                    }
	                }
	                for (c = 0; c <= 2; c++) {
	                    var viewportRect = layout._viewportRect(r, c);
	                    if(self._isNeedTopLine(sheet._scrollTopRow) && isNotColOutline) {
	                        viewportRect.y = viewportRect.y - offsetTop;
	                        viewportRect.height = viewportRect.height + offsetTop;
	                    }
	                    if(self._isNeedLeftLine(sheet._scrollLeftCol) && isNotHaveRowOutline) {
	                        viewportRect.x = viewportRect.x - offsetLeft;
	                        viewportRect.width = viewportRect.width + offsetLeft;
	                    }
	                    if (viewportRect) {
	                        intersectRect = clipRect ? viewportRect.getIntersectRect(clipRect) : viewportRect;
	                        if (intersectRect) {
	
	                            self._paintViewport(ctx, r, c, intersectRect, isPrinting);
	                        }
	                    }
	                }
	            }
	           
	            var headerCornerRect = layout._headerCornerRect();
	            if (headerCornerRect) {
	
	                intersectRect = clipRect ? headerCornerRect.getIntersectRect(clipRect) : headerCornerRect;
	                if (intersectRect) {
	                    self._paintColHeaderCorner(ctx, intersectRect, isPrinting);
	                }
	            }
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	        },
	        _paintGrayArea: function (ctx) {
	            var self = this;
	            var sheet = self._sheet;
	            var layout = sheet._getSheetLayout(), headerX = layout._headerX, headerY = layout._headerY,
	                frozenTrailingX = layout._frozenTrailingX, frozenTrailingY = layout._frozenTrailingY,
	                layout_width = getWidth(layout), layout_height = getHeight(layout),
	                viewportY = layout._viewportY, viewportX = layout._viewportX;
	            var rowLayoutModel = sheet._getRowLayout(1);
	            if (rowLayoutModel.length > 0) {
	                var rowLayout = rowLayoutModel[rowLayoutModel.length - 1], bottomY = rowLayout.y + getHeight(rowLayout);
	                if (bottomY < frozenTrailingY) {
	                    ctx.fillStyle = self._getGrayAreaBackColor(false);
	                    ctx.fillRect(headerX, bottomY, layout_width, frozenTrailingY - bottomY);
	                }
	            } else if (rowLayoutModel.length === 0) {
	                ctx.fillStyle = self._getGrayAreaBackColor(false);
	                ctx.fillRect(headerX, viewportY, layout_width, frozenTrailingY - viewportY);
	            }
	            var colLayoutModel = sheet._getColumnLayout(1);
	            if (colLayoutModel.length > 0) {
	                var colLayout = colLayoutModel[colLayoutModel.length - 1], rightX = colLayout.x + getWidth(colLayout);
	                if (rightX < frozenTrailingX) {
	                    ctx.fillStyle = self._getGrayAreaBackColor(false);
	                    ctx.fillRect(rightX, headerY, frozenTrailingX - rightX, layout_height);
	                }
	            } else if (colLayoutModel.length === 0) {
	                ctx.fillStyle = self._getGrayAreaBackColor(false);
	                ctx.fillRect(viewportX, headerY, frozenTrailingX - viewportX, layout_height);
	            }
	        },
	        _paintSheetOffset: function (ctx, rect) {
	            var self = this;
	            var sheet = self._sheet, grayAreaBackColor = self._getGrayAreaBackColor(false), options = sheet.options, offsetLeft = options.sheetAreaOffset.left, offsetTop = options.sheetAreaOffset.top;
	            var rectX = rect.x, rectY = rect.y, width = getWidth(rect), height = getHeight(rect);
	            ctx.save();
	
	            if (offsetLeft > 0) {
	                _strokeLine(ctx, offsetLeft, grayAreaBackColor, rectX + offsetLeft / 2, rectY, rectX + offsetLeft / 2, rectY + Math_max(0, height));
	            }
	            if (offsetTop > 0) {
	                _strokeLine(ctx, offsetTop, grayAreaBackColor, rectX, rectY + offsetTop / 2, rectX + Math_max(0, width), rectY + offsetTop / 2);
	            }
	
	            ctx.beginPath();
	            ctx.restore();
	        },
	        _paintSheet: function (ctx, clipRect) {
	            var self = this;
	            var sheet = self._sheet;
	            if (!ctx || sheet._layoutSuspended > 0) {
	                return;
	            }
	            _CacheMgr._startCache(sheet, 0, 0, sheet.getRowCount() - 1, sheet.getColumnCount() - 1);
	            var rect = sheet._getBounds();
	            ctx.save();
	            if (!clipRect) {
	                ctx.rect(rect.x, rect.y, getWidth(rect), getHeight(rect));
	            } else {
	                ctx.rect(clipRect.x, clipRect.y, getWidth(clipRect), getHeight(clipRect));
	            }
	            ctx.clip();
	            ctx.beginPath();
	           
	            self._paintBackground(ctx, rect);
	
	            Worksheet._callFeatureHandler(sheet, 'paint', {ctx: ctx, clipRect: clipRect});
	           
	            self._paintSheetOffset(ctx, rect);
	
	           
	            self._paintHeadersAndViewport(ctx, clipRect, false);
	           
	            self._paintGrayArea(ctx);
	           
	            self._paintFrozenLine(ctx);
	
	           
	            _CacheMgr._clearCache();
	            ctx.beginPath();
	            ctx.restore();
	        },
	        _paintSheetForPrint: function (ctx, clipRect, needTopLeftLine) {
	            var self = this;
	            var sheet = self._sheet;
	            if (!ctx) {
	                return;
	            }
	            _CacheMgr._startCache(sheet, 0, 0, sheet.getRowCount() - 1, sheet.getColumnCount() - 1);
	            var rect = sheet._getBounds();
	            ctx.save();
	
	            var actualClipRect = clipRect || new Rect(rect.x, rect.y, getWidth(rect), getHeight(rect));
	            ctx.rect(actualClipRect.x, actualClipRect.y, getWidth(actualClipRect), getHeight(actualClipRect));
	            ctx.clip();
	            ctx.beginPath();
	           
	            self._paintBackground(ctx, rect);
	           
	            self._paintHeadersAndViewport(ctx, actualClipRect, true, needTopLeftLine);
	           
	            _CacheMgr._clearCache();
	
	            ctx.beginPath();
	            ctx.restore();
	        },
	        _paintResizeLine: function (ctx) {
	            var x, y, movingX, movingY, endX, endY;
	            var sheet = this._sheet, eventHandler = sheet._eventHandler, currentTarget = sheet._currentTarget;
	            if (eventHandler && eventHandler.isResizing && currentTarget) {
	                var resizeInfo = currentTarget.resizeInfo;
	                if (resizeInfo) {
	                    var sheetLayout = sheet._getSheetLayout(), lineColor = STR_BLACK;
	                    ctx.save();
	                    if (ctx.strokeStyle !== lineColor) {
	                        ctx.strokeStyle = lineColor;
	                    }
	                    if (ctx.lineWidth !== 1) {
	                        ctx.lineWidth = 1;
	                    }
	                    ctx.beginPath();
	                    if (resizeInfo.action === 'sizeRow' || resizeInfo.action === 'sizeHiddenRow') {
	                        y = Math_max(0, resizeInfo.startY - 0.5);
	                        movingY = resizeInfo.movingY - 0.5;
	                        endX = sheetLayout.x + getWidth(sheetLayout);
	                        for (x = sheetLayout.x; x < endX; x += 2) {
	                            ctx.moveTo(x, y);
	                            ctx.lineTo(x + 1, y);
	                            ctx.moveTo(x, movingY);
	                            ctx.lineTo(x + 1, movingY);
	                        }
	                    } else {
	                        x = Math_max(0, resizeInfo.startX - 0.5);
	                        movingX = resizeInfo.movingX - 0.5;
	                        endY = sheetLayout.y + getHeight(sheetLayout);
	                        for (y = sheetLayout.y; y < endY; y += 2) {
	                            ctx.moveTo(x, y);
	                            ctx.lineTo(x, y + 1);
	                            ctx.moveTo(movingX, y);
	                            ctx.lineTo(movingX, y + 1);
	                        }
	                    }
	                    ctx.stroke();
	                    ctx.beginPath();
	                    ctx.restore();
	                }
	            }
	        },
	        _paintColHeaderCorner: function (ctx, clipRect, isPrinting) {
	            var sheet = this._sheet;
	            ctx.beginPath();
	            var rect = sheet._getSheetLayout()._headerCornerRect();
	            var x = rect.x, y = rect.y, width = getWidth(rect), height = getHeight(rect);
	            var style = sheet.getActualStyle(-1, -1, 0 );
	            this._paintCells(ctx, [{
	                data: keyword_null,
	                row: -1,
	                col: -1,
	                x: x,
	                y: y,
	                width: width,
	                height: height,
	                style: style.clone()
	            }], 0 , isPrinting);
	            var border = new _Borders(sheet, 0, 0, 0 );
	            border._addCellLines(0, 0, x, y, width, height);
	            border.paint(ctx, clipRect);
	        },
	        _paintFrozenLine: function (ctx) {
	            var sheet = this._sheet;
	            var frozenRowCount = sheet.frozenRowCount();
	            var frozenColCount = sheet.frozenColumnCount();
	            var frozenTrailingRowCount = sheet.frozenTrailingRowCount();
	            var frozenTrailingColCount = sheet.frozenTrailingColumnCount();
	            if (frozenRowCount || frozenColCount || frozenTrailingRowCount || frozenTrailingColCount) {
	                var sheetLayout = sheet._getSheetLayout();
	                var viewportX = sheetLayout._viewportX, viewportY = sheetLayout._viewportY,
	                    frozenTrailingX = sheetLayout._frozenTrailingX, frozenTrailingY = sheetLayout._frozenTrailingY,
	                    sheetLayout_x = sheetLayout.x, sheetLayout_y = sheetLayout.y,
	                    sheetLayout_width = getWidth(sheetLayout), sheetLayout_height = getHeight(sheetLayout);
	                ctx.save();
	                ctx.strokeStyle = _ThemeContext._getColor(sheet, sheet.options.frozenlineColor);
	                ctx.lineWidth = 1;
	                ctx.beginPath();
	                if (frozenColCount) {
	                    ctx.moveTo(viewportX - 0.5, sheetLayout_y);
	                    ctx.lineTo(viewportX - 0.5, sheetLayout_y + sheetLayout_height);
	                }
	                if (frozenRowCount) {
	                    ctx.moveTo(sheetLayout_x, viewportY - 0.5);
	                    ctx.lineTo(sheetLayout_x + sheetLayout_width, viewportY - 0.5);
	                }
	                if (frozenTrailingColCount) {
	                    ctx.moveTo(frozenTrailingX - 0.5, sheetLayout_y);
	                    ctx.lineTo(frozenTrailingX - 0.5, sheetLayout_y + sheetLayout_height);
	                }
	                if (frozenTrailingRowCount) {
	                    ctx.moveTo(sheetLayout_x, frozenTrailingY - 0.5);
	                    ctx.lineTo(sheetLayout_x + sheetLayout_width, frozenTrailingY - 0.5);
	                }
	                ctx.stroke();
	                ctx.restore();
	            }
	        },
	        _paintColHeader: function (ctx, c, clipRect, isPrinting) {
	            this._paintViewportImp(ctx, -1, c, 1 , clipRect, isPrinting);
	        },
	        _paintRowHeader: function (ctx, r, clipRect, isPrinting) {
	            this._paintViewportImp(ctx, r, -1, 2 , clipRect, isPrinting);
	        },
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	        _paintViewport: function (ctx, rowViewportIndex, colViewportIndex, clipRect, isPrinting) {
	            this._paintViewportImp(ctx, rowViewportIndex, colViewportIndex, 3 , clipRect, isPrinting);
	           
	            var cutCopyIndicatorManager = this._sheet._cutCopyIndicatorManager;
	            if (cutCopyIndicatorManager) {
	                cutCopyIndicatorManager._paintCutCopyIndicator(ctx, clipRect, rowViewportIndex, colViewportIndex);
	            }
	        },
	        _paintSelection: function (ctx, rowViewportIndex, colViewportIndex, clipRect) {
	            var self = this, sheet = self._sheet;
	            if (needPaintSelection(sheet)) {
	                if (!sheet.addSelection) {
	                    return;
	                }
	                var eventHandler = sheet._eventHandler, selections = sheet._modelManager.getSelections(),
	                    selectionCount = selections.length;
	                clipRect = self._getClipRect(rowViewportIndex, colViewportIndex, clipRect);
	                if (!clipRect) {
	                    return;
	                }
	                var themeStyle = _ThemeStyleHelper._getCssClassThemeStyle('gc-selection'),
	                    themeVersion = parseIntFunc(themeStyle.zIndex);
	                if (themeVersion > 2007 ) {
	                    self._paintHeaderSelection(ctx, rowViewportIndex, colViewportIndex, clipRect);
	                }
	                var selectionRects = self._getPaintingRects(rowViewportIndex, colViewportIndex, selections, clipRect),
	                    selectionRectCount = selectionRects.length, selectionRect;
	                if (selectionRectCount <= 0) {
	                    return;
	                }
	
	                var deselectRect = self._getPaintingRects(rowViewportIndex, colViewportIndex, [sheet._deselectRange], clipRect)[0];
	
	               
	                var needClip = false, i;
	                for (i = 0; i < selectionRectCount; i++) {
	                    selectionRect = selectionRects[i];
	                    if (!clipRect.containsRect(selectionRect)) {
	                        needClip = true;
	                        break;
	                    }
	                }
	                if (deselectRect && !clipRect.containsRect(deselectRect)) {
	                    needClip = true;
	                }
	
	               
	                ctx.save();
	                if (needClip) {
	                    ctx.rect(clipRect.x, clipRect.y, getWidth(clipRect), getHeight(clipRect));
	                    ctx.clip();
	                }
	                ctx.beginPath();
	               
	                if (selectionRectCount > 0) {
	                    var selectionBackColor = _ThemeContext._getColor(sheet, sheet.getSelectionBackColor());
	                    if (ctx.fillStyle !== selectionBackColor) {
	                        ctx.fillStyle = selectionBackColor;
	                    }
	                    var posAdjust = 0, sizeAdjust = 0;
	                    if (themeVersion > 2007 ) {
	                        posAdjust = 1;
	                        sizeAdjust = -3;
	                    }
	                    for (i = 0; i < selectionRectCount; i++) {
	                        selectionRect = selectionRects[i];
	                        ctx.fillRect(selectionRect.x + posAdjust, selectionRect.y + posAdjust, getWidth(selectionRect) + sizeAdjust, getHeight(selectionRect) + sizeAdjust);
	                    }
	                }
	               
	                var activeRowIndex = sheet._activeRowIndex, activeColIndex = sheet._activeColIndex;
	                if(deselectRect) {
	                    activeRowIndex = sheet._oldActiveRow;
	                    activeColIndex = sheet._oldActiveCol;
	                }
	                var rect = sheet.getCellRect(activeRowIndex, activeColIndex, rowViewportIndex, colViewportIndex),
	                    rectX, rectY, rectWidth, rectHeight;
	                if (rect && rect.intersectRect(clipRect)) {
	                    rectX = rect.x;
	                    rectY = rect.y;
	                    rectWidth = getWidth(rect);
	                    rectHeight = getHeight(rect);
	                    posAdjust = 1;
	                    sizeAdjust = -2;
	                    if (themeVersion > 2007 ) {
	                        posAdjust = 0;
	                        sizeAdjust = 0;
	                    }
	                    self._copyDoubleBuffer(rectX + posAdjust, rectY + posAdjust, rectWidth + sizeAdjust, rectHeight + sizeAdjust);
	                    if (selectionCount > 1) {
	                        ctx.strokeStyle = STR_BLACK;
	                        ctx.lineWidth = 1;
	                        ctx.strokeRect(rectX + 1.5, rectY + 1.5, rectWidth - 4, rectHeight - 4);
	                    }
	                }
	                ctx.restore();
	
	                ctx.save();
	                ctx.beginPath();
	                if (selectionCount === 1) {
	                   
	                    if (eventHandler && eventHandler._isDraggingFill && eventHandler._isDragClear && eventHandler._isDragClear() && !eventHandler._isDragAroundIndicator) {
	                        var fillRange = eventHandler._getCurrentFillRange && eventHandler._getCurrentFillRange();
	                        var fillRect = sheet.getRangeRect(rowViewportIndex, colViewportIndex, fillRange),
	                            fillRectWidth = getWidth(fillRect), fillRectHeight = getHeight(fillRect);
	                        if (fillRect && fillRectWidth > 0 && fillRectHeight > 0) {
	                            ctx.fillStyle = themeStyle && themeStyle.color;
	                            ctx.fillRect(fillRect.x, fillRect.y, fillRectWidth, fillRectHeight);
	                        }
	                    }
	                    if (selectionRect && getWidth(selectionRect) >= 0 && getHeight(selectionRect) >= 0) {
	                        self._adjustClipRect(clipRect, sheet, rowViewportIndex, colViewportIndex, themeVersion);
	                        self._paintSelectionBorder(ctx, rowViewportIndex, colViewportIndex, selectionRect, clipRect, selections[0]);
	                    }
	                }
	                if(deselectRect) {
	                    ctx.save();
	                    if (needClip) {
	                        ctx.rect(clipRect.x, clipRect.y, getWidth(clipRect), getHeight(clipRect));
	                        ctx.clip();
	                    }
	                    ctx.beginPath();
	                    ctx.fillStyle = "rgba(255,255,255,0.4)";
	                    ctx.fillRect(deselectRect.x + posAdjust, deselectRect.y + posAdjust, getWidth(deselectRect) + sizeAdjust, getHeight(deselectRect) + sizeAdjust);
	                    ctx.fillStyle = selectionBackColor;
	                    ctx.strokeStyle = "rgb(124,124,124)";
	                    ctx.lineWidth = 1;
	                    ctx.strokeRect(deselectRect.x - 0.5, deselectRect.y - 0.5, getWidth(deselectRect), getHeight(deselectRect));
	
	                    ctx.restore();
	                }
	
	                ctx.beginPath();
	                ctx.restore();
	            }
	        },
	        _adjustClipRect: function (clipRect, sheet, rowViewportIndex, colViewportIndex, themeVersion) {
	           
	            var frozenTrailingRowCount = sheet.frozenTrailingRowCount();
	            var frozenTrailingColCount = sheet.frozenTrailingColumnCount();
	            var selections = sheet.getSelections(),
	                layout = sheet._getSheetLayout(),
	                lastViewportRowIndex = sheet.getRowCount() - frozenTrailingRowCount - 1,
	                lastViewportColIndex = sheet.getColumnCount() - frozenTrailingColCount - 1,
	                colLayout = sheet._getColumnLayout(1, 3 ),
	                rowLayout = sheet._getRowLayout(1, 3 );
	
	            if (selections.length === 1 && themeVersion > 2007 ) {
	                var frozenRowCount = sheet.frozenRowCount();
	                var frozenColCount = sheet.frozenColumnCount();
	                var sel = selections[0], selRow = sel.row, selCol = sel.col, selRowCount = sel.rowCount,
	                    selColCount = sel.colCount;
	                if (frozenRowCount > 0) {
	                   
	                    if (selRow >= frozenRowCount && sheet._getPrevVisualRow(selRow) < frozenRowCount) {
	                        clipRect.y -= 2;
	                        clipRect.height += 2;
	                    } else if (selRow + selRowCount <= frozenRowCount && sheet._getNextVisualRow(selRow + selRowCount - 1) === sheet._scrollTopRow) {
	                        clipRect.height += 2;
	                    }
	                }
	                if (frozenColCount > 0) {
	                    if (selCol >= frozenColCount && sheet._getPrevVisualColumn(selCol) < frozenColCount) {
	                        clipRect.x -= 2;
	                        clipRect.width += 2;
	                    } else if (selCol + selColCount <= frozenColCount && sheet._getNextVisualColumn(selCol + selColCount - 1) === sheet._scrollLeftCol) {
	                        clipRect.width += 2;
	                    }
	                }
	               
	                if (selRow === 0 && selCol === 0) {
	                    clipRect.x -= 2;
	                    clipRect.y -= 2;
	                    clipRect.width += 2;
	                    clipRect.height += 2;
	                }
	               
	                if (selRow === -1) {
	                    selRow = 0;
	                    selRowCount = sheet.getRowCount();
	                }
	                if (selCol === -1) {
	                    selCol = 0;
	                    selColCount = sheet.getColumnCount();
	                }
	                var isLastRowInViewportVisible = false, isLastColInViewportVisible = false,
	                    lastViewportRowLayout = rowLayout.findRow(lastViewportRowIndex),
	                    lastViewportColLayout = colLayout.findCol(lastViewportColIndex);
	                if (lastViewportRowLayout && lastViewportRowLayout.y + getHeight(lastViewportRowLayout) < layout._viewportY + layout._viewportHeight) {
	                    isLastRowInViewportVisible = true;
	                }
	                if (lastViewportColLayout && lastViewportColLayout.x + getWidth(lastViewportColLayout) < layout._viewportX + layout._viewportWidth) {
	                    isLastColInViewportVisible = true;
	                }
	                if (isLastRowInViewportVisible && selRow + selRowCount - 1 === lastViewportRowIndex) {
	                    clipRect.height += 2;
	                }
	                if (isLastColInViewportVisible && selCol + selColCount - 1 === lastViewportColIndex) {
	                    clipRect.width += 2;
	                }
	            }
	        },
	        _paintHeaderSelection: function (ctx, rowViewportIndex, colViewportIndex, clipRect) {
	           
	            var self = this, sheet = self._sheet, selections = sheet._modelManager.getSelections(),
	                layout = sheet._getSheetLayout(),
	                layout_frozenX = layout._frozenX, layout_frozenY = layout._frozenY,
	                selectionCount = selections.length;
	            var colHeaderVisible = layout._colHeaderHeight !== 0, rowHeaderVisible = layout._rowHeaderWidth !== 0;
	            if (selectionCount <= 0) {
	                return;
	            }
	            var selection = selections[0], selRow = selection.row, selRowCount = selection.rowCount,
	                selCol = selection.col, selColCount = selection.colCount;
	            if (selRow === -1) {
	                selRow = 0;
	            }
	            if (selCol === -1) {
	                selCol = 0;
	            }
	            if (selRowCount === -1) {
	                selRowCount = sheet.getRowCount();
	            }
	            if (selColCount === -1) {
	                selColCount = sheet.getColumnCount();
	            }
	            ctx.save();
	            ctx.beginPath();
	            ctx.lineWidth = 2;
	            ctx.strokeStyle = sheet.getSelectionBorderColor();
	
	            var clipRectX = clipRect.x, clipRectY = clipRect.y, clipRectWidth = getWidth(clipRect),
	                clipRectHeight = getHeight(clipRect);
	            var frozenRowCount = sheet.frozenRowCount();
	            if (colHeaderVisible && (selectionCount !== 1 || frozenRowCount !== 0 || sheet._scrollTopRow <= selRow || sheet._scrollTopRow >= selRow + selRowCount)) {
	               
	                var columnHeaderScope = self._getColumnHeaderSelectionRects(colViewportIndex);
	                for (var i = 0, len = columnHeaderScope.length; i < len; i++) {
	                    var colRect = columnHeaderScope[i], leftExpand = 0, rightExpand = 0, startX = colRect.x,
	                        endX = colRect.x + getWidth(colRect);
	                    if (colRect.x < clipRectX + clipRectWidth && clipRectX < colRect.x + getWidth(colRect)) {
	                        if (selectionCount === 1 && (frozenRowCount === 0 && sheet._scrollTopRow === selRow || frozenRowCount > 0 && selRow === 0)) {
	                            leftExpand = -1;
	                            rightExpand = 1;
	                        }
	                        if (colRect.x < clipRectX) {
	                            leftExpand = 0;
	                            startX = clipRectX;
	                        }
	                        if (colRect.x + getWidth(colRect) > clipRectX + clipRectWidth) {
	                            rightExpand = 0;
	                            endX = clipRectX + clipRectWidth;
	                        }
	                        ctx.moveTo(startX + leftExpand - 1, layout_frozenY - 1);
	                        ctx.lineTo(endX + rightExpand, layout_frozenY - 1);
	                        ctx.stroke();
	                    }
	                }
	            }
	            var frozenColCount = sheet.frozenColumnCount();
	            if (rowHeaderVisible && (selectionCount !== 1 || frozenColCount !== 0 || sheet._scrollLeftCol <= selCol || sheet._scrollLeftCol >= selCol + selColCount)) {
	               
	                var rowHeaderScope = self._getRowHeaderSelectionRects(rowViewportIndex);
	                for (var j = 0, length = rowHeaderScope.length; j < length; j++) {
	                    var rowRect = rowHeaderScope[j], topExpand = 0, bottomExpand = 0, startY = rowRect.y,
	                        endY = rowRect.y + getHeight(rowRect);
	                    if (rowRect.y < clipRectY + clipRectHeight && clipRectY < rowRect.y + getHeight(rowRect)) {
	                        if (selectionCount === 1 && (frozenColCount === 0 && sheet._scrollLeftCol === selCol || frozenColCount > 0 && selCol === 0)) {
	                            topExpand = -1;
	                            bottomExpand = 1;
	                        }
	                        if (rowRect.y < clipRectY) {
	                            topExpand = 0;
	                            startY = clipRectY;
	                        }
	                        if (rowRect.y + getHeight(rowRect) > clipRectY + clipRectHeight) {
	                            bottomExpand = 0;
	                            endY = clipRectY + clipRectHeight;
	                        }
	                        ctx.moveTo(layout_frozenX - 1, startY + topExpand - 1);
	                        ctx.lineTo(layout_frozenX - 1, endY + bottomExpand);
	                        ctx.stroke();
	                    }
	                }
	            }
	            ctx.beginPath();
	            ctx.restore();
	        },
	        _getColumnHeaderSelectionRects: function (colViewportIndex) {
	            var sheet = this._sheet, selections = sheet._modelManager.getSelections(),
	                selectionCount = selections.length,
	                columnLayout = sheet._getColumnLayout(colViewportIndex), columnHeaderScope = [];
	            for (var i = 0; i < selectionCount; i++) {
	                var sel = selections[i];
	                if (sel) {
	                    var selCol = sel.col;
	                    if (selCol === -1) {
	                        var fronzenColLayout = sheet._getColumnLayout(0, 3 ),
	                            viewportColLayout = sheet._getColumnLayout(1, 3 ),
	                            trailingFrozenColLayout = sheet._getColumnLayout(2, 3 );
	                        var x = -1, width = -1;
	                        if (fronzenColLayout.length > 0) {
	                            x = fronzenColLayout[0].x;
	                            width = fronzenColLayout[fronzenColLayout.length - 1].x + fronzenColLayout[fronzenColLayout.length - 1].width - x;
	                            columnHeaderScope.push(new Rect(x, -1, width, -1));
	                        }
	                        if (viewportColLayout.length > 0) {
	                            x = viewportColLayout[0].x;
	                            width = viewportColLayout[viewportColLayout.length - 1].x + viewportColLayout[viewportColLayout.length - 1].width - x;
	                            columnHeaderScope.push(new Rect(x, -1, width, -1));
	                        }
	                        if (trailingFrozenColLayout.length > 0) {
	                            x = trailingFrozenColLayout[0].x;
	                            width = trailingFrozenColLayout[trailingFrozenColLayout.length - 1].x + trailingFrozenColLayout[trailingFrozenColLayout.length - 1].width - x;
	                            columnHeaderScope.push(new Rect(x, -1, width, -1));
	                        }
	                    } else if (columnLayout) {
	                        var selStartColumnLayout = columnLayout.findCol(selCol),
	                            selEndColumnLayout = columnLayout.findCol(selCol + sel.colCount - 1);
	                        if (selStartColumnLayout || selEndColumnLayout) {
	                            var rect = new Rect(-1, -1, -1, -1);
	                            if (selStartColumnLayout) {
	                                rect.x = selStartColumnLayout.x;
	                            } else {
	                                rect.x = columnLayout[0].x;
	                            }
	                            if (selEndColumnLayout) {
	                                rect.width = selEndColumnLayout.x + getWidth(selEndColumnLayout) - rect.x;
	                            } else {
	                                rect.width = columnLayout[columnLayout.length - 1].x + columnLayout[columnLayout.length - 1].width - rect.x;
	                            }
	                            columnHeaderScope.push(rect);
	                        }
	                    }
	                }
	            }
	            return columnHeaderScope;
	        },
	        _getRowHeaderSelectionRects: function (rowViewportIndex) {
	            var sheet = this._sheet, selections = sheet._modelManager.getSelections(),
	                selectionCount = selections.length,
	                rowLayout = sheet._getRowLayout(rowViewportIndex), rowHeaderScope = [];
	            for (var i = 0; i < selectionCount; i++) {
	                var sel = selections[i];
	                if (sel) {
	                    var selRow = sel.row;
	                    if (selRow === -1) {
	                        var fronzenRowLayout = sheet._getRowLayout(0, 3 ),
	                            viewportRowLayout = sheet._getRowLayout(1, 3 ),
	                            trailingFrozenRowLayout = sheet._getRowLayout(2, 3 );
	                        var y = -1, height = -1;
	                        if (fronzenRowLayout.length > 0) {
	                            y = fronzenRowLayout[0].y;
	                            height = fronzenRowLayout[fronzenRowLayout.length - 1].y + fronzenRowLayout[fronzenRowLayout.length - 1].height - y;
	                            rowHeaderScope.push(new Rect(-1, y, -1, height));
	                        }
	                        if (viewportRowLayout.length > 0) {
	                            y = viewportRowLayout[0].y;
	                            height = viewportRowLayout[viewportRowLayout.length - 1].y + viewportRowLayout[viewportRowLayout.length - 1].height - y;
	                            rowHeaderScope.push(new Rect(-1, y, -1, height));
	                        }
	                        if (trailingFrozenRowLayout.length > 0) {
	                            y = trailingFrozenRowLayout[0].y;
	                            height = trailingFrozenRowLayout[trailingFrozenRowLayout.length - 1].y + trailingFrozenRowLayout[trailingFrozenRowLayout.length - 1].height - y;
	                            rowHeaderScope.push(new Rect(-1, y, -1, height));
	                        }
	                    } else if (rowLayout) {
	                        var selStartRowLayout = rowLayout.findRow(selRow),
	                            selEndRowLayout = rowLayout.findRow(selRow + sel.rowCount - 1);
	                        if (selStartRowLayout || selEndRowLayout) {
	                            var rect = new Rect(-1, -1, -1, -1);
	                            if (selStartRowLayout) {
	                                rect.y = selStartRowLayout.y;
	                            } else {
	                                rect.y = rowLayout[0].y;
	                            }
	                            if (selEndRowLayout) {
	                                rect.height = selEndRowLayout.y + getHeight(selEndRowLayout) - rect.y;
	                            } else {
	                                rect.height = rowLayout[rowLayout.length - 1].y + rowLayout[rowLayout.length - 1].height - rect.y;
	                            }
	                            rowHeaderScope.push(rect);
	                        }
	                    }
	                }
	            }
	            return rowHeaderScope;
	        },
	        _paintSelectionBorder: function (ctx, rowViewportIndex, colViewportIndex, selectRect, clipRect, selection) {
	            var self = this, sheet = self._sheet, parent = sheet.parent, eventHandler = sheet._eventHandler;
	            var selectRect_x = selectRect.x, selectRect_y = selectRect.y, selectRect_width = getWidth(selectRect),
	                selectRect_height = getHeight(selectRect);
	            var topRow = sheet.getViewportTopRow(rowViewportIndex), leftColumn = sheet.getViewportLeftColumn(colViewportIndex);
	            var clipRectOffsetX = 0, clipRectOffsetY = 0;
	            var layout = sheet._getSheetLayout(), colHeaderVisible = layout._colHeaderHeight !== 0, rowHeaderVisible = layout._rowHeaderWidth !== 0;
	            if(!rowHeaderVisible && selection.col === leftColumn) {
	                clipRectOffsetX = 2;
	            }
	            if(!colHeaderVisible && selection.row === topRow) {
	                clipRectOffsetY = 2;
	            }
	            if (selectRect_width >= 0 && selectRect_height >= 0 && (!clipRect || selectRect.intersect(clipRect.x - 1, clipRect.y - 1, getWidth(clipRect) + 2, getHeight(clipRect) + 2))) {
	                ctx.save();
	                if (clipRect && !clipRect.containsRect(selectRect)) {
	                    ctx.rect(clipRect.x - clipRectOffsetX, clipRect.y - clipRectOffsetY, getWidth(clipRect), getHeight(clipRect));
	                    ctx.clip();
	                }
	                ctx.beginPath();
	                ctx.strokeStyle = _ThemeContext._getColor(sheet, sheet.getSelectionBorderColor());
	                ctx.lineWidth = 2;
	                if (selectRect_width > 0 && selectRect_height > 0) {
	                    if (eventHandler && eventHandler._isDraggingFill) {
	                        var currentFillDirection = eventHandler._currentFillDirection;
	                        if (currentFillDirection === 2 ) {
	                            ctx.moveTo(selectRect_x + 0.5, selectRect_y - 0.5);
	                            ctx.lineTo(selectRect_x + selectRect_width - 1, selectRect_y - 0.5);
	                        } else if (currentFillDirection === 3 ) {
	                            ctx.moveTo(selectRect_x + 0.5, selectRect_y + selectRect_height - 0.5);
	                            ctx.lineTo(selectRect_x + selectRect_width - 1, selectRect_y + selectRect_height - 0.5);
	                        } else if (currentFillDirection === 0 ) {
	                            ctx.moveTo(selectRect_x - 0.5, selectRect_y + 0.5);
	                            ctx.lineTo(selectRect_x - 0.5, selectRect_y + selectRect_height - 1);
	                        } else if (currentFillDirection === 1 ) {
	                            ctx.moveTo(selectRect_x + selectRect_width - 0.5, selectRect_y + 0.5);
	                            ctx.lineTo(selectRect_x + selectRect_width - 0.5, selectRect_y + selectRect_height - 1);
	                        }
	                    } else {
	                        var themeVersion = parent && parent._themeVersion;
	                        if (themeVersion > 2007 ) {
	                            ctx.rect(selectRect_x - 1, selectRect_y - 1, selectRect_width + 1, selectRect_height + 1);
	                        } else {
	                            ctx.rect(selectRect_x - 0.5, selectRect_y - 0.5, selectRect_width, selectRect_height);
	                        }
	                    }
	                    ctx.stroke();
	                    if (parent && parent.options.allowUserDragFill && self._paintDragFillIndicator) {
	                        self._paintDragFillIndicator(ctx, rowViewportIndex, colViewportIndex, selectRect, clipRect);
	                    }
	                } else if (selectRect_width === 0 || selectRect_height === 0) {
	                    ctx.strokeRect(selectRect_x - 1, selectRect_y - 1, selectRect_width + 1, selectRect_height + 1);
	                }
	               
	                ctx.beginPath();
	                ctx.restore();
	            }
	        },
	        _getClipRect: function (rowViewportIndex, colViewportIndex, clipRect) {
	            var sheet = this._sheet, layout = sheet._getSheetLayout(),
	                paintRect = layout._viewportRect(rowViewportIndex, colViewportIndex);
	            if (colViewportIndex === 1) {
	                var colLayouts = sheet._getColumnLayout(colViewportIndex),
	                    lastColLayout = colLayouts.length > 0 ? colLayouts[colLayouts.length - 1] : keyword_null;
	                if (lastColLayout) {
	                    paintRect.width = Math_min(getWidth(paintRect), lastColLayout.x + getWidth(lastColLayout) - layout._viewportX);
	                }
	            }
	            if (rowViewportIndex === 1) {
	                var rowLayouts = sheet._getRowLayout(rowViewportIndex),
	                    lastRowLayout = rowLayouts.length > 0 ? rowLayouts[rowLayouts.length - 1] : keyword_null;
	                if (lastRowLayout) {
	                    paintRect.height = Math_min(getHeight(paintRect), lastRowLayout.y + getHeight(lastRowLayout) - layout._viewportY);
	                }
	            }
	            if (clipRect) {
	                clipRect = clipRect.getIntersect(paintRect.x, paintRect.y, getWidth(paintRect), getHeight(paintRect));
	            } else {
	                clipRect = paintRect;
	            }
	            return clipRect;
	        },
	        _getPaintingRects: function (rowViewportIndex, colViewportIndex, ranges, clipRect) {
	            var sheet = this._sheet, modelManager = sheet._modelManager, span, count = ranges.length, cr, rects = [],
	                rect;
	            for (var i = 0; i < count; i++) {
	                cr = ranges[i];
	                if (cr) {
	                    span = modelManager.findSpan(cr.row, cr.col);
	                    if (span && span.containsRange(cr)) {
	                        cr = span;
	                    }
	                    rect = sheet.getRangeRect(rowViewportIndex, colViewportIndex, cr);
	                    if (rect && rect.x <= clipRect.x + getWidth(clipRect) && rect.y <= clipRect.y + getHeight(clipRect) &&
	                        clipRect.x <= rect.x + getWidth(rect) && clipRect.y <= rect.y + getHeight(rect)) {
	                        rects.push(rect);
	                    }
	                }
	            }
	            return rects;
	        },
	        _paintDashRect: function (ctx, rect, color) {
	            ctx.save();
	            var rectX = rect.x, rectY = rect.y, rectWidth = getWidth(rect), rectHeight = getHeight(rect);
	            var dashLines = [6, 6];
	            if (ctx.setLineDash) {
	                ctx.beginPath();
	                ctx.lineWidth = 2;
	                ctx.strokeStyle = color;
	                ctx.setLineDash(dashLines);
	                ctx.rect(rectX, rectY, rectWidth - 1, rectHeight - 1);
	                ctx.stroke();
	            } else {
	                ctx.beginPath();
	                ctx.lineWidth = 2;
	                ctx.strokeStyle = color;
	                var dash1 = dashLines[0], dash2 = dashLines[1], x, y, remainderWidth, remainderHeight;
	               
	                x = rectX;
	                y = rectY;
	                remainderWidth = rectWidth;
	                while (remainderWidth > 0) {
	                    if (remainderWidth >= dash1 + dash2) {
	                        ctx.moveTo(x, y);
	                        ctx.lineTo(x + dash1, y);
	                        x = x + dash1 + dash2;
	                        remainderWidth = remainderWidth - dash1 - dash2;
	                    } else if (remainderWidth >= dash1) {
	                        ctx.moveTo(x, y);
	                        ctx.lineTo(x + dash1, y);
	                        remainderWidth = remainderWidth - dash1 - dash2;
	                        break;
	                    } else if (remainderWidth > 0) {
	                        ctx.moveTo(x, y);
	                        ctx.lineTo(x + remainderWidth, y);
	                        remainderWidth = remainderWidth - dash1 - dash2;
	                        break;
	                    }
	                }
	               
	                x = rectX + rectWidth - 1;
	                y = rectY + 1;
	                remainderHeight = rectHeight - 1;
	                if (remainderWidth < 0) {
	                    remainderWidth = Math_abs(remainderWidth);
	                    if (remainderWidth > dash2) {
	                        ctx.moveTo(x, y - 2);
	                        ctx.lineTo(x, y + (remainderWidth - dash2));
	                    }
	                    y += remainderWidth;
	                    remainderHeight -= remainderWidth;
	                }
	                while (remainderHeight > 0) {
	                    if (remainderHeight >= dash1 + dash2) {
	                        ctx.moveTo(x, y);
	                        ctx.lineTo(x, y + dash1);
	                        y = y + dash1 + dash2;
	                        remainderHeight = remainderHeight - dash1 - dash2;
	                    } else if (remainderHeight >= dash1) {
	                        ctx.moveTo(x, y);
	                        ctx.lineTo(x, y + dash1);
	                        remainderHeight = remainderHeight - dash1 - dash2;
	                    } else if (remainderHeight > 0) {
	                        ctx.moveTo(x, y);
	                        ctx.lineTo(x, y + remainderHeight);
	                        remainderHeight = remainderHeight - dash1 - dash2;
	                    }
	                }
	               
	                x = rectX + rectWidth - 2;
	                y = rectY + rectHeight - 1;
	                remainderWidth = rectWidth - 1;
	                if (remainderHeight < 0) {
	                    remainderHeight = Math_abs(remainderHeight);
	                    if (remainderHeight > dash2) {
	                        ctx.moveTo(x + 2, y);
	                        ctx.lineTo(x - (remainderHeight - dash2), y);
	                    }
	                    x -= remainderHeight;
	                    remainderWidth -= remainderHeight;
	                }
	                while (remainderWidth > 0) {
	                    if (remainderWidth >= dash1 + dash2) {
	                        ctx.moveTo(x, y);
	                        ctx.lineTo(x - dash1, y);
	                        x = x - dash1 - dash2;
	                        remainderWidth = remainderWidth - dash1 - dash2;
	                    } else if (remainderWidth >= dash1) {
	                        ctx.moveTo(x, y);
	                        ctx.lineTo(x - dash1, y);
	                        remainderWidth = remainderWidth - dash1 - dash2;
	                        break;
	                    } else if (remainderWidth > 0) {
	                        ctx.moveTo(x, y);
	                        ctx.lineTo(x - remainderWidth, y);
	                        remainderWidth = remainderWidth - dash1 - dash2;
	                        break;
	                    }
	                }
	               
	                x = rectX;
	                y = rectY + rectHeight - 2;
	                remainderHeight = rectHeight - 1;
	                if (remainderWidth < 0) {
	                    remainderWidth = Math_abs(remainderWidth);
	                    if (remainderWidth > dash2) {
	                        ctx.moveTo(x, y + 2);
	                        ctx.lineTo(x, y - (remainderWidth - dash2));
	                    }
	                    y -= remainderWidth;
	                    remainderHeight -= remainderWidth;
	                }
	                while (remainderHeight > 0) {
	                    if (remainderHeight >= dash1 + dash2) {
	                        ctx.moveTo(x, y);
	                        ctx.lineTo(x, y - dash1);
	                        y = y - dash1 - dash2;
	                        remainderHeight = remainderHeight - dash1 - dash2;
	                    } else if (remainderHeight >= dash1) {
	                        ctx.moveTo(x, y);
	                        if (y - dash1 === rectY) {
	                            ctx.lineTo(x, y - dash1 - 1);
	                        } else {
	                            ctx.lineTo(x, y - dash1);
	                        }
	                        remainderHeight = remainderHeight - dash1 - dash2;
	                    } else if (remainderHeight > 0) {
	                        if (y > rectY) {
	                            ctx.moveTo(x, y);
	                            ctx.lineTo(x, y - remainderHeight);
	                        }
	                        remainderHeight = remainderHeight - dash1 - dash2;
	                    }
	                }
	                ctx.stroke();
	            }
	            ctx.beginPath();
	            ctx.restore();
	        },
	        _paintViewportImp: function (ctx, rowViewportIndex, colViewportIndex, sheetArea, clipRect, isPrinting) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var self = this;
	            var sheet = self._sheet, workbook = sheet.parent,
	                resizeZeroIndicator = workbook && workbook.options.resizeZeroIndicator,
	                rowLayouts = sheet._getRowLayout(rowViewportIndex, sheetArea),
	                colLayouts = sheet._getColumnLayout(colViewportIndex, sheetArea);
	            var sheetAreaOffset = sheet.options.sheetAreaOffset, outlineLayout = sheet._getOutlineLayout && sheet._getOutlineLayout() || {x: sheetAreaOffset.left, y: sheetAreaOffset.top, width: 0, height: 0};
	
	            var rowLayoutCount = rowLayouts.length, colLayoutCount = colLayouts.length;
	            if (rowLayoutCount < 0 || colLayoutCount < 0) {
	                return;
	            }
	            var spanLayouts = sheet._getCellLayout(rowViewportIndex, colViewportIndex, sheetArea),
	                hasSpanLayout = spanLayouts.length > 0,
	                rowLayout, colLayout, cellLayout, cachePool = sheet._cachePool,
	                row, col, x = 0, y = 0, width = 0, height = 0, data, style,
	               
	                border = new _Borders(sheet, rowViewportIndex, colViewportIndex, sheetArea),
	               
	                tmpAddSpans = [], paintingCells = [],
	               
	                allowCellOverflow = sheetArea === 3  && sheet.options.allowCellOverflow,
	               
	                validationUIModel = [],
	                highlightInvalid = !isPrinting && sheetArea === 3  && workbook && workbook.options.highlightInvalidData;
	
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	
	            ctx.save();
	            ctx.beginPath();
	           
	           
	           
	           
	
	            if (clipRect) {
	                ctx.rect(clipRect.x, clipRect.y, getWidth(clipRect), getHeight(clipRect));
	                ctx.clip();
	            }
	            var doubleGridLinesInfo = [], lastDoubleGridLineRow = -1, lastDoubleGridLineCol = -1;
	            for (var i = 0; i < rowLayoutCount; i++) {
	                rowLayout = rowLayouts[i];
	                for (var j = 0; j < colLayoutCount; j++) {
	                    colLayout = colLayouts[j];
	                    cellLayout = hasSpanLayout && spanLayouts.findCell(rowLayout.row, colLayout.col);
	                    if (cellLayout) {
	                        row = cellLayout.row;
	                        col = cellLayout.col;
	                        x = cellLayout.x;
	                        y = cellLayout.y;
	                        width = getWidth(cellLayout);
	                        height = getHeight(cellLayout);
	                    } else {
	                        row = rowLayout.row;
	                        col = colLayout.col;
	                        x = colLayout.x;
	                        y = rowLayout.y;
	                        width = getWidth(colLayout);
	                        height = getHeight(rowLayout);
	                    }
	                    if (resizeZeroIndicator === 1 ) {
	                        if (rowViewportIndex === -1 && sheet.getColumnVisible(col) && sheet._getActualColumnWidth(col) === 0) {
	                           
	                            if (lastDoubleGridLineCol < 0 || lastDoubleGridLineCol !== col - 1) {
	                                doubleGridLinesInfo.push({x1: x, y1: y, x2: x, y2: y + height, horizontal: false});
	                            }
	                            lastDoubleGridLineCol = col;
	                        }
	                        if (colViewportIndex === -1 && sheet.getRowVisible(row) && sheet._getActualRowHeight(row) === 0) {
	                            if (lastDoubleGridLineRow < 0 || lastDoubleGridLineRow !== row - 1) {
	                                doubleGridLinesInfo.push({x1: x, y1: y, x2: x + width, y2: y, horizontal: true});
	                            }
	                            lastDoubleGridLineRow = row;
	                        }
	                    }
	                   
	                    if (clipRect && (x + width <= clipRect.x || x >= clipRect.x + getWidth(clipRect) ||
	                        y + height <= clipRect.y || y >= clipRect.y + getHeight(clipRect))) {
	                        continue;
	                    }
	                    if (width === 0 || height === 0) {
	                        continue;
	                    }
	                   
	                    if (!cellLayout || !ArrayHelper._contains(tmpAddSpans, cellLayout)) {
	                        data = cachePool._getValue(row, col, sheetArea, 1);
	                        style = cachePool._getActualStyle(row, col, sheetArea);
	                       
	                        if (highlightInvalid && !(sheet.isValid ? sheet.isValid(row, col, data) : true)) {
	                            validationUIModel.push({x: x, y: y, width: width, height: height});
	                        }
	                       
	                        border._addCellLines(row, col, x, y, width, height, style, cellLayout, self._isNeedTopLine(row) && outlineLayout.height === 0, self._isNeedLeftLine(col) && outlineLayout.width === 0);
	                       
	                        paintingCells.push({
	                            data: data,
	                            row: row,
	                            col: col,
	                            x: x,
	                            y: y,
	                            width: width,
	                            height: height,
	                            style: style,
	                            cellLayout: cellLayout
	                        });
	                       
	                        if (cellLayout) {
	                            tmpAddSpans.push(cellLayout);
	                        }
	                    }
	                }
	            }
	           
	            if (paintingCells.length > 0) {
	                if (allowCellOverflow) {
	                    var layoutBuilder = cachePool._getCellOverflowBuilder(rowViewportIndex, colViewportIndex, function () {
	                        return new _CellOverflowLayoutBuilder(sheet, rowViewportIndex, colViewportIndex);
	                    });
	                    self._buildCellOverflowValueLayout(layoutBuilder, paintingCells, border);
	                }
	                self._paintCells(ctx, paintingCells, sheetArea, isPrinting);
	            }
	            Worksheet._callFeatureHandler(sheet, 'paintViewport', {
	                ctx: ctx,
	                rowViewportIndex: rowViewportIndex,
	                colViewportIndex: colViewportIndex,
	                sheetArea: sheetArea,
	                clipRect: clipRect,
	                isPrinting: isPrinting
	            });
	           
	            border.paint(ctx, clipRect);
	           
	            if (doubleGridLinesInfo.length > 0) {
	                self._paintDoubleGridLines(ctx, doubleGridLinesInfo, 1, 3);
	            }
	           
	            if (validationUIModel.length > 0) {
	                self._paintValidationUI(ctx, validationUIModel);
	            }
	            ctx.restore();
	        },
	        _paintDoubleGridLines: function (ctx, doubleGridLinesInfo, lineWidth, lineDistance) {
	            if (doubleGridLinesInfo.length === 0) {
	                return;
	            }
	            for (var i = 0, length = doubleGridLinesInfo.length; i < length; i++) {
	                var lineInfo = doubleGridLinesInfo[i];
	                var x1 = lineInfo.x1, y1 = lineInfo.y1, x2 = lineInfo.x2, y2 = lineInfo.y2,
	                    horizontal = lineInfo.horizontal;
	                ctx.beginPath();
	                ctx.save();
	                ctx.lineWidth = lineWidth;
	                ctx.strokeStyle = this._getHeaderGridLineColor(ctx, horizontal, x1, y1, x2, y2);
	                ctx.fillStyle = this._getHeaderBackColor(ctx, horizontal, x1, y1, x2, y2);
	                if (horizontal) {
	                    var topYOffset = -3, bottomYOffset = 1, x1Offset = -1, x2Offset = -2;
	                   
	                    ctx.fillRect(x1, y1 + topYOffset, x2 - x1 - 1, lineDistance + 2 * lineWidth);
	                    CanvasHelper._translate(ctx, 0.5, 0.5);
	                   
	                    ctx.moveTo(x1 + x1Offset, y1 + topYOffset);
	                    ctx.lineTo(x2 + x2Offset, y2 + topYOffset);
	                   
	                    ctx.moveTo(x1 + x1Offset, y1 + bottomYOffset);
	                    ctx.lineTo(x2 + x2Offset, y2 + bottomYOffset);
	                } else {
	                    var leftXOffset = -3, rightXOffset = 1, y1Offset = 0, y2Offset = -1;
	                   
	                    ctx.fillRect(x1 + leftXOffset, y1 + y1Offset, lineDistance + 2 * lineWidth, y2 - y1 - 1);
	                    CanvasHelper._translate(ctx, 0.5, 0.5);
	                   
	                    ctx.moveTo(x1 + leftXOffset, y1 + y1Offset);
	                    ctx.lineTo(x2 + leftXOffset, y2 + y2Offset);
	                   
	                    ctx.moveTo(x1 + rightXOffset, y1 + y1Offset);
	                    ctx.lineTo(x2 + rightXOffset, y2 + y2Offset);
	                }
	                CanvasHelper._translate(ctx, -0.5, -0.5);
	                ctx.stroke();
	                ctx.restore();
	            }
	        },
	        _getHeaderBackColor: function (ctx, horizontal, x1, y1, x2, y2) {
	            var headerBackColor;
	            var headerTypeString = horizontal ? STR_ROW_HEADER : STR_COLUMN_HEADER;
	            var themeStyle = _ThemeStyleHelper._getVisualStateThemeStyle(0 , 'gc-' + headerTypeString + '-normal');
	            var backColor = themeStyle && themeStyle.backgroundColor,
	                backgroundImg = themeStyle && themeStyle.backgroundImage;
	            if (!horizontal && backgroundImg && backgroundImg.indexOf('linear-gradient') !== -1) {
	                var colors = util_common_util._getLinearGradientColors(backgroundImg);
	                headerBackColor = ctx.createLinearGradient(x1, y1, x2, y2);
	                for (var i = 0, len = colors.length; i < len; i++) {
	                    var color1 = colors[i];
	                    headerBackColor.addColorStop(color1.point, color1.color);
	                }
	            } else if (backColor) {
	                headerBackColor = backColor;
	            }
	            return headerBackColor;
	        },
	        _getHeaderGridLineColor: function (ctx, horizontal, x1, y1, x2, y2) {
	            var headerGridLineColor = ctx.createLinearGradient(x1, y1, x2, y2);
	            var headerTypeString = horizontal ? STR_ROW_HEADER : STR_COLUMN_HEADER;
	            var themeStyle = _ThemeStyleHelper._getVisualStateThemeStyle(0 , 'gc-' + headerTypeString + '-normal');
	            if (horizontal) {
	                headerGridLineColor.addColorStop(0, themeStyle.borderTopColor);
	                headerGridLineColor.addColorStop(1, themeStyle.borderBottomColor);
	            } else {
	                headerGridLineColor.addColorStop(0, themeStyle.borderLeftColor);
	                headerGridLineColor.addColorStop(1, themeStyle.borderRightColor);
	            }
	            return headerGridLineColor;
	        },
	        _paintValidationUI: function (ctx, validationUIModel) {
	            if (validationUIModel) {
	                var length = validationUIModel.length;
	                for (var i = 0; i < length; i++) {
	                    var circle = validationUIModel[i];
	                    var x = circle.x - 4, y = circle.y - 4, w = getWidth(circle) + 8, h = getHeight(circle) + 8;
	                    var kappa = 0.5522848, ox = w / 2 * kappa, oy = h / 2 * kappa, xe = x + w, ye = y + h,
	                        xm = x + w / 2, ym = y + h / 2;
	                    ctx.save();
	                    ctx.lineWidth = 2;
	                    ctx.strokeStyle = 'red';
	                    ctx.beginPath();
	                    ctx.moveTo(x, ym);
	                    ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
	                    ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
	                    ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
	                    ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
	                    ctx.closePath();
	                    ctx.stroke();
	                    ctx.restore();
	                }
	            }
	        },
	        _paintCells: function (ctx, cells, sheetArea, isPrinting) {
	            var self = this;
	            var sheet = self._sheet, isViewportArea = sheetArea === 3 , zoomFactor = sheet.zoom(),
	                defaultFontInfo = StyleHelper_scaleFont(self._getDefaultFont(), zoomFactor),
	                defaultStyle = sheet.getDefaultStyle(sheetArea),
	                defaultCellType = sheet._getDefaultCellType(sheetArea), conditionalFormats = sheet.conditionalFormats,
	                sheetBackColor = getSheetBackColor(sheet);
	
	            var rowHeaderLeftCol = sheet._getFirstVisualColumn(2 ),
	                colHeaderTopRow = sheet._getFirstVisualRow(1 );
	
	           
	            var imageLoader = sheet._getImageLoader();
	            ctx.save();
	            ctx.beginPath();
	           
	            ctx.fillStyle = defaultStyle && defaultStyle.foreColor || STR_BLACK;
	            setContextFont(ctx, defaultFontInfo.font);
	            ctx.textAlign = isViewportArea ? 'right' : 'center';
	
	            var i, k, count = cells.length, cell, cellType, data, row, col, x, y, width, height, style,
	                cellOverflowLayout,
	                richText,
	                visualState, fontInfo, lineHeight, sparkline, supportSparkline = !!getSparklineModule(),
	                overflowCells = [], overflowCell, options = {
	                    sheet: sheet,
	                    row: -1,
	                    col: -1,
	                    fontInfo: keyword_null,
	                    lineHeight: -1,
	                    imageLoader: imageLoader,
	                    conditionalFormats: conditionalFormats,
	                    sheetArea: sheetArea,
	                    parentBackColor: sheetBackColor
	                };
	            for (i = 0; i < count; i++) {
	                cell = cells[i];
	                data = cell.data;
	                row = cell.row;
	                col = cell.col;
	                x = cell.x;
	                y = cell.y;
	                width = getWidth(cell);
	                height = getHeight(cell);
	                style = cell.style;
	                cellOverflowLayout = cell.cellOverflowLayout;
	               
	                if (style.font) {
	                    fontInfo = StyleHelper_scaleFont(style.font, zoomFactor);
	                } else {
	                    fontInfo = defaultFontInfo;
	                }
	                style.font = fontInfo.font;
	                if (width > 0 && height > 0) {
	                    cellType = style.cellType || defaultCellType;
	                    x--;
	                    y--;
	                   
	                   
	                    width++;
	                    height++;
	                    if (isViewportArea) {
	                        sparkline = supportSparkline && sheet.getSparkline(row, col);
	                        options.sparkline = sparkline;
	                    } else {
	                        if (isPrinting) {
	                            visualState = 0 ;
	                        } else {
	                            visualState = self._getVisualState(row, col, sheetArea);
	                        }
	                        options.visualState = visualState;
	                    }
	                   
	                   
	                   
	                   
	                    lineHeight = getFontHeight(fontInfo.font);
	                   
	                    options.lineHeight = lineHeight;
	                   
	                    options.row = row;
	                    options.col = col;
	                    options.fontInfo = fontInfo;
	                    options.cellOverflowLayout = cellOverflowLayout;
	                    options.needTopGridline = (sheetArea === 1  && row === colHeaderTopRow || sheetArea === 0 );
	                    options.needLeftGridline = (sheetArea === 2  && col === rowHeaderLeftCol || sheetArea === 0 );
	                    cellType.paint(ctx, data, x, y, width, height, style, options);
	                    if (cellOverflowLayout && !options.showBarIconOnly) {
	                        var cellRect = new util_common.Rect(x, y, width, height);
	                        var contentRect = cellType._getContentRectImp ? cellType._getContentRectImp(ctx, cellRect, style, options) : cellRect;
	                        overflowCells.push({
	                            cellType: cellType,
	                            data: data,
	                            x: contentRect.x,
	                            y: contentRect.y,
	                            width: contentRect.width,
	                            height: contentRect.height,
	                            style: style,
	                            richText: richText,
	                            options: {
	                                sheet: sheet,
	                                row: row,
	                                col: col,
	                                fontInfo: fontInfo,
	                                lineHeight: lineHeight,
	                                cellOverflowLayout: cellOverflowLayout,
	                                parentBackColor: sheetBackColor,
	                                imageLoader: imageLoader
	                            }
	                        });
	                    }
	                }
	            }
	           
	            count = overflowCells.length;
	            if (count > 0) {
	                var isEditing = sheet.isEditing(), activeRow = sheet._activeRowIndex, activeCol = sheet._activeColIndex;
	                for (k = 0; k < count; k++) {
	                    overflowCell = overflowCells[k];
	                    data = overflowCell.data;
	                    options = overflowCell.options;
	                   
	                    if (isEditing && options.row === activeRow && options.col === activeCol) {
	                        continue;
	                    }
	                    var Sparkline = getSparklineModule();
	                    if (Sparkline && (data && data.typeName === 'SparklineExValue')) {
	                        continue;
	                    }
	                   
	                    self._paintPaddingValueForOverflow(ctx, overflowCell);
	                }
	            }
	            ctx.restore();
	
	            for (i = 0, count = cells.length; i < count; i++) {
	                cell = cells[i];
	                Worksheet._callFeatureHandler(sheet, 'paintCell', {
	                    ctx: ctx,
	                    sheetArea: sheetArea,
	                    cell: cell,
	                    isPrinting: isPrinting
	                });
	            }
	        },
	        _paintPaddingValueForOverflow: function (ctx, overflowCell) {
	            var cellType = overflowCell.cellType, data = overflowCell.data, x = overflowCell.x, y = overflowCell.y,
	                width = getWidth(overflowCell), height = getHeight(overflowCell), style = overflowCell.style,
	                options = overflowCell.options;
	
	            if (cellType._paintPadding) {
	                var cellOverflowlayout = options.cellOverflowLayout,
	                    layout = (cellOverflowlayout && cellOverflowlayout.layout);
	                var rect = new Rect(layout ? layout.x : x, layout ? layout.y : y, layout ? layout.width : width, layout ? layout.height : height);
	                cellType._paintPadding(ctx, rect, style, options, data);
	            }
	            if (cellType.paintValue) {
	                cellType.paintValue(ctx, data, x, y, width, height, style, options);
	            }
	        },
	        _getVisualState: function (row, col, sheetArea) {
	            var sheet = this._sheet;
	            var visualState = 0 ;
	            if (needPaintSelection(sheet)) {
	               
	                if (sheetArea === 3  || isNullOrUndefined(sheetArea)) {
	                    if (!sheet.isEditing() && sheet._isActiveCell(row, col)) {
	                        visualState = 3 ;
	                    } else if (sheet._isSelected(row, col, sheetArea)) {
	                        visualState = 2 ;
	                    }
	                } else {
	                    if (sheet._isSelected(row, col, sheetArea)) {
	                        visualState = 1 ;
	                        if (sheet._isAllSelected(row, col, sheetArea)) {
	                            visualState = 2 ;
	                        }
	                    }
	                    if (sheet._isHover(row, col, sheetArea)) {
	                        visualState = 4 ;
	                    }
	                }
	            }
	            return visualState;
	        },
	        _buildCellOverflowValueLayout: function (layoutBuilder, paintingCells, border) {
	            var sheet = this._sheet, cachePool = sheet._cachePool, count = paintingCells.length, cell, data, style, row,
	                col,
	                x, y, width, height, backgroundWidth, textX, newX, newCell, overflowLayoutModel, headingOverflowLayout,
	                trailingOverflowLayout, overflowLayout;
	            var processed = {};
	            var removeIndexes = [];
	            for (var i = 0; i < count; i++) {
	                cell = paintingCells[i];
	                row = cell.row;
	                col = cell.col;
	                x = cell.x;
	                y = cell.y;
	                height = getHeight(cell);
	                overflowLayoutModel = layoutBuilder._getCellOverflowLayoutModel(row);
	                headingOverflowLayout = overflowLayoutModel.headingOverflowlayout;
	                trailingOverflowLayout = overflowLayoutModel.trailingOverflowLayout;
	                if (!processed[row]) {
	                    var rowProcessed = {};
	                    for (var index = 0; index < overflowLayoutModel.length; index++) {
	                        rowProcessed[overflowLayoutModel[index].column] = false;
	                    }
	                    if (headingOverflowLayout) {
	                        rowProcessed[headingOverflowLayout.column] = false;
	                    }
	                    if (trailingOverflowLayout) {
	                        rowProcessed[trailingOverflowLayout.column] = false;
	                    }
	                    processed[row] = rowProcessed;
	                }
	                var overflowRowProcessed = processed[row];
	                overflowLayout = overflowLayoutModel.find(col);
	                if (overflowLayout) {
	                    if (overflowLayout.column === col) {
	                        width = getWidth(cell);
	                        backgroundWidth = overflowLayout.backgroundWidth;
	                        if (overflowLayout.backgroundLeftWidth < 0) {
	                            textX = x;
	                        } else if (overflowLayout.backgroundRightWidth < 0) {
	                            textX = x + width - backgroundWidth;
	                        } else {
	                            textX = x + width / 2 - overflowLayout.backgroundLeftWidth;
	                        }
	                        cell.cellOverflowLayout = overflowLayout;
	                        if (overflowRowProcessed[overflowLayout.column]) {
	                            removeIndexes.push(i);
	                        }
	                    } else if (!overflowRowProcessed[overflowLayout.column]) {
	                        col = overflowLayout.column;
	                        style = cachePool._getActualStyle(row, col);
	                        data = sheet.getValue(row, col);
	                        width = overflowLayout.columnWidth;
	                        backgroundWidth = overflowLayout.backgroundWidth;
	                        var columnCellRect = sheet.getCellRect(row, overflowLayout.column);
	                        if (overflowLayout.backgroundLeftWidth < 0) {
	                            textX = columnCellRect.x;
	                        } else if (overflowLayout.backgroundRightWidth < 0) {
	                            textX = columnCellRect.x + getWidth(columnCellRect) - backgroundWidth;
	                        } else {
	                            textX = columnCellRect.x + getWidth(columnCellRect) / 2 - overflowLayout.backgroundLeftWidth;
	                        }
	                        newCell = {
	                            data: data,
	                            row: row,
	                            col: col,
	                            x: columnCellRect.x,
	                            y: y,
	                            width: width,
	                            height: height,
	                            style: style,
	                            cellOverflowLayout: overflowLayout
	                        };
	                        paintingCells.push(newCell);
	                    }
	                    overflowLayout.layout = new Rect(textX, y, backgroundWidth, height);
	                    border._addCellOverlfowLayout(row, overflowLayout);
	                    overflowRowProcessed[overflowLayout.column] = true;
	                } else if (headingOverflowLayout && !overflowRowProcessed[headingOverflowLayout.column] && headingOverflowLayout.contains(col)) {
	                    col = headingOverflowLayout.column;
	                    style = cachePool._getActualStyle(row, col);
	                    data = sheet.getValue(row, col);
	                    width = headingOverflowLayout.columnWidth;
	                    backgroundWidth = headingOverflowLayout.backgroundWidth;
	                    var endColumnCellRect = sheet.getCellRect(row, headingOverflowLayout.endColumn);
	                    textX = endColumnCellRect.x + getWidth(endColumnCellRect) - backgroundWidth;
	                    newCell = {
	                        data: data,
	                        row: row,
	                        col: col,
	                        x: textX,
	                        y: y,
	                        width: width,
	                        height: height,
	                        style: style,
	                        cellOverflowLayout: headingOverflowLayout
	                    };
	                    paintingCells.push(newCell);
	                    headingOverflowLayout.layout = new Rect(textX, y, backgroundWidth, height);
	                    border._addCellOverlfowLayout(row, headingOverflowLayout);
	                    overflowRowProcessed[headingOverflowLayout.column] = true;
	                } else if (trailingOverflowLayout && !overflowRowProcessed[trailingOverflowLayout.column] && trailingOverflowLayout.contains(col)) {
	                    col = trailingOverflowLayout.column;
	                    style = cachePool._getActualStyle(row, col);
	                    data = sheet.getValue(row, col);
	                    width = trailingOverflowLayout.columnWidth;
	                    backgroundWidth = trailingOverflowLayout.backgroundWidth;
	                    var startColumnCellRect = sheet.getCellRect(row, trailingOverflowLayout.startColumn);
	                    textX = startColumnCellRect.x;
	                    newX = startColumnCellRect.x + backgroundWidth - width;
	                    newCell = {
	                        data: data,
	                        row: row,
	                        col: col,
	                        x: newX,
	                        y: y,
	                        width: width,
	                        height: height,
	                        style: style,
	                        cellOverflowLayout: trailingOverflowLayout
	                    };
	                    paintingCells.push(newCell);
	                    trailingOverflowLayout.layout = new Rect(textX, y, backgroundWidth, height);
	                    border._addCellOverlfowLayout(row, trailingOverflowLayout);
	                    overflowRowProcessed[trailingOverflowLayout.column] = true;
	                }
	            }
	            if (removeIndexes.length > 0) {
	                for (var j = removeIndexes.length - 1; j >= 0; j--) {
	                    paintingCells.splice(removeIndexes[j], 1);
	                }
	            }
	        }
	    };
	    exports._SheetRender = _SheetRender;
	   
	
	   
	    var TEXT_WIDTH_OFFSET = 2;
	    var MAX_CELLOVERFLOW_DISTANCE = 100;
	
	    function getCellPaddingOffset(cellPadding, zoomFactor) {
	        var offset = 0;
	        if (typeof cellPadding === 'string') {
	            var paddingArray = cellPadding.split(' ', 4), length = paddingArray.length;
	            if (length === 1) {
	                offset = parseIntFunc(paddingArray[0]) * 2;
	            } else if (length === 2 || length === 3) {
	                offset = parseIntFunc(paddingArray[1]) * 2;
	            } else if (length === 4) {
	                offset = parseIntFunc(paddingArray[1]) + parseIntFunc(paddingArray[3]);
	            }
	        }
	        return offset * zoomFactor;
	    }
	
	    function getCellWidth(data, text, style, defaultFont, sheet, row, col) {
	        var zoomFactor = sheet.zoom();
	        var font = style.font, textIndent = style.textIndent;
	        if (font) {
	            font = StyleHelper_scaleFont(font, zoomFactor).font;
	        } else {
	            font = defaultFont;
	        }
	        var textWidth = 0;
	        if (data && data.richText) {
	            textWidth = getHorizontalRichTextWidth(data.richText, font, zoomFactor);
	        } else {
	            textWidth = _WordWrapHelper._measureText(text, font);
	        }
	        textWidth += getIndentWidth(sheet, textIndent, row, col) + TEXT_WIDTH_OFFSET;
	        return textWidth + getCellPaddingOffset(style.cellPadding, zoomFactor);
	    }
	
	    function getHorizontalRichTextWidth(richText, defaultFont, zoomFactor) {
	        scaleFontByZoomFactor(richText, defaultFont, zoomFactor);
	        return _WordWrapHelper._getTextLengthInLine(richText, defaultFont, 1);
	    }
	
	    function scaleFontByZoomFactor (richText, defaultFont, zoomFactor) {
	        for (var i = 0; i < richText.length; i++) {
	            var font;
	            richText[i].style = richText[i].style || {};
	            var style = richText[i].style;
	            if (style.font) {
	                font = StyleHelper_scaleFont(style.font, zoomFactor).font;
	            } else {
	                font = defaultFont;
	            }
	            style.font = font;
	        }
	    }
	
	    function getIndentWidth(sheet, textIndent, row, col) {
	        if (!isNullOrUndefined(row) && !isNullOrUndefined(col) && sheet.outlineColumn) {
	            var width = sheet.outlineColumn._getWidth(row, col);
	            if (width) {
	                return width;
	            }
	        }
	        return textIndent ? textIndent * 8 : 0;
	    }
	
	    function buildCellOverflowLayoutModelForLeftOrRight(sheet, cellLayoutModel, defaultCellType, defaultFont, cellContext, row, col, deadCol, isLeft) {
	        var cachePool = sheet._cachePool,
	            colWidth = getWidth(cellContext), backgroundWidth = getWidth(cellContext), data,
	            style = cellContext.style, nextCol, text = cellContext.text, textWidth, nextStyle,
	            watermark = style.watermark;
	        if (cellLayoutModel.findCell(row, col)) {
	            return keyword_null;
	        }
	        var cellType = style.cellType || defaultCellType;
	        if (!cellType.allowOverflow || !text && !watermark) {
	            return keyword_null;
	        }
	        if (!text) {
	            text = watermark;
	        }
	        textWidth = getCellWidth(cellContext.data, text, style, defaultFont, sheet, row, col);
	        if (textWidth <= backgroundWidth) {
	            return keyword_null;
	        }
	       
	        var startCol = col, endCol = col;
	        for (nextCol = col + (isLeft ? 1 : -1); isLeft ? nextCol <= deadCol : nextCol >= deadCol; nextCol += isLeft ? 1 : -1) {
	            if (cellLayoutModel.findCell(row, nextCol)) {
	                break;
	            }
	            data = cachePool._getValue(row, nextCol);
	            if (!isNullOrUndefined(data)) {
	                break;
	            }
	            nextStyle = cachePool._getActualStyle(row, nextCol);
	            if (nextStyle.watermark) {
	                break;
	            }
	            if (isLeft) {
	                endCol = nextCol;
	            } else {
	                startCol = nextCol;
	            }
	            backgroundWidth += cachePool._getZoomColWidth(nextCol);
	            if (textWidth <= backgroundWidth) {
	                break;
	            }
	        }
	        if ((isLeft && endCol === col) || (!isLeft && startCol === col)) {
	            return keyword_null;
	        }
	        return new _CellOverflowLayout(col, startCol, endCol, textWidth, colWidth, backgroundWidth, isLeft ? -1 : backgroundWidth, isLeft ? backgroundWidth : -1);
	    }
	
	    function _CellOverflowLayoutBuilder(sheet, rowViewportIndex, colViewportIndex) {
	        var self = this;
	        self._sheet = sheet;
	        self._colLayoutModel = sheet._getColumnLayout(colViewportIndex);
	        self._cellLayoutModel = sheet._getCellLayout(rowViewportIndex, colViewportIndex);
	        self._defaultFont = StyleHelper_scaleFont(sheet._render._getDefaultFont(), sheet.zoom()).font;
	        self._defaultCellType = sheet._getDefaultCellType();
	        self._cachedCellOverflowModels = {};
	    }
	
	    _CellOverflowLayoutBuilder.prototype = {
	        constructor: _CellOverflowLayoutBuilder,
	        _getCellOverflowLayoutModel: function (row) {
	            var self = this;
	            var cache = self._cachedCellOverflowModels[row];
	            if (cache) {
	                return cache;
	            }
	            var sheet = self._sheet, cachePool = sheet._cachePool, colLayoutModel = self._colLayoutModel,
	                count = colLayoutModel.length,
	                colLayout, col, style, data, width, hAlign, text;
	            var cellOverflowLayoutModel = new _CellOverflowLayoutModel(), cellOverflowLayout;
	            if (count > 0) {
	               
	                cellOverflowLayoutModel.headingOverflowlayout = self._buildHeadingCellOverflowLayout(row);
	                var vpLeft = colLayoutModel[0].col, vpRight = colLayoutModel[count - 1].col;
	                for (var i = 0; i < count; i++) {
	                    colLayout = colLayoutModel[i];
	                    if (getWidth(colLayout) <= 0) {
	                        continue;
	                    }
	                    col = colLayout.col;
	                   
	                    data = cachePool._getValue(row, col, 3, 1);
	                    style = cachePool._getActualStyle(row, col);
	                    if (isNullOrUndefined(data) && !style.watermark) {
	                        continue;
	                    }
	                   
	                    if (style.shrinkToFit || style.wordWrap || style.isVerticalText) {
	                        continue;
	                    }
	
	                   
	                    var cfs = sheet.conditionalFormats;
	                    if (cfs) {
	                        var dataBarAndIconSet = cfs._getIconSetAndDataBar(sheet, row, col, data),
	                            dataBar = dataBarAndIconSet.dataBar, iconSet = dataBarAndIconSet.iconSet;
	                        if (dataBar && dataBar.showBarOnly || iconSet && iconSet.showIconOnly) {
	                            continue;
	                        }
	                    }
	
	                   
	                    width = cachePool._getZoomColWidth(col);
	                   
	                    text = _CacheMgr._getFormattedTextByStyle(sheet, style, data);
	                    hAlign = style.hAlign;
	                    if (hAlign === 3 ) {
	                        hAlign = getHAlignByValueType(hAlign, data, style.formatter);
	                    }
	                    if (hAlign === 0 ) {
	                        cellOverflowLayout = self._buildCellOverflowLayoutForLeft({
	                            data: data,
	                            style: style,
	                            width: width,
	                            text: text
	                        }, row, col, vpRight);
	                        if (cellOverflowLayout) {
	                            cellOverflowLayoutModel.push(cellOverflowLayout);
	                        }
	                    } else if (hAlign === 2 ) {
	                        cellOverflowLayout = self._buildCellOverflowLayoutForRight({
	                            data: data,
	                            style: style,
	                            width: width,
	                            text: text
	                        }, row, col, vpLeft);
	                        if (cellOverflowLayout) {
	                            cellOverflowLayoutModel.push(cellOverflowLayout);
	                        }
	                    } else if (hAlign === 1 ) {
	                        cellOverflowLayout = self._buildCellOverflowLayoutForCenter({
	                            data: data,
	                            style: style,
	                            width: width,
	                            text: text
	                        }, row, col, vpLeft, vpRight);
	                        if (cellOverflowLayout) {
	                            cellOverflowLayoutModel.push(cellOverflowLayout);
	                        }
	                    }
	                }
	               
	                cellOverflowLayoutModel.trailingOverflowLayout = self._buildTrailingCellOverflowLayout(row);
	            }
	           
	            self._cachedCellOverflowModels[row] = cellOverflowLayoutModel;
	            return cellOverflowLayoutModel;
	        },
	        _buildCellOverflowLayoutForLeft: function (cellContext, row, col, deadCol) {
	            var self = this;
	            return buildCellOverflowLayoutModelForLeftOrRight(self._sheet, self._cellLayoutModel, self._defaultCellType, self._defaultFont, cellContext, row, col, deadCol, true);
	        },
	        _buildCellOverflowLayoutForRight: function (cellContext, row, col, deadCol) {
	            var self = this;
	            return buildCellOverflowLayoutModelForLeftOrRight(self._sheet, self._cellLayoutModel, self._defaultCellType, self._defaultFont, cellContext, row, col, deadCol);
	        },
	        _buildCellOverflowLayoutForCenter: function (cellContext, row, col, leftDeadCol, rightDeadCol) {
	            var self = this;
	            var sheet = self._sheet, cachePool = sheet._cachePool, cellLayoutModel = self._cellLayoutModel,
	                colWidth = getWidth(cellContext), backgroundWidth = getWidth(cellContext), data,
	                style = cellContext.style, nextCol, text = cellContext.text, textWidth, nextStyle,
	                watermark = style.watermark;
	            if (cellLayoutModel.findCell(row, col)) {
	                return keyword_null;
	            }
	            var cellType = style.cellType || self._defaultCellType;
	            if (!cellType.allowOverflow || !text && !watermark) {
	                return keyword_null;
	            }
	            if (!text) {
	                text = watermark;
	            }
	            textWidth = getCellWidth(cellContext.data, text, style, self._defaultFont, sheet, row, col);
	
	            if (textWidth <= backgroundWidth) {
	                return keyword_null;
	            }
	           
	            var startCol = col, leftBackgroundWidth = backgroundWidth / 2;
	            for (nextCol = col - 1; nextCol >= leftDeadCol; nextCol--) {
	                if (cellLayoutModel.findCell(row, nextCol)) {
	                    break;
	                }
	                data = cachePool._getValue(row, nextCol);
	                if (!isNullOrUndefined(data)) {
	                    break;
	                }
	                nextStyle = cachePool._getActualStyle(row, nextCol);
	                if (nextStyle.watermark) {
	                    break;
	                }
	                startCol = nextCol;
	                leftBackgroundWidth += cachePool._getZoomColWidth(nextCol);
	                if (textWidth / 2 <= leftBackgroundWidth) {
	                    break;
	                }
	            }
	           
	            var endCol = col, rightBackgroundWidth = backgroundWidth / 2;
	            for (nextCol = col + 1; nextCol <= rightDeadCol; nextCol++) {
	                if (cellLayoutModel.findCell(row, nextCol)) {
	                    break;
	                }
	                data = cachePool._getValue(row, nextCol);
	                if (!isNullOrUndefined(data)) {
	                    break;
	                }
	                endCol = nextCol;
	                rightBackgroundWidth += cachePool._getZoomColWidth(nextCol);
	                if (textWidth / 2 <= rightBackgroundWidth) {
	                    break;
	                }
	            }
	            if (startCol === endCol) {
	                return keyword_null;
	            }
	            return new _CellOverflowLayout(col, startCol, endCol, textWidth, colWidth, leftBackgroundWidth + rightBackgroundWidth, leftBackgroundWidth, rightBackgroundWidth);
	        },
	        _buildHeadingCellOverflowLayout: function (row) {
	            var self = this;
	            var sheet = self._sheet, cachePool = sheet._cachePool, colLayoutModel = self._colLayoutModel,
	                vpLeft = colLayoutModel[0].col, vpRight = colLayoutModel[colLayoutModel.length - 1].col,
	                modelManager = sheet._modelManager, style, data, width, hAlign,
	                maxFindCount = MAX_CELLOVERFLOW_DISTANCE,
	                col = vpLeft, nextCol, ret, text, cellContext;
	            for (var i = 1; i < maxFindCount; i++) {
	                nextCol = col - i;
	                if (nextCol < 0) {
	                    return keyword_null;
	                }
	                if (modelManager.findSpan(row, nextCol)) {
	                    return keyword_null;
	                }
	               
	                data = cachePool._getValue(row, nextCol);
	               
	                width = cachePool._getZoomColWidth(nextCol);
	                if (width > 0 && !isNullOrUndefined(data)) {
	                    style = cachePool._getActualStyle(row, nextCol);
	                    hAlign = style.hAlign;
	                    if (hAlign === 3 ) {
	                        hAlign = getHAlignByValueType(hAlign, data);
	                    }
	
	                    text = _CacheMgr._getFormattedTextByStyle(sheet, style, data);
	                    cellContext = {
	                        data: data,
	                        style: style,
	                        width: width,
	                        text: text
	                    };
	                    if (hAlign === 0 ) {
	                        ret = self._buildCellOverflowLayoutForLeft(cellContext, row, nextCol, vpRight);
	                    } else if (hAlign === 1 ) {
	                        ret = self._buildCellOverflowLayoutForCenter(cellContext, row, nextCol, vpLeft, vpRight);
	                    }
	                    if (ret && ret.endColumn >= vpLeft) {
	                        return ret;
	                    }
	                    return keyword_null;
	                }
	            }
	        },
	        _buildTrailingCellOverflowLayout: function (row) {
	            var self = this;
	            var sheet = self._sheet, cachePool = sheet._cachePool, colLayoutModel = self._colLayoutModel,
	                vpLeft = colLayoutModel[0].col, vpRight = colLayoutModel[colLayoutModel.length - 1].col,
	                modelManager = sheet._modelManager, style, data, width, hAlign,
	                maxFindCount = MAX_CELLOVERFLOW_DISTANCE,
	                colCount = sheet.getColumnCount(), col = vpRight, nextCol, ret, text, cellContext;
	            for (var i = 1; i < maxFindCount; i++) {
	                nextCol = col + i;
	                if (nextCol >= colCount) {
	                    return keyword_null;
	                }
	                if (modelManager.findSpan(row, nextCol)) {
	                    return keyword_null;
	                }
	               
	                data = cachePool._getValue(row, nextCol);
	               
	                width = cachePool._getZoomColWidth(nextCol);
	                if (width > 0 && !isNullOrUndefined(data)) {
	                    style = cachePool._getActualStyle(row, nextCol);
	                    hAlign = style.hAlign;
	                    if (hAlign === 3 ) {
	                        hAlign = getHAlignByValueType(hAlign, data);
	                    }
	
	                    text = _CacheMgr._getFormattedTextByStyle(sheet, style, data);
	                    cellContext = {
	                        data: data,
	                        style: style,
	                        width: width,
	                        text: text
	                    };
	                    if (hAlign === 2 ) {
	                        ret = self._buildCellOverflowLayoutForRight(cellContext, row, nextCol, vpLeft);
	                    } else if (hAlign === 1 ) {
	                        ret = self._buildCellOverflowLayoutForCenter(cellContext, row, nextCol, vpLeft, vpRight);
	                    }
	                    if (ret && ret.startColumn <= vpRight) {
	                        return ret;
	                    }
	                    return keyword_null;
	                }
	            }
	        }
	    };
	    exports._CellOverflowLayoutBuilder = _CellOverflowLayoutBuilder;
	   
	
	   
	    var CUTCOPYINDICATOR_EVENT_NS = '.cutCopyIndicator';
	    var Events_CellChanged = Events.CellChanged, Events_ClipboardChanged = Events.ClipboardChanged,
	        Events_ValueChanged = Events.ValueChanged, Events_ColumnChanged = Events.ColumnChanged,
	        Events_RowChanged = Events.RowChanged, Events_RangeChanged = Events.RangeChanged,
	        Events_ClipboardPasting = Events.ClipboardPasting, Events_ClipboardPasted = Events.ClipboardPasted,
	        Events_DragMerging = Events.DragMerging, Events_FloatingElementSelected = Events.FloatingElementSelected;
	
	    function _CutCopyIndicatorManager(sheet) {
	        var self = this;
	        self._needPaint = false;
	        self._pasteInternal = false;
	        self._sheet = sheet;
	        self._bindEvents();
	    }
	
	    _CutCopyIndicatorManager.prototype = {
	        constructor: _CutCopyIndicatorManager,
	
	        _isPastedInternal: function (value) {
	            var self = this;
	            if (arguments.length === 0) {
	                return self._pasteInternal;
	            }
	            self._pasteInternal = value;
	        },
	        _needPaintIndicator: function (value) {
	            var self = this;
	            if (arguments.length === 0) {
	                return self._needPaint;
	            }
	            if (self._needPaint !== value || value) {
	                self._needPaint = value;
	                var sheet = self._sheet;
	                if (sheet) {
	                    sheet._invalidate();
	                }
	            }
	        },
	        _bindEvents: function () {
	            var self = this, sheet = self._sheet, cacheNeedPaintIndicator = false;
	            var CONST_RESIZABLE = 'resizable', CONST_ISVISIBLE = 'isVisible';
	
	            function setNeedPaintFalseHandler() {
	                self._needPaintIndicator(false);
	            }
	
	            sheet._bind(Events_ClipboardChanged + CUTCOPYINDICATOR_EVENT_NS, function () {
	                self._needPaintIndicator(true);
	            });
	            sheet._bind(Events_ValueChanged + CUTCOPYINDICATOR_EVENT_NS, setNeedPaintFalseHandler);
	            sheet._bind(Events_CellChanged + CUTCOPYINDICATOR_EVENT_NS, setNeedPaintFalseHandler);
	            sheet._bind(Events_ColumnChanged + CUTCOPYINDICATOR_EVENT_NS, function (event, data) {
	                var propertyName = data.propertyName;
	                if (propertyName !== CONST_RESIZABLE && propertyName !== 'width' && propertyName !== CONST_ISVISIBLE) {
	                    setNeedPaintFalseHandler();
	                }
	            });
	            sheet._bind(Events_RowChanged + CUTCOPYINDICATOR_EVENT_NS, function (event, data) {
	                var propertyName = data.propertyName;
	                if (propertyName !== CONST_RESIZABLE && propertyName !== 'height' && propertyName !== CONST_ISVISIBLE) {
	                    setNeedPaintFalseHandler();
	                }
	            });
	            sheet._bind(Events_RangeChanged + CUTCOPYINDICATOR_EVENT_NS, setNeedPaintFalseHandler);
	            sheet._bind(Events_ClipboardPasting + CUTCOPYINDICATOR_EVENT_NS, function () {
	                cacheNeedPaintIndicator = self._needPaintIndicator();
	            });
	            sheet._bind(Events_ClipboardPasted + CUTCOPYINDICATOR_EVENT_NS, function (event, args) {
	                var cellRange = args.cellRange, ch = args.sheet._getClipboardHelper(), ranges = ch._ranges;
	                var needPaint = cacheNeedPaintIndicator;
	                if (cellRange && ranges && ch._fromSheet) {
	                    if (!self._isPastedInternal()) {
	                        needPaint = false;
	                    } else {
	                        for (var i = 0; i < ranges.length; i++) {
	                            if (ranges[i].intersect(cellRange.row, cellRange.col, cellRange.rowCount, cellRange.colCount)) {
	                                needPaint = false;
	                                break;
	                            }
	                        }
	                    }
	                    self._needPaintIndicator(needPaint);
	                }
	            });
	            sheet._bind(Events_DragMerging + CUTCOPYINDICATOR_EVENT_NS, setNeedPaintFalseHandler);
	            sheet._bind(Events_FloatingElementSelected + CUTCOPYINDICATOR_EVENT_NS, function (event, data) {
	                if (data.type !== 'worksheet') {
	                    sheet.endEdit();
	                    _FocusHelper._hideSelectionImp(sheet);
	                }
	            });
	        },
	        _paintCutCopyIndicator: function (ctx, clipRect, rowViewportIndex, colViewportIndex) {
	            var self = this;
	            if (self._needPaint) {
	                var sheet = self._sheet, render = sheet._render, workbook = sheet.parent,
	                    options = workbook ? workbook.options : {};
	                var ch = sheet._getClipboardHelper(), ranges = ch._ranges;
	                var visible = options.cutCopyIndicatorVisible;
	                if (isNullOrUndefined(visible)) {
	                    visible = true;
	                }
	                var color = _ThemeContext._getColor(sheet, options.cutCopyIndicatorBorderColor || 'blue');
	                if (visible && ch._fromSheet === sheet && ranges) {
	                    var layout = sheet._getSheetLayout(),
	                        viewportRect = layout._viewportRect(rowViewportIndex, colViewportIndex),
	                        indicatorRects = render._getPaintingRects(rowViewportIndex, colViewportIndex, ranges, clipRect);
	                    if (indicatorRects && viewportRect) {
	                        ctx.save();
	                        ctx.rect(viewportRect.x, viewportRect.y, getWidth(viewportRect), getHeight(viewportRect));
	                        ctx.clip();
	                        for (var i = 0; i < indicatorRects.length; i++) {
	                            render._paintDashRect(ctx, indicatorRects[i], color);
	                        }
	                        ctx.beginPath();
	                        ctx.restore();
	                    }
	                }
	            }
	        },
	        _onRowsAdded: function () {
	            this._needPaintIndicator(false);
	        },
	        _onRowsDeleted: function () {
	            this._needPaintIndicator(false);
	        },
	        _onColumnsAdded: function () {
	            this._needPaintIndicator(false);
	        },
	        _onColumnsDeleted: function () {
	            this._needPaintIndicator(false);
	        },
	        _cancelIndicator: function () {
	            this._needPaintIndicator(false);
	        },
	        _dispose: function () {
	            var sheet = this._sheet;
	            sheet._unbind(Events_CellChanged + CUTCOPYINDICATOR_EVENT_NS);
	            sheet._unbind(Events_ClipboardChanged + CUTCOPYINDICATOR_EVENT_NS);
	            sheet._unbind(Events_ValueChanged + CUTCOPYINDICATOR_EVENT_NS);
	            sheet._unbind(Events_ColumnChanged + CUTCOPYINDICATOR_EVENT_NS);
	            sheet._unbind(Events_RowChanged + CUTCOPYINDICATOR_EVENT_NS);
	            sheet._unbind(Events_RangeChanged + CUTCOPYINDICATOR_EVENT_NS);
	            sheet._unbind(Events_ClipboardPasting + CUTCOPYINDICATOR_EVENT_NS);
	            sheet._unbind(Events_ClipboardPasted + CUTCOPYINDICATOR_EVENT_NS);
	            sheet._unbind(Events_DragMerging + CUTCOPYINDICATOR_EVENT_NS);
	            sheet._unbind(Events_FloatingElementSelected + CUTCOPYINDICATOR_EVENT_NS);
	        }
	    };
	    exports._CutCopyIndicatorManager = _CutCopyIndicatorManager;
	   
	
	    module.exports = exports;
	
	}());

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var exports = __webpack_require__(1),
	        Worksheet = __webpack_require__(17).Worksheet,
	        util_common = __webpack_require__(3),
	        Common = __webpack_require__(5),
	        $ = __webpack_require__(4).GC$;
	
	    var createRange = util_common._createRange,
	        _ThemeStyleHelper = util_common._ThemeStyleHelper,
	        _FocusHelper = util_common._FocusHelper,
	        isNullOrUndefined = Common._Types._isNullOrUndefined,
	        _ArrayHelper_getLength = Common._ArrayHelper._getLength;
	
	    var keyword_null = null, Math_max = Math.max, Math_min = Math.min,
	        GC_SELECTION = 'gc-selection';
	
	    function getSheetColumnCount(sheet, sheetArea) {
	        return sheet.getColumnCount(sheetArea);
	    }
	
	    function getSheetRowCount(sheet, sheetArea) {
	        return sheet.getRowCount(sheetArea);
	    }
	
	    function getRowCount(obj) {
	        return obj.rowCount;
	    }
	
	    function getColCount(obj) {
	        return obj.colCount;
	    }
	
	   
	    
	    exports.SelectionPolicy = {
	        
	        single: 0,
	        
	        range: 1,
	        
	        multiRange: 2
	    };
	
	   
	    
	    exports.SelectionUnit = {
	        
	        cell: 0,
	        
	        row: 1,
	        
	        column: 2
	    };
	
	   
	   
	   
	   
	   
	
	   
	    $.extend(Worksheet.prototype, {
	       
	        
	        addSelection: function (row, column, rowCount, columnCount) {
	            var self = this;
	           
	            var r = row;
	            var c = column;
	            var rc = rowCount;
	            var cc = columnCount;
	            if (r !== -1 && c !== -1) {
	                var spans = self._modelManager.getSpans();
	                if (spans && _ArrayHelper_getLength(spans) > 0) {
	                    var newSelection = self._cellRangeInflate(spans, createRange(row, column, rowCount, columnCount));
	                    r = newSelection.row;
	                    c = newSelection.col;
	                    rc = getRowCount(newSelection);
	                    cc = getColCount(newSelection);
	                }
	            }
	            self._modelManager.do('addSelection', r, c, rc, cc);
	            self._invalidate();
	        },
	       
	        
	        setSelection: function (row, column, rowCount, columnCount) {
	           
	            this._setSelectionImp(row, column, rowCount, columnCount, 2 );
	        },
	        _setSelectionImp: function (row, column, rowCount, columnCount, focusPolicy) {
	            var self = this;
	            var sheetRowCount = getSheetRowCount(self);
	            var sheetColCount = getSheetColumnCount(self);
	            if (row >= sheetRowCount) {
	                row = sheetRowCount - 1;
	            }
	            if (column >= sheetColCount) {
	                column = sheetColCount - 1;
	            }
	            var activeRow = Math_max(0, row);
	            var activeCol = Math_max(0, column);
	            self._clearSelectionImp();
	           
	            var setFocus = (focusPolicy === 2 ) ? _FocusHelper._isActiveElement(self) : focusPolicy === 1;
	            self._setActiveCellImp(activeRow, activeCol, self._getRowViewportIndex(activeRow), self._getColumnViewportIndex(activeCol), !setFocus);
	            self.addSelection(row, column, rowCount, columnCount);
	        },
	       
	        
	        getSelections: function () {
	            return this._modelManager.getSelections();
	        },
	       
	        
	        clearSelection: function () {
	            var self = this;
	            self._clearSelectionImp();
	            self._setActiveCellImp(0, 0);
	            Worksheet._callFeatureHandler(self, 'clearSelection');
	            self._invalidate();
	        },
	        _clearSelectionImp: function () {
	            this._modelManager.do('clearSelection');
	        },
	        _canSelect: function (row, column, style) {
	            var self = this, options = self.options, protectionOptions = options.protectionOptions;
	            var allowLocked = protectionOptions.allowSelectLockedCells !== false,
	                allowUnlocked = protectionOptions.allowSelectUnlockedCells !== false;
	            if (!options.isProtected || allowLocked && allowUnlocked) {
	                return true;
	            }
	            if (!allowLocked && !allowUnlocked) {
	                return false;
	            }
	           
	           
	           
	            var locked = style ? style.locked : self._getStyleProperty(row, column, 'locked');
	            var isFullRow = column < 0, isFullCol = row < 0;
	            if (allowLocked === locked && (isFullCol || isFullRow)) {
	                var rowCount = isFullCol ? getSheetRowCount(self) : 1;
	                row = isFullCol ? 0 : row;
	                var colCount = isFullRow ? getSheetColumnCount(self) : 1;
	                column = isFullRow ? 0 : column;
	                var modelManager = self._modelManager, lastRow = row + rowCount - 1, lastCol = column + colCount - 1;
	                var r, c;
	                for (r = row; r <= lastRow; r++) {
	                    for (c = column; c <= lastCol; c++) {
	                        style = modelManager.getStyle(r, c);
	                        if (style && allowLocked !== style.locked) {
	                            return false;
	                        }
	                    }
	                }
	                if (isFullCol) {
	                    for (r = row; r <= lastRow; r++) {
	                        style = modelManager.getStyle(r, -1);
	                        if (style && allowLocked !== style.locked) {
	                            return false;
	                        }
	                    }
	                }
	                if (isFullRow) {
	                    for (c = column; c <= lastCol; c++) {
	                        style = modelManager.getStyle(-1, c);
	                        if (style && allowLocked !== style.locked) {
	                            return false;
	                        }
	                    }
	                }
	            }
	            return allowLocked === locked;
	        },
	        _containsLockedCellsInSelection: function (row, column, rowCount, columnCount) {
	            var self = this;
	            row = row < 0 ? 0 : row;
	            column = column < 0 ? 0 : column;
	            for (var i = row; i < row + rowCount; i++) {
	                for (var j = column; j < column + columnCount; j++) {
	                    if (self._getStyleProperty(i, j, 'locked')) {
	                        return true;
	                    }
	                }
	            }
	        },
	        _isFullRows: function () {
	            var selections = this.getSelections();
	            for (var i = 0; i < selections.length; i++) {
	                if (selections[i].col !== -1) {
	                    return false;
	                }
	            }
	            return true;
	        },
	        _isFullCols: function () {
	            var selections = this.getSelections();
	            for (var i = 0; i < selections.length; i++) {
	                if (selections[i].row !== -1) {
	                    return false;
	                }
	            }
	            return true;
	        },
	       
	        
	        selectionPolicy: function (value) {
	            var self = this, modelManager = self._modelManager;
	            if (arguments.length === 0) {
	                return modelManager.getSelectionPolicy();
	            }
	            modelManager.do('setSelectionPolicy', value);
	            return self;
	        },
	       
	        
	        selectionUnit: function (value) {
	            var self = this, modelManager = self._modelManager;
	            if (arguments.length === 0) {
	                return modelManager.getSelectionUnit();
	            }
	            modelManager.do('setSelectionUnit', value);
	            return self;
	        },
	        getSelectionBackColor: function () {
	            return this.options.selectionBackColor || _ThemeStyleHelper._getCssClassThemeStyle(GC_SELECTION).backgroundColor;
	        },
	        getSelectionBorderColor: function () {
	            return this.options.selectionBorderColor || _ThemeStyleHelper._getCssClassThemeStyle(GC_SELECTION).borderTopColor;
	        },
	        _selectionIndicatorColor: function (color) {
	            if(color) {
	                this.options._selectionIndicatorColor = color;
	            } else {
	                return this.options._selectionIndicatorColor;
	            }
	        },
	        _saveAndClearSheetSelections: function () {
	            var self = this;
	            var selections = self._modelManager.getSelections();
	            if (_ArrayHelper_getLength(selections) > 0) {
	                var selectionModelCache = {
	                    selections: selections
	                };
	                var activeSelectedRangeIndex = self._modelManager.getActiveSelectedRangeIndex();
	                if (activeSelectedRangeIndex !== 0) {
	                    selectionModelCache.activeSelectedRangeIndex = activeSelectedRangeIndex;
	                }
	                self._selectionModelCache = selectionModelCache;
	                self._clearSelectionImp();
	                self._render._repaintSelection();
	            }
	        },
	        _loadAndSetSheetSelections: function () {
	            var self = this, selectionModelCache = self._selectionModelCache,
	                selections = selectionModelCache && selectionModelCache.selections;
	            if (selections) {
	                self._modelManager.do('setSelections', selections);
	                self._modelManager.do('setActiveSelectedRangeIndex', selectionModelCache.activeSelectedRangeIndex || 0);
	            }
	        },
	        _moveActiveCellUp: function (row, col, wrap) {
	            var self = this;
	            var upCell = self._getMoveUpCell(row, col, wrap, self._leadingCellCol || 0);
	            if (upCell) {
	                var r = upCell.row, c = upCell.col, leadingCellCol = upCell.leadingCellCol;
	                if (self._canMoveCurrentTo(r, c)) {
	                    self._leadingCellRow = r;
	                    self._leadingCellCol = leadingCellCol;
	                    self._setActiveCellCore(r, c);
	                }
	            }
	        },
	        _getMoveUpCell: function (row, col, wrap, leadingCellCol) {
	            var self = this;
	            var rowCount = getSheetRowCount(self);
	            var colCount = getSheetColumnCount(self);
	            var r = row, c;
	            if (r === 0 && !wrap || !(rowCount !== 0 && colCount !== 0)) {
	                return keyword_null;
	            }
	            var cell = self._getPrevRow(r, leadingCellCol);
	            if (!wrap) {
	                self._adjustCell(cell);
	            }
	            r = cell.r;
	            c = cell.c;
	            if (r < 0 && wrap) {
	                c = self._getPrevVisualColumn(c);
	                if (c < 0 || isNullOrUndefined(c)) {
	                    c = self._getPrevVisualColumn(colCount);
	                }
	                leadingCellCol = c;
	                cell = self._getPrevRow(rowCount, c);
	                r = cell.r;
	                c = cell.c;
	               
	                if (c === col && r <= row) {
	                    return keyword_null;
	                }
	            }
	            return {row: r, col: c, leadingCellCol: leadingCellCol};
	        },
	        _moveActiveCellDown: function (row, col, wrap) {
	            var self = this;
	            var downCell = self._getMoveDownCell(row, col, wrap, self._leadingCellCol || 0);
	            if (downCell && (downCell.row !== row || downCell.col !== col)) {
	                var r = downCell.row, c = downCell.col, leadingCellCol = downCell.leadingCellCol;
	                if (self._canMoveCurrentTo(r, c)) {
	                    self._leadingCellRow = r;
	                    self._leadingCellCol = leadingCellCol;
	                    self._setActiveCellCore(r, c);
	                }
	            }
	        },
	        _getMoveDownCell: function (row, col, wrap, leadingCellCol) {
	            var self = this;
	            var rowCount = getSheetRowCount(self);
	            var colCount = getSheetColumnCount(self);
	            var r = row, c;
	            if (r === rowCount - 1 && !wrap || !(rowCount !== 0 && colCount !== 0)) {
	                return;
	            }
	            var cell = self._getNextRow(r, leadingCellCol);
	            if (!wrap) {
	                self._adjustCell(cell);
	            }
	            r = cell.r;
	            c = cell.c;
	            if (r === rowCount && wrap) {
	                c = self._getNextVisualColumn(c);
	                if (c >= colCount || isNullOrUndefined(c)) {
	                    c = self._getNextVisualColumn(-1);
	                }
	                leadingCellCol = c;
	                cell = self._getNextRow(-1, c);
	                r = cell.r;
	                c = cell.c;
	               
	                if (c === col && r >= row) {
	                    return;
	                }
	            }
	            return {row: r, col: c, leadingCellCol: leadingCellCol};
	        },
	        _moveActiveCellLast: function () {
	            var self = this;
	            var lastCell = self._getMoveLastCell();
	            if (lastCell) {
	                var r = lastCell.row, c = lastCell.col;
	                self._leadingCellRow = r;
	                self._leadingCellCol = c;
	                self._setActiveCellCore(r, c);
	            }
	        },
	        _getMoveLastCell: function () {
	            var self = this;
	            var r = self._getLastVisualRow(), lastCol = self._getLastVisualColumn(), c = lastCol;
	            if (!r && !c) {
	                return keyword_null;
	            }
	            var options = self.options, protectionOption = options.protectionOptions;
	            var allowLocked = protectionOption.allowSelectLockedCells !== false,
	                allowUnlocked = protectionOption.allowSelectUnlockedCells !== false;
	            if (!options.isProtected || allowLocked && allowUnlocked) {
	                return {row: r, col: c};
	            }
	            if (!allowLocked && !allowUnlocked) {
	                return keyword_null;
	            }
	            for (; r !== keyword_null && r >= 0; r = self._getPrevVisualRow(r)) {
	                for (c = lastCol; c !== keyword_null && c >= 0; c = self._getPrevVisualColumn(c)) {
	                   
	                   
	                   
	                    var locked = self._getStyleProperty(r, c, 'locked');
	                    if (allowLocked === locked) {
	                        return {row: r, col: c};
	                    }
	                }
	            }
	            return keyword_null;
	        },
	        _moveActiveCellFirst: function () {
	            var self = this;
	            var first = self._getMoveFirstCell();
	            if (first) {
	                var r = first.row, c = first.col;
	                self._leadingCellRow = r;
	                self._leadingCellCol = c;
	                self._setActiveCellCore(r, c);
	            }
	        },
	        _getMoveFirstCell: function () {
	            var self = this;
	            var r = self._getNextVisualRow(self.frozenRowCount() - 1),
	                firstCol = self._getNextVisualColumn(self.frozenColumnCount() - 1), c = firstCol,
	                lastRow = self._getLastVisualRow(), lastCol = self._getLastVisualColumn();
	            if (r === keyword_null || c === keyword_null) {
	                return keyword_null;
	            }
	            var options = self.options, protectionOption = options.protectionOptions;
	            var allowLocked = protectionOption.allowSelectLockedCells !== false,
	                allowUnlocked = protectionOption.allowSelectUnlockedCells !== false;
	            if (!options.isProtected || allowLocked && allowUnlocked) {
	                return {row: r, col: c};
	            }
	            if (!allowLocked && !allowUnlocked) {
	                return keyword_null;
	            }
	            for (; r !== keyword_null && r <= lastRow; r = self._getNextVisualRow(r)) {
	                for (c = firstCol; c !== keyword_null && c <= lastCol; c = self._getNextVisualColumn(c)) {
	                   
	                   
	                   
	                    var locked = self._getStyleProperty(r, c, 'locked');
	                    if (allowLocked === locked) {
	                        return {row: r, col: c};
	                    }
	                }
	            }
	            return keyword_null;
	        },
	        _moveActiveCellLeft: function (row, col, wrap) {
	            var self = this;
	            var leftCell = self._getMoveLeftCell(row, col, wrap, self._leadingCellRow || 0);
	            if (leftCell) {
	                var r = leftCell.row, c = leftCell.col, leadingCellRow = leftCell.leadingCellRow;
	                if (self._canMoveCurrentTo(r, c)) {
	                    self._leadingCellRow = leadingCellRow;
	                    self._leadingCellCol = c;
	                    self._setActiveCellCore(r, c);
	                }
	            }
	        },
	        _getMoveLeftCell: function (row, col, wrap, leadingCellRow) {
	            var self = this;
	            var rowCount = getSheetRowCount(self);
	            var colCount = getSheetColumnCount(self);
	            var r, c = col;
	            if (c === 0 && !wrap || !(rowCount !== 0 && colCount !== 0)) {
	                return keyword_null;
	            }
	            var cell = self._getPrevColumn(leadingCellRow, c), startLeadingCellRow = leadingCellRow;
	            if (!wrap) {
	                self._adjustCell(cell);
	            }
	            r = cell.r;
	            c = cell.c;
	            while (c < 0 && wrap) {
	                r = self._getPrevVisualRow(r, 3 , true);
	                if (r < 0 || isNullOrUndefined(r)) {
	                    r = self._getPrevVisualRow(rowCount, 3 , true);
	                }
	                leadingCellRow = r;
	                cell = self._getPrevColumn(leadingCellRow, colCount);
	                r = cell.r;
	                c = cell.c;
	                if (r === row && c < col) {
	                    return keyword_null;
	                } else if (r === row && c === col) {
	                    if (leadingCellRow === startLeadingCellRow) {
	                        return keyword_null;
	                    }
	                    cell = self._getPrevColumn(leadingCellRow, c);
	                    r = cell.r;
	                    c = cell.c;
	                }
	            }
	            return {row: r, col: c, leadingCellRow: leadingCellRow};
	        },
	        _adjustCell: function (cell) {
	            var self = this, adjusted = false;
	            if (cell.r < 0) {
	                cell.r = self._getFirstVisualRow();
	            } else if (cell.r >= getSheetRowCount(self)) {
	                cell.r = self._getLastVisualRow();
	                adjusted = true;
	            }
	            if (cell.c < 0) {
	                cell.c = self._getFirstVisualColumn();
	            } else if (cell.c >= getSheetColumnCount(self)) {
	                cell.c = self._getLastVisualColumn();
	                adjusted = true;
	            }
	            if (adjusted) {
	                var currentSpan = self._modelManager.getSpan(cell.r, cell.c);
	                if (currentSpan.row !== cell.r) {
	                    cell.r = currentSpan.row;
	                }
	                if (currentSpan.col !== cell.c) {
	                    cell.c = currentSpan.col;
	                }
	            }
	        },
	        _moveActiveCellLeftInSelection: function (row, col) {
	            var self = this;
	            var modelManager = self._modelManager, startRangeIndex = modelManager.getActiveSelectedRangeIndex(),
	                prevRangeIndex = -1;
	            var startRange = self._getActualRange(self._getActiveSelectedRange()), beginRow = startRange.row,
	                beginCol = startRange.col, endCol = startRange.col + getColCount(startRange) - 1;
	            var r = row, c = col, cell;
	            for (; ;) {
	                cell = self._getPrevColumnInSelection(r, c);
	                r = cell.r;
	                c = cell.c;
	                if (c >= beginCol) {
	                    break;
	                }
	               
	                if (prevRangeIndex === startRangeIndex && r === row && c <= col) {
	                    return;
	                }
	               
	                r--;
	                if (r >= beginRow) {
	                    c = endCol + 1;
	                } else {
	                    var prevRange = self._getActualRange(self._getActiveSelectedRange(3 ));
	                    prevRangeIndex = modelManager.getActiveSelectedRangeIndex();
	                    beginRow = prevRange.row;
	                    beginCol = prevRange.col;
	                    endCol = prevRange.col + getColCount(prevRange) - 1;
	                    r = prevRange.row + getRowCount(prevRange) - 1;
	                    c = prevRange.col + getColCount(prevRange);
	                }
	            }
	            if (r >= 0) {
	                self._setActiveCellCore(r, c);
	                self._leadingCellRow = r;
	                self._leadingCellCol = c;
	            }
	        },
	        _moveActiveCellRightInSelection: function (row, col) {
	            var self = this;
	            var modelManager = self._modelManager, startRangeIndex = modelManager.getActiveSelectedRangeIndex(),
	                nextRangeIndex = -1;
	            var startRange = self._getActualRange(self._getActiveSelectedRange()), beginCol = startRange.col,
	                endRow = startRange.row + getRowCount(startRange) - 1,
	                endCol = startRange.col + getColCount(startRange) - 1;
	            var r = row, c = col, cell;
	            for (; ;) {
	                cell = self._getNextColumnInSelection(r, c);
	                r = cell.r;
	                c = cell.c;
	                if (c <= endCol) {
	                    break;
	                }
	               
	                if (nextRangeIndex === startRangeIndex && r === row && c >= col) {
	                    return;
	                }
	               
	                r++;
	                if (r <= endRow) {
	                    c = beginCol - 1;
	                } else {
	                    var nextRange = self._getActualRange(self._getActiveSelectedRange(4 ));
	                    nextRangeIndex = modelManager.getActiveSelectedRangeIndex();
	                    beginCol = nextRange.col;
	                    endRow = nextRange.row + getRowCount(nextRange) - 1;
	                    endCol = nextRange.col + getColCount(nextRange) - 1;
	                    r = nextRange.row;
	                    c = nextRange.col - 1;
	                }
	            }
	            if (r >= 0) {
	                self._setActiveCellCore(r, c);
	                self._leadingCellRow = r;
	                self._leadingCellCol = c;
	            }
	        },
	        _moveActiveCellRight: function (row, col, wrap) {
	            var self = this;
	            var rightCell = self._getMoveRightCell(row, col, wrap, self._leadingCellRow || 0);
	            if (rightCell && (rightCell.row !== row || rightCell.col !== col)) {
	                var r = rightCell.row, c = rightCell.col, leadingCellRow = rightCell.leadingCellRow;
	                if (self._canMoveCurrentTo(r, c)) {
	                    self._leadingCellRow = leadingCellRow;
	                    self._leadingCellCol = c;
	                    self._setActiveCellCore(r, c);
	                }
	            }
	        },
	        _getMoveRightCell: function (row, col, wrap, leadingCellRow) {
	            var self = this;
	            var rowCount = getSheetRowCount(self);
	            var colCount = getSheetColumnCount(self);
	            var r, c = col;
	            if (c === colCount - 1 && !wrap || !(rowCount !== 0 && colCount !== 0)) {
	                return keyword_null;
	            }
	            var cell = self._getNextColumn(leadingCellRow, c), startLeadingCellRow = leadingCellRow;
	            if (!wrap) {
	                self._adjustCell(cell);
	            }
	            r = cell.r;
	            c = cell.c;
	            while (c === colCount && wrap) {
	                r = self._getNextVisualRow(r, 3 , true);
	                if (r >= rowCount || isNullOrUndefined(r)) {
	                    r = self._getNextVisualRow(-1, 3 , true);
	                }
	                leadingCellRow = r;
	                cell = self._getNextColumn(leadingCellRow, -1);
	                r = cell.r;
	                c = cell.c;
	                if (r === row && c > col) {
	                    return keyword_null;
	                } else if (r === row && c === col) {
	                    if (leadingCellRow === startLeadingCellRow) {
	                        return keyword_null;
	                    }
	                    cell = self._getNextColumn(leadingCellRow, c);
	                    r = cell.r;
	                    c = cell.c;
	                }
	            }
	            return {row: r, col: c, leadingCellRow: leadingCellRow};
	        },
	        _getPrevColumn: function (r, c) {
	            var self = this;
	            var row, col = c;
	            while (col >= 0) {
	                row = r;
	                col--;
	                if (col < 0) {
	                    break;
	                }
	                var spans = self.getSpans(createRange(row, col, 1, 1));
	                if (spans && _ArrayHelper_getLength(spans) > 0) {
	                    var span = spans[0];
	                    if (col >= span.col) {
	                        col = span.col;
	                        row = span.row;
	                    }
	                }
	                if (self._canMoveCurrentTo(row, col)) {
	                    return {r: row, c: col};
	                }
	            }
	            return {r: row, c: col};
	        },
	        _getPrevColumnInSelection: function (r, c) {
	            var self = this;
	            while (c >= 0) {
	                c--;
	                if (c < 0) {
	                    break;
	                }
	                var span = self._modelManager.findSpan(r, c);
	                if (span) {
	                    var activeSelectedRange = self._getActiveSelectedRange();
	                    if (activeSelectedRange.row <= span.row && span.row + getRowCount(span) <= activeSelectedRange.row + getRowCount(activeSelectedRange) &&
	                        activeSelectedRange.col <= span.col && span.col + getColCount(span) <= activeSelectedRange.col + getColCount(activeSelectedRange)) {
	                        if (!(span.row === r && span.col === c)) {
	                            continue;
	                        }
	                    } else {
	                        continue;
	                    }
	                    if (c >= span.col) {
	                        c = span.col;
	                        r = span.row;
	                    }
	                }
	                if (self._canMoveCurrentTo(r, c)) {
	                    return {r: r, c: c};
	                }
	            }
	            return {r: r, c: c};
	        },
	        _getNextColumn: function (r, c) {
	            var self = this;
	            var colCount = getSheetColumnCount(self);
	            var row, col = c;
	            while (col < colCount) {
	                row = r;
	                var currentSpan = self._modelManager.getSpan(row, col);
	                col += getColCount(currentSpan);
	                if (col >= colCount) {
	                    break;
	                }
	                var spans = self.getSpans(createRange(row, col, 1, 1));
	                if (spans && _ArrayHelper_getLength(spans) > 0) {
	                    var span = spans[0];
	                    if (col > span.col) {
	                        col = Math_max(col, span.col + getColCount(span));
	                    } else {
	                        row = span.row;
	                    }
	                }
	                if (self._canMoveCurrentTo(row, col)) {
	                    return {r: row, c: col};
	                }
	            }
	            return {r: row, c: col};
	        },
	        _getNextColumnInSelection: function (r, c) {
	            var self = this, modelManager = self._modelManager;
	            var colCount = getSheetColumnCount(self);
	            while (c < colCount) {
	                var currentSpan = modelManager.getSpan(r, c);
	                c = currentSpan.col + getColCount(currentSpan);
	                if (c >= colCount) {
	                    break;
	                }
	                var span = modelManager.findSpan(r, c);
	                if (span) {
	                    var activeSelectedRange = self._getActiveSelectedRange();
	                    if (activeSelectedRange.row <= span.row && span.row + getRowCount(span) <= activeSelectedRange.row + getRowCount(activeSelectedRange) &&
	                        activeSelectedRange.col <= span.col && span.col + getColCount(span) <= activeSelectedRange.col + getColCount(activeSelectedRange)) {
	                        if (!(span.row === r && span.col === c)) {
	                            continue;
	                        }
	                    } else {
	                        continue;
	                    }
	                    if (c > span.col) {
	                        c = Math_max(c, span.col + getColCount(span));
	                    } else {
	                        r = span.row;
	                    }
	                }
	                if (self._canMoveCurrentTo(r, c)) {
	                    return {r: r, c: c};
	                }
	            }
	            return {r: r, c: c};
	        },
	        _canMoveCurrentTo: function (r, c) {
	            var self = this;
	            if (!self._canSelect(r, c)) {
	                return false;
	            }
	            var canMove = (r >= 0 && r < getSheetRowCount(self) && c >= 0 && c < getSheetColumnCount(self) &&
	                self.getRowVisible(r) && self.getColumnVisible(c) &&
	                self._getZoomRowHeight(r) > 0 && self._getZoomColumnWidth(c) > 0);
	            var checkTab = !!self._isTabNavigation;
	            if (canMove === true && checkTab === true) {
	                var tabStop = self._getStyleProperty(r, c, 'tabStop');
	                if (tabStop === false) {
	                    canMove = false;
	                }
	            }
	            return canMove;
	        },
	        _getPrevRow: function (r, c) {
	            var self = this;
	            while (r >= 0) {
	                r--;
	                if (r < 0) {
	                    break;
	                }
	                var spans = self.getSpans(createRange(r, c, 1, 1));
	                if (spans && _ArrayHelper_getLength(spans) > 0) {
	                    var span = spans[0];
	                    if (r >= span.row) {
	                        r = span.row;
	                        c = span.col;
	                    }
	                }
	                if (self._canMoveCurrentTo(r, c)) {
	                    return {r: r, c: c};
	                }
	            }
	            return {r: r, c: c};
	        },
	        _getNextRow: function (r, c) {
	            var self = this;
	            var rowCount = getSheetRowCount(self);
	            while (r < rowCount) {
	                var currentSpan = self._modelManager.getSpan(r, c);
	                r += getRowCount(currentSpan);
	                if (r >= rowCount) {
	                    break;
	                }
	                var spans = self.getSpans(createRange(r, c, 1, 1));
	                if (spans && _ArrayHelper_getLength(spans) > 0) {
	                    var span = spans[0];
	                    if (r > span.row) {
	                        r = Math_max(r, span.row + getRowCount(span));
	                    } else {
	                        c = span.col;
	                    }
	                }
	                if (self._canMoveCurrentTo(r, c)) {
	                    return {r: r, c: c};
	                }
	            }
	            return {r: r, c: c};
	        },
	        _setSelectedRange: function (r, c, rc, cc, repaint) {
	            var self = this;
	            self._modelManager.do('addSelection', r, c, rc, cc);
	            if (repaint && self._layoutSuspended <= 0) {
	                self._render._repaintSelection();
	            }
	        },
	        _extendSelectedRange: function (r, c, repaint) {
	            var self = this;
	            var extendedRange = self._getExtendedRange(r, c, self._activeRowIndex, self._activeColIndex);
	            var newRow = extendedRange.row, newCol = extendedRange.col, newRowCount = getRowCount(extendedRange),
	                newColCount = getColCount(extendedRange);
	            var selectionPolicy = self.selectionPolicy(), selectionUnit = self.selectionUnit();
	            if (selectionPolicy === 0 ) {
	                return;
	            } else if (selectionPolicy === 1 ) {
	                self._modelManager.do('clearSelection');
	            }
	            if (selectionUnit === 1 ) {
	                newCol = -1;
	                newColCount = -1;
	            } else if (selectionUnit === 2 ) {
	                newRow = -1;
	                newRowCount = -1;
	            }
	            self._replaceActiveSelectedRange(newRow, newCol, newRowCount, newColCount, repaint);
	        },
	        _getExtendedRange: function (r, c, anchorRow, anchorCol, oneMergedCellAsOneCell) {
	            var self = this;
	            if (isNullOrUndefined(anchorRow)) {
	                anchorRow = self._activeRowIndex;
	            }
	            if (isNullOrUndefined(anchorCol)) {
	                anchorCol = self._activeColIndex;
	            }
	            var modelManager = self._modelManager;
	            var anchorRange = modelManager.getSpan(anchorRow, anchorCol);
	            var endRange = modelManager.getSpan(r, c);
	            if (oneMergedCellAsOneCell && anchorRange.equals(endRange)) {
	                return new exports.Range(anchorRange.row, anchorRange.col, 1, 1);
	            }
	            var extendedRange = anchorRange.union(endRange);
	            var spans = self.getSpans();
	            if (spans && _ArrayHelper_getLength(spans) > 0) {
	                extendedRange = self._inflateRangeToCoverSpans(spans, extendedRange);
	            }
	            return extendedRange;
	        },
	        _replaceActiveSelectedRange: function (r, c, rc, cc, repaint) {
	            var self = this, modelManager = self._modelManager;
	            var oldSelectedRange = self._getActiveSelectedRange();
	            if (_ArrayHelper_getLength(modelManager.getSelections()) > 0) {
	                    var newRange = createRange(r, c, rc, cc);
	                    if(self._isDeselecting) {
	                        var oldDeselectRange = self._deselectRange;
	                        self._deselectRange = newRange;
	                    }else {
	                var selections = modelManager.getSelections();
	                        selections[modelManager.getActiveSelectedRangeIndex()] = newRange;
	                modelManager.do('setSelections', selections);
	                    }
	
	                } else if(!self._isDeselecting) {
	                modelManager.do('addSelection', r, c, rc, cc);
	            }
	            if (repaint && self._layoutSuspended <= 0) {
	                var newSelectedRange = self._getActiveSelectedRange();
	                if (!self._isDeselecting && newSelectedRange.row === oldSelectedRange.row && newSelectedRange.col === oldSelectedRange.col &&
	                    getRowCount(newSelectedRange) === getRowCount(oldSelectedRange) && getColCount(newSelectedRange) === getColCount(oldSelectedRange)) {
	                    return;
	                }
	                var render = self._render;
	
	                if(self._isDeselecting) {
	                    var unionRange = self._deselectRange;
	                    if(oldDeselectRange && oldDeselectRange.containsRange(unionRange)) {
	                        unionRange = oldDeselectRange;
	                    }else if(oldDeselectRange) {
	                        unionRange = oldDeselectRange.union(unionRange);
	                    }
	                    unionRange = unionRange.union(self.getActiveRowIndex(), self.getActiveColumnIndex(), 1, 1);
	                    oldSelectedRange = unionRange.union(oldSelectedRange);
	                    newSelectedRange = unionRange.union(newSelectedRange);
	                }
	
	                if (oldSelectedRange.containsRange(newSelectedRange)) {
	                    render._repaintSelection(oldSelectedRange);
	                } else if (newSelectedRange.containsRange(oldSelectedRange)) {
	                    render._repaintSelection(newSelectedRange);
	                } else {
	                    render._repaintSelection(oldSelectedRange);
	                    render._repaintSelection(newSelectedRange);
	                    render._repaintSelection(self._deselectRange);
	                }
	            }
	        },
	        
	        _deselectSelection: function (originalRange, deselectRange, maxRowCount, maxColCount) {
	            deselectRange = this._getActualRange(deselectRange);
	            var result = [];
	            var newRange = originalRange.getIntersect(deselectRange, maxRowCount, maxColCount);
	            if(originalRange && newRange) {
	
	                var originalRow = originalRange.row >= 0 ? originalRange.row : 0, originalCol = originalRange.col >= 0 ? originalRange.col : 0, originalRowCount = originalRange.rowCount, originalColCount = originalRange.colCount;
	                var newRow = newRange.row, newCol = newRange.col, newRowCount = newRange.rowCount, newColCount = newRange.colCount;
	                var originalEndRow = originalRow + originalRowCount, originalEndCol = originalCol + originalColCount,
	                    newEndRow = newRow + newRowCount, newEndCol = newCol + newColCount;
	               
	                if(originalEndRow - newEndRow > 0) {
	                    result.push(createRange(newEndRow, originalCol, originalEndRow - newEndRow, originalColCount));
	                }
	               
	                if(originalEndCol - newEndCol > 0) {
	                    result.push(createRange(newRow, newEndCol, newRowCount, originalEndCol - newEndCol));
	                }
	               
	                if(newCol - originalCol > 0) {
	                    result.push(createRange(newRow, originalCol, newRowCount, newCol - originalCol));
	                }
	               
	                if(newRow - originalRow > 0) {
	                    result.push(createRange(originalRow, originalCol, newRow - originalRow, originalColCount));
	                }
	            }else {
	                 result.push(originalRange);
	            }
	            return result;
	
	        },
	        _deselectSelections: function (selections, deselectRange) {
	
	            var result = [], maxRowCount = this.getRowCount(3 ), maxColCount = this.getColumnCount(3 );
	            if(selections && selections.length > 0) {
	                var len = selections.length, temArr = [], hasSetActiveCell = false;
	
	                for(var i = len - 1; i >= 0; i--) {
	                    temArr = this._deselectSelection(selections[i], deselectRange, maxRowCount, maxColCount);
	                    var temArrLen = _ArrayHelper_getLength(temArr);
	                    if(!hasSetActiveCell && temArrLen > 0) {
	                        this.setSelection(temArr[temArrLen - 1].row, temArr[temArrLen - 1].col, 1, 1);
	                        hasSetActiveCell = true;
	                    }
	                    result = temArr.concat(result);
	                }
	            }
	            this._clearSelectionImp();
	            var resultLen = result.length;
	
	            this.suspendPaint();
	            for(var j = 0; j < resultLen ;j++) {
	                this.addSelection(result[j].row, result[j].col, result[j].rowCount, result[j].colCount);
	            }
	           
	            if(!hasSetActiveCell) {
	                this.setActiveCell(this._activeRowIndex, this._activeColIndex);
	            }
	            this.resumePaint();
	
	        },
	        _changeActiveSelectedRange: function (key, isCtrl) {
	            var self = this;
	            var oldSelections = self._modelManager.getSelections();
	            if (_ArrayHelper_getLength(oldSelections) <= 0) {
	                return;
	            }
	            var oldActiveRange = self._getActiveSelectedRange();
	            var newRange = self._getKeyboardSelectedRange(oldActiveRange, key, isCtrl);
	            if (newRange) {
	                var newRow = newRange.row, newCol = newRange.col, newRowCount = getRowCount(newRange),
	                    newColCount = getColCount(newRange);
	                var selectionPolicy = self.selectionPolicy(), selectionUnit = self.selectionUnit();
	                if (selectionPolicy === 0 ) {
	                    return;
	                } else if (selectionPolicy === 1 ) {
	                    self._modelManager.do('clearSelection');
	                }
	                if (selectionUnit === 1 ) {
	                    newCol = -1;
	                    newColCount = -1;
	                } else if (selectionUnit === 2 ) {
	                    newRow = -1;
	                    newRowCount = -1;
	                }
	                self._replaceActiveSelectedRange(newRow, newCol, newRowCount, newColCount, true);
	                var newSelections = self._modelManager.getSelections();
	                if (self._eventHandler._notEqualSelecions(oldSelections, newSelections)) {
	                    self._raiseSelectionChanging(oldSelections, newSelections);
	                    self._raiseSelectionChanged(oldSelections);
	                }
	            }
	        },
	        _getKeyboardSelectedRange: function (activeRange, key, isCtrl, anchorRow, anchorCol) {
	            var self = this;
	            var range = self._getActualRange(activeRange);
	            var newRange = keyword_null;
	            if (key === 37 ) {
	                newRange = isCtrl ? self._searchSelectedRangebyLeftCtrl(range, false, anchorRow, anchorCol) : self._searchSelectedRangebyLeft(range, anchorRow, anchorCol);
	            } else if (key === 39 ) {
	                newRange = isCtrl ? self._searchSelectedRangebyRightCtrl(range, false, anchorRow, anchorCol) : self._searchSelectedRangebyRight(range, anchorRow, anchorCol);
	            } else if (key === 38 ) {
	                newRange = isCtrl ? self._searchSelectedRangebyUpCtrl(range, false, anchorRow, anchorCol) : self._searchSelectedRangebyUp(range, anchorRow, anchorCol);
	            } else if (key === 40 ) {
	                newRange = isCtrl ? self._searchSelectedRangebyDownCtrl(range, false, anchorRow, anchorCol) : self._searchSelectedRangebyDown(range, anchorRow, anchorCol);
	            } else if (key === 36 ) {
	                newRange = isCtrl ? self._searchSelectedRangebyHomeCtrl(range, anchorRow, anchorCol) : self._searchSelectedRangebyHome(range, anchorRow, anchorCol);
	            } else if (key === 35 ) {
	                newRange = isCtrl ? self._searchSelectedRangebyEndCtrl(range, anchorRow, anchorCol) : self._searchSelectedRangebyEnd(range, anchorRow, anchorCol);
	            } else if (key === 33 ) {
	                newRange = self._searchSelectedRangebyPageUp(range, anchorRow, anchorCol);
	            } else if (key === 34 ) {
	                newRange = self._searchSelectedRangebyPageDown(range, anchorRow, anchorCol);
	            }
	            if (newRange) {
	                if (activeRange.row < 0) {
	                    newRange.row = -1;
	                    newRange.rowCount = self.getRowCount();
	                }
	                if (activeRange.col < 0) {
	                    newRange.col = -1;
	                    newRange.colCount = self.getColumnCount();
	                }
	            }
	            return newRange;
	        },
	        _searchSelectedRangebyLeft: function (activeRange, anchorRow, anchorCol) {
	            var self = this, activeRangeRow = activeRange.row, activeRangeCol = activeRange.col,
	                activeRangeRowCount = getRowCount(activeRange), activeRangeColCount = getColCount(activeRange);
	            var beginCol = activeRangeCol + activeRangeColCount - 1;
	            var endCol = 0;
	            var startPositionRow = activeRangeRow + activeRangeRowCount - 1;
	            var extendedRange, row, col, row2, col2, rowCount, colCount;
	            while (beginCol > endCol) {
	                beginCol--;
	                if (!self._canMoveCurrentTo(startPositionRow, beginCol)) {
	                    continue;
	                }
	                extendedRange = self._getExtendedRange(startPositionRow, beginCol, anchorRow, anchorCol);
	                row = Math_min(activeRangeRow, extendedRange.row);
	                col = Math_min(activeRangeCol, extendedRange.col);
	                row2 = Math_max(activeRangeRow + activeRangeRowCount - 1, extendedRange.row + getRowCount(extendedRange) - 1);
	                col2 = Math_min(activeRangeCol + activeRangeColCount - 1, extendedRange.col + getColCount(extendedRange) - 1);
	                rowCount = row2 - row + 1;
	                colCount = col2 - col + 1;
	                if (!(row === activeRangeRow && col === activeRangeCol && rowCount === activeRangeRowCount && colCount === activeRangeColCount)) {
	                    var scrollLeftCol = self._scrollLeftCol;
	                    var activeCol = self._activeColIndex;
	                    if (activeRangeCol < activeCol) {
	                        if (col <= scrollLeftCol) {
	                            self._setLeftColumn(col);
	                        }
	                    } else if (activeRangeCol === activeCol && col2 <= scrollLeftCol) {
	                        self._setLeftColumn(col2);
	                    }
	                    return createRange(row, col, rowCount, colCount);
	                }
	            }
	            return keyword_null;
	        },
	        _searchSelectedRangebyLeftCtrl: function (activeRange, isHomeKey, anchorRow, anchorCol) {
	            var self = this, activeRangeRow = activeRange.row, activeRangeCol = activeRange.col;
	            var frozenColCount = self.frozenColumnCount();
	            var firstCol = frozenColCount ? self._getNextVisualColumn(frozenColCount - 1) : self._getFirstVisualColumn();
	            var beginCol = isHomeKey ? firstCol : self._getFirstVisualColumn();
	            if (isNullOrUndefined(beginCol)) {
	                return;
	            } else if (frozenColCount <= 0 || isHomeKey) {
	                self._setLeftColumn(beginCol);
	            }
	            var extendedRange, row, col, row2, col2, rowCount, colCount;
	            extendedRange = self._getExtendedRange(activeRangeRow, beginCol, anchorRow, anchorCol);
	            row = Math_min(activeRangeRow, extendedRange.row);
	            col = Math_min(activeRangeCol, extendedRange.col);
	            row2 = Math_max(activeRangeRow + getRowCount(activeRange) - 1, extendedRange.row + getRowCount(extendedRange) - 1);
	            col2 = Math_min(activeRangeCol + getColCount(activeRange) - 1, extendedRange.col + getColCount(extendedRange) - 1);
	            rowCount = row2 - row + 1;
	            colCount = col2 - col + 1;
	            return createRange(row, col, rowCount, colCount);
	        },
	        _searchSelectedRangebyRight: function (activeRange, anchorRow, anchorCol) {
	            var self = this, activeRangeRow = activeRange.row, activeRangeCol = activeRange.col,
	                activeRangeRowCount = getRowCount(activeRange), activeRangeColCount = getColCount(activeRange);
	            var beginCol = activeRangeCol;
	            var endCol = getSheetColumnCount(self) - 1;
	            var startPositionRow = activeRangeRow + activeRangeRowCount - 1;
	            var extendedRange, row, col, row2, col2, rowCount, colCount;
	            while (beginCol < endCol) {
	                beginCol++;
	                if (!self._canMoveCurrentTo(startPositionRow, beginCol)) {
	                    continue;
	                }
	                extendedRange = self._getExtendedRange(startPositionRow, beginCol, anchorRow, anchorCol);
	                row = Math_min(activeRangeRow, extendedRange.row);
	                col = Math_max(activeRangeCol, extendedRange.col);
	                row2 = Math_max(activeRangeRow + activeRangeRowCount - 1, extendedRange.row + getRowCount(extendedRange) - 1);
	                col2 = Math_max(activeRangeCol + activeRangeColCount - 1, extendedRange.col + getColCount(extendedRange) - 1);
	                rowCount = row2 - row + 1;
	                colCount = col2 - col + 1;
	                if (!(row === activeRangeRow && col === activeRangeCol && rowCount === activeRangeRowCount && colCount === activeRangeColCount)) {
	                    var pageRightCol = self._getPageRightColumn();
	                    var activeCol = self._activeColIndex;
	                    if (activeRangeCol < activeCol) {
	                        if (col >= pageRightCol) {
	                            self._setLeftColumn(self._getNewLeftColumn(col, 2 ));
	                        }
	                    } else if (activeRangeCol === activeCol && col2 >= pageRightCol) {
	                        self._setLeftColumn(self._getNewLeftColumn(col2, 2 ));
	                    }
	                    return createRange(row, col, rowCount, colCount);
	                }
	            }
	            return keyword_null;
	        },
	        _searchSelectedRangebyRightCtrl: function (activeRange, isEndKey, anchorRow, anchorCol) {
	            var self = this, activeRangeRow = activeRange.row, activeRangeCol = activeRange.col;
	            var newPageLeftCol = self._getLastPageLeftColumn();
	            if (isNullOrUndefined(newPageLeftCol)) {
	                return;
	            }
	            self._setLeftColumn(newPageLeftCol);
	            var endCol = self._getLastVisualColumn();
	            if (!isEndKey) {
	                endCol += self.frozenTrailingColumnCount();
	            }
	            var extendedRange, row, col, row2, col2, rowCount, colCount;
	            extendedRange = self._getExtendedRange(activeRangeRow, endCol, anchorRow, anchorCol);
	            row = Math_min(activeRangeRow, extendedRange.row);
	            col = Math_max(activeRangeCol, extendedRange.col);
	            row2 = Math_max(activeRangeRow + getRowCount(activeRange) - 1, extendedRange.row + getRowCount(extendedRange) - 1);
	            col2 = Math_max(activeRangeCol + getColCount(activeRange) - 1, extendedRange.col + getColCount(extendedRange) - 1);
	            rowCount = row2 - row + 1;
	            colCount = col2 - col + 1;
	            return createRange(row, col, rowCount, colCount);
	        },
	        _searchSelectedRangebyUp: function (activeRange, anchorRow, anchorCol) {
	            var self = this, activeRangeRow = activeRange.row, activeRangeCol = activeRange.col,
	                activeRangeRowCount = getRowCount(activeRange), activeRangeColCount = getColCount(activeRange);
	            var beginRow = activeRangeRow + activeRangeRowCount - 1;
	            var endRow = 0;
	            var startPositionCol = activeRangeCol + activeRangeColCount - 1;
	            var extendedRange, row, col, row2, col2, rowCount, colCount;
	            while (beginRow > endRow) {
	                beginRow--;
	                if (!self._canMoveCurrentTo(beginRow, startPositionCol)) {
	                    continue;
	                }
	                extendedRange = self._getExtendedRange(beginRow, startPositionCol, anchorRow, anchorCol);
	                row = Math_min(activeRangeRow, extendedRange.row);
	                col = Math_min(activeRangeCol, extendedRange.col);
	                row2 = Math_min(activeRangeRow + activeRangeRowCount - 1, extendedRange.row + getRowCount(extendedRange) - 1);
	                col2 = Math_max(activeRangeCol + activeRangeColCount - 1, extendedRange.col + getColCount(extendedRange) - 1);
	                rowCount = row2 - row + 1;
	                colCount = col2 - col + 1;
	                if (!(row === activeRangeRow && col === activeRangeCol && rowCount === activeRangeRowCount && colCount === activeRangeColCount)) {
	                    var scrollTopRow = self._scrollTopRow;
	                    var activeRow = self._activeRowIndex;
	                    if (activeRangeRow < activeRow) {
	                        if (row <= scrollTopRow) {
	                            self._setTopRow(row);
	                        }
	                    } else if (activeRangeRow === activeRow && row2 <= scrollTopRow) {
	                        self._setTopRow(row2);
	                    }
	                    return createRange(row, col, rowCount, colCount);
	                }
	            }
	            return keyword_null;
	        },
	        _searchSelectedRangebyUpCtrl: function (activeRange, isHomeKey, anchorRow, anchorCol) {
	            var self = this, activeRangeRow = activeRange.row, activeRangeCol = activeRange.col;
	            var frozenRowCount = self.frozenRowCount();
	            var firstRow = frozenRowCount ? self._getNextVisualRow(frozenRowCount - 1) : self._getFirstVisualRow();
	            var beginRow = isHomeKey ? firstRow : self._getFirstVisualRow();
	            if (isNullOrUndefined(beginRow)) {
	                return;
	            } else if (frozenRowCount <= 0 || isHomeKey) {
	                self._setTopRow(beginRow);
	            }
	            var extendedRange, row, col, row2, col2, rowCount, colCount;
	            extendedRange = self._getExtendedRange(beginRow, activeRangeCol, anchorRow, anchorCol);
	            row = Math_min(activeRangeRow, extendedRange.row);
	            col = Math_min(activeRangeCol, extendedRange.col);
	            row2 = Math_min(activeRangeRow + getRowCount(activeRange) - 1, extendedRange.row + getRowCount(extendedRange) - 1);
	            col2 = Math_max(activeRangeCol + getColCount(activeRange) - 1, extendedRange.col + getColCount(extendedRange) - 1);
	            rowCount = row2 - row + 1;
	            colCount = col2 - col + 1;
	            return createRange(row, col, rowCount, colCount);
	        },
	        _searchSelectedRangebyDown: function (activeRange, anchorRow, anchorCol) {
	            var self = this, activeRangeRow = activeRange.row, activeRangeCol = activeRange.col,
	                activeRangeRowCount = getRowCount(activeRange), activeRangeColCount = getColCount(activeRange);
	            var beginRow = activeRangeRow;
	            var endRow = getSheetRowCount(self) - 1;
	            var startPositionCol = activeRangeCol + activeRangeColCount - 1;
	            var extendedRange, row, col, row2, col2, rowCount, colCount;
	            while (beginRow < endRow) {
	                beginRow++;
	                if (!self._canMoveCurrentTo(beginRow, startPositionCol)) {
	                    continue;
	                }
	                extendedRange = self._getExtendedRange(beginRow, startPositionCol, anchorRow, anchorCol);
	                row = Math_max(activeRangeRow, extendedRange.row);
	                col = Math_min(activeRangeCol, extendedRange.col);
	                row2 = Math_max(activeRangeRow + activeRangeRowCount - 1, extendedRange.row + getRowCount(extendedRange) - 1);
	                col2 = Math_max(activeRangeCol + activeRangeColCount - 1, extendedRange.col + getColCount(extendedRange) - 1);
	                rowCount = row2 - row + 1;
	                colCount = col2 - col + 1;
	                if (!(row === activeRangeRow && col === activeRangeCol && rowCount === activeRangeRowCount && colCount === activeRangeColCount)) {
	                    var pageBottomRow = self._getPageBottomRow();
	                    var activeRow = self._activeRowIndex;
	                    if (activeRangeRow < activeRow) {
	                        if (row >= pageBottomRow) {
	                            self._setTopRow(self._getNewTopRow(row, 2 ));
	                        }
	                    } else if (activeRangeRow === activeRow && row2 >= pageBottomRow) {
	                        self._setTopRow(self._getNewTopRow(row2, 2 ));
	                    }
	                    return createRange(row, col, rowCount, colCount);
	                }
	            }
	            return keyword_null;
	        },
	        _searchSelectedRangebyDownCtrl: function (activeRange, isEndKey, anchorRow, anchorCol) {
	            var self = this, activeRangeRow = activeRange.row, activeRangeCol = activeRange.col;
	            var newTopRow = self._getLastPageTopRow();
	            if (isNullOrUndefined(newTopRow)) {
	                return;
	            }
	            self._setTopRow(newTopRow);
	            var endRow = self._getLastVisualRow();
	            if (!isEndKey) {
	                endRow += self.frozenTrailingRowCount();
	            }
	            var extendedRange, row, col, row2, col2, rowCount, colCount;
	            extendedRange = self._getExtendedRange(endRow, activeRangeCol, anchorRow, anchorCol);
	            row = Math_max(activeRangeRow, extendedRange.row);
	            col = Math_min(activeRangeCol, extendedRange.col);
	            row2 = Math_max(activeRangeRow + getRowCount(activeRange) - 1, extendedRange.row + getRowCount(extendedRange) - 1);
	            col2 = Math_max(activeRangeCol + getColCount(activeRange) - 1, extendedRange.col + getColCount(extendedRange) - 1);
	            rowCount = row2 - row + 1;
	            colCount = col2 - col + 1;
	            return createRange(row, col, rowCount, colCount);
	        },
	        _searchSelectedRangebyHome: function (activeRange, anchorRow, anchorCol) {
	            var self = this, activeRangeRow = activeRange.row, activeRangeCol = activeRange.col,
	                activeRangeRowCount = getRowCount(activeRange), activeRangeColCount = getColCount(activeRange);
	            var beginCol = self.frozenColumnCount() - 1;
	            var endCol = self._activeColIndex;
	            var startPositionRow = activeRangeRow + activeRangeRowCount - 1;
	            var extendedRange, row, col, row2, col2, rowCount, colCount;
	            while (beginCol < endCol) {
	                beginCol++;
	                if (!self._canMoveCurrentTo(startPositionRow, beginCol)) {
	                    continue;
	                }
	                if (activeRangeCol <= beginCol && (activeRangeCol + activeRangeColCount - 1) === self._activeColIndex) {
	                    break;
	                }
	                extendedRange = self._getExtendedRange(startPositionRow, beginCol, anchorRow, anchorCol);
	                row = Math_min(activeRangeRow, extendedRange.row);
	                col = Math_min(activeRangeCol, extendedRange.col);
	                row2 = Math_max(activeRangeRow + activeRangeRowCount - 1, extendedRange.row + getRowCount(extendedRange) - 1);
	                col2 = Math_min(activeRangeCol + activeRangeColCount - 1, extendedRange.col + getColCount(extendedRange) - 1);
	                rowCount = row2 - row + 1;
	                colCount = col2 - col + 1;
	                self._setLeftColumn(self._getFirstVisualColumn());
	                return createRange(row, col, rowCount, colCount);
	            }
	            return keyword_null;
	        },
	        _searchSelectedRangebyHomeCtrl: function (activeRange, anchorRow, anchorCol) {
	            activeRange = this._searchSelectedRangebyLeftCtrl(activeRange, true, anchorRow, anchorCol);
	            activeRange = this._searchSelectedRangebyUpCtrl(activeRange, true, anchorRow, anchorCol);
	            return activeRange;
	        },
	        _searchSelectedRangebyEnd: function (activeRange, anchorRow, anchorCol) {
	            var self = this, activeRangeRow = activeRange.row, activeRangeCol = activeRange.col,
	                activeRangeRowCount = getRowCount(activeRange), activeRangeColCount = getColCount(activeRange);
	            var beginCol = getSheetColumnCount(self);
	            var endCol = self._activeColIndex;
	            var startPositionRow = activeRangeRow + activeRangeRowCount - 1;
	            var extendedRange, row, col, row2, col2, rowCount, colCount;
	            while (beginCol > endCol) {
	                beginCol--;
	                if (!self._canMoveCurrentTo(startPositionRow, beginCol)) {
	                    continue;
	                }
	                if (activeRangeCol + activeRangeColCount - 1 >= beginCol && activeRangeCol === self._activeColIndex) {
	                    break;
	                }
	                extendedRange = self._getExtendedRange(startPositionRow, beginCol, anchorRow, anchorCol);
	                row = Math_min(activeRangeRow, extendedRange.row);
	                col = Math_max(activeRangeCol, extendedRange.col);
	                row2 = Math_max(activeRangeRow + activeRangeRowCount - 1, extendedRange.row + getRowCount(extendedRange) - 1);
	                col2 = Math_max(activeRangeCol + activeRangeColCount - 1, extendedRange.col + getColCount(extendedRange) - 1);
	                rowCount = row2 - row + 1;
	                colCount = col2 - col + 1;
	                self._setLeftColumn(self._getLastPageLeftColumn());
	                return createRange(row, col, rowCount, colCount);
	            }
	            return keyword_null;
	        },
	        _searchSelectedRangebyEndCtrl: function (activeRange, anchorRow, anchorCol) {
	            activeRange = this._searchSelectedRangebyRightCtrl(activeRange, true, anchorRow, anchorCol);
	            activeRange = this._searchSelectedRangebyDownCtrl(activeRange, true, anchorRow, anchorCol);
	            return activeRange;
	        },
	        _searchSelectedRangebyPageUp: function (activeRange, anchorRow, anchorCol) {
	            var self = this, activeRangeRow = activeRange.row, activeRangeCol = activeRange.col,
	                activeRangeRowCount = getRowCount(activeRange);
	            var prevPageTopRow = self._getPrevPageTopRow();
	            if (isNullOrUndefined(prevPageTopRow)) {
	                return keyword_null;
	            }
	            var rls = self._getRowLayout(1);
	            var scrolled = self._setTopRow(prevPageTopRow);
	            var beginRow = -1;
	            if (scrolled) {
	                beginRow = self._getNextVisualRow(activeRangeRow + activeRangeRowCount - 1 - _ArrayHelper_getLength(rls));
	            } else if (self.frozenRowCount() <= 0) {
	                beginRow = self._getFirstVisualRow();
	            }
	            if (beginRow < self._scrollTopRow) {
	                beginRow = self._scrollTopRow;
	            } else if (beginRow >= self._getPageBottomRow()) {
	                beginRow = self._getPrevVisualRow(self._getPageBottomRow());
	            }
	            var extendedRange, row, col, row2, col2, rowCount, colCount;
	            extendedRange = self._getExtendedRange(beginRow, activeRangeCol, anchorRow, anchorCol);
	            row = Math_min(activeRangeRow, extendedRange.row);
	            col = Math_min(activeRangeCol, extendedRange.col);
	            row2 = Math_min(activeRangeRow + activeRangeRowCount - 1, extendedRange.row + getRowCount(extendedRange) - 1);
	            col2 = Math_max(activeRangeCol + getColCount(activeRange) - 1, extendedRange.col + getColCount(extendedRange) - 1);
	            rowCount = row2 - row + 1;
	            colCount = col2 - col + 1;
	            return createRange(row, col, rowCount, colCount);
	        },
	        _searchSelectedRangebyPageDown: function (activeRange, anchorRow, anchorCol) {
	            var self = this, activeRangeRow = activeRange.row, activeRangeCol = activeRange.col,
	                activeRangeRowCount = getRowCount(activeRange);
	            var nextPageTopRow = self._getNextPageTopRow();
	            if (isNullOrUndefined(nextPageTopRow)) {
	                return keyword_null;
	            }
	            var rls = self._getRowLayout(1);
	            self._setTopRow(nextPageTopRow);
	            var beginRow = self._getPrevVisualRow(activeRangeRow + activeRangeRowCount - 1 + _ArrayHelper_getLength(rls));
	            if (beginRow < self._scrollTopRow) {
	                beginRow = self._scrollTopRow;
	            } else if (beginRow >= self._getPageBottomRow()) {
	                if (self._scrollTopRow >= self._getLastPageTopRow()) {
	                    beginRow = self._getPageBottomRow();
	                } else {
	                    beginRow = self._getPrevVisualRow(self._getPageBottomRow());
	                }
	            }
	            var extendedRange, row, col, row2, col2, rowCount, colCount;
	            extendedRange = self._getExtendedRange(beginRow, activeRangeCol, anchorRow, anchorCol);
	            row = Math_max(activeRangeRow, extendedRange.row);
	            col = Math_min(activeRangeCol, extendedRange.col);
	            row2 = Math_max(activeRangeRow + activeRangeRowCount - 1, extendedRange.row + getRowCount(extendedRange) - 1);
	            col2 = Math_max(activeRangeCol + getColCount(activeRange) - 1, extendedRange.col + getColCount(extendedRange) - 1);
	            rowCount = row2 - row + 1;
	            colCount = col2 - col + 1;
	            return createRange(row, col, rowCount, colCount);
	        },
	        _getPrevPageTopRow: function () {
	            var self = this;
	            var rls = self._getRowLayout(1);
	            if (!rls || _ArrayHelper_getLength(rls) <= 0) {
	                return keyword_null;
	            }
	            var frozenRowCount = self.frozenRowCount();
	            var firstRow = frozenRowCount ? self._getNextVisualRow(frozenRowCount - 1) : self._getFirstVisualRow();
	           
	           
	           
	            var h = 0;
	            var r = self._scrollTopRow;
	            var sheetLayout = self._getSheetLayout();
	            while (r > firstRow) {
	                r--;
	                h += self._getZoomRowHeight(r);
	                if (h > sheetLayout._viewportHeight) {
	                    break;
	                }
	            }
	            return r;
	        },
	        _getPrevPageLeftColumn: function () {
	            var self = this;
	            var rls = self._getColumnLayout(1);
	            if (!rls || _ArrayHelper_getLength(rls) <= 0) {
	                return keyword_null;
	            }
	            var frozenColCount = self.frozenColumnCount();
	            var firstColumn = frozenColCount ? self._getNextVisualColumn(frozenColCount - 1) : self._getFirstVisualColumn();
	           
	           
	           
	            var w = 0;
	            var c = self._scrollLeftCol;
	            var sheetLayout = self._getSheetLayout();
	            while (c > firstColumn) {
	                c--;
	                w += self._getZoomColumnWidth(c);
	                if (w > sheetLayout._viewportWidth) {
	                    break;
	                }
	            }
	            return c;
	        },
	        _getNextPageTopRow: function () {
	            var rls = this._getRowLayout(1), length;
	            if (rls && (length = _ArrayHelper_getLength(rls)) > 0) {
	                var lastRow = rls[length - 1].row;
	                if (this._getLastVisualRow() <= lastRow) {
	                    return this._scrollTopRow;
	                }
	                return lastRow;
	            }
	            return keyword_null;
	        },
	        _getLastPageTopRow: function () {
	            var self = this;
	            if (self._getLastVisualRow() === self._getPageBottomRow()) {
	                var sheetLayout = self._getSheetLayout();
	                var rls = self._getRowLayout(1), length;
	                if (rls && (length = _ArrayHelper_getLength(rls)) >= 1) {
	                    var endRowLayout = rls[length - 1];
	                    if (endRowLayout.y + endRowLayout.height <= sheetLayout._viewportY + sheetLayout._viewportHeight) {
	                        return self._scrollTopRow;
	                    }
	                }
	            }
	            var catchTopRow = self._scrollTopRow;
	            try {
	                self._scrollTopRow = self._getLastVisualRow();
	                var lastPageTopRow = self._getPrevPageTopRow();
	                lastPageTopRow = self._getNextVisualRow(lastPageTopRow);
	                return lastPageTopRow;
	            } catch (e) {
	               
	            } finally {
	                self._scrollTopRow = catchTopRow;
	            }
	        },
	        _getLastPageLeftColumn: function () {
	            var self = this;
	            var sheetLayout;
	            if (self._getLastVisualColumn() === self._getPageRightColumn()) {
	                sheetLayout = self._getSheetLayout();
	                var rls = self._getColumnLayout(1), length;
	                if (rls && (length = _ArrayHelper_getLength(rls)) >= 1) {
	                    var endColLayout = rls[length - 1];
	                    if (endColLayout.x + endColLayout.width <= sheetLayout._viewportX + sheetLayout.width) {
	                        return self._scrollLeftCol;
	                    }
	                }
	            }
	            sheetLayout = self._getSheetLayout();
	            var width = 0;
	            var col = self._getLastVisualColumn();
	            while (col > 0) {
	                width += self._getZoomColumnWidth(col);
	                if (width > sheetLayout._viewportWidth) {
	                    break;
	                }
	                col--;
	            }
	            if (col > 0) {
	                col = self._getNextVisualColumn(col);
	            }
	            return col;
	        },
	        _getPageBottomRow: function () {
	            var rls = this._getRowLayout(1), length;
	            if (rls && (length = _ArrayHelper_getLength(rls)) > 0) {
	                return rls[length - 1].row;
	            }
	            return keyword_null;
	        },
	        _getPageRightColumn: function () {
	            var rls = this._getColumnLayout(1), length;
	            if (rls && (length = _ArrayHelper_getLength(rls)) > 0) {
	                return rls[length - 1].col;
	            }
	            return keyword_null;
	        },
	        _getLastFullyVisibleRow: function () {
	            var rls = this._getRowLayout(1), length;
	            if (rls && (length = _ArrayHelper_getLength(rls)) > 0) {
	                var layout = this._getSheetLayout();
	                var i = length - 1;
	                if (rls[i].y + rls[i].height <= layout._viewportY + layout._viewportHeight) {
	                    return rls[i].row;
	                }
	                return rls[Math_max(i - 1, 0)].row;
	            }
	            return keyword_null;
	        },
	        _getLastFullyVisibleColumn: function () {
	            var cls = this._getColumnLayout(1), length;
	            if (cls && (length = _ArrayHelper_getLength(cls)) > 0) {
	                var layout = this._getSheetLayout();
	                var i = length - 1;
	                if (cls[i].x + cls[i].width <= layout._viewportX + layout._viewportWidth) {
	                    return cls[i].col;
	                }
	                return cls[Math_max(i - 1, 0)].col;
	            }
	            return keyword_null;
	        },
	        _getLastVisualRow: function (sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var rowCount = getSheetRowCount(this, sheetArea);
	            if (sheetArea === 3  || sheetArea === 2 ) {
	                rowCount = rowCount - this.frozenTrailingRowCount();
	            }
	            return this._getPrevVisualRow(rowCount, sheetArea);
	        },
	        _getLastVisualColumn: function (sheetArea) {
	            if (isNullOrUndefined(sheetArea)) {
	                sheetArea = 3 ;
	            }
	            var colCount = getSheetColumnCount(this, sheetArea);
	            if (sheetArea === 3  || sheetArea === 1 ) {
	                colCount = colCount - this.frozenTrailingColumnCount();
	            }
	            return this._getPrevVisualColumn(colCount, sheetArea);
	        },
	        _inflateRangeToCoverSpans: function (spans, cellRange) {
	            if (spans) {
	                for (var i = 0, length = _ArrayHelper_getLength(spans); i < length; i++) {
	                    var cr = spans[i];
	                    if (cellRange.intersect(cr.row, cr.col, getRowCount(cr), getColCount(cr))) {
	                        spans.splice(i--, 1);
	                        return this._inflateRangeToCoverSpans(spans, cellRange.union(cr));
	                    }
	                }
	            }
	            return cellRange;
	        },
	        _getActiveSelectedRange: function (dir) {
	            var self = this, modelManager = self._modelManager,
	                selectionModelLength = _ArrayHelper_getLength(modelManager.getSelections());
	            var activeSelectedRange = createRange(-1, -1, 0, 0);
	            if (selectionModelLength <= 0) {
	                return activeSelectedRange;
	            }
	            var activeSelectedRangeIndex = modelManager.getActiveSelectedRangeIndex();
	            if (dir === 3 ) {
	                activeSelectedRangeIndex--;
	                if (activeSelectedRangeIndex < 0) {
	                    activeSelectedRangeIndex = selectionModelLength - 1;
	                }
	                modelManager.do('setActiveSelectedRangeIndex', activeSelectedRangeIndex);
	            } else if (dir === 4 ) {
	                activeSelectedRangeIndex++;
	                if (activeSelectedRangeIndex >= selectionModelLength) {
	                    activeSelectedRangeIndex = 0;
	                }
	                modelManager.do('setActiveSelectedRangeIndex', activeSelectedRangeIndex);
	            }
	
	            activeSelectedRangeIndex = modelManager.getActiveSelectedRangeIndex();
	            if (activeSelectedRangeIndex >= 0) {
	                activeSelectedRange = modelManager.getSelections()[activeSelectedRangeIndex];
	            }
	            return activeSelectedRange;
	        }
	    });
	   
	
	   
	    Worksheet._registerFeature('selection', {
	        init: function () {
	            this._modelManager.do('addSelection', 0, 0, 1, 1);
	        }
	    });
	   
	
	    module.exports = exports;
	
	}());

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var exports = __webpack_require__(1);
	    var Common = __webpack_require__(5);
	    var GC$ = __webpack_require__(4).GC$;
	    var util_common = __webpack_require__(3);
	    var Worksheet = __webpack_require__(17).Worksheet;
	
	    var DateTimeHelper_toOADate = Common._DateTimeHelper._toOADate;
	    var isNullOrUndefined = Common._Types._isNullOrUndefined;
	
	    var const_boolean = 'boolean', const_string = 'string', const_number = 'number';
	
	    function getSwapIndex(array, start, index) {
	        var t = array[index - start];
	        while (t < index) {
	            t = array[t - start];
	        }
	        return t;
	    }
	
	    function formatColor(color) {
	        return Common._ColorHelper._toString(Common._ColorHelper._fromString(color));
	    }
	
	    function isEquals(v1, v2) {
	        if (v1 instanceof Date && v2 instanceof Date) {
	            return DateTimeHelper_toOADate(v1) === DateTimeHelper_toOADate(v2);
	        } else if (typeof v1 === const_string && typeof v2 === const_string) {
	            return v1.toLowerCase() === v2.toLowerCase();
	        }
	        return v1 === v2;
	    }
	
	    function colorCompare(style1, style2, color, isBackColor) {
	        var ret = 0, color1, color2;
	        if (!isNullOrUndefined(style1)) {
	            color1 = isBackColor ? style1.backColor : style1.foreColor;
	            if(!isNullOrUndefined(color1)) {
	                color1 = formatColor(color1);
	            }
	        }
	        if (!isNullOrUndefined(style2)) {
	            color2 = isBackColor ? style2.backColor : style2.foreColor;
	            if(!isNullOrUndefined(color2)) {
	                color2 = formatColor(color2);
	        }
	        }
	        color1 = color1 || "";
	        color2 = color2 || "";
	        if (color1 === color2) {
	            ret = 0;
	        } else if (color1 === color) {
	            ret = 1;
	        } else if (color2 === color) {
	            ret = -1;
	        } else {
	            ret = 0;
	        }
	        return ret;
	    }
	
	    function isGreaterThan(v1, v2) {
	       
	       
	
	        if (v1 instanceof Date) {
	            v1 = DateTimeHelper_toOADate(v1);
	        }
	        if (v2 instanceof Date) {
	            v2 = DateTimeHelper_toOADate(v2);
	        }
	
	        var value1Type = typeof v1, value2Type = typeof v2;
	        var value1IsSting = value1Type === const_string,
	            value2IsString = value2Type === const_string, value2IsNumber = value2Type === const_number;
	        if (value1Type !== value2Type && (value1Type === const_number || value2IsNumber)) {
	            return value2IsNumber;
	        }
	        if (value1Type === const_boolean && value2IsString) {
	            return true;
	        }
	        if (value1IsSting && value2Type === const_boolean) {
	            return false;
	        }
	
	        if (value1IsSting && value2IsString) {
	            return v1.toLowerCase() > v2.toLowerCase();
	        }
	        return v1 > v2;
	    }
	
	    function sortCompare(x, y, sheet, byRows, sortInfo, cellValueCache) {
	        var ret = 0, x_sortInfo = sortInfo, x_index = x, y_index = y;
	        if (x_sortInfo) {
	            for (var i = 0; i < x_sortInfo.length; i++) {
	                if (x_sortInfo[i]) {
	                    var ascending = x_sortInfo[i].ascending;
	                    var index = x_sortInfo[i].index;
	                    if (0 <= index) {
	                        var value1, value2;
	                        var row1 = byRows ? x_index : index, column1 = byRows ? index : x_index,
	                            row2 = byRows ? y_index : index, column2 = byRows ? index : y_index;
	                        if (cellValueCache) {
	                            value1 = cellValueCache[row1][column1];
	                            value2 = cellValueCache[row2][column2];
	                        } else {
	                            value1 = sheet.getValue(row1, column1);
	                            value2 = sheet.getValue(row2, column2);
	                        }
	
	                        if (!isNullOrUndefined(x_sortInfo[i].color)) {
	                            var style1, style2;
	                            style1 = sheet.getActualStyle(row1, column1, 3 , false, false, true);
	                            style2 = sheet.getActualStyle(row2, column2, 3 , false, false, true);
	                            ret = colorCompare(style1, style2, x_sortInfo[i].color, x_sortInfo[i].isBackColor);
	                            if (!ascending) {
	                                ret = ret * -1;
	                            }
	                        } else {
	                            var value1IsNullOrEmptyOrNaN = isNullOrUndefined(value1) || value1 === '' || (typeof value1 === const_number && isNaN(value1)),
	                                value2IsNullOrEmptyOrNaN = isNullOrUndefined(value2) || value2 === '' || (typeof value2 === const_number && isNaN(value2));
	                            if (value1IsNullOrEmptyOrNaN || value2IsNullOrEmptyOrNaN) {
	                                if (value1IsNullOrEmptyOrNaN && value2IsNullOrEmptyOrNaN) {
	                                    ret = 0;
	                                } else if (value1IsNullOrEmptyOrNaN && !value2IsNullOrEmptyOrNaN) {
	                                    ret = 1;
	                                } else if (!value1IsNullOrEmptyOrNaN && value2IsNullOrEmptyOrNaN) {
	                                    ret = -1;
	                                }
	                            } else if (isEquals(value1, value2)) {
	                                ret = 0;
	                            } else if (isGreaterThan(value1, value2)) {
	                                ret = (ascending ? 1 : -1);
	                            } else {
	                                ret = (ascending ? -1 : 1);
	                            }
	                        }
	                    }
	                }
	                if (ret !== 0) {
	                    break;
	                }
	            }
	        }
	        return ret;
	    }
	
	    function quickSortImp(arr, sheet, byRows, sortInfo, cellValueCache) {
	        var arrLength = arr.length;
	        if (arrLength <= 1) {
	            return arr;
	        }
	        var pivotIndex = Math.floor(arrLength / 2);
	        var pivot = arr[pivotIndex];
	        var left = [];
	        var right = [];
	        var equal = [];
	        for (var i = 0; i < arrLength; i++) {
	            var compareResult = sortCompare(arr[i], pivot, sheet, byRows, sortInfo, cellValueCache);
	            if (compareResult < 0) {
	                left.push(arr[i]);
	            } else if (compareResult > 0) {
	                right.push(arr[i]);
	            } else {
	                equal.push(arr[i]);
	            }
	        }
	        return quickSortImp(left, sheet, byRows, sortInfo, cellValueCache).concat(equal, quickSortImp(right, sheet, byRows, sortInfo, cellValueCache));
	    }
	
	    function _quickSort(sheet, row, column, rowCount, columnCount, byRows, sortInfo, cellValueCache) {
	        var count = byRows ? rowCount : columnCount,
	            startIndex = byRows ? row : column;
	        var array = [];
	        var temp, i;
	        for (temp = 0; temp < count; temp++) {
	            array[temp] = startIndex + temp;
	        }
	        if (byRows) {
	            var filterOutRows = [];
	            for (i = array.length - 1; i >= 0; i--) {
	                var item = array[i];
	                if (sheet._isRowFilterOut && sheet._isRowFilterOut(item)) {
	                    array.splice(i, 1);
	                    filterOutRows.push({_index: i, _value: item});
	                }
	            }
	        }
	        array = quickSortImp(array, sheet, byRows, sortInfo, cellValueCache);
	        if (byRows) {
	            for (i = filterOutRows.length - 1; i >= 0; i--) {
	                var rowItem = filterOutRows[i];
	                array.splice(rowItem._index, 0, rowItem._value);
	            }
	        }
	        return array;
	    }
	
	    function beforeSwapCalcModel(calcModel, row, col) {
	        var cellCalc = calcModel._getCellCalc(row, col, false);
	        if (cellCalc && cellCalc.hasListeners()) {
	            cellCalc._addListenersToAdjust();
	        }
	    }
	
	    function afterSwapCalcModel(calcModel, row, col, changeInfo) {
	        var CalcEngine_module = __webpack_require__(2);
	        var CalcOperatorAdjustor = CalcEngine_module.CalcOperatorAdjustor;
	        var expr = CalcOperatorAdjustor._copyExpression(calcModel._source, calcModel._source, calcModel._getExpr(row, col), row, col, 0, 0);
	        calcModel._setExpr(row, col, expr, changeInfo);
	        var cellCalc = calcModel._getCellCalc(row, col, !!expr);
	        if (cellCalc) {
	            cellCalc._startListening();
	        }
	    }
	
	    GC$.extend(Worksheet.prototype, {
	       
	        
	        sortRange: function (row, column, rowCount, columnCount, byRows, sortInfo) {
	            var self = this;
	            var rowcnt = self.getRowCount();
	            var colcnt = self.getColumnCount();
	            if (exports._supportsCalc && !self._checkArrayFormula(row, 0, rowCount, colcnt, false)) {
	                return;
	            }
	           
	            var spans = self.getSpans(new util_common.Range(row, column, rowCount, columnCount));
	            if (spans && spans.length > 0) {
	                return false;
	            }
	
	           
	            var tableManager = self.tables, tableArray, hasOneWholeTable;
	            if (tableManager) {
	                tableArray = tableManager._findByRange(row, column, rowCount, columnCount);
	                hasOneWholeTable = tableArray.length === 1 && tableArray[0].dataRange().equals(util_common._createRange(row, column, rowCount, columnCount));
	                if (!(tableArray.length <= 0 || hasOneWholeTable)) {
	                    return false;
	                }
	            }
	
	            var bm = self._bindingManager;
	            var isBindingMode = (bm && bm._dataSource) || (hasOneWholeTable && tableArray[0] && tableArray[0]._getDataSource());
	
	           
	            if (row === -1) {
	                row = 0;
	            }
	            if (rowCount === -1) {
	                rowCount = rowcnt;
	            }
	            if (column === -1) {
	                column = 0;
	            }
	            if (columnCount === -1) {
	                columnCount = colcnt;
	            }
	           
	            if (row < 0 || row >= rowcnt || column < 0 || column >= colcnt ||
	                rowCount < 0 || row + rowCount > rowcnt || columnCount < 0 || column + columnCount > colcnt || !sortInfo) {
	                return false;
	            }
	            self.suspendPaint();
	            self.suspendEvent();
	            exports._supportsCalc && self.suspendCalcService();
	            try {
	                var changedCells = [], cellValueCache;
	                if (isBindingMode) {
	                   
	                    cellValueCache = [];
	                    for (var rIndex = row; rIndex < row + rowCount; rIndex++) {
	                        cellValueCache[rIndex] = [];
	                        for (var cIndex = column; cIndex < column + columnCount; cIndex++) {
	                            cellValueCache[rIndex][cIndex] = self.getValue(rIndex, cIndex);
	                        }
	                    }
	                }
	               
	                var array = _quickSort(self, row, column, rowCount, columnCount, byRows, sortInfo, cellValueCache);
	                if (array) {
	                    var modelrow, modelcol, modelrow2, modelcol2;
	                    var data1, data2, comment1, comment2;
	                    var modelManager = self._modelManager,
	                        calcModel = exports._supportsCalc && self._getCalcModel(),
	                        sheetSource = exports._supportsCalc && self._getSheetSource(),
	                        comments = modelManager._comments,
	                        viewIndex;
	                    var outerIndex, outerStartIndex = byRows ? row : column,
	                        outerEndIndex = byRows ? row + rowCount : column + columnCount;
	                    var innerIndex, innerStartIndex = byRows ? column : row,
	                        innerEndIndex = byRows ? column + columnCount : row + rowCount;
	                   
	                    for (outerIndex = outerStartIndex; outerIndex < outerEndIndex; outerIndex++) {
	                        viewIndex = getSwapIndex(array, outerStartIndex, outerIndex);
	                        if (outerIndex === viewIndex) {
	                            continue;
	                        }
	                        if (byRows) {
	                            modelrow = outerIndex;
	                            modelrow2 = viewIndex;
	                        } else {
	                            modelcol = outerIndex;
	                            modelcol2 = viewIndex;
	                        }
	                        for (innerIndex = innerStartIndex; innerIndex < innerEndIndex; innerIndex++) {
	                            if (byRows) {
	                                modelcol = innerIndex;
	                                modelcol2 = innerIndex;
	                            } else {
	                                modelrow = innerIndex;
	                                modelrow2 = innerIndex;
	                            }
	                            if (isBindingMode) {
	                                data1 = cellValueCache[modelrow][modelcol];
	                                data2 = cellValueCache[modelrow2][modelcol2];
	                            }
	                            if (comments) {
	                                comment1 = comments.get(modelrow, modelcol);
	                                comment2 = comments.get(modelrow2, modelcol2);
	                            }
	                            if (calcModel && sheetSource) {
	                                beforeSwapCalcModel(calcModel, modelrow, modelcol);
	                                beforeSwapCalcModel(calcModel, modelrow2, modelcol2);
	                               
	                                calcModel._swapNode(modelrow, modelcol, modelrow2, modelcol2);
	                                afterSwapCalcModel(calcModel, modelrow, modelcol);
	                                afterSwapCalcModel(calcModel, modelrow2, modelcol2);
	                            }
	                           
	                            modelManager.do('swapNode', modelrow, modelcol, modelrow2, modelcol2);
	                           
	                            self._validations && self._swapValidator(modelrow, modelcol, modelrow2, modelcol2);
	                            if (comments) {
	                               
	                               
	                               
	                                comments._swap(comment1, modelrow, modelcol, comment2, modelrow2, modelcol2);
	                            }
	                           
	                           
	                            if (isBindingMode) {
	                                cellValueCache[modelrow][modelcol] = data2;
	                                cellValueCache[modelrow2][modelcol2] = data1;
	                            }
	                            changedCells.push({row: modelrow, col: modelcol});
	                            changedCells.push({row: modelrow2, col: modelcol2});
	                        }
	                    }
	                    if (isBindingMode) {
	                       
	                        for (rIndex = row; rIndex < row + rowCount; rIndex++) {
	                            for (cIndex = column; cIndex < column + columnCount; cIndex++) {
	                                self.setValue(rIndex, cIndex, cellValueCache[rIndex][cIndex]);
	                            }
	                        }
	                        cellValueCache = null;
	                    }
	                    if (calcModel) {
	                        for (var rowIndex = row; rowIndex < row + rowCount; rowIndex++) {
	                            for (var colIndex = column; colIndex < column + columnCount; colIndex++) {
	                                var expression = calcModel._getExpr(rowIndex, colIndex);
	                                if (expression) {
	                                    calcModel._setExpression(rowIndex, colIndex, expression, undefined);
	                                }
	                            }
	                        }
	                        self.getCalcService().recalcRange(sheetSource, row, column, rowCount, columnCount);
	                    }
	                    Worksheet._callFeatureHandler(self, 'sortRangeChanged', {column: column, columnCount: columnCount});
	                    return true;
	                }
	                return false;
	            } finally {
	                exports._supportsCalc && self.resumeCalcService(false);
	                self.resumeEvent();
	                self.resumePaint();
	               
	               
	               
	               
	               
	                self._raiseRangeDataChanged(row, column, rowCount, columnCount, changedCells, 4 );
	
	            }
	
	
	        },
	        _canDoSort: function () {
	            var options = this.options;
	            return !options.isProtected || options.protectionOptions.allowSort;
	        },
	        _swapValidator: function (fromRow, fromCol, toRow, toCol) {
	            var self = this,
	                validator1 = self.getDataValidator(fromRow, fromCol),
	                validator2 = self.getDataValidator(toRow, toCol);
	
	            self.setDataValidator(fromRow, fromCol, validator2);
	            self.setDataValidator(toRow, toCol, validator1);
	        }
	    });
	
	    module.exports = exports;
	
	}());

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var exports = __webpack_require__(1);
	    var Worksheet = __webpack_require__(17).Worksheet;
	    var Style = __webpack_require__(12).Style;
	    var $ = __webpack_require__(4).GC$;
	    var Range = __webpack_require__(3).Range;
	    var isNullOrUndefined = __webpack_require__(5)._Types._isNullOrUndefined;
	
	    var sheetPrototype = Worksheet.prototype;
	
	    function defProperty(getCallback, setCallback) {
	        var getFn = getCallback, setFn = setCallback;
	        return function (value) {
	            var self = this, sheet = self.sheet, row = self.row, col = self.col, sheetArea = self.sheetArea;
	            if (arguments.length === 0) {
	                return getFn.call(sheet, row, col, sheetArea);
	            }
	
	            if (row >= 0 && col >= 0) {
	                for (var r = row; r < row + self.rowCount; r++) {
	                    for (var c = col; c < col + self.colCount; c++) {
	                        if (isValidIndex(sheet, r, c, sheetArea)) {
	                            setFn.call(sheet, r, c, value, sheetArea);
	                        }
	                    }
	                }
	            }
	            return self;
	        };
	    }
	
	    function isValidIndex(sheet, row, col, sheetArea) {
	        var rowCount = sheet.getRowCount(sheetArea);
	        var colCount = sheet.getColumnCount(sheetArea);
	        return ((col < 0 && 0 <= row && row < rowCount) ||
	        (row < 0 && 0 <= col && col < colCount) ||
	        (0 <= row && row < rowCount && 0 <= col && col < colCount));
	    }
	
	   
	   
	    
	    function CellRange(sheet, row, col, rowCount, colCount, sheetArea) {
	        var self = this;
	        if (row < 0) {
	            row = rowCount = -1;
	        }
	        if (col < 0) {
	            col = colCount = -1;
	        }
	       
	        
	        self.sheet = sheet;
	       
	        
	        self.row = row;
	       
	        
	        self.rowCount = isNullOrUndefined(rowCount) ? 1 : rowCount;
	       
	        
	        self.col = col;
	       
	        
	        self.colCount = isNullOrUndefined(colCount) ? 1 : colCount;
	       
	        
	        self.sheetArea = isNullOrUndefined(sheetArea) ? 3  : sheetArea;
	    }
	
	    function _setCellStyle(sheet, r, c, propertyName, value, sheetArea) {
	        if (isValidIndex(sheet, r, c, sheetArea)) {
	            var style = sheet._getStyleImp(r, c, sheetArea);
	            if (!style) {
	                style = new Style();
	            }
	            style[propertyName] = value;
	            sheet.setStyle(r, c, style, sheetArea);
	        }
	    }
	
	    var CellRange_prototype = CellRange.prototype = {
	        constructor: CellRange,
	       
	        
	        value: defProperty(sheetPrototype.getValue, sheetPrototype.setValue),
	       
	        
	        text: defProperty(sheetPrototype.getText, sheetPrototype.setText),
	       
	        
	        formula: defProperty(function (row, col) {
	            return exports._supportsCalc && this.getFormula(row, col);
	        }, function (row, col, formula, sheetArea) {
	            exports._supportsCalc && this.setFormula(row, col, formula, sheetArea);
	        }),
	       
	        
	        tag: function (value) {
	            var self = this, sheet = self.sheet, row = self.row, col = self.col,
	                rowCount = self.rowCount, colCount = self.colCount, sheetArea = self.sheetArea,
	                r, c;
	            if (arguments.length === 0) {
	                return sheet.getTag(row, col, sheetArea);
	            }
	
	            if (row >= 0 && col >= 0) {
	                for (r = row; r < row + rowCount; r++) {
	                    for (c = col; c < col + colCount; c++) {
	                        sheet.setTag(r, c, value, sheetArea);
	                    }
	                }
	            } else if (row >= 0) {
	                for (r = row; r < row + rowCount; r++) {
	                    sheet.setTag(r, -1, value, sheetArea);
	                }
	            } else if (col >= 0) {
	                for (c = col; c < col + colCount; c++) {
	                    sheet.setTag(-1, c, value, sheetArea);
	                }
	            }
	            return self;
	        },
	       
	        
	        width: function (value) {
	            var self = this, sheet = self.sheet, row = self.row, col = self.col, sheetArea = self.sheetArea;
	            if (arguments.length === 0) {
	                if (row < 0) {
	                    return sheet.getColumnWidth(col, sheetArea);
	                }
	            } else {
	                if (row < 0) {
	                    for (var c = 0; c < self.colCount; c++) {
	                        sheet.setColumnWidth(c + col, value, sheetArea);
	                    }
	                }
	                return self;
	            }
	        },
	       
	        
	        height: function (value) {
	            var self = this, sheet = self.sheet, row = self.row, col = self.col, sheetArea = self.sheetArea;
	            if (arguments.length === 0) {
	                if (col < 0) {
	                    return sheet.getRowHeight(row, sheetArea);
	                }
	            } else {
	                if (col < 0) {
	                    for (var r = 0; r < self.rowCount; r++) {
	                        sheet.setRowHeight(r + row, value, sheetArea);
	                    }
	                }
	                return self;
	            }
	        },
	       
	        
	        visible: function (value) {
	            var self = this, sheet = self.sheet, row = self.row, col = self.col, sheetArea = self.sheetArea;
	            if (arguments.length === 0) {
	                if (col < 0 && row >= 0) {
	                    return sheet.getRowVisible(row, sheetArea);
	                } else if (col >= 0 && row < 0) {
	                    return sheet.getColumnVisible(col, sheetArea);
	                }
	            } else {
	                if (col < 0 && row >= 0) {
	                    for (var r = 0; r < self.rowCount; r++) {
	                        sheet.setRowVisible(r + row, value, sheetArea);
	                    }
	                } else if (col >= 0 && row < 0) {
	                    for (var c = 0; c < self.colCount; c++) {
	                        sheet.setColumnVisible(c + col, value, sheetArea);
	                    }
	                }
	                return self;
	            }
	        },
	       
	        
	        resizable: function (value) {
	            var self = this, sheet = self.sheet, row = self.row, col = self.col, sheetArea = self.sheetArea;
	            if (arguments.length === 0) {
	                if (col < 0 && row >= 0) {
	                    return sheet.getRowResizable(row, sheetArea);
	                } else if (col >= 0 && row < 0) {
	                    return sheet.getColumnResizable(col, sheetArea);
	                }
	            } else {
	                if (col < 0 && row >= 0) {
	                    for (var r = 0; r < self.rowCount; r++) {
	                        sheet.setRowResizable(r + row, value, sheetArea);
	                    }
	                } else if (col >= 0 && row < 0) {
	                    for (var c = 0; c < self.colCount; c++) {
	                        sheet.setColumnResizable(c + col, value, sheetArea);
	                    }
	                }
	                return self;
	            }
	        },
	        _getStyleProperty: function (propertyName) {
	            var self = this;
	            return self.sheet._getStyleProperty(self.row, self.col, propertyName, self.sheetArea);
	        },
	        _setStyleProperty: function (propertyName, value) {
	            var self = this, r, c, sheet = self.sheet, row = self.row, col = self.col, rowCount = self.rowCount, colCount = self.colCount, sheetArea = self.sheetArea;
	            if (row >= 0 && col >= 0) {
	                for (r = row; r < row + rowCount; r++) {
	                    for (c = col; c < col + colCount; c++) {
	                        _setCellStyle(sheet, r, c, propertyName, value, sheetArea);
	                    }
	                }
	            } else if (row >= 0) {
	                c = -1;
	                for (r = row; r < row + rowCount; r++) {
	                    _setCellStyle(sheet, r, c, propertyName, value, sheetArea);
	                }
	            } else if (col >= 0) {
	                r = -1;
	                for (c = col; c < col + colCount; c++) {
	                    _setCellStyle(sheet, r, c, propertyName, value, sheetArea);
	                }
	            }
	            return self;
	        },
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	        styleName: defProperty(sheetPrototype.getStyleName, sheetPrototype.setStyleName),
	       
	        
	        clear: function (type) {
	            var self = this;
	            self.sheet.clear(self.row, self.col, self.rowCount, self.colCount, self.sheetArea, type);
	        },
	       
	        
	        setBorder: function (border, option) {
	            var self = this;
	            var sheet = self.sheet, sheetArea = self.sheetArea;
	            sheet.suspendPaint();
	            try {
	                var cellRange = new Range(self.row, self.col, self.rowCount, self.colCount);
	                var actualRange = sheet._getActualRange(cellRange, sheetArea);
	                var row = actualRange.row;
	                var col = actualRange.col;
	                var rowCount = actualRange.rowCount;
	                var colCount = actualRange.colCount;
	                var r, c;
	                var all = option.all, outline = option.outline, inside = option.inside;
	                if (option.left || all || outline) {
	                    for (r = 0; r < rowCount; r++) {
	                        sheet.getCell(row + r, col, sheetArea).borderLeft(border);
	                    }
	                }
	                if (option.top || all || outline) {
	                    for (c = 0; c < colCount; c++) {
	                        sheet.getCell(row, col + c, sheetArea).borderTop(border);
	                    }
	                }
	                if (option.right || all || outline) {
	                    for (r = 0; r < rowCount; r++) {
	                        sheet.getCell(row + r, col + colCount - 1, sheetArea).borderRight(border);
	                    }
	                }
	                if (option.bottom || all || outline) {
	                    for (c = 0; c < colCount; c++) {
	                        sheet.getCell(row + rowCount - 1, col + c, sheetArea).borderBottom(border);
	                    }
	                }
	                if (option.diagonalUp) {
	                    for (r = 0; r < rowCount; r++) {
	                        for (c = 0; c < colCount; c++) {
	                            sheet.getCell(row + r, col + c, sheetArea).diagonalUp(border);
	                        }
	                    }
	                }
	                if (option.diagonalDown) {
	                    for (r = 0; r < rowCount; r++) {
	                        for (c = 0; c < colCount; c++) {
	                            sheet.getCell(row + r, col + c, sheetArea).diagonalDown(border);
	                        }
	                    }
	                }
	                if (option.innerHorizontal || all || inside) {
	                    for (r = 0; r < rowCount - 1; r++) {
	                        for (c = 0; c < colCount; c++) {
	                            sheet.getCell(row + r, col + c, sheetArea).borderBottom(border);
	                            sheet.getCell(row + r + 1, col + c, sheetArea).borderTop(border);
	                        }
	                    }
	                }
	                if (option.innerVertical || all || inside) {
	                    for (c = 0; c < colCount - 1; c++) {
	                        for (r = 0; r < rowCount; r++) {
	                            sheet.getCell(row + r, col + c, sheetArea).borderRight(border);
	                            sheet.getCell(row + r, col + c + 1, sheetArea).borderLeft(border);
	                        }
	                    }
	                }
	            } finally {
	                sheet.resumePaint();
	            }
	        }
	    };
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	    $.each(['backColor', 'foreColor', 'hAlign', 'vAlign', 'themeFont', 'font', 'formatter', 'borderLeft', 'borderTop',
	        'borderRight', 'borderBottom', 'diagonalDown', 'diagonalUp', 'locked', 'textIndent', 'wordWrap', 'shrinkToFit', 'backgroundImage', 'backgroundImageLayout',
	        'cellType', 'tabStop', 'textDecoration', 'imeMode', 'watermark', 'cellPadding', 'labelOptions', 'quotePrefix', 'isVerticalText'], function (i, p) {
	        CellRange_prototype[p] = function (value) {
	            return arguments.length === 0 ? this._getStyleProperty(p) : this._setStyleProperty(p, value);
	        };
	    });
	
	    CellRange._defProperty = defProperty;
	    exports.CellRange = CellRange;
	   
	
	   
	    $.extend(sheetPrototype, {
	       
	        
	        getRange: function (row, col, rowCount, colCount, sheetArea) {
	            return new CellRange(this, row, col, rowCount, colCount, sheetArea);
	        },
	       
	        
	        getCell: function (row, col, sheetArea) {
	            if (isNullOrUndefined(col)) {
	                col = -1;
	            }
	            return new CellRange(this, row, col, 1, 1, sheetArea);
	        }
	    });
	   
	
	   
	    
	
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	    
	   
	    
	   
	    
	   
	    
	   
	    
	
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	   
	    
	
	    module.exports = exports;
	
	}());

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var exports = __webpack_require__(1);
	    var $ = __webpack_require__(4).GC$;
	    var util_common = __webpack_require__(3);
	    var CalcEngine = __webpack_require__(2);
	    var NameInfo = __webpack_require__(21).NameInfo;
	    var Workbook = __webpack_require__(22).Workbook;
	    var Common = __webpack_require__(5);
	    var toUpperCase = Common._StringHelper._toUpperCase;
	    var sR = function () {
	        return Common._getResource(exports.SR)();
	    };
	    var keyword_undefined = void 0, keyword_null = null;
	    var workbookEx = {
	        _initCalcService: function (cloneOldState) {
	            var self = this;
	            var oldService = self._calcService;
	            self._calcService = new CalcEngine.CalcService();
	            if (cloneOldState && oldService) {
	                self._calcService.cloneFrom(oldService);
	            }
	            self._spreadSource = new exports.CalcEngine.SpreadSource(self);
	            self._spreadSourceModel = self._calcService.getGlobalSourceModel(self._spreadSource);
	        },
	       
	        
	        addCustomFunction: function (fn) {
	            this._addCustomFunctionCore(fn);
	        },
	        _addCustomFunctionCore: function (fn) {
	            if (!fn || !(fn instanceof CalcEngine.Functions.Function)) {
	                throw new Error(sR.Exp_InvalidCustomFunction);
	            }
	            this._functions[toUpperCase(fn.name)] = fn;
	        },
	       
	        
	        getCustomFunction: function (name) {
	            return name ? this._functions[toUpperCase(name)] : keyword_undefined;
	        },
	       
	        
	        removeCustomFunction: function (name) {
	            if (name) {
	                delete this._functions[toUpperCase(name)];
	                this._recalcAll();
	            }
	        },
	       
	        
	        clearCustomFunctions: function () {
	            this._functions = {};
	        },
	       
	        
	        addCustomName: function (name, formula, baseRow, baseCol, comment) {
	            this._addCustomNameCore(name, formula, baseRow, baseCol, false, comment);
	        },
	        _isUniqueCustomName: function (name) {
	            return !this._nameInfos[toUpperCase(name)];
	        },
	        isValidCustomName: function(name) {
	            return name && util_common._util._isValidCustomName(name) && this._isUniqueCustomName(name);
	        },
	        _addCustomNameCore: function (name, formula, baseRow, baseCol, ignoreError, comment) {
	            var self = this;
	            if (!name || !formula || (!ignoreError && !self.isValidCustomName(name))) {
	                throw new Error(sR().Exp_InvalidCustomName);
	            }
	            if (self._calcService) {
	                var sheet = this.getActiveSheet();
	                var source = sheet ? sheet._getSheetSource() : keyword_null;
	                var expr;
	                if (ignoreError) {
	                    try {
	                        expr = self._calcService.parse(source, formula, baseRow, baseCol, false, false, true);
	                    } catch (ex) {
	                    }
	                } else {
	                    expr = self._calcService.parse(source, formula, baseRow, baseCol);
	                }
	                self._nameInfos[toUpperCase(name)] = new NameInfo(name, expr, baseRow, baseCol, comment);
	                if (!ignoreError) {
	                    var names = {};
	                    names[name] = name;
	                    this._updateCalc(names, true);
	                }
	            }
	        },
	       
	        
	        getCustomName: function (name) {
	            return name ? this._nameInfos[toUpperCase(name)] : keyword_undefined;
	        },
	       
	        
	        getCustomNames: function () {
	            var result = [];
	            $.each(this._nameInfos, function (p, v) {
	                result.push(v);
	            });
	            return result;
	        },
	       
	        
	        removeCustomName: function (name) {
	            if (name) {
	                delete this._nameInfos[toUpperCase(name)];
	                var names = {};
	                names[name] = name;
	                this._updateCalc(names, false);
	            }
	        },
	       
	        
	        clearCustomNames: function () {
	            var names = this._nameInfos;
	            this._nameInfos = {};
	            this._updateCalc(names, false);
	        },
	        _updateCalc: function (names, start) {
	            if (!names || names.length === 0) {
	                return;
	            }
	            var calcModel = this._spreadSourceModel;
	            for (var name in names) {
	                if (calcModel) {
	                    calcModel.updateNameCalc(name, start);
	                }
	            }
	            this._recalcAll();
	        },
	        _recalcAll: function () {
	            if (this._calcService && !this._calcService.IsSuspended()) {
	                var sheet = this.getActiveSheet();
	                if (sheet) {
	                    sheet.suspendPaint();
	                    this._calcService.recalculateAll();
	                    sheet.resumePaint();
	
	                }
	            }
	        },
	        
	        getCalcService: function () {
	            return this._calcService;
	        },
	        _getCalcServiceInternal: function () {
	            return this._calcService;
	        },
	       
	        
	        suspendCalcService: function (ignoreDirty) {
	            if (this._calcService) {
	                this._calcService.suspend(ignoreDirty);
	            }
	        },
	       
	        
	        resumeCalcService: function (recalcAll) {
	            if (this._calcService) {
	                this._calcService.resume(recalcAll);
	            }
	        }
	    };
	
	    $.extend(Workbook.prototype, workbookEx);
	
	   
	    Workbook._registerFeature('calc', {
	        priority: 1000,
	        init: function () {
	            this._functions = {};
	            this._nameInfos = {};
	        },
	        toJson: function (data) {
	            var self = this;
	           
	            var functions = self._functions;
	            if (!$.isEmptyObject(functions)) {
	                data.customFunctions = functions;
	            }
	           
	            var names = [], sheetNames = self.getCustomNames(), calcService = self._calcService;
	            if (sheetNames && calcService) {
	                $.each(sheetNames, function (i, ni) {
	                    var name = ni.getName(), row = ni.getRow(), col = ni.getColumn(), expr = ni.getExpression(),
	                        comment = ni.getComment();
	                    var f = calcService.unparse(null, expr, row, col, false, true);
	                    var nameProperty = {name: name, formula: f, row: row, col: col};
	                    if (comment) {
	                        nameProperty.comment = comment;
	                    }
	                    names.push(nameProperty);
	                });
	                if (names.length > 0) {
	                    data['names'] = names;
	                }
	            }
	        },
	        fromJson: function (workbookData, noSchema, deserializationOptions) {
	            var self = this;
	            var calcService = self._calcService;
	            if (calcService) {
	                calcService.suspend();
	            }
	           
	            self.clearCustomNames();
	            var names = workbookData.names;
	            if (names) {
	                for (var n = 0; n < names.length; n++) {
	                    var ni = names[n];
	                    self._addCustomNameCore(ni.name, ni.formula, ni.row, ni.col, true, ni.comment);
	                }
	            }
	           
	            self.clearCustomFunctions();
	            var customFunctions = workbookData.customFunctions;
	            if (customFunctions) {
	                for (var func in customFunctions) {
	                    if (customFunctions.hasOwnProperty(func)) {
	                        var funcJsonData = customFunctions[func];
	                        var customFunctionClass = util_common.getTypeFromString(funcJsonData.typeName);
	                        if (customFunctionClass) {
	                            var customFunc = new customFunctionClass();
	                            customFunc.fromJSON(funcJsonData, noSchema);
	                            self._addCustomFunctionCore(customFunc);
	                        }
	                    }
	                }
	            }
	
	           
	            var i, sheet, sheetsData = workbookData.sheets, sheets = [];
	            if (sheetsData) {
	                i = 0;
	                for (var sh in sheetsData) {
	                    if (typeof (sh) === 'string') {
	                        var sheetObj = sheetsData[sh];
	                        sheet = self.getSheetFromName(sheetObj.name || sh);
	                        sheets.push(sheet);
	                        sheet.nameFunctionsFromJSON(sheetObj, noSchema, deserializationOptions);
	                        i++;
	                    }
	                }
	                for (i = 0; i < sheets.length; i++) {
	                    sheets[i].formulaFromJSON(sheetsData[sheets[i].name()], noSchema, deserializationOptions);
	                }
	            }
	
	            if (calcService) {
	                if (workbookData.noRecalc || (deserializationOptions && deserializationOptions.doNotRecalculateAfterLoad)) {
	                    calcService.resumeWithoutCalc();
	                } else {
	                    calcService.resume(true);
	                }
	            }
	        }
	    });
	    module.exports = exports;
	
	}());

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var exports = __webpack_require__(1);
	    var Workbook = __webpack_require__(22).Workbook,
	        Style = __webpack_require__(12).Style,
	        $ = __webpack_require__(4).GC$,
	        util_common = __webpack_require__(3),
	        CultureManager = __webpack_require__(5).CultureManager;
	    var Commands = __webpack_require__(23);
	    var UndoManager = Commands.UndoManager;
	
	    var Workbook_features = Workbook._features,
	        $_each = $.each,
	        isDefined = util_common._util._isDefined;
	
	    var convertToFloat = parseFloat;
	
	    function hasOwnProperty(obj, prop) {
	        return obj.hasOwnProperty(prop);
	    }
	
	    function _getJsonDataVersion(version) {
	        if (!version || typeof version !== 'string') {
	            return 1.0;
	        }
	        var versionInfo = version.split('.'), length = versionInfo.length;
	       
	        if (length > 3) {
	            return 3.0;
	        }
	       
	        var mjaorVersion = convertToFloat(versionInfo[0]);
	        if (length <= 2) {
	            if (isNaN(mjaorVersion)) {
	                return 1.0;
	            }
	            return mjaorVersion;
	        }
	        var yearVersion = convertToFloat(versionInfo[1]);
	        if (mjaorVersion >= 10.0) {
	            return mjaorVersion;
	        } else if (mjaorVersion >= 3.0) {
	            if (yearVersion >= 20143) {
	                return 3.0;
	            } else if (yearVersion >= 20142) {
	                return 2.0;
	            }
	        }
	        return 1.0;
	    }
	
	    function _processFrozenLinesAsHeaders(workbookData, deserializationOptions) {
	        var self = this;
	        var frozenColumnsAsRowHeaders = deserializationOptions && deserializationOptions.frozenColumnsAsRowHeaders;
	        var frozenRowsAsColumnHeaders = deserializationOptions && deserializationOptions.frozenRowsAsColumnHeaders;
	        var i = 0, sheet, sheets = workbookData.sheets;
	        if ((frozenRowsAsColumnHeaders || frozenColumnsAsRowHeaders)) {
	            for (var s in sheets) {
	                if (typeof (s) === 'string') {
	                    var sheetData = sheets[s];
	                    var index = isDefined(sheetData.index) ? sheetData.index : sheetData._index;
	                    sheet = self.sheets[isDefined(index) ? index : i];
	                    if (frozenRowsAsColumnHeaders) {
	                        sheet.deleteRows(0, sheetData.frozenRowCount);
	                    }
	                    if (frozenColumnsAsRowHeaders) {
	                        sheet.deleteColumns(0, sheetData.frozenColCount);
	                    }
	                    i++;
	                }
	            }
	        }
	    }
	
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	
	    $.extend(Workbook.prototype, {
	       
	        
	        toJSON: function (serializationOption) {
	            var toJsonSpread = this;
	            var sdata = {version: util_common.productInfo.productVersion};
	
	            var rowHeadersAsFrozenColumns = serializationOption && serializationOption.rowHeadersAsFrozenColumns;
	            var columnHeadersAsFrozenRows = serializationOption && serializationOption.columnHeadersAsFrozenRows;
	            var needCloneSpread = rowHeadersAsFrozenColumns || columnHeadersAsFrozenRows;
	            if (needCloneSpread) {
	                var cloneSpread = new Workbook();
	                cloneSpread.fromJSON(toJsonSpread.toJSON({includeBindingSource: true}));
	                toJsonSpread = cloneSpread;
	            }
	
	            toJsonSpread._suspendSetFocus = true;
	            toJsonSpread.suspendPaint();
	            toJsonSpread.suspendEvent();
	            exports._supportsCalc && toJsonSpread._calcService.suspend(true);
	
	            var startSheetIndex = toJsonSpread.startSheetIndex();
	            if (startSheetIndex) {
	                sdata.startSheetIndex = startSheetIndex;
	            }
	           
	            $_each(toJsonSpread.options, function (i, p) {
	                if (i !== '_ps' && Workbook._defaultOptions[i] !== p) {
	                    sdata[i] = p;
	                }
	            });
	
	            var sheetCount = toJsonSpread.getSheetCount();
	            if (sheetCount !== Workbook._defaultSheetCount) {
	                sdata.sheetCount = sheetCount;
	            }
	            var activeSheetIndex = toJsonSpread.getActiveSheetIndex();
	            if (activeSheetIndex !== Workbook._defaultActiveSheetIndex) {
	                sdata.activeSheetIndex = activeSheetIndex;
	            }
	           
	            var sheets = {};
	            for (var j = 0; j < sheetCount; j++) {
	                var sheet = toJsonSpread.getSheet(j);
	                sheets[sheet.name()] = sheet.toJSON(serializationOption);
	                sheets[sheet.name()].index = j;
	            }
	            if (!$.isEmptyObject(sheets)) {
	                sdata.sheets = sheets;
	            }
	           
	            var namedStyles = [], workbookNamedStyles = toJsonSpread._namedStyles;
	            if (workbookNamedStyles) {
	                for (var namedStyle in workbookNamedStyles) {
	                    if (hasOwnProperty(workbookNamedStyles, namedStyle)) {
	                        namedStyles.push(workbookNamedStyles[namedStyle]);
	                    }
	                }
	                if (namedStyles.length > 0) {
	                    sdata.namedStyles = namedStyles;
	                }
	            }
	
	           
	            if (Workbook_features) {
	                $_each(Workbook_features, function (n, f) {
	                    if (f.toJson) {
	                        f.toJson.call(toJsonSpread, sdata, serializationOption);
	                    }
	                });
	            }
	            toJsonSpread._suspendSetFocus = false;
	            exports._supportsCalc && toJsonSpread._calcService.resume(false);
	            toJsonSpread.resumeEvent();
	            toJsonSpread.resumePaint();
	
	            return sdata;
	        },
	       
	        
	        fromJSON: function (workbookData, deserializationOptions) {
	            if (!workbookData) {
	                return;
	            }
	            var self = this;
	            var jsonVersion = _getJsonDataVersion(workbookData.version);
	            var noSchema = jsonVersion < 3.0;
	            var versionInfo = {noSchema: noSchema, version: jsonVersion};
	            var oldActiveElement = util_common._FocusHelper._getActiveElement();
	            self._suspendSetFocus = true;
	            self.suspendPaint();
	            self.suspendEvent();
	            var oldCulture = CultureManager.culture();
	            CultureManager.culture('');
	            try {
	                self._initOptions();
	               
	                self._undoManager = new UndoManager(self, -1, self.options.allowUndo);
	
	                exports._supportsCalc && self._initCalcService(true);
	                exports._supportsCalc && self._calcService.suspendAdjust();
	                self._availableSheetIndex = -1;
	                self.clearSheets();
	               
	                var options = self.options;
	                var workbookData_canUserEditFormula = workbookData.canUserEditFormula;
	                if (isDefined(workbookData_canUserEditFormula)) {
	                    options.allowUserEditFormula = workbookData_canUserEditFormula;
	                }
	                var workbookData_allowDragDrop = workbookData.allowDragDrop;
	                if (isDefined(workbookData_allowDragDrop)) {
	                    options.allowUserDragDrop = workbookData_allowDragDrop;
	                }
	                var workbookData_allowDragFill = workbookData.allowDragFill;
	                if (isDefined(workbookData_allowDragFill)) {
	                    options.allowUserDragFill = workbookData_allowDragFill;
	                }
	
	                for (var op in options) {
	                    if (hasOwnProperty(options, op)) {
	                        var value = workbookData[op];
	                        if (isDefined(value)) {
	                            options[op] = value;
	                        }
	                    }
	                }
	                var sheetCount = workbookData.sheetCount;
	                if (!isDefined(sheetCount)) {
	                    sheetCount = Workbook._defaultSheetCount;
	                }
	                self._setSheetCountImp(sheetCount, 0 );
	               
	                self._namedStyles = {};
	                var workbookData_namedStyles = workbookData.namedStyles;
	                if (workbookData_namedStyles) {
	                    for (var ns_index = 0; ns_index < workbookData_namedStyles.length; ns_index++) {
	                        var item = workbookData_namedStyles[ns_index];
	                        var style = new Style();
	                        style.fromJSON(item, noSchema);
	                        self._addNamedStyleImp(style);
	                    }
	                }
	               
	                var i = 0, sheet, sheets = workbookData.sheets, allowUndo, sheetData_allowUndo,
	                    allowUndoHasValue = false, allowUndoAreEqual = true;
	                if (sheets) {
	                   
	                   
	                   
	                   
	                   
	                    for (var s in sheets) {
	                        if (typeof (s) === 'string') {
	                            var sheetData = sheets[s];
	                            var index = isDefined(sheetData.index) ? sheetData.index : sheetData._index;
	                            sheet = self.sheets[isDefined(index) ? index : i];
	                            sheet.fromJSON(sheetData, false, versionInfo, deserializationOptions, true);
	                            i++;
	
	                            sheetData_allowUndo = sheetData.allowUndo;
	                            if (!allowUndoHasValue) {
	                                allowUndo = sheetData_allowUndo;
	                                allowUndoHasValue = true;
	                            } else {
	                                allowUndoAreEqual = allowUndoAreEqual && (sheetData_allowUndo === allowUndo);
	                            }
	                        }
	                    }
	                }
	
	                if (isDefined(allowUndo) && allowUndoAreEqual) {
	                    options.allowUndo = allowUndo;
	                }
	
	                var activeSheetIndex = workbookData.activeSheetIndex;
	                if (!isDefined(activeSheetIndex)) {
	                    activeSheetIndex = Workbook._defaultActiveSheetIndex;
	                }
	                self._setActiveSheetIndexImp(activeSheetIndex, 0 );
	                var workbookData_startSheetIndex = workbookData.startSheetIndex;
	                if (isDefined(workbookData_startSheetIndex)) {
	                    self.startSheetIndex(workbookData_startSheetIndex);
	                }
	
	               
	                if (Workbook_features) {
	                    $_each(Workbook_features, function (n, f) {
	                        var t = f.fromJson;
	                        if (t) {
	                            t.call(self, workbookData, noSchema, deserializationOptions);
	                        }
	                    });
	                }
	               
	               
	               
	               
	               
	               
	                exports._supportsCalc && self._calcService.resumeAdjust();
	                _processFrozenLinesAsHeaders.call(self, workbookData, deserializationOptions);
	            } finally {
	                exports._supportsCalc && self._calcService.resumeAdjust();
	                CultureManager.culture(oldCulture);
	                self._suspendSetFocus = false;
	                var activeSheet = self.getActiveSheet();
	                if (oldActiveElement && activeSheet) {
	                    activeSheet._setFocus();
	                }
	                self.resumeEvent();
	                self._doResize();
	                self.resumePaint();
	               
	                if (activeSheet) {
	                   
	                    self._trigger(util_common.Events.FormulatextboxActiveSheetChanged, {
	                        oldSheet: undefined,
	                        newSheet: activeSheet
	                    });
	                }
	               
	            }
	        }
	    });
	
	
	}());

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var Worksheet = __webpack_require__(17).Worksheet;
	    var $ = __webpack_require__(4).GC$;
	    var util_common = __webpack_require__(3);
	    var CellTypes_Module = __webpack_require__(13).CellTypes;
	    var Common = __webpack_require__(5);
	
	    var exports = __webpack_require__(1);
	    if (!exports.CellTypes) {
	        exports.CellTypes = {};
	    }
	    var CellTypes = exports.CellTypes;
	
	    var isNullOrUndefined = Common._Types._isNullOrUndefined;
	    var _WordWrapHelper = util_common._WordWrapHelper;
	    var Events_EditChange = util_common.Events.EditChange;
	    var _FocusHelper = util_common._FocusHelper;
	    var util_common_util = util_common._util;
	    var createElement = util_common_util._createElement;
	    var browser = util_common_util._browser, browser_msie = browser.msie,
	        browser_edge = browser.edge, browser_chrome = browser.chrome;
	    var cancelDefault = util_common_util._cancelDefault;
	    var getHAlignByValueType = util_common_util._getHAlignByValueType;
	    var formatValue2Text = util_common_util._formatValue2Text;
	    var getPreferredZIndex = util_common_util._getPreferredZIndex;
	    var util_device = util_common_util._device();
	    var getFontHeight = util_common_util._getFontHeight;
	    var getTextHeight = util_common_util._getTextHeight;
	    var BaseCellType = CellTypes_Module.Base;
	    var CellTypeContext = CellTypes_Module.Context;
	    var replaceSpaceChar = util_common_util._replaceSpaceChar;
	    var adjustFontWithFallback = util_common_util._adjustFontWithFallback;
	    var convertRichTextValue = util_common_util._convertRichTextValue;
	
	    var cssLeft = 'left', cssRight = 'right', cssCenter = 'center',
	        attrGcUIElement = 'gcUIElement', cssNone = 'none', _gcEditingInput = '.gcEditingInput', cssWidth = 'width',
	        cssHeight = 'height', cssTextAlign = 'text-align', cssHidden = 'hidden', cssWordWrap = 'word-wrap',
	        cssOverflow = 'overflow',
	        cssNormal = 'normal', cssBreakWord = 'break-word', cssOverflowY = 'overflow-y', cssScroll = 'scroll',
	        cssWordBreak = 'word-break', cssFloat = 'float', WINDOW = window,
	        DOCUMENT = document;
	    var WATERMARK_OPACITY = 0.337;
	    var IS_MOBILE_DEVICE = util_device.iphone || util_device.ipad || util_device.android;
	    var keyword_null = null, keyword_undefined = void 0, Math_ceil = Math.ceil, Math_min = Math.min,
	        Math_max = Math.max, parseIntFunc = parseInt;
	    var NBSP_SPACE_CHAR = '\u00a0',    
	        ZERO_WIDTH_CHAR = '\u200b';    
	
	
	   
	
	    function isTextareaAsEditor(editorType) {
	        return IS_MOBILE_DEVICE || editorType === 0 ;
	    }
	
	    function getDOMElement(editorType) {
	        return isTextareaAsEditor(editorType) ? $(createElement('textarea')) : $(createElement('div'));
	    }
	
	    function isEditableDIVElement(element) {
	        return element && element.tagName === 'DIV' && element.contentEditable === 'true';
	    }
	
	    function getEditorContent(editor) {
	        if (isEditableDIVElement(editor)) {
	            if (browser_msie && parseFloat(browser.version) < 10) {    
	                return util_common_util._getEditableDivValue(editor);
	            }
	            return editor.innerText;
	        }
	        return editor.value;
	    }
	
	    function setEditorContent(editor, value) {
	        if (isEditableDIVElement(editor)) {
	            editor.innerText = value;
	        } else {
	            editor.value = value;
	        }
	    }
	
	    function moveCaretToEnd(editor) {
	        if (isEditableDIVElement(editor)) {
	            var selection = WINDOW.getSelection();
	            selection.selectAllChildren(editor);
	            if (selection.rangeCount > 0) {
	                selection.collapseToEnd();
	            }
	        } else {
	            editor.selectionStart = editor.selectionEnd = editor.value.length;
	        }
	    }
	
	    function getCaretStartPosition(editor) {
	        if (isEditableDIVElement(editor)) {
	            var selection = WINDOW.getSelection();
	            if (selection.rangeCount > 0) {
	                var range = selection.getRangeAt(0);
	                return range.startOffset;
	            }
	            return 0;
	        }
	        return editor.selectionStart;
	    }
	
	    function getCaretEndPosition(editor) {
	        if (isEditableDIVElement(editor)) {
	            var selection = WINDOW.getSelection();
	            if (selection.rangeCount > 0) {
	                var range = selection.getRangeAt(0);
	                return range.endOffset;
	            }
	            return 0;
	        }
	        return editor.selectionEnd;
	    }
	
	    function getAsciiCodeFromKeyCode(event) {
	        var keyCode = event.keyCode, shiftKey = event.shiftKey;
	        var keyMap = {
	            106: 42,   
	            107: 43,   
	            109: 45,   
	            110: 46,   
	            111: 47,   
	            173: 45    
	        }, generalKeyMap = {
	            186: 59,   
	            187: 61,   
	            188: 44,   
	            189: 45,   
	            190: 46,   
	            191: 47,   
	            192: 96,   
	            219: 91,   
	            220: 92,   
	            221: 93,   
	            222: 39    
	        }, shiftKeyMap = {
	            186: 58,   
	            187: 43,   
	            188: 60,   
	            189: 95,   
	            190: 62,   
	            191: 63,   
	            192: 126,  
	            219: 123,  
	            220: 124,  
	            221: 125,  
	            222: 34    
	        };
	        var retCode = keyCode;
	        if (keyCode >= 96 && keyCode <= 105) {   
	            retCode = keyCode - 48;
	        } else if (keyMap[keyCode]) {
	            retCode = keyMap[keyCode];
	        } else if (shiftKey && shiftKeyMap[keyCode]) {
	            retCode = shiftKeyMap[keyCode];
	        } else if (!shiftKey && generalKeyMap[keyCode]) {
	            retCode = generalKeyMap[keyCode];
	        } else if (!shiftKey && keyCode >= 65 && keyCode <= 90) {   
	            retCode = keyCode + 32;
	        }
	       
	       
	       
	       
	       
	        return retCode;
	    }
	
	    function isBrElement(element) {
	        return element && element.tagName === 'BR';
	    }
	
	    function isSpanElement(element) {
	        return element && element.tagName === 'SPAN';
	    }
	
	    function isDivElement(element) {
	        return element && element.tagName === 'DIV';
	    }
	
	    function isTextNode(element) {
	        return element instanceof Text;
	    }
	
	    function isZeroWidthChar(letter) {
	        return letter === ZERO_WIDTH_CHAR;
	    }
	
	    function isZeroWidthCharTextNode(element) {
	        if (element && isTextNode(element)) {
	            var textContent = element.textContent;
	            if (textContent.length === 1 && isZeroWidthChar(textContent[0])) {
	                return true;
	            }
	        }
	        return false;
	    }
	
	    function isOnlyWithZeroWidthChartSpan(element) {
	        if (element) {
	            var childNodes = element.childNodes;
	            return isSpanElement(element) && childNodes.length === 2 &&
	                isBrElement(childNodes[0]) && isZeroWidthCharTextNode(childNodes[1]);
	        }
	        return false;
	    }
	
	    function getCaretSelectionInputtingValue(value, start, end, letter) {
	        var preValue = value.substr(0, start);
	        var endValue = value.substr(end, value.length - end);
	        return preValue + letter + endValue;
	    }
	
	    function getElementInnerText(element, range, start, end, letter, isNodeInSelection) {
	        var content = '';
	        var childNodes = element.childNodes, length = childNodes.length;
	        for (var i = 0; i < length; i++) {
	            var item = childNodes[i];
	            if (isSpanElement(item)) {
	                content += getElementInnerText(item, range, start, end, letter, isNodeInSelection);
	            } else if (isTextNode(item)) {
	                var startContainer = range && range.startContainer, endContainer = range && range.endContainer;
	                var tempContent = item.textContent;
	                if (item === startContainer || item === endContainer) {
	                    if (startContainer !== endContainer) {
	                        if (item === startContainer) {
	                            content += getCaretSelectionInputtingValue(tempContent, start, tempContent.length, letter);
	                            isNodeInSelection = true;
	                        } else {
	                            content += getCaretSelectionInputtingValue(tempContent, 0, end, '');   
	                            isNodeInSelection = false;
	                        }
	                    } else {
	                        content += getCaretSelectionInputtingValue(tempContent, start, end, letter);
	                    }
	                } else if (!isNodeInSelection) {
	                    content += tempContent;
	                }
	            } else if (isBrElement(item) && !isNodeInSelection) {
	                content += '\n';
	            }
	        }
	        return content;
	    }
	
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	    function getEditorInputtingValue(editor, value, startCaretPos, endCaretPos, event) {
	        var letter = String.fromCharCode(getAsciiCodeFromKeyCode(event));
	        if (!isEditableDIVElement(editor)) {
	            return getCaretSelectionInputtingValue(value, startCaretPos, endCaretPos, letter);
	        }
	        var selection = WINDOW.getSelection(), range;
	        if (selection.rangeCount > 0) {
	            range = selection.getRangeAt(0);
	            if (isTextNode(range.startContainer)) {
	                return getElementInnerText(editor, range, startCaretPos, endCaretPos, letter);
	            }
	        }
	       
	        if (range && range.startOffset === range.endOffset) {
	            return value + letter;
	        }
	       
	       
	       
	        return letter;
	    }
	
	    function findPreviousNodeWithCondition(argNode, callback) {
	        var tempNode = argNode && argNode.previousSibling;
	        while (tempNode) {
	            if (callback(tempNode)) {
	                return tempNode;
	            }
	            tempNode = tempNode.lastChild;
	        }
	        return keyword_null;
	    }
	
	    function getPreviousCaretInfo(anchorNode, anchorOffset) {
	        var childNodesLength = anchorNode.childNodes.length;
	        var nodeWithZeroWidthChar, tempNode;
	        if (isZeroWidthChar(anchorNode.textContent[0]) && (anchorOffset === 0 || anchorOffset === 1)) {
	            nodeWithZeroWidthChar = anchorNode;
	        } else if (anchorOffset === 0) {
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	            tempNode = anchorNode;
	            if (anchorNode === anchorNode.parentNode.firstChild) {
	                tempNode = anchorNode.parentNode;
	            }
	            var spanNode = findPreviousNodeWithCondition(tempNode, isOnlyWithZeroWidthChartSpan);
	            nodeWithZeroWidthChar = spanNode && spanNode.lastChild;
	        } else if (isDivElement(anchorNode)) {
	            if (childNodesLength === 1 && anchorOffset === 1) {
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	                nodeWithZeroWidthChar = anchorNode.firstChild.firstChild.lastChild;
	            } else if (childNodesLength > 1 && anchorOffset === childNodesLength) {
	               
	               
	               
	               
	               
	               
	                nodeWithZeroWidthChar = anchorNode.lastChild;
	            }
	            if (isZeroWidthCharTextNode(nodeWithZeroWidthChar)) {
	                return {
	                    zeroWidthCharNode: nodeWithZeroWidthChar,
	                    previousTextNode: nodeWithZeroWidthChar.previousSibling.previousSibling
	                };
	            } else if (isOnlyWithZeroWidthChartSpan(nodeWithZeroWidthChar)) {
	                return {
	                    zeroWidthCharNode: nodeWithZeroWidthChar,
	                    previousTextNode: findPreviousNodeWithCondition(tempNode, isTextNode)
	                };
	            }
	            return keyword_null;
	        } else if (isSpanElement(anchorNode) && (anchorOffset === childNodesLength || anchorOffset === childNodesLength - 1)) {
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	            if (isOnlyWithZeroWidthChartSpan(anchorNode)) {
	                nodeWithZeroWidthChar = anchorNode;
	            } else if (isOnlyWithZeroWidthChartSpan(anchorNode.lastChild)) {
	                nodeWithZeroWidthChar = anchorNode.lastChild;
	            }
	        }
	        if (nodeWithZeroWidthChar) {
	            if (isSpanElement(nodeWithZeroWidthChar)) {
	                tempNode = nodeWithZeroWidthChar;
	            } else if (isTextNode(nodeWithZeroWidthChar)) {
	                var tempPreviousNode = nodeWithZeroWidthChar.previousSibling,
	                    parentNode = nodeWithZeroWidthChar.parentNode;
	                if (tempPreviousNode === parentNode.firstChild) {
	                    tempNode = parentNode;
	                } else {
	                    tempNode = tempPreviousNode;
	                }
	            }
	            return {
	                zeroWidthCharNode: nodeWithZeroWidthChar,
	                previousTextNode: findPreviousNodeWithCondition(tempNode, isTextNode)
	            };
	        }
	        return keyword_null;
	    }
	
	    function isDeleteLastChar(anchorNode, anchorOffset, target) {
	        if (anchorOffset === 1 && isSpanElement(target.firstChild) && isSpanElement(target.firstChild.firstChild)) {
	            var tempLastChild = target.firstChild.firstChild.lastChild, tempValue;
	            if (anchorNode === target) {
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	                tempValue = tempLastChild.textContent;
	                return tempValue.length === 1 && tempValue[0] !== ZERO_WIDTH_CHAR && isBrElement(tempLastChild.previousSibling);
	            } else if (tempLastChild === anchorNode || isBrElement(tempLastChild) && anchorNode === tempLastChild.previousSibling) {
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	                tempValue = anchorNode.textContent;
	                return tempValue.length === 1 && tempValue[0] !== ZERO_WIDTH_CHAR && isBrElement(anchorNode.previousSibling);
	            }
	        }
	        return false;
	    }
	
	    function processBackspaceAndLeftArrowKeyEvent(event, isBackspaceKey) {
	        var selection = WINDOW.getSelection();
	        if (selection.rangeCount <= 0) {
	            return;
	        }
	        var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset,
	            tempTarget = event.target;
	       
	        if (browser_msie && !browser_edge && isBackspaceKey && isDeleteLastChar(anchorNode, anchorOffset, tempTarget)) {
	            var tempEditorValue = parseFloat(browser.version) < 10 ? getElementInnerText(tempTarget) : tempTarget.innerText;
	            var newValue = tempEditorValue.slice(0, -1);
	            tempTarget.innerHTML = newValue.replace(/\r/g, '').replace(/\n/g, '<br>\u200b');
	            selection.selectAllChildren(tempTarget);
	            if (selection.rangeCount > 0) {
	                selection.collapseToEnd();
	            }
	            cancelDefault(event);
	            return;
	        }
	        var previousCaretInfo = getPreviousCaretInfo(anchorNode, anchorOffset);
	        if (previousCaretInfo) {
	            var zeroWidthCharNode = previousCaretInfo.zeroWidthCharNode,
	                previousTextNode = previousCaretInfo.previousTextNode;
	
	            if (isBackspaceKey) {
	                if (isSpanElement(zeroWidthCharNode)) {
	                    zeroWidthCharNode.parentNode.removeChild(zeroWidthCharNode);
	                } else {
	                   
	                    zeroWidthCharNode.parentNode.removeChild(zeroWidthCharNode.previousSibling);
	
	                   
	                   
	                   
	                   
	                   
	                   
	                   
	                   
	                    if (isBrElement(previousTextNode)) {
	                        cancelDefault(event);
	                        return;
	                    }
	                   
	                    var range = selection.getRangeAt(0);
	                    range.setStart(zeroWidthCharNode, 0);
	                    range.setEnd(zeroWidthCharNode, 1);
	                    range.deleteContents();
	                }
	            }
	
	           
	            var newRange = DOCUMENT.createRange();
	            newRange.setStartAfter(previousTextNode);
	            newRange.setEndAfter(previousTextNode);
	            newRange.collapse(false);
	            selection.removeAllRanges();
	            selection.addRange(newRange);
	
	            cancelDefault(event);
	        }
	    }
	
	    function findNextNode(argNode) {
	        var tempNode = argNode;
	        while (tempNode) {
	            var tempParentNode = tempNode.parentNode;
	            if (tempNode !== tempParentNode.lastChild) {
	                return tempNode.nextSibling;
	            }
	            tempNode = tempParentNode;
	        }
	        return keyword_null;
	    }
	
	    function getNextCaretInfo(selection) {
	        var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset;
	        var textContent = anchorNode.textContent, textContentLength = textContent.length;
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	        if (anchorOffset === textContentLength) {
	            var nextNode = findNextNode(anchorNode), zeroWidthCharNode;
	            if (isSpanElement(nextNode) && isZeroWidthChar(nextNode.textContent[0])) {
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	                while (isSpanElement(nextNode.firstChild)) {
	                    nextNode = nextNode.firstChild;
	                }
	                zeroWidthCharNode = nextNode.childNodes[1];    
	            } else if (isBrElement(nextNode) && isZeroWidthChar(nextNode.nextSibling.textContent[0])) {
	                zeroWidthCharNode = nextNode.nextSibling;
	            }
	            return {node: zeroWidthCharNode, offset: 1};
	        }
	        return keyword_null;
	    }
	
	    function processDeleteAndRightArrowKeyEvent(event, isDeleteKey) {
	        var selection = WINDOW.getSelection();
	        if (selection.rangeCount <= 0) {
	            return;
	        }
	        var caretInfo = getNextCaretInfo(selection);
	        if (caretInfo) {
	            var zeroWidthCharNode = caretInfo.node, caretOffset = caretInfo.offset;
	
	            if (isDeleteKey) {
	                var range = selection.getRangeAt(0);
	                range.setStart(zeroWidthCharNode, 0);
	                range.setEnd(zeroWidthCharNode, 1);
	                range.deleteContents();
	
	                zeroWidthCharNode.parentNode.removeChild(zeroWidthCharNode.previousSibling);
	            } else {
	                var newRange = DOCUMENT.createRange();
	                newRange.setStart(zeroWidthCharNode, caretOffset);
	                newRange.setEnd(zeroWidthCharNode, caretOffset);
	                newRange.collapse(false);
	                selection.removeAllRanges();
	                selection.addRange(newRange);
	            }
	
	            cancelDefault(event);
	        }
	    }
	
	    function getProcessedEditorValue(text) {
	        var editorValue = addZeroWidthCharToText(text);
	       
	        if (editorValue && editorValue.indexOf(' ') >= 0) {
	            editorValue = replaceSpaceChar(editorValue, ' ', NBSP_SPACE_CHAR);
	        }
	        return editorValue;
	    }
	
	   
	    function textCellType_processEditingWrap(event, context) {
	        var src = event.srcElement || event.target;
	        if (src && src.getAttribute(attrGcUIElement) === 'gcEditingInput' && (event.keyCode === 13  && (event.ctrlKey || event.altKey))) {
	            var ae = _FocusHelper._getActiveElement();
	            if (ae instanceof Worksheet) {
	                var ct = ae.getCellType(ae._activeRowIndex, ae._activeColIndex);
	                if (ct) {
	                    if (isEditableDIVElement(src)) {
	                       
	                        var selection = WINDOW.getSelection();
	                        if (selection.rangeCount > 0) {
	                            var range = selection.getRangeAt(0);
	                            var textNode = DOCUMENT.createElement('span');
	                            textNode.innerHTML = '<br/>' + ZERO_WIDTH_CHAR;
	                            range.insertNode(textNode);
	
	                            var newRange = DOCUMENT.createRange();
	                            newRange.setStartAfter(textNode);
	                            newRange.setEndAfter(textNode);
	                            newRange.collapse(false);
	                            selection.removeAllRanges();
	                            selection.addRange(newRange);
	                        }
	                    } else {
	                        var index = src.selectionStart;
	                        var value = src.value;
	                        var preValue = value.substr(0, index);
	                        var endValue = value.substr(index, value.length - index);
	                        src.value = preValue + '\n' + endValue;
	                        src.selectionStart = index + 1;
	                        src.selectionEnd = index + 1;
	                    }
	                    ct.updateEditor(ae._editor, keyword_null, keyword_null, context);
	                }
	            }
	            cancelDefault(event);
	        }
	    }
	
	   
	   
	    function removeZeroWidthCharFromText(text) {
	        var retValue = text;
	        if (!retValue) {
	            return retValue;
	        }
	        if (retValue.indexOf(ZERO_WIDTH_CHAR) < 0 && retValue.indexOf('\n') < 0) {
	            return retValue;
	        }
	        var valueArray = text.split('\n');
	        valueArray.forEach(function (item, index, array) {
	            if (isZeroWidthChar(item[0])) {
	                array[index] = item.substr(1);
	            }
	        });
	        return valueArray.join('\n');
	    }
	
	   
	    function addZeroWidthCharToText(text) {
	        var retValue = text;
	        if (!retValue) {
	            return retValue;
	        }
	        var length = retValue.length;
	        if (length > 0 && retValue[length - 1] === '\n') {
	            retValue += ZERO_WIDTH_CHAR;
	        }
	        return retValue;
	    }
	
	    function getElementSelectionText(editor) {
	        var selection = WINDOW.getSelection();
	        var startFlag = false, index = 0, endPosition = 0;
	        if (selection.rangeCount > 0) {
	            var range = selection.getRangeAt(0);
	            var startCaretPos = getCaretStartPosition(editor), endCaretPos = getCaretEndPosition(editor);
	            var startRangeContainer = range.startContainer;
	            var endRangeContainer = range.endContainer;
	            if (isDivElement(startRangeContainer)) {
	                startFlag = true;
	                index = startCaretPos;
	            }
	            if (isDivElement(endRangeContainer)) {
	                endPosition = endCaretPos;
	            }
	            var result = getElementSelectionInnerText(editor, startCaretPos, endCaretPos, startRangeContainer, endRangeContainer, startFlag, index, endPosition);
	            return result.content;
	        }
	    }
	
	    function getElementSelectionInnerText(element, start, end, startContainer, endContainer, startFlag, index, endPosition) {
	        if (startContainer === endContainer && !startFlag) {
	            return {content: removeZeroWidthCharFromText(startContainer.textContent.slice(start, end))};
	        }
	        var content = '', i = index;
	        var tempContent, endFlag;
	        var childNodes = element.childNodes, length = endPosition || childNodes.length;
	        for (i; i < length; i++) {
	            var item = childNodes[i];
	            if (isSpanElement(item)) {
	                tempContent = getElementSelectionInnerText(item, start, end, startContainer, endContainer, startFlag, 0, 0);
	                content += tempContent.content;
	                if (tempContent.startFlag) {
	                    startFlag = true;
	                }
	                if (tempContent.endFlag) {
	                    endFlag = true;
	                    break;
	                }
	            } else if (isTextNode(item) && item === startContainer) {
	                content += item.textContent.slice(start, item.textContent.length);
	                startFlag = true;
	            } else if (isTextNode(item) && item === endContainer) {
	                content += item.textContent.slice(0, end);
	                endFlag = true;
	                break;
	            } else if (startFlag) {
	                if (isBrElement(item)) {
	                    content += '\n';
	                } else {
	                    content += item.innerText || item.textContent;
	                }
	            }
	        }
	        return ({content: removeZeroWidthCharFromText(content), startFlag: startFlag, endFlag: endFlag});
	    }
	
	    function getLineHeightArray(lines, font) {
	        var length = lines.length, lineHeightArray = [];
	        for (var i = 0; i < length; i++) {
	            lineHeightArray.push(getTextHeight(lines[i], font));
	        }
	        return lineHeightArray;
	    }
	
	    function getEditorHeight(lineHeightArray) {
	        var length = lineHeightArray.length, totalHeight = 0;
	        for (var i = 0; i < length; i++) {
	            totalHeight += lineHeightArray[i];
	        }
	        return totalHeight;
	    }
	
	    function getTextWrapHeight(lineWidthArray, editorWidth, lineHeight, lineHeightArray) {
	        var wrapHeight = 0, tempLineHeight = lineHeight;
	        for (var i = 0; i < lineWidthArray.length; i++) {
	            if (browser_chrome) {
	                tempLineHeight = lineHeightArray[i];
	            }
	            if (lineWidthArray[i] > editorWidth) {
	                var rowCount = Math_ceil(lineWidthArray[i] / editorWidth);
	                wrapHeight += tempLineHeight * rowCount;
	            } else {
	                wrapHeight += tempLineHeight;
	            }
	        }
	        return wrapHeight;
	    }
	
	    function isFormulaEditor(editor, pasteValue, caretStartPosition) {
	        var editorValue = getEditorContent(editor);
	        return (editorValue && editorValue[0] === '=') || (editorValue === '' && pasteValue[0] === '=') ||
	            (caretStartPosition === 0 && pasteValue[0] === '=');
	    }
	
	   
	
	   
	
	   
	    
	    CellTypes.EditorType = {
	        
	        textarea: 0,
	        
	        editableDiv: 1
	    };
	
	    $.inherit(TextCellType, BaseCellType);
	
	   
	    
	    function TextCellType(editorType) {
	        BaseCellType.call(this);
	        this.allowOverflow = true;
	        this.typeName = 1  + '';
	        this.editorType = isNullOrUndefined(editorType) ? 1  : editorType;
	    }
	
	    $.extend(TextCellType.prototype, {
	       
	        getText: function (value, context) { 
	            return value;
	        },
	        paintValue: function (ctx, value, x, y, w, h, style, options) {
	            var self = this;
	            value = self.getText(value, options);
	            var formattedData = {}, text;
	            options.quotePrefix = style.quotePrefix;
	            text = self.format(convertRichTextValue(value), style.formatter || style._autoFormatter, formattedData, options);
	           
	            var labelOptions = style.labelOptions;
	            var watermark = style.watermark;
	            var needPaintWatermark = !labelOptions || labelOptions.visibility !== 0 ;
	            if (watermark && !text && needPaintWatermark) {
	                self.paintText(ctx, watermark, x, y, w, h, style, options, watermark, formattedData, WATERMARK_OPACITY);
	                return;
	            }
	            if (!text && (!formattedData.content || !formattedData.content.length)) {
	                return;
	            }
	           
	            if (style.vAlign === 1  && browser_chrome) {
	                y--;
	            }
	            self.paintText(ctx, value, x, y, w, h, style, options, text, formattedData);
	        },
	        createEditorElement: function (context, cellWrapperElement) {
	            var host = context && context.sheet && context.sheet.parent && context.sheet.parent._host;
	            var zindex = getPreferredZIndex(host) + 1000;
	            $(cellWrapperElement).css('z-index', zindex);
	
	            var $editor = getDOMElement(this.editorType);
	            $editor.css({
	                'font': 'normal 11pt calibri',
	                'outline': cssNone,
	                'resize': cssNone,
	                'border': cssNone,
	                'padding': '1px',
	                'vertical-align': 'top',
	                'min-height': '0px',
	                'box-sizing': 'content-box'
	            }).css(cssWordWrap, cssNormal).attr({
	                'tabindex': -1,
	                'autocomplete': 'off',
	                'contenteditable': true,
	            }).css(cssOverflow, cssHidden).attr(attrGcUIElement, 'gcEditingInput');
	            if (browser.safari) {
	                $editor.css('-webkit-user-select', 'auto');
	            }
	            var isDIVElement = isEditableDIVElement($editor[0]);
	            if (isDIVElement) {
	                $editor.css('display', 'table-cell');
	                $editor.css(cssWordBreak, cssNormal);
	            }
	
	            return $editor[0];
	        },
	        getEditorValue: function (editorContext, context) { 
	            if (editorContext) {
	                var v = getEditorContent(editorContext);
	                if (!isNullOrUndefined(v) && v.length > 0) {
	                    var retValue = removeZeroWidthCharFromText(v);
	                   
	                    retValue = retValue.replace(/\r\n?/g, '\n');
	                   
	                    if (retValue.indexOf(NBSP_SPACE_CHAR) < 0) {
	                        return retValue;
	                    }
	                   
	                    return replaceSpaceChar(retValue, NBSP_SPACE_CHAR, ' ');
	                }
	            }
	            return keyword_null;
	
	        },
	        setEditorValue: function (editorContext, value, context) {
	            if (editorContext) {
	               
	               
	
	               
	               
	               
	               
	                var startEditByKeydown = context && context.sheet && context.sheet._startEditByKeydown;
	                var editorValue = getProcessedEditorValue(value);
	                if (browser_msie) {
	                    if (!startEditByKeydown || !context.isImeInput) {
	                        setEditorContent(editorContext, isNullOrUndefined(editorValue) ? '' : editorValue); 
	                    }
	                } else {
	                    setEditorContent(editorContext, startEditByKeydown ? '' : editorValue);
	                }
	            }
	        },
	        selectAll: function (editorContext, context) { 
	            if (editorContext && editorContext.select) {
	                editorContext.select();
	            } else {
	                var selection = WINDOW.getSelection();
	                selection.selectAllChildren(editorContext);
	            }
	        },
	        focus: function (editorContext, context) { 
	            if (this.isImeAware() && editorContext) {
	                editorContext.focus();
	                moveCaretToEnd(editorContext);
	            } else {
	                editorContext.parentNode.parentNode.focus();
	            }
	        },
	        _formatEditorValue: function (editorContext, cellStyle, value, context) {
	            var sheet = editorContext && context && context.sheet, formatterRef = {};
	            var text = formatValue2Text(cellStyle, value, sheet, formatterRef);
	            editorContext._editingFormatter = formatterRef.formatter || keyword_undefined;
	            return text;
	        },
	        activateEditor: function (editorContext, cellStyle, cellRect, context) {
	            var sheet = context && context.sheet;
	            if (sheet) {
	               
	                var self = this;
	                var editor = editorContext;
	                if (editor) {
	                    var $editor = $(editor);
	                    var isDIVElement = isEditableDIVElement(editor);
	                    self._editingElement = editor;
	                    $editor.bind('keydown' + _gcEditingInput, function (event) {
	                        try {
	                            var keyCode = event.keyCode;
	                            if (isDIVElement) {
	                                if (keyCode === 8 ) {
	                                    processBackspaceAndLeftArrowKeyEvent(event, true);
	                                } else if (keyCode === 46 ) {
	                                    processDeleteAndRightArrowKeyEvent(event, true);
	                                } else if (keyCode === 37 ) {
	                                    processBackspaceAndLeftArrowKeyEvent(event, false);
	                                } else if (keyCode === 39  ) {
	                                    processDeleteAndRightArrowKeyEvent(event, false);
	                                }
	                            }
	                            var isIme = keyCode === 229 || keyCode === 0;
	                           
	                            if (!(isIme || self._isImeInputing)) {
	                                self._updateEditorImp(editor, cellStyle, cellRect, event, context, true);
	                            }
	                            textCellType_processEditingWrap(event, context);
	                        } catch (ex) {
	                           
	                        }
	                    });
	                    $editor.bind('keyup' + _gcEditingInput, function (event) {
	                        var keyCode = event.keyCode, ctrlKey = event.ctrlKey, altKey = event.altKey;
	                        var isIme = keyCode === 229 || keyCode === 0;
	                        if (!isIme && !self._isImeInputing) {
	                            if ((keyCode === 46  || keyCode === 8 ) ||
	                                ((keyCode === 90  || keyCode === 89 ) && ctrlKey && !altKey)) {
	                               
	                               
	                               
	                                if (isDIVElement && editor.innerText === '\n') {
	                                    $(editor).empty();
	                                }
	                                self._updateEditorImp(editor, cellStyle, cellRect, event, context);
	                            }
	                           
	                           
	                           
	                           
	                           
	                           
	                            if ((keyCode !== 13  && keyCode !== 9  && keyCode !== 27 && keyCode !== 16 ) || ctrlKey || altKey) {
	                                sheet._trigger(Events_EditChange, {
	                                    sheet: sheet,
	                                    sheetName: sheet.name(),
	                                    row: sheet._activeRowIndex,
	                                    col: sheet._activeColIndex,
	                                    editingText: self.getEditorValue(editor, context)
	                                });
	                            }
	                        }
	                    });
	                    $editor.bind('mousedown' + _gcEditingInput, function () {
	                        if (sheet._editorStatus === 1 ) {
	                            sheet._editorStatus = 2 ;
	                            sheet._raiseEditorStatusChanged(1 , 2 );
	                        }
	                    });
	                    $editor.bind('compositionstart' + _gcEditingInput, function () {
	                        self._isImeInputing = true;
	                        self._oldValueBeforeImeInputting = getEditorContent(editor);
	                    });
	                    $editor.bind('compositionupdate' + _gcEditingInput, function (event) {
	                        self._updateEditorImp(editor, cellStyle, cellRect, event ? event : keyword_null, context, true);
	                    });
	                    $editor.bind('compositionend' + _gcEditingInput, function (event) {
	                        self._updateEditorImp(editor, cellStyle, cellRect, event ? event : keyword_null, context);
	                        self._isImeInputing = false;
	                        var keyCode = event.keyCode, ctrlKey = event.ctrlKey, altKey = event.altKey;
	                        var editingText = self.getEditorValue(editor, context) || "";
	                        if ((self._oldValueBeforeImeInputting !== editingText) &&
	                            (keyCode === keyword_undefined || (keyCode !== 13  && keyCode !== 9 ) || ctrlKey || altKey)) {
	                            sheet._trigger(Events_EditChange, {
	                                sheet: sheet,
	                                sheetName: sheet.name(),
	                                row: sheet._activeRowIndex,
	                                col: sheet._activeColIndex,
	                                editingText: editingText
	                            });
	                        }
	                    });
	                    if (isDIVElement) {
	                        $editor.bind('copy' + _gcEditingInput, function (event) {
	                            var window_clipboardData = WINDOW.clipboardData,
	                                clipboardData = event.clipboardData,
	                                textContent = getElementSelectionText(event.currentTarget);
	                            if (!isNullOrUndefined(textContent)) {
	                                if (window_clipboardData && window_clipboardData.setData) { 
	                                    window_clipboardData.setData('text', textContent);
	                                    cancelDefault(event);
	                                } else if (clipboardData && clipboardData.setData) {   
	                                    clipboardData.setData('text/plain', textContent);
	                                    cancelDefault(event);
	                                }
	                            }
	                        });
	                        $editor.bind('paste' + _gcEditingInput, function (event) {
	                            var needCancelDefault = false;
	                            if (isDIVElement) {
	                                try {
	                                    var pasteValue;
	                                    if (browser_msie && !browser_edge && WINDOW.clipboardData && WINDOW.clipboardData.getData) { 
	                                        pasteValue = WINDOW.clipboardData.getData('text');
	                                    } else if (event.clipboardData && event.clipboardData.getData) {   
	                                        pasteValue = event.clipboardData.getData('text/plain');
	                                    }
	                                    pasteValue = pasteValue.replace(/\r\n?/g, '\n');
	                                    pasteValue = getProcessedEditorValue(pasteValue);
	
	                                    var selection = WINDOW.getSelection();
	                                    if (selection.rangeCount > 0) {
	                                        var range = selection.getRangeAt(0);
	                                        var caretStartPosition = range.startOffset, caretEndPosition = range.endOffset;
	                                        if (caretStartPosition !== caretEndPosition) {
	                                            range.deleteContents();
	                                        }
	                                       
	                                        if (!isFormulaEditor(editor, pasteValue, caretStartPosition)) {
	                                            var textNode = DOCUMENT.createElement('span');
	                                            textNode.innerText = pasteValue;
	                                            range.insertNode(textNode);
	
	                                            var newRange = document.createRange();
	                                            newRange.setStartAfter(textNode);
	                                            newRange.setEndAfter(textNode);
	                                            newRange.collapse(false);
	                                            selection.removeAllRanges();
	                                            selection.addRange(newRange);
	                                            needCancelDefault = true;
	                                        }
	                                    }
	                                } catch (ex) {
	                                   
	                                }
	                            }
	                            self._pasteInputSizingToken = setTimeout(function () {
	                                self._updateEditorImp(editor, cellStyle, cellRect, event, context);
	                                if (self._pasteInputSizingToken) {
	                                    clearTimeout(self._pasteInputSizingToken);
	                                    delete self._pasteInputSizingToken;
	                                }
	                            }, 10);
	                            if (needCancelDefault) {
	                                cancelDefault(event);
	                            }
	                        });
	                    }
	                }
	            }
	        },
	        deactivateEditor: function (editorContext, context) { 
	            if (editorContext) {
	               
	                $(editorContext).unbind(_gcEditingInput);
	            }
	            this._editingElement = keyword_null;
	        },
	        getEditingElement: function () {
	            return this._editingElement;
	        },
	        _updateEditorImp: function (editorContext, cellStyle, cellRect, event, context, startEditByKeyDown) {
	            var sheet = context && context.sheet, self = this;
	            var editor = editorContext;
	            if (editor && sheet) {
	                var $editor = $(editor), render = sheet._render;
	                var editorValue = getEditorContent(editor);
	                if (sheet.isEditing()) {
	                    var isDIVElement = isEditableDIVElement(editor);
	                    var hAlign, hAlignValue = cssLeft, font;
	                    var getPositionOffset = CellTypeContext._getPositionOffset;
	                    var paddingTop = 0, paddingRight = 0, paddingBottom = 0, paddingLeft = 0;
	                    if (cellStyle) {
	                        paddingTop = getPositionOffset(cellStyle, 0 );
	                        paddingRight = getPositionOffset(cellStyle, 1 );
	                        paddingBottom = getPositionOffset(cellStyle, 2 );
	                        paddingLeft = getPositionOffset(cellStyle, 3 );
	                        hAlign = getHAlignByValueType(cellStyle.hAlign, editorContext._originalValue);
	                        if (hAlign === 1 ) {
	                            hAlignValue = cssCenter;
	                        } else if (hAlign === 2 ) {
	                            hAlignValue = cssRight;
	                        }
	                        $editor.css(cssTextAlign, hAlignValue);
	                        if (cellStyle.foreColor) {
	                            $editor.css('color', cellStyle.foreColor);
	                        }
	                        font = cellStyle.font || render._getDefaultFont();
	                        if (font) {
	                            if (sheet.zoom() > 1) {
	                                font = render._getZoomFont(font);
	                            }
	                            $editor.css('font', adjustFontWithFallback(font));
	                        }
	                        if (cellStyle.textDecoration) {
	                            self._setTextDecoration($editor, cellStyle.textDecoration);
	                        }
	                    }
	                    var adjustWidth = parseIntFunc($editor.css('padding-left'), 10) + parseIntFunc($editor.css('padding-right'), 10);
	                    var adjustHeight = parseIntFunc($editor.css('padding-top'), 10) + parseIntFunc($editor.css('padding-bottom'), 10);
	                    if (cellRect) {
	                        var sheetLayout = sheet._getSheetLayout();
	                        var width = cellRect.width;
	                        if (cellRect.x + cellRect.width > sheetLayout.width) {
	                            width = sheetLayout.width - cellRect.x;
	                        }
	                        $editor.css(cssWidth, width - adjustWidth).css(cssHeight, cellRect.height - adjustHeight);
	                       
	                       
	                        editor.maxWidth = sheetLayout.width - cellRect.x - adjustWidth - paddingRight;
	                        
	                       
	                       
	                       
	                        $editor.css('max-width', editor.maxWidth + 'px');
	                        editor.maxHeight = sheetLayout.height - cellRect.y - adjustHeight - paddingBottom;
	                        editor.minWidth = parseIntFunc(editor.style.width, 10);
	                        editor.minHeight = parseIntFunc(editor.style.height, 10);
	                    }
	
	                    var startCaretPos = getCaretStartPosition(editor), endCaretPos = getCaretEndPosition(editor);
	                    startEditByKeyDown = startEditByKeyDown && event && event.keyCode && sheet._eventHandler._allowEnterEditing(event) && startCaretPos === 0 && endCaretPos === editorValue.length;
	                    startEditByKeyDown = startEditByKeyDown || sheet._startEditByKeydown;
	                   
	                   
	                   
	                    var value = startEditByKeyDown ? '' : editorValue;   
	
	                    font = editor.style.font;
	                    if (!font) {
	                        font = render._getZoomFont(render._getDefaultFont());
	                    }
	                    var lineHeight = getFontHeight(font);
	                    if (!startEditByKeyDown && event) {
	                        if (sheet._eventHandler._allowEnterEditing(event) && event.keyCode !== 8 ) {
	                            value = getEditorInputtingValue(editor, value, startCaretPos, endCaretPos, event);
	                        }
	                        if (self._isImeInputing) {
	                            if (browser_msie) {
	                                value = editorValue;
	                            } else {
	                                value = self._oldValueBeforeImeInputting + event.data;
	                            }
	                        }
	                    }
	                    var lines = [];
	                    if (cellStyle && cellStyle.wordWrap) {
	                       
	                        lines = _WordWrapHelper._getWrapInfo(value, parseIntFunc(editor.style.width) - adjustWidth, font);
	                    } else {
	                        lines = value.split(/\r\n|\r|\n/);
	                    }
	                    var i, lineWidth, linesLength = lines.length;
	                    editor.minWidth = Math_min(editor.minWidth, editor.maxWidth);
	                    editor.minHeight = Math_min(editor.minHeight, editor.maxHeight);
	                    if ((cellStyle && cellStyle.wordWrap) || linesLength > 0) {
	                        var wrapHeight, lineHeightArray;
	                       
	                        if (browser_chrome) {
	                            lineHeightArray = getLineHeightArray(lines, font);
	                            wrapHeight = getEditorHeight(lineHeightArray);
	                        } else {
	                            wrapHeight = linesLength * lineHeight;
	                        }
	                        if (cellStyle && cellStyle.wordWrap) {
	                            $editor.css(cssWordWrap, cssBreakWord).css(cssOverflow, cssHidden).css('max-width', editor.style.width);
	                        } else {
	                            var maxLineWidth = 0;
	                            var lineWidthTemps = [];
	                            for (i = 0; i < linesLength; i++) {
	                                lineWidth = Math_ceil(sheet._getStringWidth(lines[i], font));
	                                lineWidthTemps.push(lineWidth);
	                                maxLineWidth = Math_max(maxLineWidth, lineWidth);
	                            }
	                            var wordWrapStyle = $editor.css(cssWordWrap),
	                                editorWidth = parseIntFunc(editor.style.width);
	                            if (cellStyle || wordWrapStyle !== cssBreakWord) {
	                                if (maxLineWidth <= editor.minWidth) {
	                                    $editor.css(cssWidth, editor.minWidth).css(cssWordWrap, cssNormal)
	                                        .css(cssOverflow, cssHidden);
	                                    if (isDIVElement) {
	                                        $editor.css(cssWordBreak, cssNormal);
	                                    }
	                                } else if (maxLineWidth > editor.minWidth && maxLineWidth <= editor.maxWidth) {
	                                    $editor.css(cssWidth, maxLineWidth).css(cssWordWrap, cssNormal)
	                                        .css(cssOverflow, cssHidden);
	                                    if (isDIVElement) {
	                                        $editor.css(cssWordBreak, cssNormal);
	                                    }
	                                } else if (maxLineWidth > editor.maxWidth) {
	                                    $editor.css(cssWidth, editor.maxWidth - 2).css(cssWordWrap, cssBreakWord)
	                                        .css(cssOverflow, cssHidden);
	                                    wrapHeight = getTextWrapHeight(lineWidthTemps, editor.maxWidth, lineHeight, lineHeightArray);
	                                }
	                            } else if (maxLineWidth > editorWidth) {   
	                                wrapHeight = getTextWrapHeight(lineWidthTemps, editorWidth, lineHeight, lineHeightArray);
	                            }
	                        }
	                        if (wrapHeight <= editor.minHeight) {
	                            $editor.css(cssHeight, editor.minHeight).css(cssFloat, cssNone);
	                        } else if (wrapHeight > editor.minHeight && wrapHeight <= editor.maxHeight) {
	                            $editor.css(cssHeight, wrapHeight).css(cssFloat, cssNone);
	                        } else if (wrapHeight > editor.maxHeight) {
	                           
	                            $editor.css(cssHeight, editor.maxHeight - 1)
	                                .css(cssOverflowY, cssScroll).css(cssFloat, cssLeft);
	                        }
	                    }
	                    hAlign = $editor.css(cssTextAlign);
	                    var flowWidth = $editor.width() - editor.minWidth;
	                    if (!isNullOrUndefined(hAlign) && hAlign !== cssLeft) {
	                        if (hAlign === cssCenter) {
	                            $editor.css(cssLeft, editor.originalLeft - flowWidth / 2);
	                        } else if (hAlign === cssRight) {
	                            $editor.css(cssLeft, editor.originalLeft - flowWidth);
	                        }
	                    }
	
	                    if (cellStyle && isDIVElement) {
	                        var vAlign = cellStyle.vAlign;
	                        if (vAlign === 1 ) {
	                            $editor.css('vertical-align', 'middle');
	                        } else if (vAlign === 2 ) {
	                            $editor.css('vertical-align', 'bottom');
	                        }
	                    }
	
	                    var editorContainerHeight = parseIntFunc(editor.style.height) + adjustHeight + paddingTop + paddingBottom;
	                    var editorContextOffset = adjustWidth + paddingLeft + paddingRight;
	                    if ($editor.css(cssOverflowY) === cssScroll) {
	                        self.updateEditorContainer(editor, {
	                            width: editor.offsetWidth + editorContextOffset,
	                            height: startEditByKeyDown ? 0 : editorContainerHeight
	                        }, cellStyle);
	                    } else {
	                        self.updateEditorContainer(editor, {
	                            width: parseIntFunc(editor.style.width) + editorContextOffset,
	                            height: editorContainerHeight
	                        }, cellStyle);
	                    }
	                }
	            }
	        },
	        updateEditor: function (editorContext, cellStyle, cellRect, context) {
	            this._updateEditorImp(editorContext, cellStyle, cellRect, keyword_null, context);
	            if (browser_msie && editorContext) {
	                var $editor = $(editorContext), width = $editor.width();
	                $editor.width(width + 1).width(width);
	            }
	        },
	        updateImeMode: function (editorContext, imeMode, context) { 
	            if (this.isImeAware() && editorContext) {
	                CellTypeContext._setImeMode(editorContext, imeMode);
	            }
	        },
	        isReservedKey: function (event, context) {
	            var src = event.srcElement || event.target, keyCode = event.keyCode, ctrlKey = event.ctrlKey,
	                altKey = event.altKey, metaKey = event.metaKey;
	            if (src && context && context.isEditing && src.getAttribute(attrGcUIElement) === 'gcEditingInput') {
	                return keyCode === 13  && (ctrlKey && !event.shiftKey || altKey) ||
	                    (keyCode === 90  && ctrlKey && !altKey) ||
	                    (keyCode === 89  && ctrlKey && !altKey) ||
	                    (keyCode === 67  && (ctrlKey || metaKey) && !altKey) ||
	                    (keyCode === 88  && (ctrlKey || metaKey) && !altKey);
	            }
	            return false;
	        },
	        isImeAware: function (context) { 
	            return true;
	        },
	        toJSON: function () {
	            var settings = {}, self = this;
	            for (var p in self) {
	                if (self.hasOwnProperty(p) && p !== '_editingElement') {
	                    settings[p] = self[p];
	                }
	            }
	            return settings;
	        }
	    });
	    CellTypes.Text = TextCellType;
	    CellTypes._typeDict[1 ] = TextCellType;
	   
	
	    module.exports = exports;
	
	}());

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var $ = __webpack_require__(4).GC$;
	    var util_common = __webpack_require__(3);
	    var StyleHelper = __webpack_require__(11)._StyleHelper;
	    var CellTypes_Module = __webpack_require__(13).CellTypes;
	    var Common = __webpack_require__(5);
	
	    var exports = __webpack_require__(1);
	    if (!exports.CellTypes) {
	        exports.CellTypes = {};
	    }
	    var CellTypes = exports.CellTypes;
	
	    var _ThemeStyleHelper = util_common._ThemeStyleHelper;
	    var _WordWrapHelper = util_common._WordWrapHelper;
	    var getLinearGradientColors = util_common._util._getLinearGradientColors;
	    var _isCJKText = util_common._util._isCJKText;
	    var setContextFont = util_common._util._setContextFont;
	    var isNullOrUndefined = Common._Types._isNullOrUndefined;
	    var BaseCellType = CellTypes_Module.Base;
	    var CellTypeContext = CellTypes_Module.Context;
	    var convertRichTextValue = util_common._util._convertRichTextValue;
	    var $_inherit = $.inherit;
	    var cloneObject = $.extend;
	
	    var cssNone = 'none', keyword_undefined = void 0, Math_floor = Math.floor;
	
	   
	    function getThemeStyleForPaint(visualState, headerTypeString) {
	        visualState = visualState || 0 ;
	        return _ThemeStyleHelper._getVisualStateThemeStyle(visualState, 'gc-' + headerTypeString + '-' + _ThemeStyleHelper._getString(visualState));
	    }
	
	    function headerCellType_paintCSSBackgroundImage(ctx, x, y, w, h, backgroundImg) {
	        var img = new Image();
	        var src = backgroundImg;
	        src = src.replace('url("', '');
	        src = src.replace('")', '');
	        img.src = src;
	        ctx.drawImage(img, x, y, w, h);
	    }
	
	    function headerCellType_paintBackground(ctx, x, y, w, h, style, options, visualState, themeStyle) {
	        if (!isNullOrUndefined(visualState)) {
	            ctx.save();
	            ctx.beginPath();
	            var fillStyle;
	            if (visualState === 0  && style.backColor) {
	                fillStyle = style.backColor;
	                if (ctx.fillStyle !== fillStyle) {
	                    ctx.fillStyle = fillStyle;
	                }
	                ctx.fillRect(x + 1, y + 1, w - 1, h - 1);
	            } else {
	                try {
	                    var backColor = themeStyle && themeStyle.backgroundColor,
	                        backgroundImg = themeStyle && themeStyle.backgroundImage;
	                    if (backgroundImg && backgroundImg.indexOf('linear-gradient') !== -1) {
	                        var colors = getLinearGradientColors(backgroundImg);
	                        fillStyle = ctx.createLinearGradient(x + w / 2, y, x + w / 2, y + h);
	                        for (var i = 0, len = colors.length; i < len; i++) {
	                            var color = colors[i];
	                            fillStyle.addColorStop(color.point, color.color);
	                        }
	                        ctx.fillStyle = fillStyle;
	                        ctx.fillRect(x + 1, y + 1, w - 1, h - 1);
	                    } else if (backColor) {
	                        ctx.fillStyle = backColor;
	                        ctx.fillRect(x + 1, y + 1, w - 1, h - 1);
	                    } else if (backgroundImg && backgroundImg !== cssNone) {
	                        headerCellType_paintCSSBackgroundImage(ctx, x + 1, y + 1, w - 1, h - 1, backgroundImg);
	                    }
	                } catch (ex) {
	                   
	                }
	            }
	           
	            CellTypeContext._paintBackgroundImage(ctx, x, y, w, h, style.backgroundImage, style.backgroundImageLayout, options.imageLoader);
	            ctx.restore();
	        }
	    }
	
	    function headerCellType_paint(cellType, ctx, value, x, y, w, h, style, options, headerTypeString, sheetArea) {
	        if (ctx) {
	            var visualState = options.visualState || 0 ;
	            var themeStyle = getThemeStyleForPaint(visualState, headerTypeString);
	            headerCellType_paintBackground(ctx, x, y, w, h, style, options, visualState, themeStyle);
	            CellTypeContext._paintHeaderCellGridline(ctx, x, y, w, h, style, headerTypeString, themeStyle, sheetArea, options.needTopGridline, options.needLeftGridline);
	
	            var rect = new util_common.Rect(x, y, w, h);
	            if (cellType._paintLabel) {
	                cellType._paintLabel(ctx, rect, style, options);
	                rect = cellType._getContentRect(rect, style);
	            }
	            if (rect.width > 0 && rect.height > 0) {
	                cellType.paintContent(ctx, value, rect.x, rect.y, rect.width, rect.height, style, options);
	            }
	        }
	    }
	
	    function getFontByVisualStatus(getThemeStyleFunc, font, fillStyle, options, sheetArea, themeStyle) {
	        var fontInfo = {font: font, fillStyle: fillStyle}, sheet = options.sheet;
	
	        if (options.visualState !== 0  && parseInt(themeStyle.zIndex) > 2007 
	            && sheet._isSelected(options.row, options.col, sheetArea)) {
	            var hlThemeStyle;
	            if (sheet._isAllSelected(options.row, options.col, sheetArea)) {
	                hlThemeStyle = getThemeStyleFunc(options.visualState, 'gc-columnHeader-selected');
	            } else {
	                hlThemeStyle = getThemeStyleFunc(options.visualState, 'gc-columnHeader-highlight');
	            }
	            fontInfo.fillStyle = hlThemeStyle.color;
	            fontInfo.font = StyleHelper._setStringFont(fontInfo.font, 'bold');
	        }
	        return fontInfo;
	    }
	
	    function headerCellType_paintText(cellType, ctx, value, x, y, w, h, style, options, sheetArea, themeStyle) {
	        var formattedData = {};
	        var text = cellType.format(convertRichTextValue(value), style.formatter, formattedData);
	        if (text) {
	            ctx.save();
	            ctx.beginPath();
	
	           
	            var sheet = options.sheet, rowFilter = sheet.rowFilter && sheet.rowFilter();
	            var hasFilterHeader = !!(rowFilter && rowFilter._isFilterHeader(options.row, options.col, sheetArea) && rowFilter.filterButtonVisible(options.col));
	            if (hasFilterHeader) {
	                w -= sheet._getFilterButtonRect(new util_common.Rect(x, y, w, h), sheetArea).width;
	            }
	
	           
	            var fillStyle = style.foreColor;
	            if (!fillStyle) {
	                fillStyle = themeStyle.color;
	            }
	            if (fillStyle && ctx.fillStyle !== fillStyle) {
	                ctx.fillStyle = fillStyle;
	            }
	           
	            if ((value && value.richText && value.richText.length > 0)
	                || style.isVerticalText) {
	                headerCellType_paintRichTextOrVerticalText(cellType, sheet, ctx, value, x, y, w, h, style, text, formattedData, options, sheetArea, themeStyle);
	            } else {
	                headerCellType_paintHorizontalText(cellType, ctx, value, x, y, w, h, style, text, formattedData, options, sheetArea, themeStyle);
	            }
	
	            ctx.restore();
	        }
	    }
	
	    function headerCellType_paintRichTextOrVerticalText(cellType, sheet, ctx, value, x, y, w, h, style, text, formattedData, options, sheetArea, themeStyle) {
	        var clipRect = {x: x, y: y, width: w, height: h};
	       
	        var defaultFont = getFontByVisualStatus(cellType.getThemeStyle, style.font || ctx.font, ctx.fillStyle, options, sheetArea, themeStyle);
	        var isVerticalText = style.isVerticalText, hAlign = style.hAlign;
	        var indent = getIndent(style);
	        var isRichTextAvailable = cellType._isRichTextAvailable(style.formatter || style._autoFormatter);
	        var richText = cloneObject(true, [], cellType._getRichTextValue(value, text, isRichTextAvailable, defaultFont.font, defaultFont.fillStyle));
	       
	       
	       
	        if (value && value.richText && value.richText.length > 0) {
	            var zoomFactor = options.sheet ? options.sheet.zoom() : 1;
	            cellType._scaleFontByZoomFactor(richText, defaultFont, zoomFactor);
	        }
	
	        if (!style.wordWrap && style.shrinkToFit) {
	            cellType._scaleFontByShrinkToFit(richText, w, h, style, defaultFont, 1, isVerticalText);
	        }
	        var data = cellType._processDataByWordWrap(ctx, text, style.font, isVerticalText ? h : w, indent,
	            isVerticalText ? style.vAlign : style.hAlign, style.wordWrap, isVerticalText, richText);
	        var linesStyle = cellType._getLinesStyle(data, style, hAlign);
	        clipRectangle(ctx, style, x, y, w, h, indent, data[0].textLength, linesStyle[0].lineHeight);
	        var isCJKText = isVerticalText ? _isCJKText(text) : keyword_undefined;
	        var paintPositions = cellType._calcPaintPositions(clipRect.x, clipRect.y, clipRect.width, clipRect.height, hAlign, style.vAlign, indent, isVerticalText, isCJKText, data, linesStyle);
	        var count = data.length;
	        if (count === 1 && formattedData.content && !isRichTextAvailable) {
	            cellType._paintFormattedData(ctx, sheet, text, formattedData, paintPositions[0].x, paintPositions[0].y, w, h, hAlign, style, clipRect.width, clipRect.height, indent, isVerticalText, data[0].textLength);
	        } else {
	            for (var i = 0; i < count; i++) {
	                cellType._paintEntireLineOfText(ctx, sheet, paintPositions[i].x, paintPositions[i].y, linesStyle[i], hAlign, data[i]);
	            }
	        }
	    }
	
	    function headerCellType_paintHorizontalText(cellType, ctx, value, x, y, w, h, style, text, formattedData, options, sheetArea, themeStyle) {
	        var clipRect = {x: x, y: y, width: w, height: h};
	       
	        var fontInfo = getFontByVisualStatus(cellType.getThemeStyle, style.font || ctx.font, ctx.fillStyle, options, sheetArea, themeStyle);
	        setContextFont(ctx, fontInfo.font);
	        ctx.fillStyle = fontInfo.fillStyle;
	        var indent = 0, textIndent = style.textIndent;
	        if (textIndent > 0) {
	            indent = textIndent * 8;
	        }
	        var fontSize = options.fontInfo.fontSize;
	
	        var hAlign = style.hAlign, vAlign = style.vAlign;
	       
	        var textAlign = 'left', adjX = 2;
	        adjX += indent;
	        if (hAlign === 1 ) {
	            adjX = w / 2;
	            textAlign = 'center';
	        } else if (hAlign === 2 ) {
	            adjX = w - 1;
	            adjX -= indent;
	            textAlign = 'right';
	        }
	        if (ctx.textAlign !== textAlign) {
	            ctx.textAlign = textAlign;
	        }
	       
	        var textHeight = 0, textBaseline = 'alphabetic', adjY = 2, wordWrap = style.wordWrap,
	            lineHeight = options.lineHeight, lines = [], lineCount = 0;
	        if (wordWrap) {
	           
	           
	            var wordWrapWidth = w - 3 - indent;
	            wordWrapWidth -= 1;
	            lines = _WordWrapHelper._getWrapInfo(text, wordWrapWidth, fontInfo.font);
	            lineCount = lines.length;
	            if (lineCount > 1 && vAlign !== 0 ) {
	                textHeight = (lineCount - 1) * lineHeight;
	            }
	        }
	        var baselineOffset = fontSize > 8 ? Math_floor((fontSize - 8) / 5 + 2) : 1,
	            lineOffset = lineHeight / 2 - fontSize / 2 + baselineOffset - 1;
	        adjY += lineHeight - lineOffset;
	        if (vAlign === 1 ) {
	            adjY = (h - textHeight) / 2 + lineHeight / 2 - lineOffset;
	        } else if (vAlign === 2 ) {
	            adjY = h - textHeight - 2 - lineOffset;
	        }
	        if (ctx.textBaseline !== textBaseline) {
	            ctx.textBaseline = textBaseline;
	        }
	        var textDecoration = style.textDecoration;
	        var clipX = clipRect.x, clipY = clipRect.y, clipWidth = clipRect.width, clipHeight = clipRect.height;
	        if (style.wordWrap) {
	            ctx.rect(clipX, clipY, clipWidth, clipHeight);
	            ctx.clip();
	            ctx.beginPath();
	            var vpos = y + adjY;
	            if (lineCount > 1) {
	                for (var i = 0; i < lineCount; i++) {
	                    ctx.fillText(lines[i], x + adjX, vpos);
	                    if (textDecoration) {
	                        var textLength = ctx.measureText(lines[i]).width;
	                        cellType._renderTextDecoration(ctx, textDecoration, x + adjX, vpos, textLength, fontSize, baselineOffset);
	                    }
	                    vpos += lineHeight;
	                }
	            } else {
	                cellType._renderCellTextNormal(ctx, text, formattedData, x + adjX, y + adjY, hAlign, clipWidth, indent, textDecoration, baselineOffset, fontSize);
	            }
	        } else {
	           
	            var txtWidth = ctx.measureText(text).width;
	            if (txtWidth > clipWidth || lineHeight > clipHeight) {
	                ctx.rect(clipX, clipY, clipWidth, clipHeight);
	                ctx.clip();
	                ctx.beginPath();
	            }
	            cellType._renderCellTextNormal(ctx, text, formattedData, x + adjX, y + adjY, hAlign, clipWidth, indent, textDecoration, baselineOffset, fontSize);
	        }
	
	    }
	
	    function clipRectangle(ctx, style, clipX, clipY, clipWidth, clipHeight, indent, txtLength, lineHeight) {
	        var needClip = false;
	        if (style.wordWrap) {
	            needClip = true;
	        } else if (style.isVerticalText) {
	            needClip = txtLength + indent > clipHeight || lineHeight > clipWidth;
	        } else {
	            needClip = txtLength + indent > clipWidth || lineHeight > clipHeight;
	        }
	        if (needClip) {
	            ctx.rect(clipX, clipY, clipWidth, clipHeight);
	            ctx.clip();
	            ctx.beginPath();
	        }
	    }
	
	    function getIndent(style) {
	        var indent = 0, textIndent = style.textIndent;
	        if (textIndent > 0) {
	            indent = textIndent * 8;
	        }
	        return indent;
	    }
	
	   
	
	   
	    $_inherit(ColumnHeaderCellType, BaseCellType);
	
	   
	    
	    function ColumnHeaderCellType() {
	        BaseCellType.call(this);
	        this.typeName = 2  + '';
	    }
	
	    ColumnHeaderCellType.prototype.paint = function (ctx, value, x, y, w, h, style, context) {
	        headerCellType_paint(this, ctx, value, x, y, w, h, style, context, 'columnHeader', 1 );
	    };
	    ColumnHeaderCellType.prototype.paintContent = function (ctx, value, x, y, w, h, style, context) {
	        var themeStyle = getThemeStyleForPaint(context.visualState, 'columnHeader');
	        headerCellType_paintText(this, ctx, value, x, y, w, h, style, context, 1 , themeStyle);
	    };
	    CellTypes.ColumnHeader = ColumnHeaderCellType;
	    CellTypes._typeDict[2 ] = ColumnHeaderCellType;
	   
	
	   
	    $_inherit(RowHeaderCellType, BaseCellType);
	
	   
	    
	    function RowHeaderCellType() {
	        BaseCellType.call(this);
	        this.typeName = 3  + '';
	    }
	
	    RowHeaderCellType.prototype.paint = function (ctx, value, x, y, w, h, style, context) {
	        headerCellType_paint(this, ctx, value, x, y, w, h, style, context, 'rowHeader', 2 );
	    };
	    RowHeaderCellType.prototype.paintContent = function (ctx, value, x, y, w, h, style, context) {
	        var themeStyle = getThemeStyleForPaint(context.visualState, 'rowHeader');
	        headerCellType_paintText(this, ctx, value, x, y, w, h, style, context, 2 , themeStyle);
	    };
	    CellTypes.RowHeader = RowHeaderCellType;
	    CellTypes._typeDict[3 ] = RowHeaderCellType;
	   
	
	   
	    $_inherit(CornerCellType, BaseCellType);
	
	   
	    
	    function CornerCellType() {
	        BaseCellType.call(this);
	        this.typeName = 4  + '';
	    }
	
	    CornerCellType.prototype.paint = function (ctx, value, x, y, w, h, style, context) {
	        if (!ctx) {
	            return;
	        }
	        ctx.save();
	       
	        ctx.rect(x, y, w, h);
	        ctx.clip();
	        ctx.beginPath();
	       
	        var self = this;
	        var visualState = context.visualState || 0 ;
	        try {
	            var tmpStyle = self.getThemeStyle(context.visualState, 'gc-corner-' + _ThemeStyleHelper._getString(visualState)),
	                backColor = (tmpStyle && tmpStyle.backgroundColor), backImg = (tmpStyle && tmpStyle.backgroundImage);
	            if (backColor) {
	                ctx.fillStyle = backColor;
	                ctx.fillRect(x, y, w, h);
	            } else if (backImg && backImg !== cssNone) {
	                headerCellType_paintCSSBackgroundImage(ctx, x, y, w, h, backImg);
	            }
	        } catch (ex) {
	           
	        }
	        var hoverStyle = self.getThemeStyle(4 , 'gc-corner-triangle-' + _ThemeStyleHelper._getString(visualState));
	        var backgroundImg = hoverStyle && hoverStyle.backgroundImage,
	            backgroundColor = hoverStyle && hoverStyle.backgroundColor;
	        var gradient = ctx.createLinearGradient(x + w / 2, y, x + w / 2, y + h);
	        if (backgroundImg && backgroundImg.indexOf('linear-gradient') !== -1) {
	            var colors = getLinearGradientColors(backgroundImg);
	            for (var i = 0, len = colors.length; i < len; i++) {
	                var color = colors[i];
	                gradient.addColorStop(color.point, color.color);
	            }
	            ctx.fillStyle = gradient;
	        } else if (backgroundColor) {
	            gradient.addColorStop(0.125, '#f6fafb');
	            gradient.addColorStop(1.0, backgroundColor);
	            ctx.fillStyle = gradient;
	        }
	       
	        var rightStrokeStyle = ctx.createLinearGradient(x + w, y + 1, x + w, y + h - 2);
	        rightStrokeStyle.addColorStop(0, hoverStyle.borderLeftColor);
	        rightStrokeStyle.addColorStop(1, hoverStyle.borderRightColor);
	        ctx.beginPath();
	        ctx.strokeStyle = rightStrokeStyle;
	        ctx.moveTo(x + w - 0.5, y);
	        ctx.lineTo(x + w - 0.5, y + h);
	        ctx.stroke();
	       
	        if (context.needLeftGridline) {
	            ctx.beginPath();
	            ctx.strokeStyle = hoverStyle.borderLeftColor;
	            ctx.moveTo(x + 0.5, y);
	            ctx.lineTo(x + 0.5, y + h);
	            ctx.stroke();
	        }
	       
	        var bottomStrokeStyle = ctx.createLinearGradient(x, y, x + w - 2, y);
	        bottomStrokeStyle.addColorStop(0, hoverStyle.borderTopColor);
	        bottomStrokeStyle.addColorStop(1, hoverStyle.borderBottomColor);
	        ctx.beginPath();
	        ctx.strokeStyle = bottomStrokeStyle;
	        ctx.moveTo(x, y + h - 0.5);
	        ctx.lineTo(x + w, y + h - 0.5);
	        ctx.stroke();
	       
	        if (context.needTopGridline) {
	            ctx.beginPath();
	            ctx.strokeStyle = hoverStyle.borderTopColor;
	            ctx.moveTo(x, y + 0.5);
	            ctx.lineTo(x + w, y + 0.5);
	            ctx.stroke();
	        }
	
	        ctx.beginPath();
	        var padding = 3;
	        var size = h;
	        if (w < h) {
	            size = w;
	        }
	        ctx.moveTo(x + w - size + padding, y + h - padding);
	        ctx.lineTo(x + w - padding, y + h - padding);
	        ctx.lineTo(x + w - padding, y + h - size + padding);
	        ctx.fill();
	        ctx.restore();
	    };
	    CellTypes.Corner = CornerCellType;
	    CellTypes._typeDict[4 ] = CornerCellType;
	   
	
	    module.exports = exports;
	
	}());

/***/ }),
/* 43 */
/***/ (function(module, exports) {

	(function () {
	    'use strict';
	
	    module.exports = {
	        Exp_NotSupported: 'NotSupportException',
	        Exp_PasteExtentIsNull: 'pasteExtent is null',
	        Exp_InvalidPastedArea: 'The pasted area should have the same size as the copy or cut area.',
	        Exp_ChangePartOfArray: 'Cannot change part of an array.',
	        Exp_InvalidAndSpace: 'Invalid {0}: {1} (must be between {2} and {3}).',
	        Exp_SrcIsNull: 'The argument \'src\' is null',
	        Exp_DestIsNull: 'The argument \'dest\' is null',
	        Exp_InvalidCustomFunction: 'invalid custom function',
	        Exp_InvalidCustomName: 'invalid custom name',
	        Exp_IndexOutOfRange: 'Index is out of range!',
	        Exp_InvalidRange: 'Invalid range',
	        Exp_ArgumentOutOfRange: 'ArgumentOutOfRange',
	        Exp_PasteSourceCellsLocked: 'Source sheet\'s cells are locked.',
	        Exp_InvalidCopyPasteSize: 'The copy and paste areas are not the same size.',
	        Exp_PasteDestinationCellsLocked: 'The cell you are trying to change is protected and therefore read-only.',
	        Exp_PasteChangeMergeCell: 'Cannot change part of a merged cell.',
	        Tip_Row: 'Row: ',
	        Tip_Column: 'Column: ',
	        Tip_Height: 'Height: {0} pixels',
	        Tip_Width: 'Width: {0} pixels',
	        NewTab: 'New...',
	        Exp_EmptyNamedStyle: 'The name of named style cannot be empty or null',
	        Exp_SheetNameInvalid: 'The sheet name can not be blank or contains these characters : *, :, [, ], ?, \\, /',
	        Exp_ArrayFromulaSpan: 'Array formulas are not valid in merged cells.',
	        Exp_DestSheetIsNull: 'destSheet is null',
	        Exp_SheetIsNull: 'sheet is null.',
	        Exp_OverlappingSpans: 'This operation will cause overlapping spans.',
	        NeedCanvasSupport: 'You need a browser which full supports HTML5 Canvas to run SpreadJS',
	        lsru: ['',
	            '6465706c6f796d656e74'],
	        lsde: ['',
	            '64657369676e6572'],
	       
	        ls1 : ['',
	            '506f776572656420627920477261706543697479205370726561642e5368656574732e0d0a596f752063616e206f6e6c79206465706c6f792074686973204556414c554154494f4e2076657273696f6e206c6f63616c6c792e0d0a54656d706f72617279207b317d206b6579732061726520617661696c61626c6520666f722074657374696e672e0d0a456d61696c2075732e73616c6573406772617065636974792e636f6d2e'],
	       
	        ls2:  ['',
	            '506f776572656420627920477261706543697479205370726561642e5368656574732e0d0a596f75722074656d706f72617279207b317d206b6579206578706972657320696e207b307d206461792873292e'],
	       
	        ls3:  ['',
	            '4c6963656e7365204e6f7420466f756e640d0a596f75206e65656420612076616c6964206c6963656e7365206b657920746f2072756e205370726561642e5368656574732e0d0a54656d706f72617279206b6579732061726520617661696c61626c6520666f72206576616c756174696f6e2e0d0a496620796f75207075726368617365642061206c6963656e73652c20796f7572206b657920697320696e20796f757220707572636861736520636f6e6669726d6174696f6e20656d61696c2e0d0a456d61696c2075732e73616c6573406772617065636974792e636f6d20696620796f75206e65656420617373697374616e63652e'],
	       
	        ls4: ['',
	            '496e76616c6964206c6963656e7365206b65792e20456d61696c2075732e73616c6573406772617065636974792e636f6d20696620796f75206e6565642068656c702e'],
	       
	        ls5: ['',
	            '506f776572656420627920477261706543697479205370726561642e5368656574732e0d0a596f75722074656d706f72617279207b317d206b65792068617320657870697265642e0d0a456d61696c2075732e73616c6573406772617065636974792e636f6d20666f722068656c702e'],
	       
	        ls6:  ['',
	            '506f776572656420627920477261706543697479205370726561642e536865657473204576616c756174696f6e2056657273696f6e0d0a4e6f74204c6963656e73656420666f7220446973747269627574696f6e']
	    };
	    
	}());

/***/ })
/******/ ]);
//# sourceMappingURL=gc.spread.sheets.core.12.0.0.js.map