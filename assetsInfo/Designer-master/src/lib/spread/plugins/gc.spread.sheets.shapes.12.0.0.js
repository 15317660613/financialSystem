/*!
 * 
 * Spread.Sheets Library 12.0.0
 * 
 * Copyright(c) GrapeCity, Inc.  All rights reserved.
 * 
 * Licensed under the SpreadJS Commercial License.
 * us.sales@grapecity.com
 * http://www.grapecity.com/en/licensing/grapecity/
 * 
 * 
 */

(function (factory) {
   if(typeof module === 'object' && typeof module.exports === 'object') {
       module.exports = factory(require('@grapecity/spread-sheets'));
   } else if(typeof define === 'function' && define.amd) {
       define(['@grapecity/spread-sheets'], factory)
   } else if(typeof exports === 'object') {
       exports['Spread'] = factory(require('@grapecity/spread-sheets'));
   } else {
       factory(GC);
   }
}(function (GC) {
   GC = GC || {}; GC["Spread"] = GC["Spread"] || {}; GC["Spread"]["Sheets"] = GC["Spread"]["Sheets"] || {}; GC["Spread"]["Sheets"]["Shapes"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/assets/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var Shapes = __webpack_require__(1);
	    Shapes.SR = {};
	    Shapes.SR['en'] = __webpack_require__(2);
	
	    var ShapesUI = __webpack_require__(3);
	    __webpack_require__(4);
	    __webpack_require__(5);
	    __webpack_require__(6);
	    __webpack_require__(7);
	    __webpack_require__(9);
	    __webpack_require__(10);
	    __webpack_require__(11);
	    __webpack_require__(12);
	    __webpack_require__(14);
	    for (var p in ShapesUI) {
	        if (ShapesUI.hasOwnProperty(p)) {
	            Shapes[p] = ShapesUI[p];
	        }
	    }
	
	    __webpack_require__(15);
	    __webpack_require__(18);
	    __webpack_require__(19);
	    __webpack_require__(20);
	    __webpack_require__(21);
	    __webpack_require__(22);
	    __webpack_require__(23);
	    __webpack_require__(24);
	    __webpack_require__(26);
	    __webpack_require__(27);
	
	    module.exports = Shapes;
	}());

/***/ }),
/* 1 */
/***/ (function(module, exports) {

	(function() {
	    'use strict';
	
	    module.exports = {};
	
	}());

/***/ }),
/* 2 */
/***/ (function(module, exports) {

	(function() {
	    'use strict';
	
	    module.exports = {
	        Exp_InvalidConnectionSite: 'Invalid connection site.',
	        Exp_DuplicatedName: 'Duplicated name.',
	        Exp_EmptyName: 'Empty name.'
	    };
	
	}());

/***/ }),
/* 3 */
/***/ (function(module, exports) {

	(function() {
	    'use strict';
	
	    module.exports = {};
	
	}());

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	var Shapes = __webpack_require__(3);
	
	var Common = (function () {
	    var common = {};
	
	    var tmpSpan = null;
	    var fontHeightCache = {};
	
	    function getFontHeight(font) {
	        if (fontHeightCache[font]) {
	            return fontHeightCache[font];
	        }
	
	        if (!tmpSpan) {
	            var doc = document;
	            tmpSpan = doc.createElement("span");
	            var style = tmpSpan.style;
	            style.position = "absolute";
	            style.left = "-1000px";
	            doc.body.appendChild(tmpSpan);
	        }
	        if (font) {
	            tmpSpan.style.font = font;
	        }
	        tmpSpan.innerHTML = "H";
	        fontHeightCache[font] = tmpSpan.offsetHeight;
	        return fontHeightCache[font];
	    }
	
	    common.getFontHeight = getFontHeight;
	
	    function Rect(x, y, w, h) {
	        var self = this;
	        if (w < 0) {
	            w = -w;
	            x -= w;
	        }
	        if (h < 0) {
	            h = -h;
	            y -= h;
	        }
	        self.x = x;
	        self.y = y;
	        self.width = w;
	        self.height = h;
	    }
	    Rect.prototype = {
	        getIntersectRect: function (rect) {
	            return this.getIntersect(rect.x, rect.y, rect.width, rect.height);
	        },
	        getIntersect: function (x, y, width, height) {
	            if (width < 0) {
	                width = -width;
	                x -= width;
	            }
	            if (height < 0) {
	                height = -height;
	                y -= height;
	            }
	            var self = this, x1_s = self.x, y1_s = self.y, x1_e = self.x + self.width, y1_e = self.y + self.height,
	                x2_s = x, y2_s = y, x2_e = x + width, y2_e = y + height,
	                intersectX_s = Math.max(x1_s, x2_s), intersectY_s = Math.max(y1_s, y2_s),
	                intersectX_e = Math.min(x1_e, x2_e), intersectY_e = Math.min(y1_e, y2_e),
	                newX = intersectX_s, newY = intersectY_s, newWidth = intersectX_e - intersectX_s,
	                newHeight = intersectY_e - intersectY_s;
	            if (newWidth > 0 && newHeight > 0) {
	                return new Rect(newX, newY, newWidth, newHeight);
	            }
	        },
	        intersect: function (x, y, width, height) {
	            var self = this;
	            if (width < 0) {
	                width = -width;
	                x -= width;
	            }
	            if (height < 0) {
	                height = -height;
	                y -= height;
	            }
	            return x < self.x + self.width && self.x < x + width && y < self.y + self.height && self.y < y + height;
	        },
	        expand: function (amount) {
	            var self = this;
	            self.x -= amount;
	            self.y -= amount;
	            self.width += 2 * amount;
	            self.height += 2 * amount;
	        }
	    };
	    common.Rect = Rect;
	
	    function Point(x, y) {
	        var self = this;
	        self.x = x;
	        self.y = y;
	    }
	    Point.prototype.clone = function () {
	        var self = this;
	        return new Point(self.x, self.y);
	    };
	    common.Point = Point;
	
	    common.extend = function (target) {
	        var to = Object(target);
	        var args = arguments, len = args.length;
	
	        for (var index = 1; index < len; index++) {
	            var nextSource = args[index];
	
	            if (nextSource !== null && nextSource !== undefined) {
	                for (var nextKey in nextSource) {
	                   
	                    if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
	                        to[nextKey] = nextSource[nextKey];
	                    }
	                }
	            }
	        }
	        return to;
	    };
	
	    function toRadius(angle) {
	        return (angle / 180) * Math.PI;
	    }
	
	    common.toRadius = toRadius;
	
	    function rotatePoint(point, origin, radians) {
	        point.x -= origin.x;
	        point.y -= origin.y;
	        var v = rotateVector(point, radians);
	
	        return { x: v.x + origin.x, y: v.y + origin.y };
	    }
	
	    common.rotatePoint = rotatePoint;
	
	    function rotateVector(vector, radians) {
	        var sin = Math.sin(radians),
	            cos = Math.cos(radians),
	            rx = vector.x * cos - vector.y * sin,
	            ry = vector.x * sin + vector.y * cos;
	        return {
	            x: rx,
	            y: ry
	        };
	    }
	
	    common.rotateVector = rotateVector;
	
	    function isFormulaOption(option, typeOfOptoin) {
	        return (typeOfOptoin === "string" && option.length > 0 && option[0] === "=");
	    }
	
	    function getOptionValue(option, shape) {
	        var type = typeof (option);
	        if (type === "function") {
	            return option(shape);
	        } else if (isFormulaOption(option, type)) {
	            var resolver = shape && shape.getValueResolver();
	            if (resolver) {
	                return resolver.getValue(option.substring(1));
	            }
	        }
	        return option;
	    }
	
	    common.getOptionValue = getOptionValue;
	
	    function cloneOptions(options) {
	        return JSON.parse(JSON.stringify(options));
	    }
	
	    common.cloneOptions = cloneOptions;
	
	    function defineProperty(obj, prop, descriptor) {
	        descriptor.configurable = true;
	        descriptor.enumerable = true;
	        Object.defineProperty(obj, prop, descriptor);
	    }
	    common.defineProperty = defineProperty;
	
	    function getLength(array) {
	        return array && array.length;
	    }
	    common._getArrayLength = getLength;
	    common._inArray = function (elem, arr, i) {
	        var len;
	        if (arr) {
	            var core_indexOf = [].indexOf;
	            if (core_indexOf) {
	                return core_indexOf.call(arr, elem, i);
	            }
	            len = arr.length;
	            if (i === undefined || i === null) {
	                i = 0;
	            }
	            i = i < 0 ? Math.max(0, len + i) : i;
	            for (; i < len; i++) {
	               
	                if (i in arr && arr[i] === elem) {
	                    return i;
	                }
	            }
	        }
	        return -1;
	    };
	
	    function arrayPush(array, value) {
	        array.push(value);
	    }
	    common._arrayPush = arrayPush;
	    function Array_remove(array, item) {
	        var self = array;
	        var n = self.indexOf(item);
	        if (n >= 0) {
	            self.splice(n, 1);
	        }
	    }
	    common.Array_remove = Array_remove;
	
	    function createElement(node) {
	        return document.createElement(node);
	    }
	    common.createElement = createElement;
	    function fixNumber(n, digits) {
	        digits = digits || 3;
	        return +(n.toFixed(digits));
	    }
	    common.fixNumber = fixNumber;
	     function distance(x1, y1, x2, y2) {
	         return fixNumber(Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)));
	     }
	
	    function getPointToLine(x, y, x1, y1, x2, y2) {
	        var ans = 0,
	            a = distance(x1, y1, x2, y2),
	            b = distance(x1, y1, x, y),
	            c = distance(x, y, x2, y2);
	        if (c + b === a) {
	            ans = 0;
	            return ans;
	        }
	        if (a <= 0.00001) {
	            ans = b;
	            return ans;
	        }
	        if (c * c >= a * a + b * b) {
	            ans = b;
	            return ans;
	        }
	        if (b * b >= a * a + c * c) {
	            ans = c;
	            return ans;
	        }
	        var p0 = (a + b + c) / 2;// half perimeter
	        var s = Math.sqrt(p0 * (p0 - a) * (p0 - b) * (p0 - c));
	        ans = 2 * s / a;
	        return ans;
	    }
	
	    common.getPointToLine = getPointToLine;
	
	    return common;
	})();
	
	
	
	Shapes.Common = Common;
	
	var DIFF_LIMIT = 1.0e-10, CALC_COUNT_LIMIT = 100;
	
	function evaluateBoundFunction() {
	    var _this = this;
	    return _this._fn.apply(null, [].concat.apply([_this._width, _this._height], arguments));
	}
	
	function getBoundFunction(fn, width, height) {
	    var bindObject = { _fn: fn, _width: width, _height: height };
	    return evaluateBoundFunction.bind(bindObject);
	}
	
	function evaluteFunction(fn, value) {
	    var values = [value].concat(fn.values);
	    return fn.apply(null, values);
	}
	
	function getAdjustValue(fnNames, width, height, targetX, targetY, valueRange, shape) {
	    var minX = valueRange[0], maxX = valueRange[1];
	    var diffX = (maxX - minX);
	    var fnDefs = shape._fnDefs, fnArgs = shape._fnArgs;
	    var fnX = fnDefs[fnNames[0]], fnY = fnDefs[fnNames[1]];
	    if (!fnX && !fnY) {
	        return;
	    }
	    var fn = getBoundFunction(fnX || fnY, width, height);
	    var values, service = shape.service, id = shape.id;
	    if (fnX) {
	        if (fnX.length > 3) {  
	            values = fnArgs[fnNames[0]].slice(1).map(function (name) { return service.getValue(id, "variables." + name); });
	        }
	    } else if (fnY.length > 3) {
	        values = fnArgs[fnNames[1]].slice(1).map(function (name) { return service.getValue(id, "variables." + name); });
	    }
	    fn.values = values || [];
	    var v0 = evaluteFunction(fn, minX), v1 = evaluteFunction(fn, maxX), isReversed = v0 > v1, diffValue = v0 - v1;
	    var range = [v0, v1], offset = isReversed ? 1 : 0, minValue = range[offset % 2], maxValue = range[(offset + 1) % 2];
	    var result = {
	        min: minValue,
	        max: maxValue,
	        reversed: isReversed
	    };
	
	    var value, d;
	    var targetValue = fnX ? targetX : targetY;
	    if (targetValue < minValue) {
	        value = isReversed ? maxX : minX;
	    } else if (targetValue > maxValue) {
	        value = isReversed ? minX : maxX;
	    } else {
	        var x = Math.abs((targetValue - v0) * diffX / diffValue) + minX;
	        var y = evaluteFunction(fn, x), n = 0, last = 0;
	        d = y - targetValue;
	        while (Math.abs(d) > DIFF_LIMIT) {
	            x += diffX * d / diffValue;
	            y = evaluteFunction(fn, x);
	            d = y - targetValue;
	            if (last - d < DIFF_LIMIT) {
	               
	                break;
	            }
	            last = d;
	            n++;
	            if (n > CALC_COUNT_LIMIT) {
	               
	                break;
	            }
	        }
	        value = x;
	       
	       
	    }
	
	    result.value = value;
	
	    return result;
	}
	
	Shapes.getAdjustValue = getAdjustValue;
	
	
	var oneDegreeInExcelAngle = 60000,
	    radianToExcelAngle = oneDegreeInExcelAngle * 180 / Math.PI,
	    circleExcelAngle = oneDegreeInExcelAngle * 360, halfCircleExcelAngle = oneDegreeInExcelAngle * 180;
	
	
	function getAdjustAngle(rotateAngle, cx, cy, x, y, adjustInfo) {
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	
	   
	   
	   
	    var theta = Math.atan2(y - cy, x - cx) * radianToExcelAngle;
	    if (rotateAngle) {
	       
	       
	       
	       
	    }
	    if (adjustInfo) {
	        if (adjustInfo.toHalfCircle && theta < 0) {
	            theta += halfCircleExcelAngle;
	        } else if (adjustInfo.toNegative && theta > 0) {
	            theta -= halfCircleExcelAngle;
	        }
	    } else if (theta < 0) {
	        theta += circleExcelAngle;
	    }
	    return theta;
	}
	Shapes.getAdjustAngle = getAdjustAngle;
	
	function getShapeNameList(shapes) {
	    var iDList = [];
	    shapes.forEach(function (sp) {
	        if (sp._shapeType === 3 ) {
	            iDList = iDList.concat(getShapeNameList(sp._shapes));
	        } else {
	            iDList.push(sp.name());
	        }
	    });
	    return iDList;
	}
	Shapes.getShapeNameList = getShapeNameList;
	function getLineShapeInGroup(group) {
	    var lines = [];
	    group._shapes.forEach(function (sp) {
	        if (sp._shapeType === 4 ) {
	            lines.push(sp);
	        }
	        if (sp._shapeType === 3 ) {
	            lines = lines.concat(getLineShapeInGroup(sp));
	        }
	    });
	    return lines;
	}
	Shapes.getLineShapeInGroup = getLineShapeInGroup;
	
	if (CanvasRenderingContext2D.prototype.ellipse === undefined) {
	    CanvasRenderingContext2D.prototype.ellipse = function (x, y, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise) {
	        var self = this;
	        self.save();
	        self.translate(x, y);
	        self.rotate(rotation);
	        self.scale(radiusX, radiusY);
	        self.arc(0, 0, 1, startAngle, endAngle, antiClockwise);
	        self.restore();
	    };
	}
	
	module.exports = Shapes;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	
	var Shapes = __webpack_require__(3);
	
	
	
	Shapes.ShapeFillType = {
	    
	    none: 0, 
	    
	    solid: 1
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	};
	
	var GradientTypes = {
	    linear: 0,
	    radial: 1,
	    rectangular: 2,
	    path: 3
	};
	
	Shapes.GradientTypes = GradientTypes;
	
	var GradientDirections = {
	    topLeft: 1,
	    topRight: 2,
	    center: 3,
	    bottomLeft: 4,
	    bottomRight: 5
	};
	
	Shapes.GradientDirections = GradientDirections;
	
	var CapType = {
	    square: "square", round: "round", flat: "butt"
	};
	
	Shapes.CapType = CapType;
	
	var JoinType = {
	    round: "round", bevel: "bevel", miter: "miter"
	};
	
	Shapes.JoinType = JoinType;
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	var colors = ["white", "black", "grey", "blue", "red", "yellow", "green", "cyan"];
	
	if (!Shapes.strokes) {
	    Shapes.strokes = {};
	}
	if (!Shapes.fills) {
	    Shapes.fills = {};
	}
	colors.forEach(function (color) {
	    Shapes.strokes[color] = createStroke(1 , color);
	    Shapes.fills[color] = createFill(1 , color);
	});
	
	function createStroke(type, color, width) {
	    return {
	        type: type || 1 ,
	        color: color || "black",
	        width: width || 1
	    };
	}
	
	Shapes.createStroke = createStroke;
	
	function createFill(type, color, width) {
	    return {
	        type: type || 1 ,
	        color: color || "white",
	        width: width || 1
	    };
	}
	
	Shapes.createFill = createFill;
	
	function createColorStops(color, position) {
	    return {
	        color: color,
	        position: position
	    };
	}
	
	Shapes.createColorStops = createColorStops;
	
	function createGradient(type, direction, angle, stops, transparency, brightness) {
	    return {
	        type: type || 0 ,
	        direction: direction || 3 ,
	        angle: angle || 0,
	        stops: stops,
	        transparency: transparency || 0,
	        brightness: brightness || 1,
	        rotateWithShape: true
	    };
	}
	
	Shapes.createGradient = createGradient;
	
	var defaultFont = "11pt Calibri";
	var defaultTextDirection = "horizontal";
	
	function createTextFormat(font, fill, textDirection, nowrap, textToOverflowShape) {
	    return {
	        font: font || defaultFont,
	        fill: fill || Shapes.fills.black,
	        allowTextToOverflowShape: textToOverflowShape,
	        textDirection: textDirection || defaultTextDirection,
	        wrapTextInShape: !nowrap,
	    };
	}
	
	Shapes.createTextFormat = createTextFormat;
	
	var defaultOptions = {
	    stroke: Shapes.strokes.grey,
	    fill: Shapes.fills.white,
	    textFormatOptions: createTextFormat(defaultFont, Shapes.fills.white, defaultTextDirection, false, false),
	};
	
	registerStyle("default", defaultOptions);
	
	var defaultLineOptions = {
	    stroke: {
	        type: 1 ,
	        color: "blue",
	    },
	    endPoints: {
	        beginArrow: { type: 1 , widthType: 1 , lengthType: 1  },
	        endArrow: { type: 3 , widthType: 1 , lengthType: 1  }
	    }
	};
	
	registerStyle("defaultLine", defaultLineOptions);
	
	function registerStyle(name, style) {
	    if (!Shapes.styles) {
	        Shapes.styles = {};
	    }
	    Shapes.styles[name] = style;
	}
	
	Shapes.registerStyle = registerStyle;
	
	function getStyle(name) {
	    return Shapes.styles[name];
	}
	
	Shapes.getStyle = getStyle;
	
	module.exports = Shapes;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	var Shapes = __webpack_require__(3);
	
	
	function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {
	    var sqrt = Math.sqrt,
	        Math_min = Math.min, Math_max = Math.max,
	        abs = Math.abs, tvalues = [],
	        bounds = [[], []],
	        a, b, c, t, t1, t2, b2ac, sqrtb2ac;
	
	    b = 6 * x0 - 12 * x1 + 6 * x2;
	    a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
	    c = 3 * x1 - 3 * x0;
	
	    for (var i = 0; i < 2; ++i) {
	        if (i > 0) {
	            b = 6 * y0 - 12 * y1 + 6 * y2;
	            a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
	            c = 3 * y1 - 3 * y0;
	        }
	
	        if (abs(a) < 1e-12) {
	            if (abs(b) < 1e-12) {
	                continue;
	            }
	            t = -c / b;
	            if (0 < t && t < 1) {
	                tvalues.push(t);
	            }
	            continue;
	        }
	        b2ac = b * b - 4 * c * a;
	        if (b2ac < 0) {
	            continue;
	        }
	        sqrtb2ac = sqrt(b2ac);
	        t1 = (-b + sqrtb2ac) / (2 * a);
	        if (0 < t1 && t1 < 1) {
	            tvalues.push(t1);
	        }
	        t2 = (-b - sqrtb2ac) / (2 * a);
	        if (0 < t2 && t2 < 1) {
	            tvalues.push(t2);
	        }
	    }
	
	    var x, y, j = tvalues.length, jlen = j, mt;
	    while (j--) {
	        t = tvalues[j];
	        mt = 1 - t;
	        x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);
	        bounds[0][j] = x;
	
	        y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);
	        bounds[1][j] = y;
	    }
	
	    bounds[0][jlen] = x0;
	    bounds[1][jlen] = y0;
	    bounds[0][jlen + 1] = x3;
	    bounds[1][jlen + 1] = y3;
	    return [
	        {
	            x: Math_min.apply(null, bounds[0]),
	            y: Math_min.apply(null, bounds[1])
	        },
	        {
	            x: Math_max.apply(null, bounds[0]),
	            y: Math_max.apply(null, bounds[1])
	        }
	    ];
	}
	
	function max(array, isMin) {
	    var m = isMin ? Number.MAX_VALUE : Number.MIN_VALUE;
	    array.forEach(function (v) {
	        m = isMin ? Math.min(m, v) : Math.max(m, v);
	    });
	    return m;
	}
	
	function min(array) {
	    return max(array, true);
	}
	
	function isRelativeCommand(cmd) {
	   
	   
	    return "mlhvcsqtaz".indexOf(cmd) > -1;
	}
	
	function makeAbsolute(cmd, current, value) {
	    if (isRelativeCommand(cmd)) {
	        return current + value;
	    }
	    return value;
	}
	
	function Path(path) {
	    var self = this;
	    self.pathCommands = [];
	    if (path) {
	        self.parse(path);
	    }
	}
	
	Path.prototype = {
	   
	    parse: function (path) {
	        var cmds = path.split(";");
	        for (var i = 0, len = cmds.length; i < len; i++) {
	            var cmd = cmds[i].trim().split(" ");
	            var c = [];
	            c.push(cmd[0].trim());
	
	            for (var j = 1, cmdLength = cmd.length; j < cmdLength; j++) {
	                if (cmd[j] && cmd[j][0] === '=') {
	                    c.push(cmd[j]);
	                } else {
	                    c.push(parseFloat(cmd[j]));
	                }
	            }
	
	            this.pathCommands.push(c);
	        }
	    },
	    moveTo: function (x, y) {
	        var self = this;
	        self.pathCommands.push(['M', x, y]);
	        return self;
	    },
	    lineTo: function (x, y) {
	        var self = this;
	        self.pathCommands.push(['L', x, y]);
	        return self;
	    },
	    bezierCurveTo: function (cp1x, cp1y, cp2x, cp2y, x, y) {
	        var self = this;
	        self.pathCommands.push(['B', cp1x, cp1y, cp2x, cp2y, x, y]);
	        return self;
	    },
	    quadraticCurveTo: function (cpx, cpy, x, y) {
	        var self = this;
	        self.pathCommands.push(['Q', cpx, cpy, x, y]);
	        return self;
	    },
	    arc: function (x, y, r, startAngle, endAngle) {
	        this.pathCommands.push(['A', x, y, r, startAngle, endAngle]);
	    },
	    arcTo: function (x1, y1, x2, y2, r) {
	        var self = this;
	        self.pathCommands.push(['AT', x1, y1, x2, y2, r]);
	        return self;
	    },
	    beginPath: function () {
	    },
	    closePath: function () {
	        var self = this;
	        self.pathCommands.push(['Z']);
	        return self;
	    },
	    parseDimensions: function () {
	        var path = this;
	        var aX = [],
	            aY = [],
	            current,
	            subpathStartX = 0,
	            subpathStartY = 0,
	            x = 0,
	            y = 0,
	            bounds = [];
	
	        var pathCommands = path.pathCommands;
	
	        for (var i = 0, len = pathCommands.length; i < len; ++i) {
	
	            current = pathCommands[i];
	            var current0 = current[0], current1 = current[1], current2 = current[2], current3 = current[3],
	                current4 = current[4], current5 = current[5], current6 = current[6];
	
	            switch (current0) {
	               
	                case 'V':
	                case 'v':
	                    y = makeAbsolute(current0, y, current1);
	                    break;
	                case 'H':
	                case 'h':
	                    x = makeAbsolute(current0, x, current1);
	                    break;
	                case 'L':
	                case 'l':
	                   
	                    x = makeAbsolute(current0, x, current1);
	                    y = makeAbsolute(current0, y, current2);
	
	                    bounds = [];
	                    break;
	
	                case 'M':
	                case 'm':
	                   
	                    x = makeAbsolute(current0, x, current1);
	                    y = makeAbsolute(current0, y, current2);
	
	                    subpathStartX = x;
	                    subpathStartY = y;
	                    bounds = [];
	                    break;
	
	                case 'B':
	                case 'C':
	                case 'c':
	                   
	                    var curX = x;
	                    var curY = y;
	
	                    var x0 = makeAbsolute(current0, x, current1);
	                    var y0 = makeAbsolute(current0, y, current2);
	
	                    var x1 = makeAbsolute(current0, x, current3);
	                    var y1 = makeAbsolute(current0, y, current4);
	
	                    x = makeAbsolute(current0, x, current5);
	                    y = makeAbsolute(current0, y, current6);
	
	                    bounds = getBoundsOfCurve(curX, curY,
	                        x0,
	                        y0,
	                        x1,
	                        y1,
	                        x,
	                        y
	                    );
	                    break;
	
	                case 'Q':
	                case 'q':
	                case 'S':
	                case 's':
	                   
	                    curX = x;
	                    curY = y;
	
	                    x0 = makeAbsolute(current0, x, current1);
	                    y0 = makeAbsolute(current0, y, current2);
	
	                    x = makeAbsolute(current0, x, current3);
	                    y = makeAbsolute(current0, y, current4);
	
	                    bounds = getBoundsOfCurve(curX, curY,
	                        x0,
	                        y0,
	                        x0,
	                        y0,
	                        x,
	                        y
	                    );
	                    break;
	
	                case 'AT':
	                case 'T':
	                    x0 = makeAbsolute(current0, x, current1);
	                    y0 = makeAbsolute(current0, y, current2);
	
	                    x = makeAbsolute(current0, x, current3);
	                    y = makeAbsolute(current0, y, current4);
	
	                    bounds.push({ x: x0, y: y0 });
	                    bounds.push({ x: x, y: y });
	                    break;
	
	                case 'A':
	                case 'a':
	                case 'E':
	                case 'e':
	                    x = makeAbsolute(current0, x, current1);
	                    y = makeAbsolute(current0, y, current2);
	
	                    bounds.push({ x: x, y: y });
	                    var r = current3;
	                    var a1 = current4;
	                    var a2 = current5;
	
	                    var PI = Math.PI;
	                    bounds.push({ x: x + r * Math.cos(a1), y: y + r * Math.sin(a1) });
	                    bounds.push({ x: x + r * Math.cos(a2), y: y + r * Math.sin(a2) });
	
	                    if (a1 === 0 || a2 === 2 * PI) {
	                        bounds.push({ x: x + r, y: y });
	                    }
	                    if (a1 < PI / 2 || a2 > PI / 2) {
	                        bounds.push({ x: x, y: y + r });
	                    }
	                    if (a1 < PI || a2 > PI) {
	                        bounds.push({ x: x - r, y: y });
	                    }
	                    if (a1 < PI + PI / 2 || a2 > PI + PI / 2) {
	                        bounds.push({ x: x, y: y - r });
	                    }
	                    break;
	
	                case 'Z':
	                case 'z':
	                    x = subpathStartX;
	                    y = subpathStartY;
	                    break;
	            }
	
	            bounds.forEach(function (point) {
	                aX.push(point.x);
	                aY.push(point.y);
	            });
	            aX.push(x);
	            aY.push(y);
	        }
	
	        var minX = min(aX) || 0,
	            minY = min(aY) || 0,
	            maxX = max(aX) || 0,
	            maxY = max(aY) || 0,
	            deltaX = maxX - minX,
	            deltaY = maxY - minY;
	
	        return {
	            left: minX,
	            top: minY,
	            right: maxX,
	            bottom: maxY,
	            width: deltaX,
	            height: deltaY
	        };
	    }
	};
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	Shapes.Path = Path;
	
	module.exports = Shapes;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	var Shapes = __webpack_require__(3);
	var Common = Shapes.Common;
	var extend = Common.extend;
	var ColorHelper = __webpack_require__(8)._ColorHelper;
	
	var Rect = Common.Rect;
	var createElement = Common.createElement;
	
	var getOptionValue = Common.getOptionValue;
	var arrayPush = Common._arrayPush, arrayHelper_getLength = Common._getArrayLength;
	
	var toRadius = Common.toRadius;
	var rotatePoint = Common.rotatePoint;
	
	var defineProperty = Common.defineProperty;
	var parseIntHex = function (num) {
	    return parseInt(num, 16);
	};
	var keyword_undefined, keyword_null = keyword_null;
	
	var Math_min = Math.min, Math_max = Math.max, Math_abs = Math.abs, Math_sin = Math.sin, Math_cos = Math.cos;
	
	var _2PI = 2 * Math.PI;
	
	function getValueInRange(range, value) {
	    return Math_min(range[1], Math_max(range[0], value));
	}
	
	var normalizeColorString = (function () {
	    var _canvasContext;
	    return function (strColor) {
	        if (!_canvasContext) {
	            var c = createElement('canvas');
	            if (c && c.getContext) {
	                _canvasContext = c.getContext('2d');
	            }
	        }
	        if (!_canvasContext) {
	            return strColor;
	        }
	        _canvasContext.fillStyle = strColor;
	        strColor = _canvasContext.fillStyle;
	        return strColor;
	    };
	}());
	
	
	var rrggbbPattern = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i;
	var re = RegExp;
	
	function getColor(colorString, alpha) {
	    var cs = normalizeColorString(colorString);
	    if (rrggbbPattern.test(cs)) {
	        return "rgba(" + parseIntHex(re.$1) + "," + parseIntHex(re.$2) + "," + parseIntHex(re.$3) + "," + alpha + ")";
	    }
	    return cs;
	}
	
	var reRGBColorPattern = /rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d\.]+))?/;
	var tintDic = {
	    darken: -0.4,
	    darkenLess: -0.2,
	    lightenLess: 0.2,
	    lighten: 0.4
	};
	function getMappedColor (strColor, style) {
	    var rgbColor = normalizeColorString(strColor);
	    var r, g, b, a;
	    if (rgbColor[0] === '#') {
	        r = parseIntHex(rgbColor.substr(1, 2));
	        g = parseIntHex(rgbColor.substr(3, 2));
	        b = parseIntHex(rgbColor.substr(5, 2));
	    } else {
	        var ms = strColor.match(reRGBColorPattern);
	        if (ms && arrayHelper_getLength(ms) === 5) {
	            r = +ms[1];
	            g = +ms[2];
	            b = +ms[3];
	           
	            a = +ms[4];
	            if (a === 0) {
	               
	                return rgbColor;
	            }
	        } else {
	            return rgbColor;
	        }
	    }
	    var rgb = [r, g, b];
	    var tint = tintDic[style];
	    if (tint) {
	        var color = ColorHelper._applyTint({ r: r, g: g, b: b }, tint);
	        rgb = [color.r, color.g, color.b];
	    }
	
	   
	    if (a) {
	        rgb.push(a);
	    }
	    return (a ? 'rgba(' : 'rgb(') + rgb.join(',') + ')';
	}
	
	function getColorFromOption(options, shape) {
	    var color = getOptionValue(options.color, shape);
	    if (color) {
	        var t = 0, transparency = options.transparency;
	        if (transparency !== keyword_null && transparency !== keyword_undefined) {
	            t = getOptionValue(transparency, shape);
	        }
	        color = getColor(color, 1 - t);
	    }
	    return color;
	}
	Shapes.getColorFromOption = getColorFromOption;
	
	function createSolidFill(options, shape) {
	    return getColorFromOption(options, shape);
	}
	
	function createLinearGradient(shape, gradientOptions, width, height) {
	    var angle = 0;
	    if (gradientOptions.angle) {
	        angle = gradientOptions.angle;
	    }
	
	    var offsetX = shape.left + width / 2;
	    var offsetY = shape.top + height / 2;
	
	   
	    var x = shape.left - offsetX, y = shape.top - offsetY;
	
	    var h = Math_sin(toRadius(angle)) * Math_max(width, height);
	    var w = Math_cos(toRadius(angle)) * Math_max(width, height);
	
	    var x2 = x + Math_abs(w), y2 = y + Math_abs(h);
	    var t;
	    if (angle > 90 && angle < 270) {
	       
	        t = x;
	        x = x2;
	        x2 = t;
	    }
	
	    if (angle > 180) {
	       
	        t = y;
	        y = y2;
	        y2 = t;
	    }
	
	    var grd = getCtx().createLinearGradient(x, y, x2, y2);
	    var stops = gradientOptions.stops;
	    for (var i = 0, len = arrayHelper_getLength(stops); i < len; i++) {
	        var c = getOptionValue(stops[i].color, shape);
	        var p = getOptionValue(stops[i].position, shape);
	        grd.addColorStop(p, c);
	    }
	    return grd;
	}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	function getCtx() {
	    var ctx = Shapes.bufferContext;
	    if (!ctx) {
	        var canvas = createElement("canvas");
	        canvas.hidden = true;
	        canvas.width = 1;
	        canvas.height = 1;
	       
	       
	       
	        
	        document.body.appendChild(canvas);
	        Shapes.buff = canvas;
	        Shapes.bufferContext = ctx = canvas.getContext("2d");
	    }
	
	    return ctx;
	}
	
	Shapes.getCtx = getCtx;
	
	function applyFillOptions(ctx, options, shape, width, height, fnGetFillStyle) {
	    if (!options) {
	        return;
	    }
	
	    var fillType = options.type;
	    if (fillType === 1 ) {
	        var fillStyle = createSolidFill(options, shape);
	        if (fnGetFillStyle) {
	            fillStyle = fnGetFillStyle(fillStyle);
	        }
	        ctx.fillStyle = fillStyle;
	        ctx.fill();
	    }
	
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	
	   
	   
	   
	   
	   
	
	   
	   
	
	
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	}
	
	function applyStrokeOptions(ctx, strokeOptions, shape, width, height) {
	    if (!strokeOptions) {
	        return;
	    }
	
	    var strokeStyle = keyword_null;
	    var gos = strokeOptions.gradient;
	    if (gos && gos.type === 0) {
	        strokeStyle = createLinearGradient(shape, gos, width, height);
	    }
	
	    if (!strokeStyle) {
	        strokeStyle = getColorFromOption(strokeOptions, shape);
	    }
	
	   
	   
	   
	   
	   
	    var zoom = shape._needZoom ? (shape._zoom || 1) : 1;
	
	    var lineWidth = getOptionValue(strokeOptions.width, shape);
	    if (lineWidth > 0) {
	        ctx.lineWidth = lineWidth * zoom;
	    }
	
	    var dashLine;
	    var dashType = getOptionValue(strokeOptions.dashType, shape);
	    if (dashType && arrayHelper_getLength(dashType)) {
	        var lineDash = dashType.map(function(n) {
	            return n * zoom;
	        });
	        ctx.setLineDash(lineDash);
	        dashLine = true;
	    }
	
	    if (dashLine) {
	       
	        ctx.lineCap = "butt";
	    } else {
	        var capType = getOptionValue(strokeOptions.capType, shape);
	        if (capType) {
	            ctx.lineCap = capType;
	        }
	    }
	
	    var joinType = getOptionValue(strokeOptions.joinType, shape);
	    if (joinType) {
	        ctx.lineJoin = joinType;
	    }
	
	    if (strokeStyle) {
	        ctx.strokeStyle = strokeStyle;
	        ctx.stroke();
	    }
	}
	Shapes.applyStrokeOptions = applyStrokeOptions;
	
	function applyShadowOptions(ctx, options, shape, width, height) {
	    if (!options) {
	        return;
	    }
	
	   
	
	    var blur = getOptionValue(options.blur, shape);
	    if (blur !== keyword_undefined) {
	        ctx.shadowBlur = blur;
	    }
	
	   
	    if (options.color) {
	        ctx.shadowColor = getColorFromOption(options, shape);
	    }
	
	   
	    if (options.angle || options.distance) {
	        var angle = getOptionValue(options.angle, shape);
	        if (angle === keyword_undefined) { angle = 90; }
	
	        var distance = getOptionValue(options.distance, shape);
	        if (distance === keyword_undefined) { distance = 1; }
	
	        ctx.shadowOffsetX = distance * Math_cos(toRadius(angle));
	        ctx.shadowOffsetY = distance * Math_sin(toRadius(angle));
	    }
	}
	
	function applyReflectionOptions(ctx, options, shape, width, height) {
	    if (!options) {
	        return;
	    }
	
	    var refOptions = options.reflection;
	    if (!refOptions) {
	        return;
	    }
	
	    var distance = getOptionValue(refOptions.distance, shape);
	    if (isNaN(distance)) {
	        distance = 1;
	    }
	
	    var offset = shape.originalHeight;
	    var size = getOptionValue(refOptions.size, shape);
	    if (!isNaN(size)) {
	        offset = size;
	    }
	
	   
	   
	   
	   
	    ctx.save();    
	    ctx.beginPath();
	    
	    shape.renderPath(ctx, options, width, height);
	   
	    ctx.translate(0, distance + shape.height);
	    ctx.scale(1, -1);
	    ctx.clip(-width / 2, distance - offset, width, Math_max(2 * distance, shape.top) + height);
	
	    var fOptions = {};
	    for (var x in options.fill) { fOptions[x] = options.fill[x]; } 
	
	   
	    var t = 0.8;
	    var tmp = getOptionValue(refOptions.transparency, shape);
	    if (!isNaN(tmp)) {
	        t = t * tmp;
	    }
	    fOptions.transparency = t;
	
	    applyFillOptions(ctx, fOptions, shape, width, height);
	
	   
	   
	
	    applyStrokeOptions(ctx, options.stroke, shape, width, height);
	
	    ctx.restore();
	}
	
	function applyGlowOptions(ctx, options, shape, width, height) {
	    if (options) {
	        var size = getOptionValue(options.size, shape);
	        if (isNaN(size)) { size = 5; }
	        var shadow = {
	            blur: size,
	            color: getColorFromOption(options, shape),
	            distance: 0
	        };
	
	        applyShadowOptions(ctx, shadow, shape, width, height);
	    }
	}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	function paintText(ctx, shape, options) {
	   
	   
	   
	   
	   
	   
	   
	   
	   
	
	    var textOptions = options && options.textFormatOptions;
	    if (!textOptions) {
	        return keyword_null;
	    }
	
	    var text = getOptionValue(textOptions.text, shape);
	    if (!text) {
	        return keyword_null;
	    }
	    text = "" + text;
	
	    var width = getOptionValue(shape.width, shape);
	    var height = getOptionValue(shape.height, shape);
	    var sw = width, sh = height;
	    var left = 0, top = 0, rect = shape.textRect, w, h;
	    if (rect) {
	        setRectSize(rect);
	        w = rect.width;
	        h = rect.height;
	        left = rect.left;
	        top = rect.top;
	        width = w;
	        height = h;
	    }
	
	    var needZoom = shape._needZoom;
	    var zoom = needZoom ? (shape._zoom || 1) : 1;
	    var margins = getOptionValue(textOptions.margins, shape);
	    if (!margins) { margins = { left: 10, top: 5, right: 10, bottom: 5 }; }
	    shape._margins = margins;
	
	    var marginLeft = margins.left * zoom,
	        marginRight = margins.right * zoom,
	        marginTop = margins.top * zoom,
	        marginBottom = margins.bottom * zoom;
	
	    var verticalAlignment = getOptionValue(textOptions.verticalAlignment, shape);
	    if (!verticalAlignment) { verticalAlignment = 0 ; }
	    var horizontalAlignment = getOptionValue(textOptions.horizontalAlignment, shape);
	    if (!horizontalAlignment || horizontalAlignment > 2) { horizontalAlignment = 0 ; }
	
	   
	   
	    var x = 0;
	    var y = 0;
	
	    var textDirection = getOptionValue(textOptions.textDirection, shape);
	    if (textDirection === keyword_undefined) { textDirection = "horizontal"; }
	    var angle = 0;
	    if (textDirection === "vertical" || textDirection === "rotate90") {
	        angle = 90;
	    } else if (textDirection === "rotate270") {
	        angle = 270;
	    }
	
	   
	    w = width - marginLeft - marginRight;
	    h = height - marginTop - marginBottom;
	
	    if (w <= 0 || h <= 0) {
	        return;
	    }
	    
	    var textBaseline = "top";
	    var textAlign = "start";
	    if (angle === 0) {
	        if (verticalAlignment === 0 ) {
	           
	           
	        } else if (verticalAlignment === 1 ) {
	           
	            y = h / 2;
	        } else if (verticalAlignment === 2 ) {
	           
	           
	            y = h;
	        }
	
	        if (horizontalAlignment === 0 ) {
	            textAlign = "start";
	           
	        } else if (horizontalAlignment === 1 ) {
	            textAlign = "center";
	            x = w / 2;
	        } else if (horizontalAlignment === 2 ) {
	            textAlign = "right";
	           
	            x = w;
	        }
	    } else {
	       
	
	        if (horizontalAlignment === 2 ) {
	           
	            y = -(w / 2) + marginRight;
	           
	        } else if (horizontalAlignment === 1 ) {
	           
	           
	        } else if (horizontalAlignment === 0 ) {
	           
	            y = (w / 2) - marginLeft;
	           
	        }
	
	        if (verticalAlignment === 0 ) {
	           
	           
	            x = -(h / 2) + marginTop;
	        } else if (verticalAlignment === 1 ) {
	           
	            textAlign = "center";
	        } else if (verticalAlignment === 2 ) {
	           
	            textAlign = "right";
	            x = (h / 2) - marginBottom;
	        }
	    }
	    ctx.textAlign = textAlign;
	    ctx.textBaseline = textBaseline;
	
	    var font = getOptionValue(textOptions.font, shape);
	    if (font) {
	        if (needZoom) {
	            var shapeWrapper = shape._shapeWrapper, sheet = shapeWrapper && shapeWrapper._sheet;
	            if (sheet) {
	                font = sheet._render._getZoomFont(font);
	            } else {
	                var fontSize = parseFloat(font);
	                font = (fontSize * zoom).toFixed(2) + font.substr(font.indexOf('px '));
	            }
	        }
	        ctx.font = font;
	    }
	
	    var textHeight = Common.getFontHeight(font);
	    var wrapSize = textDirection === "horizontal" ? w : h;
	
	    var lines = textOptions.wrapTextInShape ? wrapText(text, wrapSize, textOptions.wrapNewLineOnly, font) : wrapText(text, wrapSize, true, font);
	    var totalLines = arrayHelper_getLength(lines);
	    if (totalLines) {
	        var totalHeight = textHeight * totalLines;
	        if (angle) {
	            y -= totalHeight / 2 * (2 - horizontalAlignment);
	           
	           
	           
	           
	           
	        } else {
	            y -= totalHeight / 2 * verticalAlignment;
	           
	           
	           
	           
	           
	        }
	    }
	
	    var xOffset = marginLeft + left - sw / 2;
	    var yOffset = marginTop + top - sh / 2;
	    if (angle === 0) {
	        x += xOffset;
	        y += yOffset;
	   
	   
	   
	    }
	
	    ctx.save();
	    ctx.beginPath();
	
	    applyFillOptions(ctx, textOptions.fill, shape, width, height);
	
	    applyStrokeOptions(ctx, textOptions.stroke, shape, width, height);
	
	    var shadow = textOptions.shadow, glow = textOptions.glow;
	    if (shadow) {
	        applyShadowOptions(ctx, shadow, shape, width, height);
	    } else if (glow) {
	        applyGlowOptions(ctx, glow, shape, width, height);
	    }
	    
	    var allowTextToOverflowShape = getOptionValue(textOptions.allowTextToOverflowShape, shape);
	    if (!allowTextToOverflowShape) {
	        ctx.rect(xOffset, yOffset, w, h);
	        ctx.clip();
	    }
	
	    if (angle !== 0) {
	        ctx.rotate(toRadius(angle));
	    }
	
	   
	    for (var i = 0, len = arrayHelper_getLength(lines); i < len; i++) {
	        if (textOptions.fill) {
	            ctx.fillText(lines[i], x, y);
	        }
	        if (textOptions.stroke) {
	            ctx.strokeText(lines[i], x, y);
	        }
	        y += textHeight;
	    }
	
	    ctx.restore();
	}
	
	function wrapText(text, maxWidth, wrapNewLineOnly, font) {
	    var wrapLines = [];
	    if (text && arrayHelper_getLength(text) > 0) {
	        var lines = text.split(/\r\n|\r|\n/);
	        if (wrapNewLineOnly) {
	            return lines;
	        }
	
	        var ctx = getCtx();
	        ctx.save();
	        if (font) {
	            ctx.font = font;
	        }
	
	        for (var i = 0, len = arrayHelper_getLength(lines); i < len; i++) {
	            var wrapLine = wrapWords(ctx, lines[i], maxWidth);
	            if (wrapLine) {
	                if (arrayHelper_getLength(wrapLine) === 0) {
	                    arrayPush(wrapLines, "");
	                } else {
	                    wrapLine.forEach(function (t) {
	                        arrayPush(wrapLines, t);
	                    });
	                }
	            }
	        }
	
	        ctx.restore();
	    }
	    return wrapLines;
	}
	
	function wrapWords(ctx, text, maxWidth) {
	    var words = text.split(' ');
	    var lines = [];
	    var line = "";
	    var tw = 0;
	    var spaceWidth = ctx.measureText(" ").width;
	
	    for (var n = 0, len = arrayHelper_getLength(words); n < len; n++) {
	        var word = words[n];
	        var w = ctx.measureText(word).width;
	        if (w > maxWidth) {
	            if (arrayHelper_getLength(line) > 0) {
	                arrayPush(lines, line);
	            }
	            var wraps = wrapChars(ctx, words[n], maxWidth, w);
	            wraps.forEach(function (t) {
	                arrayPush(lines, t);
	            });
	            line = "";
	            tw = 0;
	        } else {
	            var testLine = line + word;
	            tw += w + spaceWidth;
	            if (tw > maxWidth) {
	                if (tw - spaceWidth <= maxWidth) {
	                   
	                    arrayPush(lines, testLine);
	                    tw = 0;
	                    line = "";
	                } else {
	                    arrayPush(lines, line);
	                    tw = w + spaceWidth;
	                    if (tw > maxWidth) {
	                       
	                        arrayPush(lines, word);
	                        tw = 0;
	                        line = "";
	                    } else {
	                        line = word + " ";
	                    }
	                }
	            } else {
	                line = testLine + " ";
	            }
	        }
	    }
	
	    if (arrayHelper_getLength(line) > 0) {
	        arrayPush(lines, line);
	    }
	    return lines;
	}
	
	function wrapChars(ctx, word, maxWidth, wordWidth) {
	    var n = Math.ceil(wordWidth / maxWidth);
	    var avg = arrayHelper_getLength(word) / n;
	    var lines = [];
	
	    n = 0;
	    while (maxWidth > 0 && n < arrayHelper_getLength(word)) {
	        var t = word.substring(n, n + avg);
	        var w = ctx.measureText(t).width;
	        var offset = w <= maxWidth ? 1 : -1;
	        var pos = 0;
	        while ((w < maxWidth && offset > 0) || (w > maxWidth && offset < 0)) {
	            pos += offset;
	            if (n + avg + pos >= arrayHelper_getLength(word) || n + avg + pos === 0) {
	                break;
	            }
	            t = word.substring(n, n + avg + pos);
	            w = ctx.measureText(t).width;
	        }
	
	        pos -= offset;
	        if (n + avg + pos > n) {
	            arrayPush(lines, word.substring(n, n + avg + pos));
	            n = n + avg + pos;
	        } else {
	            break;
	        }
	    }
	
	    return lines;
	}
	
	function isRelativeCommand(cmd) {
	    switch (cmd) {
	        case 'm':
	        case 'l':
	        case 'h':
	        case 'v':
	        case 'c':
	        case 's':
	        case 'q':
	        case 't':
	        case 'a':
	        case 'e':
	        case 'z':
	            return true;
	    }
	    return false;
	}
	
	function makeAbsolute(cmd, current, value) {
	    if (isRelativeCommand(cmd)) {
	        return current + value;
	    }
	    return value;
	}
	
	function composite(target, source) {
	    if (source) {
	        for (var t in source) {
	            if (source.hasOwnProperty(t)) {
	                var v = source[t];
	                if (typeof v !== "object") {
	                    target[t] = v;
	                } else {
	                    if (Array.isArray(v)) {
	                        target[t] = extend([], target[t]);
	                    } else {
	                        target[t] = extend({}, target[t]);
	                    }
	                    target[t] = composite(target[t], v);
	                }
	            }
	        }
	    }
	    return target;
	}
	
	Shapes.composite = composite;
	
	function setShapeProperty(shape, id, p, value) {
	    var service = shape.service;
	    if (service) {
	        var f = service.getFormula(id, p);
	        if (f && f.indexOf('=BOUND') === 0) {
	            var newFn = value;
	            if (newFn && newFn[0] === '=') {
	                newFn = newFn.substring(1);
	            }
	            newFn = shape.getBoundFn(f, newFn);
	            service.setFormula(id, p, newFn);
	        } else if (!f || isNaN(value)) {
	            service.setValueOrFormula(id, p, value);
	        }
	    } else {
	        shape.model[p] = value;
	    }
	}
	
	Shapes.setShapeProperty = setShapeProperty;
	
	var defaultOptions = Shapes.getStyle("default");
	
	var cloneOptions = Shapes.Common.cloneOptions;
	
	var shapeProperties = ['left', 'top', 'width', 'height', 'angle', 'isSelected', 'relativeX', 'relativeY', 'relativeWidth', 'relativeHeight'];
	
	function setRectSize(rect) {
	    rect.width = rect.right - rect.left;
	    rect.height = rect.bottom - rect.top;
	}
	
	function Shape(model, service) {
	    var self = this;
	    self.model = model || {};
	    if (model) {
	        if (typeof (model.path) === "string") {
	            var path = new Shapes.Path();
	            path.parse(model.path);
	            model.path = path.pathCommands;
	        } else if (model.path && model.path.pathCommands) {
	            model.path = model.path.pathCommands;
	        }
	    }
	
	    if (model) {
	        self.defineProperties();
	    }
	
	    self.setService(service);
	    self.showConnectors = false;
	    self.connectionLines = [];
	}
	
	Shapes.createShape = function (model, service) {
	    return new Shape(model, service);
	};
	
	Shape.prototype = {
	    scaleX: 1,
	    scaleY: 1,
	    flipX: false,
	    flipY: false,
	    visible: true,
	    angle: 0,
	    getValueResolver: function () {
	       
	        return Shapes.optionResolver;
	    },
	    init: function (path) {
	        var self = this;
	        self.path = path;
	
	        if (typeof (path) === "string") {
	            var tmpPath = new Shapes.Path();
	            tmpPath.parse(path);
	            self.path = { paths: [tmpPath] };
	        }
	
	        if (path) {
	            if (self.service) {
	                self.resetPathOffset();
	            } else {
	                self.setBounds();
	            }
	        }
	    },
	    defineProperties: function () {
	        var self = this;
	
	        shapeProperties.forEach(function (p) {
	            defineProperty(self, p, {
	                get: function () {
	                    if (self.service) {
	                        var v = self.service.getValue(self.id, p);
	                        if (v === keyword_undefined && self.parentShapeID) {
	                            v = self.service.getValue(self.parentShapeID, p);
	                        }
	                        return v;
	                    }
	                    return self.model[p];
	                },
	                set: function (value) {
	                    setShapeProperty(self, self.id, p, value);
	                }
	            });
	        });
	
	        defineProperty(self, 'path', {
	            get: function () {
	                if (self.pathCache) {
	                    return self.pathCache;
	                }
	
	                var paths;
	                if (self.service) {
	                    paths = self.service.getPath(self.id);
	                } else {
	                    paths = self.model.path;
	                }
	                var result = paths && paths.map(function(item) {
	                    var path = new Shapes.Path();
	                    path.pathCommands = item;
	                    var fillMode = item.fillMode;
	                    if (fillMode) {
	                        path.fillMode = fillMode;
	                    }
	                    if (item.strokeMode) {
	                        path.strokeMode = item.strokeMode;
	                    }
	                    return path;
	                });
	                self.pathCache = result;
	                return result;
	            },
	            set: function (value) {
	                delete self.pathCache;
	                if (!value) {
	                    return;
	                }
	                var p = value.pathCommands || value;
	                if (self.service) {
	                    self.service.setPath(self.id, p);
	                } else {
	                    self.model.path = p;
	                }
	            }
	        });
	
	        defineProperty(self, 'options', {
	            get: function () {
	                if (self.optionsCache) {
	                    return self.optionsCache;
	                }
	                var p;
	                var t = extend({}, defaultOptions);
	                if (self.service) {
	                    p = self.service.getOptions(self.id);
	                    if (self.parentShapeID) {
	                        var pOptions = self.service.getOptions(self.parentShapeID);
	                        t = composite(t, pOptions);
	                    }
	                    p = self.optionsCache = composite(t, p);
	                    return p;
	                }
	                p = self.model.options;
	                p = self.optionsCache = composite(t, p);
	                return p;
	            },
	            set: function (value) {
	                delete self.optionsCache;
	                if (self.service) {
	                    self.service.setOptions(self.id, value);
	                } else {
	                    self.model.options = value;
	                }
	            }
	        });
	
	        defineProperty(self, 'controls', {
	            get: function () {
	                if (self.service) {
	                    return self.service.getControls(self.id);
	                }
	                return self.model.controls;
	            },
	            set: function (value) {
	                if (self.service) {
	                    self.service.setControls(self.id, value);
	                } else {
	                    self.model.controls = value;
	                }
	            }
	        });
	
	        defineProperty(self, 'connectionPoints', {
	            get: function () {
	                if (self.service) {
	                    return self.service.getConnectionPoints(self.id);
	                }
	                return self.model.connectionPoints;
	            },
	            set: function (value) {
	                if (self.service) {
	                    self.service.setConnectionPoints(self.id, value);
	                } else {
	                    self.model.connectionPoints = value;
	                }
	            }
	        });
	
	        defineProperty(self, 'connectionLines', {
	            get: function () {
	                if (self.service) {
	                    return self.service.getConnectionLines(self.id);
	                }
	                return self.model.connectionLines;
	            },
	            set: function (value) {
	                if (self.service) {
	                    self.service.setConnectionLines(self.id, value);
	                } else {
	                    self.model.connectionLines = value;
	                }
	            }
	        });
	
	        defineProperty(self, 'variables', {
	            get: function () {
	                if (self.service) {
	                    var t = self.service.getValues(self.id, 'variables');
	                    return t && t.variables;
	                }
	                return self.model.variables;
	            },
	            set: function (value) {
	                if (self.service) {
	                    self.service.setValues(self.id, 'variables', value);
	                } else {
	                    self.model.variables = value;
	                }
	            }
	        });
	
	        defineProperty(self, 'textRect', {
	            get: function () {
	                if (self.service) {
	                    var t = self.service.getValues(self.id, 'textRect');
	                    return t && t.textRect;
	                }
	                return self.model.textRect;
	            },
	            set: function (value) {
	                if (self.service) {
	                    self.service.setValues(self.id, 'textRect', value);
	                } else {
	                    self.model.textRect = value;
	                }
	            }
	        });
	
	        defineProperty(self, 'parent', {
	            get: function () {
	                if (self.service) {
	                    var id = self.service.getValue(self.id, 'parentId');
	                    return self.service.getShapeById(id);
	                }
	                return self.model.parentId;
	            },
	            set: function (value) {
	                if (self.service) {
	                    self.service.setValueOrFormula(self.id, 'parentId', value ? value.id : keyword_undefined);
	                } else {
	                    self.model.parentId = value ? value.id : keyword_undefined;
	                }
	            }
	        });
	
	        defineProperty(self, 'parentShapeID', {
	            get: function () {
	                if (self.service) {
	                    return self.service.getValue(self.id, 'parentShapeID');
	                }
	                return self.model.parentShapeID;
	            },
	            set: function (value) {
	                if (self.service) {
	                    self.service.setValueOrFormula(self.id, 'parentShapeID', value);
	                } else {
	                    self.model.parentShapeID = value;
	                }
	            }
	        });
	    },
	    getGeoProperties: function () {
	        var self = this;
	        var t = {};
	        shapeProperties.forEach(function (p) {
	            if (self[p] !== keyword_undefined) {
	                t[p] = self[p];
	            }
	        });
	        return t;
	    },
	    setGeoProperties: function (properties) {
	        var self = this;
	        if (properties) {
	            shapeProperties.forEach(function (p) {
	                if (properties[p] !== keyword_undefined) {
	                    self[p] = properties[p];
	                }
	            });
	        }
	    },
	    getService: function () {
	        return this.service;
	    },
	    setService: function (service) {
	        var self = this, model;
	        if (self.service !== service) {
	            if (self.service) {
	                model = self.model = self.service.getValues(self.id, '', true);
	               
	                if (self.optionsCache) {
	                    model.options = self.optionsCache; 
	                }
	            }
	
	            self.service = service;
	
	            model = self.model;
	            if (model && service) {
	                self.id = model.id || service.getUniqueShapeId();
	                service._ignoreChange = true;   
	                service.setValues(self.id, '', model);
	                delete service._ignoreChange;
	                self.model = {};
	                self.pathCache = keyword_null;
	                self.optionsCache = keyword_null;
	            }
	        }
	
	        self.setBounds();
	    },
	    getVariable: function (name) {
	        var self = this;
	        var service = self.service;
	        if (service) {
	            return service.getValue(self.id, 'variables.' + name);
	        }
	        return self.variables && self.variables[name];
	    },
	    setVariable: function (name, value) {
	        var self = this;
	        var service = self.service;
	        if (service) {
	            return service.setValueOrFormula(self.id, 'variables.' + name, value);
	        }
	        var variables = self.variables;
	        if (!variables) {
	            variables = self.variables = {};
	        }
	        variables[name] = value;
	    },
	    getCornerPoints: function () {
	        return Shapes.getShapePoints(this, this.angle);
	    },
	    getActualCornerPoints: function () {
	        var self = this;
	        var p,
	            angle = self.angle,
	            center, i;
	        if (self.parent) {
	            p = self.parent;
	            while (p) {
	                if (p.angle) {
	                    p.savedAngle = p.angle;
	                    p.setAngle(0);
	                }
	                p = p.parent;
	            }
	        }
	
	        var rotatedPoints = self.getCornerPoints();
	        if (rotatedPoints && angle !== 0) {
	            center = self.getCenterPoint(self.width, self.height);
	            for (i = 0; i < arrayHelper_getLength(rotatedPoints); i++) {
	                rotatedPoints[i] = rotatePoint(rotatedPoints[i], center, toRadius(self.angle));
	            }
	        }
	
	       
	        if (self.parent) {
	            p = self.parent;
	            while (p) {
	                angle = p.savedAngle;
	                if (!isNaN(angle) && angle !== 0) {
	                    center = p.getCenterPoint(p.width, p.height);
	                    for (i = 0; i < arrayHelper_getLength(rotatedPoints); i++) {
	                        rotatedPoints[i] = rotatePoint(rotatedPoints[i], center, toRadius(angle));
	                    }
	                }
	                p = p.parent;
	            }
	        }
	
	        if (self.parent) {
	            p = self.parent;
	            while (p) {
	                if (p.savedAngle) {
	                    p.setAngle(p.savedAngle);
	                    delete p.savedAngle;
	                }
	
	                p = p.parent;
	            }
	        }
	
	        return rotatedPoints;
	    },
	    getConnectorPoints: function () {
	        var self = this, left = self.left, top = self.top;
	
	        var pctPts = self.connectionPoints;
	        var pts = [];
	        if (pctPts) {
	            pts = pctPts.map(function (p) { return { x: left + p.x, y: top + p.y }; });
	        }
	        return pts;
	    },
	    getActualConnectorPoints: function () {
	        var self = this;
	
	       
	       
	       
	       
	       
	       
	
	       
	       
	       
	       
	       
	
	        var pts = self.getConnectorPoints();
	       
	        pts = self.rotatePoints(pts);
	
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	
	       
	       
	       
	       
	
	        return pts;
	    },
	    rotatePoints: function (points) {
	        var len = points.length, self = this;
	        var center = self.getShapeCenter();
	        var angle = self.angle;
	        var parent = self.parent;
	        if (parent) {
	            angle -= parent.angle;
	        }
	        for (var i = 0; i < len; i++) {
	            points[i] = rotatePoint(points[i], center, toRadius(angle));
	        }
	        if (parent) {
	            points = self.parent.rotatePoints(points);
	        }
	        return points;
	
	    },
	    addConnectionLine: function (line) {
	        var connectionLines = this.connectionLines;
	        arrayPush(connectionLines, line);
	        this.connectionLines = connectionLines;
	    },
	    removeConnectionLine: function (line) {
	        var connectionLines = this.connectionLines;
	        var n = connectionLines.indexOf(line);
	        if (n >= 0) {
	            connectionLines.splice(n, 1);
	            this.connectionLines = connectionLines;
	        }
	    },
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	    setBounds: function () {
	        var self = this, pathInfo = self.path;
	        if (!pathInfo) {
	            return;
	        }
	
	        var rects = pathInfo.map(function(path) {
	            return path.parseDimensions();
	        });
	        function getValue(obj) {
	            return obj[this.property];
	        }
	        var bounds = {
	            left: Math_min.apply(keyword_null, rects.map(getValue.bind({ property: 'left' }))),
	            top: Math_min.apply(keyword_null, rects.map(getValue.bind({ property: 'top' }))),
	            right: Math_max.apply(keyword_null, rects.map(getValue.bind({ property: 'right' }))),
	            bottom: Math_max.apply(keyword_null, rects.map(getValue.bind({ property: 'bottom' })))
	        };
	        setRectSize(bounds);
	
	        self._bounds = bounds;
	       
	       
	
	       
	       
	       
	       
	       
	       
	       
	
	       
	       
	       
	       
	    },
	    resetPathOffset: function () {
	        var self = this;
	        delete self.pathCache;
	        self.setBounds();
	       
	       
	       
	       
	       
	    },
	    getShapeCenter: function (forceUpdate) {
	        var shape = this;
	        var center = shape._center;
	        if (forceUpdate || !center) {
	            var w = shape.width, h = shape.height;
	            center = {
	                x: shape.left + w / 2,
	                y: shape.top + h / 2
	            };
	            shape._center = center;
	            shape._width = w;
	            shape._height = h;
	        }
	
	        return center;
	    },
	    updateCenterData: function () {
	        this.getShapeCenter(true);
	    },
	    bounds: function (left, top, width, height) {
	        var self = this;
	       
	       
	       
	       
	        self.left = left;
	        self.top = top;
	        self.width = width;
	        self.height = height;
	
	       
	       
	       
	        self.updateCenterData();
	    },
	    move: function (x, y, ignoreConnectionLines) { 
	        var self = this;
	       
	       
	       
	       
	
	        self.left = x;
	        self.top = y;
	
	       
	       
	       
	        self.updateCenterData();
	    },
	    _resizeImp: function (width, height) {
	        var self = this;
	       
	       
	       
	       
	        var selfWidth = self.width, selfHeight = self.height;
	        if (!self.originalWidth) {
	            self.originalWidth = getOptionValue(selfWidth, self);
	        }
	        if (!self.originalHeight) {
	            self.originalHeight = getOptionValue(selfHeight, self);
	        }
	
	        if (!selfWidth || !isNaN(selfWidth)) {
	            self.width = width;
	            self.scaleX = width / self.originalWidth;
	        }
	        if (!selfHeight || !isNaN(selfHeight)) {
	            self.height = height;
	            self.scaleY = height / self.originalHeight;
	        }
	       
	       
	       
	        self.resetPathOffset();
	        self.updateCenterData();
	    },
	    resize: function (width, height, lockBottom, lockRight) {
	        var self = this;
	        self.resizeHeight(height, lockBottom);
	        self.resizeWidth(width, lockRight);
	
	        var shapeWrapper = self._shapeWrapper;
	        if (shapeWrapper) {
	            shapeWrapper.flipX = self.width < 0;
	            shapeWrapper.flipY = self.height < 0;
	        }
	    },
	    resizeHeight: function (height, lockBottom) {
	        var self = this;
	        var delta = height - self.height;
	        var a = toRadius(self.angle);
	        var x = Math_sin(a) * delta / 2;
	        var y = -Math_cos(a) * delta;
	        if (!lockBottom) {
	            x *= -1;
	            y = 0;
	        }
	        self._resizeImp(self.width, height);
	        self.move(self.left + x, self.top + y, true);
	    },
	    resizeWidth: function (width, lockRight) {
	        var self = this;
	        var delta = width - self.width;
	        var a = toRadius(self.angle);
	        var x = -Math_cos(a) * delta;
	        var y = -Math_sin(a) * delta / 2;
	
	        if (!lockRight) {
	            y *= -1;
	            x = 0;
	        }
	
	        self._resizeImp(width, self.height);
	        self.move(self.left + x, self.top + y, true);
	    },
	    hitTest: function (x, y, parentCtx) {
	        var self = this;
	
	        var width = getOptionValue(self.width, self);
	        var height = getOptionValue(self.height, self);
	        var offsetLeft = width / 2 + self.left, offsetTop = height / 2 + self.top;
	
	        var ctx = parentCtx || getCtx();
	
	        ctx.save();
	        self.transformContext(ctx, width, height);
	
	        var r = new Rect(-width / 2, -height / 2, width, height);
	        var t = {}, b, i, p;
	
	       
	        ctx.beginPath();
	        ctx.moveTo(0, -r.height / 2 - 11);
	        ctx.arc(0, -r.height / 2 - 20, self._isTouchMode ? 10 : 5, 0, _2PI);
	        if (self.canRotate !== false && ctx.isPointInPath(x, y)) {
	            t.shape = self;
	            t.type = "rotate";
	        } else {
	           
	            var vrs = self.variableRects(true), isSelected = self.isSelected;
	            if (isSelected && vrs && arrayHelper_getLength(vrs) > 0) {
	                for (i = 0; i < arrayHelper_getLength(vrs); i++) {
	                    var r0 = vrs[i];
	                    ctx.beginPath();
	                    ctx.rect(r0.x - offsetLeft, r0.y - offsetTop, r0.width, r0.height);
	                    if (ctx.isPointInPath(x, y)) {
	                        t.type = "variablePoint";
	                        t.variableRect = r0;
	                        t.shape = self;
	                        break;
	                    }
	                }
	            }
	            if (!t.type) {
	                r.expand(3);
	                ctx.beginPath();
	                ctx.rect(r.x, r.y, r.width, r.height);
	                b = ctx.isPointInPath(x, y);
	                if (b) {
	                    t.shape = self;
	                    t.type = "border";
	
	                   
	                    if (isSelected && !t.variableRect) {
	                        var a = self.sizeRects();
	                        for (i = 0; i < arrayHelper_getLength(a); i++) {
	                            var sr = a[i];
	                            var resizeIndicatorExpand = self._isTouchMode ? 10 : 4;
	                            ctx.beginPath();
	                            ctx.rect(sr.x - offsetLeft - resizeIndicatorExpand, sr.y - offsetTop - resizeIndicatorExpand, sr.width + resizeIndicatorExpand * 2, sr.height + resizeIndicatorExpand * 2);
	                            if (ctx.isPointInPath(x, y)) {
	                                t.type = "select";
	                                t.sizeRect = sr;
	                                break;
	                            }
	                        }
	                    }
	
	                   
	                    var pts = self.getConnectorPoints();
	                    var size = self._isTouchMode ? 20 : 6;
	                    for (i = 0; i < arrayHelper_getLength(pts); i++) {
	                        p = pts[i];
	                        ctx.beginPath();
	                        ctx.rect(p.x - offsetLeft - size / 2, p.y - offsetTop - size / 2, size, size);
	                        if (ctx.isPointInPath(x, y)) {
	                            t.shape = self;
	                            t.type = "connectPoint";
	                            t.index = i;
	                            break;
	                        }
	                    }
	                }
	            }
	        }
	
	        if (!t.type) {
	            r = new Rect(-width / 2, -height / 2, width, height);
	            r.expand(-5);
	            ctx.beginPath();
	            ctx.rect(r.x, r.y, r.width, r.height);
	
	            b = ctx.isPointInPath(x, y);
	            if (b) {
	                t.shape = self;
	                t.type = "select";
	            }
	        }
	
	        ctx.restore();
	
	        return t;
	    },
	    sizeRects: function () {
	        var self = this;
	        var size = 3;
	        function rect(x1, y1, type) {
	            var t = new Rect(x1 - size, y1 - size, 2 * size, 2 * size);
	            t.type = type;
	            return t;
	        }
	
	        var x = self.left;
	        var y = self.top;
	        var w = getOptionValue(self.width, self);
	        var h = getOptionValue(self.height, self);
	
	        return [rect(x, y, "topleft"), rect(x + w / 2, y, "topcenter"), rect(x + w, y, "topright"), rect(x, y + h / 2, "middleleft"), rect(x + w, y + h / 2, "middleright"), rect(x, y + h, "bottomleft"), rect(x + w / 2, y + h, "bottomcenter"), rect(x + w, y + h, "bottomright")];
	    },
	    variableRects: function (forHitTest) {
	        var self = this;
	        var ps = self.controls;
	        if (ps) {
	            var rectSize = (forHitTest && self._isTouchMode) ? 20 : 6;
	            var left = self.left - rectSize / 2 + 0.5, top = self.top - rectSize / 2 + 0.5;
	            var ret = [];
	            for (var i = 0, len = arrayHelper_getLength(ps); i < len; i++) {
	                var p = ps[i];
	                var x = left + p.x, y = top + p.y;
	                var r = new Common.Rect(x, y, rectSize, rectSize);
	                r.index = i;
	                arrayPush(ret, r);
	            }
	            return ret;
	        }
	    },
	    getBoundFn: function (f, newFn) {
	       
	        if (f && f.indexOf('=BOUND') === 0) {
	            var n1 = f.indexOf('(');
	            var n2 = f.indexOf(',');
	            newFn = f.substring(0, n1 + 1) + newFn + f.substring(n2);
	        } else {
	            newFn = '=' + newFn;
	        }
	        return newFn;
	    },
	    getControlPointRange: function (items) {
	        var self = this;
	        return items.map(function(v) {
	            var n = +v;
	            if (isNaN(n)) {
	                return self.service.getValue(self.id, "variables." + v);
	            }
	            return n;
	        });
	    },
	    updateAdjustVariable: function (name, value) {
	        var shape = this, changes = shape._adjChanges, adjOld = shape._adjOld;
	        if (!changes) {
	            changes = shape._adjChanges = {};
	            adjOld = shape._adjOld = {};
	        }
	        if (!adjOld[name]) {
	            adjOld[name] = shape.getVariable(name);
	        }
	        changes[name] = value;
	        shape.setVariable(name, value);
	    },
	    getAdjustChanges: function () {
	        var shape = this, changes = shape._adjChanges;
	        if (changes) {
	            var adjOld = shape._adjOld;
	            var values = [], oldValues = [];
	            for (var name in changes) {      
	                arrayPush(values, [name, changes[name]]);
	                arrayPush(oldValues, [name, adjOld[name]]);
	            }
	            shape._adjChanges = {};
	            shape._adjOld = {};
	            return {
	                values: values,
	                oldValues: oldValues
	            };
	        }
	    },
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	    updateAdjustValue: function (controlPoint, name, width, height, value) {
	        var shape = this;
	        var fnNames = [name];
	        var rangeValue = shape.getControlPointRange([controlPoint.min, controlPoint.max]);
	        var tmp = Shapes.getAdjustValue(fnNames, width, height, value, keyword_undefined, rangeValue, shape);
	        if (tmp) {
	            shape.updateAdjustVariable(name, tmp.value);
	        }
	    },
	    updatePolarAdjustValue: function (controlPoint, names, width, height, targetX, targetY) {
	        var shape = this, value, name;
	        if (controlPoint.maxAngle) {
	            name = names[0];
	            var point = { x: width / 2, y: height / 2 };
	            var angle = Shapes.getAdjustAngle(shape.angle, point.x, point.y, targetX, targetY, controlPoint.adjustInfo);
	            value = getValueInRange(shape.getControlPointRange([controlPoint.minAngle, controlPoint.maxAngle]), angle);
	            shape.updateAdjustVariable(name, value);
	        }
	        name = names[1];
	        if (name) {
	            var fnNames = [name + "_x", name + "_y"];
	            var rangeValue = shape.getControlPointRange([controlPoint.minRadius, controlPoint.maxRadius]);
	            var tmp = Shapes.getAdjustValue(fnNames, width, height, targetX, targetY, rangeValue, shape);
	            if (tmp) {
	                value = tmp.value;
	                shape.updateAdjustVariable(name, value);
	            }
	        }
	    },
	    changeVariablePoint: function (point, hitTest) {   
	        var self = this, fnDefs = self._fnDefs;
	        var w = self.width, h = self.height;
	        var rect = hitTest.variableRect;
	        var controlPoint = self.controls[rect.index];
	
	        var r, newFn, path, f;
	       
	       
	       
	
	       
	       
	       
	        var center = self._center;
	        var pt = rotatePoint({ x: point.x - center.x, y: point.y - center.y }, { x: 0, y: 0 }, -toRadius(self.angle));
	       
	        var currentX = pt.x + w / 2, currentY = pt.y + h / 2;
	
	       
	        var aRef = controlPoint.aRef, rRef = controlPoint.rRef;
	        if (aRef || rRef) {
	            self.updatePolarAdjustValue(controlPoint, [aRef, rRef], w, h, currentX, currentY);
	            return;
	        }
	        var service = self.service;
	       
	        if (controlPoint.xBehavior === 0) {
	            if (fnDefs) {
	                self.updateAdjustValue(controlPoint, controlPoint.xRef, w, h, currentX);
	            } else {
	                r = currentX / w;
	                newFn = '' + r + '*width';
	                path = 'controls.' + rect.index + '.x';
	                f = service.getFormula(self.id, path);
	                newFn = self.getBoundFn(f, newFn);
	
	                service.setFormula(self.id, path, newFn);
	            }
	        }
	       
	        if (controlPoint.yBehavior === 0) {
	            if (fnDefs) {
	                self.updateAdjustValue(controlPoint, controlPoint.yRef, w, h, currentY);
	            } else {
	                r = currentY / h;
	                newFn = '' + r + '*height';
	                path = 'controls.' + rect.index + '.y';
	                f = service.getFormula(self.id, path);
	                newFn = self.getBoundFn(f, newFn);
	
	                service.setFormula(self.id, path, newFn);
	            }
	        }
	    },
	    getCenterPoint: function (width, height) {
	        var self = this, center = this.getShapeCenter(),
	            w = self._width,
	            h = self._height;
	        if (w !== width || h !== height) {
	           
	            center = self._center = {
	                x: center.x + (width - w) / 2,
	                y: center.y + (height - h) / 2
	            };
	            self._width = width;
	            self._height = height;
	        }
	        return center;
	    },
	    setAngle: function (angle) {
	        this.angle = angle;
	    },
	    transformContext: function (ctx, width, height) {
	        var self = this;
	        var shapeWrapper = self._shapeWrapper, flipX = shapeWrapper && shapeWrapper.flipX, flipY = shapeWrapper && shapeWrapper.flipY;
	
	        var center = self.getCenterPoint(width, height);
	        ctx.translate(center.x, center.y);
	        
	        var angle = self.angle, parent = self.parent;
	        if (parent) {
	            angle -= parent.angle;
	        }
	        if (angle) {
	            ctx.rotate(toRadius(angle));
	        }
	
	        if (flipX || flipY) {
	            ctx.scale((flipX ? -1 : 1), (flipY ? -1 : 1));
	        }
	    },
	    transform: function (ctx, width, height, center) {
	        var self = this;
	        var shapeWrapper = self._shapeWrapper, flipX = shapeWrapper && shapeWrapper.flipX, flipY = shapeWrapper && shapeWrapper.flipY;
	        
	        center = center || self.getCenterPoint(width, height);
	        ctx.translate(center.x, center.y);
	
	        if (flipX || flipY) {
	            ctx.scale((flipX ? -1 : 1), (flipY ? -1 : 1));
	        }
	
	        var angle = self.angle, parent = self.parent;
	        if (parent) {
	            angle -= parent.angle;
	        }
	
	        if (angle) {
	            ctx.rotate(toRadius(angle));
	        }
	    },
	    render: function (ctx) {
	        var self = this;
	        var center = self._center, flipX, flipY;
	        var width = getOptionValue(self.width, self);
	       
	        if (width < 0) {
	            width = -width;
	            self.width = width;
	            flipX = true;
	        }
	        var height = getOptionValue(self.height, self);
	        if (height < 0) {
	            height = -height;
	            self.height = height;
	            flipY = true;
	        }
	
	        var isLine = (self instanceof Shapes.Line) || (self instanceof Shapes.ZipLine);			
	        if ((isLine && width === 0 && height === 0) || (!isLine && (width === 0 || height === 0)) || !self.visible) {
	            return;
	        }
	
	        ctx.save();
	
	        self.transform(ctx, width, height, center);
	        self._render(ctx, width, height);
	        
	        paintText(ctx, self, self.options);
	
	       
	        self.paintSelection(ctx);
	
	        if (!self.isSelected && self.showConnectors !== false) {
	            var pts = self.getConnectorPoints(), length = pts && arrayHelper_getLength(pts);
	            var left = self.left, top = self.top, halfWidth = width / 2, halfHeight = height / 2;
	            if (length) {
	                var radius = 4;
	                ctx.beginPath();
	                for (var i = 0; i < length; i++) {
	                    var pt = pts[i], px = pt.x - halfWidth - left, py = pt.y - halfHeight - top;
	                    ctx.fillStyle = 'lightgrey';
	                    ctx.moveTo(px, py);
	                    ctx.arc(px, py, radius, 0, _2PI);
	                    ctx.fill();
	                }
	            }
	        }
	        
	        self.renderControlPoints(ctx);
	
	        ctx.restore();
	
	        if (flipX) {
	            self.width = -width;
	        }
	        if (flipY) {
	            self.height = -height;
	        }
	    },
	    renderControlPoints: function (ctx) {
	        var self = this;
	       
	        if (self.isSelected) {
	            var points = self.controls;
	            if (points) {
	                var rectSize = 6;
	                var width = getOptionValue(self.width, self);
	                var height = getOptionValue(self.height, self);
	
	                ctx.beginPath();
	
	                points.forEach(function (p) {
	                    var x = p.x - rectSize / 2 - width / 2, y = p.y - rectSize / 2 - height / 2;
	                    ctx.fillStyle = "yellow";
	                    ctx.fillRect(x, y, rectSize, rectSize);
	                    ctx.strokeStyle = "grey";
	                    ctx.strokeRect(x, y, rectSize, rectSize);
	                });
	            }
	        }
	    },
	    paintSelection: function (ctx) {
	        var shape = this;
	        if (!shape.isSelected) {
	            return;
	        }
	
	        var width = getOptionValue(shape.width, shape);
	        var height = getOptionValue(shape.height, shape);
	
	        ctx.strokeStyle = "grey";
	        ctx.lineWidth = 1;
	        ctx.fillStyle = "white";
	        ctx.beginPath();
	        ctx.strokeRect(-width / 2 + 0.5, -height / 2 + 0.5, width, height);
	
	        var a = shape.sizeRects();
	        for (var i = 0; i < arrayHelper_getLength(a); i++) {
	            var sr = a[i];
	            ctx.fillRect(sr.x - shape.left - width / 2 + 0.5, sr.y - shape.top - height / 2 + 0.5, sr.width, sr.height);
	            ctx.strokeRect(sr.x - shape.left - width / 2 + 0.5, sr.y - shape.top - height / 2 + 0.5, sr.width, sr.height);
	        }
	
	       
	        if (shape.canRotate !== false) {
	            ctx.fillStyle = "grey";
	            ctx.fillRect(-1 + 0.5, -height / 2 - 17 + 0.5, 1, 15);
	            ctx.strokeStyle = "grey";
	            ctx.arc(0, -height / 2 - 20, 5, 0, _2PI);
	            ctx.arc(0, -height / 2 - 20, 3, 0, _2PI);
	            ctx.stroke();
	        }
	    },
	    renderPath: function (ctx, options, width, height) {
	        var shape = this, shapePaths = shape.path;
	        if (!shapePaths) {
	            return;
	        }
	
	        var lastIndex = arrayHelper_getLength(shapePaths) - 1;
	        ctx.save();
	        shapePaths.forEach(function (path, index) {
	            var current,
	                subpathStartX = 0,
	                subpathStartY = 0,
	                x = 0,
	                y = 0,
	               
	                l = -width / 2,    
	                t = -height / 2;   
	
	            ctx.beginPath();
	
	            var pathCommands = path.pathCommands;
	            var x0, y0, x1, y1;
	
	            var linePoints, lineWithArrow;
	            if (index === lastIndex && options.endPoints) {
	                lineWithArrow = true;
	                linePoints = [];
	            }
	
	            for (var i = 0, len = arrayHelper_getLength(pathCommands); i < len; ++i) {
	
	                current = pathCommands[i];
	
	                var current0 = current[0], current1 = current[1], current2 = current[2], current3 = current[3], current4 = current[4], current5 = current[5];
	                switch (current0) {
	                    case 'V':
	                    case 'v':
	                       
	                        y = makeAbsolute(current0, y, current1);
	                        ctx.lineTo(x + l, y + t);
	                        break;
	                    case 'H':
	                    case 'h':
	                       
	                        x = makeAbsolute(current0, x, current1);
	                        ctx.lineTo(x + l, y + t);
	                        break;
	                    case 'L':
	                    case 'l':
	                       
	                        x = makeAbsolute(current0, x, current1);
	                        y = makeAbsolute(current0, y, current2);
	
	                        if (lineWithArrow) { 
	                            arrayPush(linePoints, { x: x + l, y: y + t });
	                        } else {
	                            ctx.lineTo(x + l, y + t);
	                        }
	                        break;
	
	                    case 'M':
	                    case 'm':
	                       
	                        x = makeAbsolute(current0, x, current1);
	                        y = makeAbsolute(current0, y, current2);
	
	                        subpathStartX = x;
	                        subpathStartY = y;
	                        if (lineWithArrow) { 
	                            arrayPush(linePoints, { x: x + l, y: y + t });
	                        } else {
	                            ctx.moveTo(x + l, y + t);
	                        }
	                        break;
	
	                    case 'B':
	                    case 'C':
	                    case 'c':
	                        lineWithArrow = false;
	                       
	                        x0 = makeAbsolute(current0, x, current1);
	                        y0 = makeAbsolute(current0, y, current2);
	                        x1 = makeAbsolute(current0, x, current3);
	                        y1 = makeAbsolute(current0, y, current4);
	
	                        x = makeAbsolute(current0, x, current5);
	                        y = makeAbsolute(current0, y, current[6]);
	
	                        ctx.bezierCurveTo(x0 + l,
	                            y0 + t,
	                            x1 + l,
	                            y1 + t,
	                            x + l,
	                            y + t);
	                        break;
	
	                    case 'Q':
	                    case 'q':
	                    case 'S':
	                    case 's':
	                        lineWithArrow = false;
	                       
	                        x0 = makeAbsolute(current0, x, current1);
	                        y0 = makeAbsolute(current0, y, current2);
	
	                        x = makeAbsolute(current0, x, current3);
	                        y = makeAbsolute(current0, y, current4);
	
	                        ctx.quadraticCurveTo(
	                            x0 + l,
	                            y0 + t,
	                            x + l,
	                            y + t
	                        );
	
	                        break;
	
	                    case 'AT':
	                    case 'T':
	                        lineWithArrow = false;
	                       
	                        x0 = makeAbsolute(current0, x, current1);
	                        y0 = makeAbsolute(current0, y, current2);
	
	                        x = makeAbsolute(current0, x, current3);
	                        y = makeAbsolute(current0, y, current4);
	
	                        ctx.arcTo(x0 + l, y0 + t, x + l, y + t, Math_abs(current5));
	
	                        break;
	
	                    case 'A':
	                    case 'a':
	                        lineWithArrow = false;
	                       
	                        x = makeAbsolute(current0, x, current1);
	                        y = makeAbsolute(current0, y, current2);
	                        ctx.arc(x + l, y + t, Math_abs(current3), current4, current5);
	                        break;
	                    case 'E':
	                    case 'e':
	                        lineWithArrow = false;
	                       
	                        x = makeAbsolute(current0, x, current1);
	                        y = makeAbsolute(current0, y, current2);
	                        ctx.ellipse(x + l, y + t, Math_abs(current3), Math_abs(current4), current5, current[6], current[7], current[8]);
	                        break;
	                    case 'Z':
	                    case 'z':
	                        lineWithArrow = false;
	                        x = subpathStartX;
	                        y = subpathStartY;
	                        ctx.closePath();
	                        break;
	                }
	            }
	
	            var fillMode = path.fillMode, strokeMode = path.strokeMode;
	            if (lineWithArrow) {
	                Shapes.drawLineShape(ctx, linePoints, shape, width, height, options);
	            } else if (fillMode === "none") { 
	                applyStrokeOptions(ctx, options.stroke, shape, width, height);
	            } else {
	                var fnGetFillStyle;
	                if (fillMode && fillMode !== "norm") {
	                    fnGetFillStyle = function (fillStyle) {
	                        return getMappedColor(fillStyle, fillMode);
	                    };
	                }
	
	                applyFillOptions(ctx, options.fill, shape, width, height, fnGetFillStyle);
	                if (strokeMode !== 'false') {
	                    applyStrokeOptions(ctx, options.stroke, shape, width, height);
	                }
	            }
	
	            if (options.shadow) {
	                applyShadowOptions(ctx, options.shadow, self, width, height);
	            } else if (options.glow) {
	                applyGlowOptions(ctx, options.glow, self, width, height);
	            }
	
	            applyReflectionOptions(ctx, options, self, width, height);
	        });
	        ctx.restore();
	    },
	    _render: function (ctx, width, height) {
	        var self = this;
	
	        var options = self.options;
	        if (!options) {
	            return;
	        }
	
	        ctx.save();
	        self.renderPath(ctx, options, width, height);
	        ctx.restore();
	    },
	    clone: function () {
	        var self = this;
	        return new Shape(self.path, cloneOptions(self.options));
	    },
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	
	   
	   
	};
	
	Shapes.ShapeProperties = shapeProperties;
	
	Shapes.ShapeUI = Shape;
	
	module.exports = Shapes;

/***/ }),
/* 8 */
/***/ (function(module, exports) {

	module.exports = GC.Spread.Common;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	var Shapes = __webpack_require__(3);
	var Common = Shapes.Common;
	var extend = Common.extend;
	var getOptionValue = Common.getOptionValue;
	var Math_atan2 = Math.atan2;
	var defaultLineOptions = Shapes.getStyle("defaultLine");
	var defineProperty = Common.defineProperty;
	var getPointToLine = Common.getPointToLine;
	var keyword_null = null;
	
	
	function setService(lineShape, service, type) {
	    var lineService = lineShape.service;
	    if (lineService !== service) {
	        if (lineService) {
	            lineShape.model = lineService.getValues(lineShape.id, '', true);
	        }
	        if (service) {
	           
	            var options = lineShape.options;
	            var points = lineShape.points;
	            if (!lineShape.id) {
	                lineShape.id = service.getUniqueShapeId();
	            }
	            service.setValue(lineShape.id, 'type', type);
	            lineShape.service = service;
	           
	            lineShape.options = options;
	            lineShape.points = points;
	        } else {
	            lineShape.service = service;
	        }
	    }
	}
	
	function Line(model, service) {
	    var self = this;
	    self.model = model || {};
	    self._shapeType = 1;
	
	    var options = keyword_null;
	    var points = keyword_null;
	    if (model) {
	        options = extend({}, defaultLineOptions, model.options);
	        points = model.points;
	        self.id = model.id;
	    }
	    self.setService(service);
	    self.defineProperties();
	
	    self.showConnectors = false;
	    if (model) {
	        self.options = options;
	        points && self.setPoints(points);
	    }
	}
	Line.prototype = new Shapes.ShapeUI();
	var linePrototype = Line.prototype;
	
	
	linePrototype.setService = function (service) {
	    setService(this, service, 'Line');
	};
	
	linePrototype.defineProperties = function () {
	    var self = this;
	
	    defineProperty(self, 'options', {
	        get: function () {
	            if (self.optionsCache) {
	                return self.optionsCache;
	            }
	            var p, service = self.service;
	            if (service) {
	                p = service.getOptions(self.id);
	            } else {
	                p = self.model.options;
	            }
	            p = self.optionsCache = extend({}, p);
	            return p;
	        },
	        set: function (value) {
	            delete self.optionsCache;
	            var service = self.service;
	            if (service) {
	                service.setOptions(self.id, value);
	            } else {
	                self.model.options = value;
	            }
	        }
	    });
	
	    defineProperty(self, 'startConnector', {
	        get: function () {
	            var service = self.service;
	            if (service) {
	                var p = service.getValues(self.id, 'startConnector');
	                return p && p.startConnector;
	            }
	            return self.model.startConnector;
	        },
	        set: function (value) {
	            var service = self.service;
	            if (service) {
	                service.setValues(self.id, 'startConnector', value);
	            } else {
	                self.model.startConnector = value;
	            }
	        }
	    });
	
	    defineProperty(self, 'endConnector', {
	        get: function () {
	            var service = self.service;
	            if (service) {
	                var p = service.getValues(self.id, 'endConnector');
	                return p && p.endConnector;
	            }
	            return self.model.endConnector;
	        },
	        set: function (value) {
	            var service = self.service;
	            if (service) {
	                service.setValues(self.id, 'endConnector', value);
	            } else {
	                self.model.endConnector = value;
	            }
	        }
	    });
	
	    var lineProperties = ['x1', 'y1', 'x2', 'y2'];
	    lineProperties.forEach(function (p) {
	        defineProperty(self, p, {
	            get: function () {
	                var service = self.service;
	                if (service) {
	                    return service.getValue(self.id, p);
	                }
	                return self.model[p];
	            },
	            set: function (value) {
	                var service = self.service;
	                if (service) {
	                    service.setValue(self.id, p, value);
	                } else {
	                    self.model[p] = value;
	                }
	            }
	        });
	    });
	};
	
	linePrototype.setPoints = function (points, zoomFactor) {
	    if (!points || points.length < 1) {
	        return;
	    }
	    if (isNaN(zoomFactor)) {
	        zoomFactor = 1;
	    }
	    var self = this;
	    var p1 = points[0];
	    var p2 = points[points.length - 1];
	    self.x1 = p1.x * zoomFactor;
	    self.y1 = p1.y * zoomFactor;
	    self.x2 = p2.x * zoomFactor;
	    self.y2 = p2.y * zoomFactor;
	
	    self.left = Math.min(self.x1, self.x2);
	    self.top = Math.min(self.y1, self.y2);
	    self.width = Math.max(self.x1, self.x2) - self.left;
	    self.height = Math.max(self.y1, self.y2) - self.top;
	    self.updateCenterData();
	    self.isFlipH = self.x1 < self.x2;
	    self.isFlipV = self.y1 < self.y2;
	};
	
	linePrototype.getPoints = function () {
	    var self = this;
	    return [{ x: self.x1, y: self.y1 }, { x: self.x2, y: self.y2 }];
	};
	
	linePrototype.getStartPoint = function () {
	    var self = this;
	    return { x: self.x1, y: self.y1 };
	};
	
	linePrototype.getEndPoint = function () {
	    var self = this;
	    return { x: self.x2, y: self.y2 };
	};
	
	linePrototype.renderPath = function (ctx) {  
	    var self = this;
	    var options = self.options;
	    var x1 = self.x1, x2 = self.x2, y1 = self.y1, y2 = self.y2;
	    var width = self.width, height = self.height;
	    var center = self._center, cx = center.x, cy = center.y;
	    var points = [{
	        x: x1 - cx,
	        y: y1 - cy
	    }, {
	        x: x2 - cx,
	        y: y2 - cy
	    }];
	    return drawLineShape(ctx, points, self, width, height, options);
	};
	
	var PI = Math.PI, _2PI = 2 * PI;
	
	
	var arrowAngles = [
	    Math_atan2(1, 2), Math_atan2(1, 3), Math_atan2(1, 5),
	    Math_atan2(1.5, 2), Math_atan2(1.5, 3), Math_atan2(1.5, 5),
	    Math_atan2(2.5, 2), Math_atan2(2.5, 3), Math_atan2(2.5, 5),
	]; 
	var arrowWidthRatio = [3, 4, 7];
	var arrowWidthRatio2 = [1, 1.5, 2.5];
	var arrowStealthRatio = 0.6;
	
	function getArrowLineInfo(widthType, lengthType, lineWidth) {
	    var lineWidthInPoint = Math.max(2, lineWidth * 3 / 4);
	    lineWidth = lineWidthInPoint * 4 / 3;
	    var radius = Math.ceil(lineWidthInPoint * arrowWidthRatio[lengthType]);
	
	    return {
	        angle: arrowAngles[widthType * 3 + lengthType],
	        radius: radius,
	        size: [lineWidth * arrowWidthRatio2[lengthType], lineWidth * arrowWidthRatio2[widthType]]
	    };
	}
	
	
	function drawLineShape(ctx, points, shape, width, height, options) {
	    var stroke = options.stroke, color = Shapes.getColorFromOption(stroke, shape), lineWidth = stroke.width;
	  
	    if (isNaN(lineWidth) || lineWidth < 1) {
	        lineWidth = 1;
	    }
	
	   
	    var zoom = shape._zoom || 1, needZoom = shape._needZoom;
	    if(zoom !== 1 && needZoom) {
	        lineWidth *= zoom;
	    }
	
	    var endPoints = options.endPoints;
	    if (endPoints) {
	        var beginArrow = endPoints.beginArrow;
	        var endArrow = endPoints.endArrow;
	        var alpha, p1, p2;
	        var arrowType = beginArrow && beginArrow.type;
	        var arrowInfo;
	        if (arrowType) {   
	            p1 = points[0];
	            p2 = points[1];
	            alpha = Math.atan2(p2.y - p1.y, p2.x - p1.x);
	            arrowInfo = getArrowLineInfo(beginArrow.widthType, beginArrow.lengthType, lineWidth);
	            drawArrowImp(ctx, p1, alpha, lineWidth, color, arrowType, arrowInfo);       
	        }
	        arrowType = endArrow && endArrow.type;
	        if (arrowType) {   
	            var len = points.length;
	            p1 = points[len - 1];
	            p2 = points[len - 2];
	            alpha = Math.atan2(p2.y - p1.y, p2.x - p1.x);
	            arrowInfo = getArrowLineInfo(endArrow.widthType, endArrow.lengthType, lineWidth);
	            drawArrowImp(ctx, p1, alpha, lineWidth, color, arrowType, arrowInfo);       
	        }
	    }
	    ctx.beginPath();
	    points.forEach(function(pt, index) {
	        if (index === 0) {
	            ctx.moveTo(pt.x, pt.y);
	        } else {
	            ctx.lineTo(pt.x, pt.y);
	        }
	    });
	    
	    Shapes.applyStrokeOptions(ctx, options.stroke, shape, width, height);
	}
	Shapes.drawLineShape = drawLineShape;
	
	
	function drawArrowImp(ctx, point, alpha, lineWidth, color, type, arrowInfo) {
	    var x1 = point.x, y1 = point.y, p3;
	    var r = arrowInfo.radius;
	    var size = arrowInfo.size;
	
	    if (type === 4 ) {
	        ctx.fillStyle = color;
	        ctx.beginPath();
	        ctx.ellipse(x1, y1, size[0], size[1], 0, 0, _2PI, false, true );
	        ctx.fill();
	    } else {
	        var ps = [], dr, arrowAngle;
	        var isArrow = type === 5 ;
	        if (type === 3 ) {
	            arrowAngle = Math.PI / 2;
	            for (var i = 0; i < 4; i++) {
	                var angle = alpha + arrowAngle * i;
	                dr = size[i % 2];
	                ps.push({
	                    x: x1 + dr * Math.cos(angle),
	                    y: y1 + dr * Math.sin(angle)
	                });
	            }
	        } else {
	            arrowAngle = arrowInfo.angle;
	            var angles = [alpha - arrowAngle, alpha + arrowAngle];
	            ps = angles.map(function (a) {
	                return {
	                    x: x1 + r * Math.cos(a),
	                    y: y1 + r * Math.sin(a)
	                };
	            });
	           
	            if (type === 2  || type === 1  ) {
	                dr = r * arrowStealthRatio;
	                p3 = {
	                    x: x1 + dr * Math.cos(alpha),
	                    y: y1 + dr * Math.sin(alpha)
	                };
	                if (type === 2 ) {
	                    ps.push(p3);
	                }
	            }
	            ps.splice(1, 0, point);
	        }
	
	        var p = ps.shift();
	        ctx.beginPath();
	        ctx.moveTo(p.x, p.y);
	        ps.forEach(function (pt) {
	            ctx.lineTo(pt.x, pt.y);
	        });
	        if (isArrow) {
	            ctx.save();
	            ctx.lineWidth = lineWidth;
	            ctx.lineCap = 'round';
	            ctx.lineJoin = 'miter';
	            ctx.strokeStyle = color;
	            ctx.setLineDash([]);
	            ctx.stroke();
	            ctx.restore();
	        } else {
	            ctx.closePath();
	            ctx.fillStyle = color;
	            ctx.fill();
	
	            if (p3) {
	               
	                point.x = p3.x;
	                point.y = p3.y;
	            }
	        }
	    }
	}
	
	linePrototype.hitTest = function (x, y) {
	    var self = this;
	
	    var width = self.width;
	    var height = self.height;
	
	    var ctx = Shapes.getCtx();
	
	    ctx.save();
	    self.transformContext(ctx, width, height);
	
	    var x1 = self.x1, x2 = self.x2, y1 = self.y1, y2 = self.y2;
	    var offsetLeft = self.left + width / 2, offsetTop = self.top + height / 2;
	
	    var endPoint = keyword_null;
	    ctx.beginPath();
	
	    var detectSize = self._isTouchMode ? 20 : 7;
	    ctx.rect(x1 - offsetLeft - detectSize, y1 - offsetTop - detectSize, 2 * detectSize, 2 * detectSize);
	    ctx.closePath();
	
	    if (ctx.isPointInPath(x, y)) {
	        endPoint = "begin";
	    } else {
	        ctx.beginPath();
	        ctx.rect(x2 - offsetLeft - detectSize, y2 - offsetTop - detectSize, 2 * detectSize, 2 * detectSize);
	        ctx.closePath();
	        if (ctx.isPointInPath(x, y)) {
	            endPoint = "end";
	        }
	    }
	
	    var t = {};
	    if (endPoint) {
	        t.shape = self;
	        t.type = "move";
	        t.endPoint = endPoint;
	    } else {
	       
	        var expandSize = self._isTouchMode ? 10 : 3;
	       
	       
	       
	       
	       
	       
	
	       
	        var b = getPointToLine(x, y, self.x1, self.y1, self.x2, self.y2) <= expandSize;
	        if (b) {
	            t.shape = self;
	            t.type = "select";
	        }
	    }
	
	    ctx.restore();
	
	    return t;
	};
	
	linePrototype.paintSelection = function (ctx) {
	    var shape = this;
	    if (!shape.isSelected) {
	        return;
	    }
	    var width = getOptionValue(shape.width, shape);
	    var height = getOptionValue(shape.height, shape);
	    var size = 6;
	    var points = shape.getPoints(), count = points.length;
	    ctx.strokeStyle = 'gray';
	    ctx.lineWidth = 1;
	    ctx.fillStyle = 'white';
	    ctx.beginPath();
	    ctx.arc(points[0].x - shape.left - width / 2 + 0.5, points[0].y - shape.top - height / 2 + 0.5, size / 2, 0, 2 * Math.PI);
	    ctx.fill();
	    ctx.arc(points[0].x - shape.left - width / 2 + 0.5, points[0].y - shape.top - height / 2 + 0.5, size / 2, 0, 2 * Math.PI);
	    ctx.stroke();
	
	    ctx.beginPath();
	    ctx.arc(points[count - 1].x - shape.left - width / 2 + 0.5, points[count - 1].y - shape.top - height / 2 + 0.5, size / 2, 0, 2 * Math.PI);
	    ctx.fill();
	    ctx.arc(points[count - 1].x - shape.left - width / 2 + 0.5, points[count - 1].y - shape.top - height / 2 + 0.5, size / 2, 0, 2 * Math.PI);
	    ctx.stroke();
	};
	
	linePrototype.move = function (x, y) {
	    var self = this;
	    var deltX = x - self.left;
	    var deltY = y - self.top;
	    self.left = x;
	    self.top = y;
	    self.x1 += deltX;
	    self.y1 += deltY;
	    self.x2 += deltX;
	    self.y2 += deltY;
	};
	
	linePrototype.resizeHeight = function (height, lockBottom) {
	    var self = this;
	    var delt = height - self.height;
	
	    if (!self.originalY1) {
	        self.originalY1 = self.y1;
	    }
	    if (!self.originalY2) {
	        self.originalY2 = self.y2;
	    }
	
	    if (self.originalY2 > self.originalY1) {
	        self.y2 += delt;
	    } else if (self.originalY2 < self.originalY1) {
	        self.y1 += delt;
	    }
	};
	
	linePrototype.resizeWidth = function (width, lockRight) { 
	    var self = this;
	    var delt = width - self.width;
	
	    if (!self.originalX1) {
	        self.originalX1 = self.x1;
	    }
	    if (!self.originalX2) {
	        self.originalX2 = self.x2;
	    }
	
	    if (self.originalX2 > self.originalX1) {
	        self.x2 += delt;
	    } else if (self.originalX2 < self.originalX1) {
	        self.x1 += delt;
	    }
	};
	
	linePrototype.moveStartPoint = function (x, y) {
	    var sp = this;
	    sp.setPoints([{ x: x, y: y }, { x: sp.x2, y: sp.y2 }]);
	};
	
	linePrototype.moveEndPoint = function (x, y) {
	   
	    var sp = this;
	    sp.setPoints([{ x: sp.x1, y: sp.y1 }, { x: x, y: y }]);
	};
	
	linePrototype.clone = function () {
	    var self = this;
	    return new Line(self.x1, self.y1, self.x2, self.y2, Common.cloneOptions(self.options));
	};
	
	linePrototype.updateStartConnector = function (connector) {
	    var self = this, oldConnector = self.startConnector;
	    if (oldConnector) {
	       
	        var oldShape = self.service.getShapeById(oldConnector.id);
	        oldShape.removeConnectionLine(self.id);
	    }
	    self.startConnector = connector;
	    if (connector) {
	       
	        var shape = self.service.getShapeById(connector.id);
	        shape.addConnectionLine(self.id);
	    }
	};
	linePrototype.updateEndConnector = function (connector) {
	    var self = this, oldConnector = this.endConnector;
	    if (oldConnector) {
	       
	        var oldShape = self.service.getShapeById(oldConnector.id);
	        oldShape.removeConnectionLine(self.id);
	    }
	    self.endConnector = connector;
	    if (connector) {
	       
	        var shape = self.service.getShapeById(connector.id);
	        shape.addConnectionLine(self.id);
	    }
	};
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	Shapes.Line = Line;
	
	function ZipLine(model, service) {
	    var self = this;
	    self.model = model || {};
	    self._shapeType = 1;
	
	    var options = keyword_null;
	    var points = keyword_null;
	    if (model) {
	        options = extend({}, defaultLineOptions, model.options);
	        points = model.points;
	        self.id = model.id;
	    }
	    self.setService(service);
	    self.defineProperties();
	    self.showConnectors = false;
	    if (model) {
	        self.options = options;
	        points && self.setPoints(points);
	    }
	}
	ZipLine.prototype = new Shapes.ShapeUI();
	var zipLinePrototype = ZipLine.prototype;
	
	zipLinePrototype.setService = function (service) {
	    setService(this, service, 'ZipLine');
	};
	
	zipLinePrototype.defineProperties = function () {
	    var self = this;
	
	    defineProperty(self, 'options', {
	        get: function () {
	            var optionsCache = self.optionsCache;
	            if (optionsCache) {
	                return optionsCache;
	            }
	            var p, service = self.service;
	            if (service) {
	                p = service.getOptions(self.id);
	            } else {
	                p = self.model.options;
	            }
	            self.optionsCache = optionsCache = extend({}, p);
	            p = optionsCache;
	            return p;
	        },
	        set: function (value) {
	            delete self.optionsCache;
	            var service = self.service;
	            if (service) {
	                service.setOptions(self.id, value);
	            } else {
	                self.model.options = value;
	            }
	        }
	    });
	
	    defineProperty(self, 'points', {
	        get: function () {
	            var service = self.service;
	            if (service) {
	                var t = service.getValues(self.id, 'points');
	                return t && t.points;
	            }
	            return self.model.points;
	        },
	        set: function (value) {
	            var service = self.service;
	            if (service) {
	                service.setValues(self.id, 'points', value);
	            } else {
	                self.model.points = value;
	            }
	        }
	    });
	
	    defineProperty(self, 'startConnector', {
	        get: function () {
	            var service = self.service;
	            if (service) {
	                var p = service.getValues(self.id, 'startConnector');
	                return p && p.startConnector;
	            }
	            return self.model.startConnector;
	        },
	        set: function (value) {
	            var service = self.service;
	            if (service) {
	                service.setValues(self.id, 'startConnector', value);
	            } else {
	                self.model.startConnector = value;
	            }
	        }
	    });
	
	    defineProperty(self, 'endConnector', {
	        get: function () {
	            var service = self.service;
	            if (service) {
	                var p = service.getValues(self.id, 'endConnector');
	                return p && p.endConnector;
	            }
	            return self.model.endConnector;
	        },
	        set: function (value) {
	            var service = self.service;
	            if (service) {
	                service.setValues(self.id, 'endConnector', value);
	            } else {
	                self.model.endConnector = value;
	            }
	        }
	    });
	};
	
	zipLinePrototype.getStartPoint = function () {
	    var ps = this.getPoints();
	    return { x: ps[0].x, y: ps[0].y };
	};
	
	zipLinePrototype.getEndPoint = function () {
	    var ps = this.getPoints();
	    return { x: ps[ps.length - 1].x, y: ps[ps.length - 1].y };
	};
	
	zipLinePrototype.moveStartPoint = function (x, y) {
	    var self = this;
	    var ps = self.getPoints();
	    var p1 = { x: x, y: y };
	    var p2 = ps[ps.length - 1];
	
	    x = (p1.x + p2.x) / 2;
	    self.setPoints([p1, { x: x, y: p1.y }, { x: x, y: p2.y }, p2]);
	};
	
	zipLinePrototype.getAdjustChanges = function () {
	    var self = this, changes, isChanged = false, oldPoints = self._oldPoints, points = self.points;
	    if (self._oldPoints) {
	        for (var i = 0, len = points.length; i < len; i++) {
	            if(oldPoints[i].x !== points[i].x || oldPoints[i].y !== points[i].y) {
	                isChanged = true;
	                break;
	            }
	        }
	        if(isChanged) {
	            changes = {
	                oldPoints : oldPoints,
	                points : points
	            };
	        }
	    }
	    delete self._oldPoints;
	    return changes;
	};
	
	zipLinePrototype.moveEndPoint = function (x, y) {
	    var self = this;
	    var ps = self.getPoints();
	    var p1 = ps[0];
	    var p2 = { x: x, y: y };
	
	    x = (p1.x + p2.x) / 2;
	    self.setPoints([p1, { x: x, y: p1.y }, { x: x, y: p2.y }, p2]);
	};
	
	zipLinePrototype.setPoints = function (points, zoomFactor) {
	    var self = this, length = points.length;
	    if (isNaN(zoomFactor)) {
	        zoomFactor = 1;
	    }
	    points = points.map(function (t) {
	        return {
	         x: t.x * zoomFactor,
	         y: t.y * zoomFactor
	        };
	    });
	    self.points = points;
	
	    if (length < 1) {
	        return;
	    }
	
	    var firstPoint = points[0];
	    var lastPoint = points[points.length - 1];
	    self.left = Math.min(firstPoint.x, lastPoint.x);
	    self.top = Math.min(firstPoint.y, lastPoint.y);
	    self.width = Math.abs(firstPoint.x - lastPoint.x);
	    self.height = Math.abs(firstPoint.y - lastPoint.y);
	    self.updateCenterData();
	};
	
	zipLinePrototype.getPoints = function () {
	    var points = this.points, newPoints = [];
	    for(var i = 0, len = points.length; i < len; i++) {
	        newPoints.push({x : points[i].x, y : points[i].y});
	    }
	    return newPoints;
	};
	
	zipLinePrototype.renderPath = function (ctx) {   
	    var self = this;
	    var options = self.options;
	    var width = self.width, height = self.height;
	    var ps = self.getPoints();
	    var center = self._center, cx = center.x, cy = center.y;
	
	    var points = ps.map(function(pt) {
	        return { x: pt.x - cx, y: pt.y - cy };
	    });
	
	    return drawLineShape(ctx, points, self, width, height, options);
	};
	
	zipLinePrototype.variableRects = function (forHitTest) {
	    var self = this;
	
	    var rectSize = (forHitTest && self._isTouchMode) ? 20 : 6;
	
	    var ps = self.getPoints();
	    var rs = [];
	    var r;
	    var length = ps.length;
	
	    if (ps && length) {
	        var p = ps[1];
	        for (var i = 2; i < length - 1; i++) {
	            var p2 = ps[i];
	            if (p2.y === p.y) {
	                r = new Common.Rect((p.x + p2.x) / 2 - rectSize / 2, (p.y + p2.y) / 2 - rectSize / 2, rectSize, rectSize);
	            } else {
	                r = new Common.Rect((p.x + p2.x) / 2 - rectSize / 2, (p.y + p2.y) / 2 - rectSize / 2, rectSize, rectSize);
	                r.vertical = true;
	            }
	            r.index = i;
	            rs.push(r);
	            p = p2;
	        }
	    }
	
	    return rs;
	};
	
	
	zipLinePrototype.changeVariablePoint = function (point, t) {
	    var self = this;
	    var x = point.x, y = point.y;
	    var r = t.variableRect;
	    var ps = self.getPoints();
	    if(!self._oldPoints) {
	        self._oldPoints = self.getPoints();
	    }
	    var n = r.index;
	    var p1 = ps[n - 1];
	    var p2 = ps[n];
	    if (r.vertical) {
	        p1.x = x;
	        p2.x = x;
	    } else {
	        p1.y = y;
	        p2.y = y;
	    }
	
	    self.setPoints(ps);
	};
	
	zipLinePrototype.hitTest = function (x, y) {
	    var self = this;
	    var ps = self.getPoints();
	
	    var width = self.width;
	    var height = self.height;
	
	    var ctx = Shapes.getCtx();
	
	    ctx.save();
	    self.transformContext(ctx, width, height);
	
	    var x1 = ps[0].x, x2 = ps[ps.length - 1].x, y1 = ps[0].y, y2 = ps[ps.length - 1].y;
	    var offsetLeft = width / 2 + self.left, offsetTop = height / 2 + self.top;
	
	    var endPoint = keyword_null;
	    ctx.beginPath();
	
	    var detectSize = self._isTouchMode ? 20 : 7;
	    ctx.rect(x1 - offsetLeft - detectSize, y1 - offsetTop - detectSize, 2 * detectSize, 2 * detectSize);
	    ctx.closePath();
	
	    if (ctx.isPointInPath(x, y)) {
	        endPoint = "begin";
	    } else {
	        ctx.beginPath();
	        ctx.rect(x2 - offsetLeft - detectSize, y2 - offsetTop - detectSize, 2 * detectSize, 2 * detectSize);
	        ctx.closePath();
	        if (ctx.isPointInPath(x, y)) {
	            endPoint = "end";
	        }
	    }
	
	    var t = {}, i, len;
	    if (endPoint) {
	        t.shape = self;
	        t.type = "move";
	        t.endPoint = endPoint;
	    } else {
	        ctx.beginPath();
	        var p1 = ps[0];
	        var expandSize = self._isTouchMode ? 10 : 2;
	       
	        var isInLinePath = false;
	        for (i = 1, len = ps.length; i < len; i++) {
	            var p2 = ps[i];
	            if(getPointToLine(x, y, p1.x, p1.y, p2.x, p2.y) <= expandSize) {
	                isInLinePath = true;
	                break;
	            }
	            p1 = p2;
	        }
	        ctx.closePath();
	
	        var b = isInLinePath;
	        if (b) {
	            t.shape = self;
	            t.type = "select";
	
	            var vrs = self.variableRects(true);
	            len = vrs.length;
	            if (vrs && len > 0) {
	                for (i = 0; i < len; i++) {
	                    var r = vrs[i];
	                    ctx.beginPath();
	                    ctx.rect(r.x - offsetLeft, r.y - offsetTop, r.width, r.height);
	                    ctx.closePath();
	                    if (ctx.isPointInPath(x, y)) {
	                        t.type = "variablePoint";
	                        t.variableRect = r;
	                        break;
	                    }
	                }
	            }
	        }
	    }
	
	    ctx.restore();
	
	    return t;
	};
	
	zipLinePrototype.paintSelection = function (ctx) {
	    var self = this;
	
	    if (!self.isSelected) {
	        return;
	    }
	    ctx.save();
	    var width = self.width;
	    var height = self.height;
	
	   
	
	    var rs = self.variableRects(false);
	   
	    ctx.lineWidth = 1;
	
	    if (rs) {
	        var offsetLeft = width / 2 + self.left, offsetTop = height / 2 + self.top;
	        for (var i = 0, len = rs.length; i < len; i++) {
	            var r = rs[i];
	            ctx.fillStyle = "yellow";
	            ctx.fillRect(r.x - offsetLeft, r.y - offsetTop, r.width, r.height);
	            ctx.strokeStyle = "grey";
	            ctx.strokeRect(r.x - offsetLeft, r.y - offsetTop, r.width, r.height);
	        }
	    }
	    var size = 6;
	    var points = self.getPoints(), count = points.length;
	    ctx.strokeStyle = 'gray';
	
	    ctx.fillStyle = 'white';
	    ctx.beginPath();
	    ctx.arc(points[0].x - self.left - width / 2 + 0.5, points[0].y - self.top - height / 2 + 0.5, size / 2, 0, 2 * Math.PI);
	    ctx.fill();
	    ctx.arc(points[0].x - self.left - width / 2 + 0.5, points[0].y - self.top - height / 2 + 0.5, size / 2, 0, 2 * Math.PI);
	    ctx.stroke();
	
	    ctx.beginPath();
	    ctx.arc(points[count - 1].x - self.left - width / 2 + 0.5, points[count - 1].y - self.top - height / 2 + 0.5, size / 2, 0, 2 * Math.PI);
	    ctx.fill();
	    ctx.arc(points[count - 1].x - self.left - width / 2 + 0.5, points[count - 1].y - self.top - height / 2 + 0.5, size / 2, 0, 2 * Math.PI);
	    ctx.stroke();
	    ctx.restore();
	};
	
	zipLinePrototype.move = function (x, y) {
	    var self = this;
	    var deltX = x - self.left;
	    var deltY = y - self.top;
	    self.left = x;
	    self.top = y;
	
	    var ps = self.getPoints();
	    for (var i = 0, len = ps.length; i < len; i++) {
	        ps[i].x += deltX;
	        ps[i].y += deltY;
	    }
	    self.setPoints(ps);
	};
	
	function getYRatio(points, top, height) {
	    var ratios = [];
	    for (var i = 0, len = points.length; i < len; i++) {
	        ratios.push((points[i].y - top) / height);
	    }
	    return ratios;
	}
	
	zipLinePrototype.resizeHeight = function (height, lockBottom) {
	    var self = this;
	
	    var ps = self.getPoints();
	    var ratios = getYRatio(ps, self.top, self.height);
	    for (var i = 0, len = ps.length; i < len; i++) {
	        ps[i].y = self.top + ratios[i] * height;
	    }
	    self.setPoints(ps);
	};
	
	function getXRatio(points, left, width) {
	    var ratios = [];
	    for (var i = 0, len = points.length; i < len; i++) {
	        ratios.push((points[i].x - left) / width);
	    }
	    return ratios;
	}
	
	zipLinePrototype.resizeWidth = function (width, lockRight) { 
	    var self = this;
	
	    var ps = self.getPoints();
	    var ratios = getXRatio(ps, self.left, self.width);
	    for (var i = 0, len = ps.length; i < len; i++) {
	        ps[i].x = self.left + ratios[i] * width;
	    }
	    self.setPoints(ps);
	};
	
	zipLinePrototype.clone = function () {
	    var self = this;
	    return new ZipLine(self.getPoints(), Common.cloneOptions(self.options));
	};
	
	zipLinePrototype.updateStartConnector = function (connector) {
	    var self = this, oldConnector = self.startConnector, service = self.service;
	    if (!service) {
	        return;
	    }
	    if (oldConnector) {
	       
	        service.getShapeById(oldConnector.id).removeConnectionLine(self.id);
	    }
	    self.startConnector = connector;
	    if (connector) {
	       
	        service.getShapeById(connector.id).addConnectionLine(self.id);
	    }
	};
	zipLinePrototype.updateEndConnector = function (connector) {
	    var self = this, oldConnector = self.endConnector, service = self.service;
	    if (oldConnector) {
	       
	        service.getShapeById(oldConnector.id).removeConnectionLine(self.id);
	    }
	    self.endConnector = connector;
	    if (connector) {
	       
	      service.getShapeById(connector.id).addConnectionLine(self.id);
	    }
	};
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	Shapes.ZipLine = ZipLine;
	
	module.exports = Shapes;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	var Shapes = __webpack_require__(3);
	var ShapesCommon = Shapes.Common;
	var defineProperty = ShapesCommon.defineProperty;
	
	var toRadius = ShapesCommon.toRadius;
	var array_remove = ShapesCommon.Array_remove;
	
	
	
	
	var shapeProperties = Shapes.ShapeProperties;
	var setShapeProperty = Shapes.setShapeProperty;
	var shapeUIPrototype = Shapes.ShapeUI.prototype;
	
	var composite = Shapes.composite;
	
	var Math_min = Math.min, Math_max = Math.max, Math_cos = Math.cos, Math_sin = Math.sin, 
	    Math_sqrt = Math.sqrt, Math_atan2 = Math.atan2;
	var PI = Math.PI, keyword_null = null;
	
	function getShapePoints(shape, angle, forBounds) {
	    var l = shape.left,
	        t = shape.top,
	        w = shape.width,
	        h = shape.height;
	
	    angle %= 360;
	
	    if (angle === 0) {
	        var r = l + w, b = t + h;
	        if (forBounds) {
	            return {
	                left: l,
	                top: t,
	                right: r,
	                bottom: b
	            };
	        }
	        return [ 
	            { x: l, y: t }, 
	            { x: r, y: t }, 
	            { x: r, y: b }, 
	            { x: l, y: b } 
	        ];
	    }
	    angle = toRadius(angle);
	
	    var center = shape.getShapeCenter(),
	        cx = center.x,
	        cy = center.y;
	    var radius = Math_sqrt(w * w + h * h) / 2,
	        alpha = Math_atan2(h, w);
	    var ps = [], points = [], x, y,
	        angles = [alpha, -alpha, PI - alpha, PI + alpha];
	    for (var i = 0; i < 4; i++) {
	        var a = angles[i] + angle;
	        x = ps[i] = cx + radius * Math_cos(a);
	        y = ps[i + 4] = cy + radius * Math_sin(a);
	        points.push({ x: x, y: y });
	    }
	    if (forBounds) {
	        return ps;
	    }
	    return points;
	}
	
	Shapes.getShapePoints = getShapePoints;
	
	function getActualBound(shape, useOriginalPosition) {
	    var angle = useOriginalPosition ? 0 : shape.angle % 360;
	    var ps = getShapePoints(shape, angle, true);
	    if (angle === 0) {
	        return ps;
	    }
	    var xs = ps.splice(0, 4);
	
	    return {
	        left: Math_min.apply(keyword_null, xs),
	        top: Math_min.apply(keyword_null, ps),
	        right: Math_max.apply(keyword_null, xs),
	        bottom: Math_max.apply(keyword_null, ps)
	    };
	}
	
	Shapes.getActualBound = getActualBound;
	function getLineShapeBoundByPoints(points) {
	    var left, top, right, bottom;
	    points.forEach(function (pt, index) {
	        if (index === 0) {
	            left = right = pt.x;
	            top = bottom = pt.y;
	        }
	        left = Math_min(pt.x, left);
	        right = Math_max(pt.x, right);
	        top = Math_min(pt.y, top);
	        bottom = Math_max(pt.y, bottom);
	    });
	    return {
	        left: left,
	        top: top,
	        right: right,
	        bottom: bottom
	    };
	}
	Shapes.getLineShapeBoundByPoints = getLineShapeBoundByPoints;
	
	function getBoundForHoldShapes(shapes, useOriginalPosition) {
	    if (shapes && shapes.length) {
	        var lefts = [], rights = [], tops = [], bottoms = [];
	        shapes.forEach(function (shape) {
	           
	           
	           
	            var bound;
	            if(shape instanceof Shapes.ZipLine) {
	                bound = getLineShapeBoundByPoints(shape.getPoints());
	            } else {
	                bound = getActualBound(shape, useOriginalPosition);
	            }
	
	            lefts.push(bound.left);
	            tops.push(bound.top);
	            rights.push(bound.right);
	            bottoms.push(bound.bottom);
	        });
	        return {
	            left: Math_min.apply(keyword_null, lefts),
	            top: Math_min.apply(keyword_null, tops),
	            right: Math_max.apply(keyword_null, rights),
	            bottom: Math_max.apply(keyword_null, bottoms)
	        };
	    }
	}
	
	Shapes.getBoundForHoldShapes = getBoundForHoldShapes;
	
	function CompoundShape(shapes, options) {
	    var self = this;
	    self.shapes = shapes;
	    self.options = options;
	    self.id = options.id;
	    self.isCompoundShape = true;
	    self._shapeType = 2;
	
	    if (!shapes) {
	        return;
	    }
	
	    var bound = getBoundForHoldShapes(shapes, true );
	    var left = bound.left, top = bound.top, right = bound.right, bottom = bound.bottom;
	
	    self.left = left;
	    self.top = top;
	    self.width = right - left;
	    self.height = bottom - top;
	    var width = self.width, height = self.height;
	
	    shapes.forEach(function (shape) {
	        shape.parent = self;
	        shape.relativeX = (shape.left - left) / width;
	        shape.relativeY = (shape.top - top) / height;
	        shape.relativeWidth = shape.width / width;
	        shape.relativeHeight = shape.height / height;
	    });
	}
	
	CompoundShape.prototype = new Shapes.ShapeUI();
	var CompoundShapePrototype = CompoundShape.prototype;
	CompoundShapePrototype.setBounds = function () {
	   
	};
	CompoundShapePrototype.setService = function (service) {
	    var self = this;
	    if (self.service !== service) {
	        var path, options, ps, connectionLines, connectionPoints, variables, parent;
	        if (self.service) {
	            var id = self.id;
	            path = self.service.getPath(id, true);
	            options = self.service.getOptions(id, true);
	            ps = self.getGeoProperties();
	            connectionPoints = self.connectionPoints;
	            connectionLines = self.connectionLines;
	            variables = self.variables;
	            parent = self.parent;
	
	            self.service.calcSource_.removeObject(id);
	            self.service = keyword_null;
	            self.model = {};
	
	            self.path = path;
	            self.options = options;
	            self.setGeoProperties(ps);
	            self.connectionPoints = connectionPoints;
	            self.connectionLines = connectionLines;
	            self.variables = variables;
	            self.parent = parent;
	        }
	
	        if (service) {
	            service.setValue(self.id, 'isCompoundShape', true);
	
	            options = self.options;
	            path = self.path;
	            ps = self.getGeoProperties();
	            connectionPoints = self.connectionPoints;
	            connectionLines = self.connectionLines;
	            variables = self.variables;
	            parent = self.parent;
	
	            self.service = service;
	
	            var pd = Object.getOwnPropertyDescriptor(self, 'options');
	            if (!pd || !pd.get) {
	                shapeProperties.forEach(function (p) {
	                    defineProperty(self, p, {
	                        get: function () {
	                            var _service = self.service;
	                            if (_service) {
	                                var v = _service.getValue(self.id, p);
	                                if (v === undefined && self.parentShapeID) {
	                                    v = _service.getValue(self.parentShapeID, p);
	                                }
	                                return v;
	                            }
	                            return self.model[p];
	                        },
	                        set: function (value) {
	                            setShapeProperty(self, self.id, p, value);
	                        }
	                    });
	                });
	
	                defineProperty(self, 'path', {
	                    get: function () {
	                        var tmpPath = new Shapes.Path();
	                        var _service = self.service;
	                        if (_service) {
	                            tmpPath.pathCommands = _service.getPath(self.id);
	                        } else {
	                            tmpPath.pathCommands = self.model.path;
	                        }
	                        if (!tmpPath.pathCommands) {
	                            tmpPath.pathCommands = [];
	                        }
	                        return tmpPath;
	                    },
	                    set: function (value) {
	                        if (!value) {
	                            return;
	                        }
	                        var p = value.pathCommands || value;
	                        var _service = self.service;
	                        if (_service) {
	                            _service.setPath(self.id, p);
	                        } else {
	                            self.model.path = value;
	                        }
	                    }
	                });
	
	                defineProperty(self, 'options', {
	                    get: function () {
	                        var _service = self.service;
	                        if (_service) {
	                            var p = _service.getOptions(self.id);
	                            p = self.optionsCache = composite({}, p);
	                            return p;
	                        }
	                        return self.model.options;
	                    },
	                    set: function (value) {
	                        var _service = self.service;
	                        if (_service) {
	                            _service.setOptions(self.id, value);
	                        } else {
	                            self.model.options = value;
	                        }
	                    }
	                });
	
	                defineProperty(self, 'connectionPoints', {
	                    get: function () {
	                        var _service = self.service;
	                        if (_service) {
	                            return _service.getConnectionPoints(self.id);
	                        }
	                        return self.model.connectionPoints;
	                    },
	                    set: function (value) {
	                        var _service = self.service;
	                        if (_service) {
	                            _service.setConnectionPoints(self.id, value);
	                        } else {
	                            self.model.connectionPoints = value;
	                        }
	                    }
	                });
	
	                defineProperty(self, 'connectionLines', {
	                    get: function () {
	                        var _service = self.service;
	                        if (_service) {
	                            return _service.getConnectionLines(self.id);
	                        }
	                        return self.model.connectionLines;
	                    },
	                    set: function (value) {
	                        var _service = self.service;
	                        if (_service) {
	                            _service.setConnectionLines(self.id, value);
	                        } else {
	                            self.model.connectionLines = value;
	                        }
	                    }
	                });
	
	                defineProperty(self, 'variables', {
	                    get: function () {
	                        var _service = self.service;
	                        if (_service) {
	                            var t = _service.getValues(self.id, 'variables');
	                            return t && t.variables;
	                        }
	                        return self.model.variables;
	                    },
	                    set: function (value) {
	                        var _service = self.service;
	                        if (_service) {
	                            _service.setValues(self.id, 'variables', value);
	                        } else {
	                            self.model.variables = value;
	                        }
	                    }
	                });
	
	                defineProperty(self, 'parent', {
	                    get: function () {
	                        var _service = self.service;
	                        if (_service) {
	                            return _service.getShapeById(_service.getValue(self.id, 'parentId'));
	                        }
	                        return self.model.parentId;
	                    },
	                    set: function (value) {
	                        var _service = self.service;
	                        if (_service) {
	                            _service.setValueOrFormula(self.id, 'parentId', value ? value.id : undefined);
	                        } else {
	                            self.model.parentId = value ? value.id : undefined;
	                        }
	                    }
	                });
	            }
	
	            self.setGeoProperties(ps);
	            self.connectionPoints = connectionPoints;
	            self.connectionLines = connectionLines;
	            self.variables = variables;
	            self.parent = parent;
	            self.path = path;
	            self.options = options || {};
	        }
	    }
	
	    self.setBounds();
	};
	
	CompoundShapePrototype.render = function (ctx) {
	    var self = this, shapes = self.shapes;
	
	    var width = self.width;
	    var height = self.height;
	
	    if (!shapes || shapes.length === 0) {
	        return;
	    }
	
	    ctx.save();
	    self.transform(ctx, width, height);
	
	   
	    ctx.translate(-self.left - width / 2, -self.top - height / 2);    
	    shapes.forEach(function (shape) {
	        shape.render(ctx);
	    });
	    ctx.translate(self.left + width / 2, self.top + height / 2);
	
	    self.paintSelection(ctx);
	
	    ctx.restore();
	};
	
	
	
	CompoundShapePrototype.setAngle = function (angle) {
	    var self = this, oldAngle = self.angle, diff = angle - oldAngle;
	    shapeUIPrototype.setAngle.call(self, angle);
	    self.shapes.forEach(function (shape) {
	        var a = (shape.angle + diff) % 360;
	        if (a < 0) {
	            a += 360;
	        }
	        if (shape._shapeWrapper && shape._shapeType !== 1  ) { 
	            shape._shapeWrapper._shapeData.Rotation = a; 
	        }
	        shape.setAngle(a);
	    });
	    self.layoutChildren();
	};
	
	CompoundShapePrototype.move = function (x, y, ignoreConnectionLines) {
	    var self = this;
	    var deltX = x - self.left;
	    var deltY = y - self.top;
	    shapeUIPrototype.move.call(self, x, y, ignoreConnectionLines);
	    
	    self.shapes.forEach(function (shape) {
	        if (shape._shapeType === 1 ) {
	            shape.move(shape.left + deltX, shape.top + deltY);
	        }
	    });
	
	    self.layoutChildren();
	};
	
	CompoundShapePrototype.resizeHeight = function (height, lockBottom) {
	    var self = this;
	    var delta = height - self.height;
	    var a = toRadius(self.angle);
	    var x = Math_sin(a) * delta;
	    var y = -Math_cos(a) * delta;
	
	    self.height = height;
	    self.shapes.forEach(function (shape) {
	        if (shape._shapeType === 1 ) {
	            shape.resizeHeight(shape.relativeHeight * height, lockBottom);
	            shape.move(shape.left, self.top + shape.relativeY * self.height);
	        }
	    });
	
	    self.layoutChildren(lockBottom);
	
	    if (lockBottom) {
	        self.move(self.left + x, self.top + y);
	    }
	};
	
	CompoundShapePrototype.resizeWidth = function (width, lockRight) {
	    var self = this;
	    var delta = width - self.width;
	    var a = toRadius(self.angle);
	    var x = -Math_cos(a) * delta;
	    var y = -Math_sin(a) * delta;
	
	    self.width = width;
	
	    self.shapes.forEach(function (shape) {
	        if (shape._shapeType === 1 ) {
	            shape.resizeWidth(shape.relativeWidth * width, lockRight);
	            shape.move(self.left + shape.relativeX * self.width, shape.top);
	        }
	    });
	    
	    self.layoutChildren(lockRight);
	
	    if (lockRight) {
	        self.move(self.left + x, self.top + y);
	    }
	};
	
	CompoundShapePrototype.layoutChildren = function () {
	    var self = this;
	    self.shapes.forEach(function (shape) {
	        shape.left = self.left + shape.relativeX * self.width;
	        shape.top = self.top + shape.relativeY * self.height;
	        shape.width = shape.relativeWidth * self.width;
	        shape.height = shape.relativeHeight * self.height;
	
	        shape.resetPathOffset();
	        shape.updateCenterData();
	
	        if (shape.layoutChildren) {
	            shape.layoutChildren();
	        }
	    });
	};
	
	CompoundShapePrototype.hitTest = function (x, y) {
	    var self = this;
	    var ret = shapeUIPrototype.hitTest.call(self, x, y);
	    if (ret && ((ret.type === "select" && ret.sizeRect) || ret.type === "rotate")) {
	        return ret;
	    }
	
	    ret = keyword_null;
	   
	
	    var ctx = Shapes.getCtx();
	    ctx.save();
	
	    var width = self.width;
	    var height = self.height;
	
	    self.transformContext(ctx, width, height);
	    ctx.translate(-self.left - width / 2, -self.top - height / 2);
	
	    self.shapes.forEach(function (shape) {
	        var t = shape.hitTest(x, y, ctx);
	        if (t && t.shape) {
	            ret = t;
	            return false;
	        }
	    });
	
	    ctx.restore();
	
	    return (ret && ret.shape) ? {
	        shape: self, type: ret.type || "select", shape2: ret.shape2 || ret.shape, index: ret.index 
	    } : keyword_null;
	};
	
	CompoundShapePrototype.addShape = function (shape, ignoreUpdate) {
	    var groupShape = this;
	    shape.parent = groupShape;
	    groupShape.shapes.push(shape);
	    if (!ignoreUpdate) { 
	        groupShape.update();
	    }
	};
	CompoundShapePrototype.update = function () {
	    var parent = this;
	    var left = Number.MAX_VALUE, top = Number.MAX_VALUE, right = Number.MIN_VALUE, bottom = Number.MIN_VALUE;
	
	    parent.shapes.forEach(function (shape) {
	        var b;
	        if (shape._shapeType === 1 ) {
	            b = getLineShapeBoundByPoints(shape.getPoints()); 
	        } else {
	            b = getActualBound(shape);
	        }
	        if (b.left < left) {
	            left = b.left;
	        }
	        if (b.top < top) {
	            top = b.top;
	        }
	        if (b.right > right) {
	            right = b.right;
	        }
	        if (b.bottom > bottom) {
	            bottom = b.bottom;
	        }
	    });
	
	    parent.left = left;
	    parent.top = top;
	    parent.width = right - left;
	    parent.height = bottom - top;
	    parent.updateCenterData();
	   
	
	    parent.shapes.forEach(function (s) {
	        s.relativeX = (s.left - parent.left) / parent.width;
	        s.relativeY = (s.top - parent.top) / parent.height;
	        s.relativeWidth = s.width / parent.width;
	        s.relativeHeight = s.height / parent.height;
	    });
	};
	CompoundShapePrototype.removeShape = function (shape, ignoreUpdate) {
	    var parent = this;
	    delete shape.parent;
	    array_remove(parent.shapes, shape);
	    
	    if (!ignoreUpdate) {
	        parent.update();
	    }
	};
	
	CompoundShapePrototype._resizeImp = function (width, height) {
	    var self = this;
	    self.width = width;
	    self.height = height;
	};
	
	CompoundShapePrototype.clone = function () {
	    var self = this;
	    var shapes = [];
	    if (self.shapes) {
	        self.shapes.forEach(function (s) {
	            shapes.push(s.clone());
	        });
	    }
	
	    return new CompoundShape(shapes, Shapes.Common.cloneOptions(self.options));
	};
	Shapes.CompoundShape = CompoundShape;
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	module.exports = Shapes;
	
	


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	var Shapes = __webpack_require__(3);
	var Common = Shapes.Common, extend = Common.extend, arrayHelper_getLength = Common._getArrayLength, arrayPush = Common._arrayPush;
	var Rect = Common.Rect, _inArray = Shapes.Common._inArray;
	
	
	
	var Math_round = Math.round, Math_max = Math.max, Math_min = Math.min,
	    keyword_null = null,
	    CSS_LEFT = 'left', CSS_RIGHT = 'right', CSS_TOP = 'top', CSS_BOTTOM = 'bottom';
	
	
	function fixNumber(n, digits) {
	    digits = digits || 3;
	    return +(n.toFixed(digits));
	}
	
	function getCanvasOffset(canvas) {
	    var t = { top: canvas.offsetTop, left: canvas.offsetLeft };
	    var p = canvas.offsetParent;
	    while (p) {
	        t.top += p.offsetTop;
	        t.left += p.offsetLeft;
	        p = p.offsetParent;
	    }
	
	    var body = document.body, clientTop = body.clientTop, clientLeft = body.clientLeft;
	    if (!isNaN(clientTop)) {
	        t.top += clientTop;
	    }
	    if (!isNaN(clientLeft)) {
	        t.left += clientLeft;
	    }
	    return t;
	}
	
	
	
	var toRadius = Common.toRadius;
	
	var rotatePoint = Common.rotatePoint;
	
	
	
	var getOptionValue = Common.getOptionValue;
	
	function resizeShape(shape, deltW, deltH, lockBottom, lockRight) {
	    resizeHeight(shape, deltH, lockBottom);
	    resizeWidth(shape, deltW, lockRight);
	}
	
	function resizeHeight(shape, deltH, lockBottom) {
	    var newSize = shape.height + deltH;
	    if (newSize <= 0) {
	        newSize = 1;
	    }
	    shape.resizeHeight(newSize, lockBottom);
	}
	
	function resizeWidth(shape, deltW, lockRight) {
	    var newSize = shape.width + deltW;
	    if (newSize <= 0) {
	        newSize = 1;
	    }
	    shape.resizeWidth(newSize, lockRight);
	}
	
	function moveEndPoint(shape, point, x, y) {
	    if (point === "begin") {
	       
	        shape.moveStartPoint(x, y);
	    } else if (point === "end") {
	       
	        shape.moveEndPoint(x, y);
	    }
	}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	var cursors = ["nw-resize", "ns-resize", "ne-resize", "ew-resize", "se-resize", "ns-resize", "sw-resize", "ew-resize"];
	var corners = ["topleft", "topcenter", "topright", "middleright", "bottomright", "bottomcenter", "bottomleft", "middleleft"];
	
	function getCursorFromHitTest(hitTest) {
	    var cursor = "";
	    if (hitTest) {
	        var shape = hitTest.shape;
	        var sr = hitTest.sizeRect;
	        if (sr) {
	            var a = shape.angle;
	
	            var n = corners.indexOf(sr.type);
	            n = (n + Math_round(a / 45)) % 8;  
	
	            if (n >= 0) {
	                cursor = cursors[n];
	            }
	        }
	        if (hitTest.type === "rotate" || hitTest.endPoint || hitTest.type === "variablePoint") {
	            cursor = "crosshair";
	        }
	        if (shape && cursor.length === 0) {
	            cursor = "move";
	        }
	    }
	
	    return cursor;
	}
	
	var defaultOptions = Shapes.getStyle("default");
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	function Canvas(model, host) {
	    this.init(model);
	    this.setHost(host);
	}
	
	Canvas.createShapeModel = function () {
	    var regItemTypes = /^(path|variables)\./;
	    var model = new Shapes.ShapeModel();
	    model.changed = function (id, path, value, old, isFormula) {
	        if (model._ignoreChange) {
	            return;
	        }
	        var derives = model.derives[id];
	        var sp = model.getShapeById(id);
	        if (path === 'options') {
	            if (sp) {
	                delete sp.optionsCache;
	            }
	            if (derives) {
	                derives.forEach(function (shape) {
	                    delete shape.optionsCache;
	                });
	            }
	        }
	
	        var ms = path && path.match(regItemTypes);
	        if (ms && arrayHelper_getLength(ms)) {
	            var prefix = ms[1];
	           
	            if (prefix === 'path' && sp) {
	                delete sp.pathCache;
	                sp.resetPathOffset();
	            }
	
	            if (derives && Shapes.ShapeProperties.indexOf(path) >= 0) {
	                derives.forEach(function (shape) {
	                    delete shape.pathCache;
	                    shape.resetPathOffset();
	                });
	            }
	        }
	        if (isFormula && value !== old && model.onPropertyChangedByFormula) {
	            model.onPropertyChangedByFormula(id, path, value);
	        }
	    };
	    return model;
	};
	Canvas._registerFeature = function (name, feature) {
	    if (!Canvas._features) {
	        Canvas._features = [];
	    }
	    var features = Canvas._features;
	    feature.name = name;
	    feature.priority = feature.priority || 5000 ;
	    for (var i = 0; ; i++) {
	        if (i >= features.length || feature.priority > features[i].priority) {
	            features.splice(i, 0, feature);
	            break;
	        }
	    }
	};
	Canvas._callFeatureHandler = function (target, fn, eventArg, endLoopFn) {
	    var sf = Canvas._features;
	    if (sf) {
	        for (var i = 0; i < sf.length; i++) {
	            var f = sf[i][fn];
	            f && f.call(target, eventArg);
	
	            if (endLoopFn && endLoopFn()) {
	                break;
	            }
	        }
	    }
	};
	Canvas.prototype = {
	    init: function (model) {
	        var self = this;
	        self.scrollLeft = 0;
	        self.scrollTop = 0;
	
	        self.model = model || Canvas.createShapeModel();
	
	        Object.defineProperty(self, 'shapes', {
	            get: function () {
	                return self.model.getShapes();
	            }
	        });
	
	        self.mouseDownFn = function (e) {
	            var argObj = { e: e, r: keyword_null };
	            Canvas._callFeatureHandler(self, 'preProcessMouseDown', argObj);
	            if (argObj.r) {
	                return;
	            }
	
	            self.doMouseDown(e);
	        };
	
	        self.mouseMoveFn = function (e) {
	            var argObj = { e: e, r: keyword_null };
	            Canvas._callFeatureHandler(self, 'preProcessMouseMove', argObj);
	            if (argObj.r) {
	                return;
	            }
	
	            self.doMouseMove(e);
	        };
	
	        self.mouseUpFn = function (e) {
	            var argObj = { e: e, r: keyword_null };
	            Canvas._callFeatureHandler(self, 'preProcessMouseUp', argObj);
	            if (argObj.r) {
	                return;
	            }
	
	            self.doMouseUp(e);
	        };
	
	        self.mousewheelFn = function (e) {
	            var argObj = { e: e, r: keyword_null };
	            Canvas._callFeatureHandler(self, 'preProcessMouseWheel', argObj);
	            if (argObj.r) {
	                return;
	            }
	        };
	
	        self.mouseoutFn = function (e) {
	            var argObj = { e: e, r: keyword_null };
	            Canvas._callFeatureHandler(self, 'preProcessMouseOut', argObj);
	            if (argObj.r) {
	                return;
	            }
	
	            self.doMouseOut(e);
	        };
	
	        self.dblclickFn = function (e) {
	            var argObj = { e: e, r: keyword_null };
	            Canvas._callFeatureHandler(self, 'preProcessDbClick', argObj);
	            if (argObj.r) {
	                return;
	            }
	        };
	    },
	    setHost: function (host) {
	        var self = this, oldHost = self.host;
	        if (host !== oldHost) {
	            if (oldHost) {
	                self.dispose();
	            }
	
	            self.host = host;
	
	            if (host) {
	                self.width = host.width;
	                self.height = host.height;
	
	                host.addEventListener("mousemove", self.mouseMoveFn);
	                host.addEventListener("mousedown", self.mouseDownFn);
	                host.addEventListener("mouseup", self.mouseUpFn);
	                host.addEventListener("mousewheel", self.mousewheelFn);
	                host.addEventListener("mouseout", self.mouseoutFn);
	                host.addEventListener("dblclick", self.dblclickFn);
	                document.addEventListener("mouseout", self.mouseoutFn);
	
	                Canvas._callFeatureHandler(self, 'setHost', host);
	            }
	        }
	    },
	    dispose: function () {
	        var self = this, host = self.host;
	        if (host) {
	            host.removeEventListener("mousedown", self.mouseDownFn);
	            host.removeEventListener("mousemove", self.mouseMoveFn);
	            host.removeEventListener("mouseup", self.mouseUpFn);
	            host.removeEventListener("mousewheel", self.mousewheelFn);
	            host.removeEventListener("mouseout", self.mouseoutFn);
	            host.removeEventListener("dblclick", self.dblclickFn);
	            document.removeEventListener("mouseout", self.mouseoutFn);
	
	            Canvas._callFeatureHandler(self, 'dispose', host);
	        }
	    },
	    getShapeById: function (id) {
	        return this.model.getShapeById(id);
	    },
	    getUniqueShapeId: function (objResult) {
	        return this.model.getUniqueShapeId(objResult);
	    },
	    ensureUniqueShapeId: function (id) {
	        return this.model.ensureUniqueShapeId(id);
	    },
	    createShapeFromPath: function (path, options, left, top, width, height, angle) {
	        options = extend({}, defaultOptions, options);
	
	        return this.createShape({
	            path: path,
	            options: options,
	            left: left,
	            top: top,
	            width: width,
	            height: height,
	            angle: angle || 0
	        });
	    },
	    createLine: function (type, model) {
	        var service = this.getModel();
	        var line = keyword_null;
	        if (type === "ZipLine") {
	            line = new Shapes.ZipLine(model, service);
	        } else if (type === "Line") {
	            line = new Shapes.Line(model, service);
	            var points = model && model.points;
	            line.setPoints(points);
	        }
	        return line;
	    },
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	    createShape: function (model) {
	        var self = this;
	        var service = self.getModel();
	        model = model || {};
	        if (!model.id) {
	            model.id = service.getUniqueShapeId();
	        }
	        return Shapes.createShape(model, service);
	    },
	    getModel: function () {
	        return this.model;
	    },
	    addShape: function (shape) {
	        var model = this.getModel();
	        model.addShape(shape);
	    },
	    removeShape: function (shape, ignoreModel) {
	        var self = this;
	        var model = self.getModel();
	
	        if (!ignoreModel) {
	            var connectionLines = self.getConnectionLines(shape);
	            if (connectionLines) {
	                var endConnector, startConnector;
	                connectionLines.forEach(function (line) {
	                    if (!line) {
	                        return;
	                    }
	                    endConnector = line.endConnector;
	                    startConnector = line.startConnector;
	                    if (endConnector && endConnector.id === shape.id) {
	                        shape.removeConnectionLine(line.id);
	                        line.endConnector = keyword_null;
	                    }
	                    if (startConnector && startConnector.id === shape.id) {
	                        shape.removeConnectionLine(line.id);
	                        line.startConnector = keyword_null;
	                    }
	                });
	            }
	            if (shape._shapeType === 1 ) {
	                shape.updateStartConnector(keyword_null);
	                shape.updateEndConnector(keyword_null);
	            }
	        }
	       
	        model.removeShape(shape, ignoreModel);
	    },
	    getPointer: function (e) {
	        var self = this;
	        var t = getCanvasOffset(self.host);
	        var x = e.pageX - t.left + self.scrollLeft, y = e.pageY - t.top + self.scrollTop;
	        return { x: x, y: y };
	    },
	    getDelta: function (p, shape, resizeType) {
	       
	        var halfWidth = shape.width / 2, halfHeight = shape.height / 2;
	        var center = shape._center;
	        var pt = rotatePoint({ x: p.x - center.x, y: p.y - center.y }, { x: 0, y: 0 }, -toRadius(shape.angle));
	        var x = pt.x, y = pt.y;
	
	        var deltX = 0, deltY = 0;
	        if (resizeType === "bottomright") {
	            deltY = y - halfHeight;
	            deltX = x - halfWidth;
	        } else if (resizeType === "topleft") {
	            deltY = y + halfHeight;
	            deltX = x + halfWidth;
	        } else if (resizeType === "topcenter") {
	            deltY = y + halfHeight;
	        } else if (resizeType === "bottomcenter") {
	            deltY = y - halfHeight;
	        } else if (resizeType === "middleleft") {
	            deltX = x + halfWidth;
	        } else if (resizeType === "middleright") {
	            deltX = x - halfWidth;
	        } else if (resizeType === "topright") {
	            deltY = y + halfHeight;
	            deltX = x - halfWidth;
	        } else if (resizeType === "bottomleft") {
	            deltY = y - halfHeight;
	            deltX = x + halfWidth;
	        }
	
	        return { x: deltX, y: deltY };
	    },
	    hitTest: function (e) {
	        var self = this;
	       
	
	        var p = self.getPointer(e);
	
	        var ret = keyword_null;
	
	        self.shapes.forEach(function (shape) {
	            var shapeWrapper = shape._shapeWrapper;
	            var canSelect = true;
	            if (shapeWrapper) {
	                var options = shapeWrapper._sheet.options;
	                var allowEditObjects = !options.isProtected || options.protectionOptions.allowEditObjects;
	                canSelect = allowEditObjects || !shapeWrapper.isLocked();
	            }
	
	            var isVisible = !shapeWrapper || shapeWrapper.isVisible();
	            if (isVisible && canSelect) {
	                var t = shape.hitTest(p.x, p.y);
	                if (t && t.shape && (!ret || !ret.endPoint)) {
	                    ret = t;
	                }
	            }
	        });
	
	        return ret;
	    },
	    paintLayerShapes: function (ctx, clipRect, isPrint) {
	        var self = this;
	        var scrollLeft = self.scrollLeft, scrollTop = self.scrollTop;
	        if (scrollLeft || scrollTop) {
	            ctx.translate(-scrollLeft, -scrollTop);
	        }
	        self.shapes.forEach(function (shape) {
	            var shapeWrapper = shape._shapeWrapper;
	            var b = Shapes.getActualBound(shape);
	            var left = b.left - scrollLeft, top = b.top - scrollTop, width = b.right - b.left, height = b.bottom - b.top;
	            var isVisible = (!shapeWrapper || shapeWrapper.isVisible());
	            var canPrint = !shapeWrapper || shapeWrapper.canPrint();
	            var canRender = !isPrint || (isPrint && canPrint);
	            if (!shape.parent && clipRect.intersect(left, top, width, height) && isVisible && canRender) {
	                shape.render(ctx);
	            }
	        });
	    },
	    paintForPrint: function (ctx) {
	        var self = this, width = self.width, height = self.height;
	        if (width <= 0 || height <= 0) {
	            return;
	        }
	        ctx.save();
	       
	        var clipRect = new Rect(self._printOffsetX || 0, self._printOffsetY || 0, width, height);
	        self.paintLayerShapes(ctx, clipRect, true );
	        ctx.restore();
	    },
	    paint: function (ctx, clipRect) {
	        var self = this, host = self.host, width = self.width, height = self.height;
	
	        if (!host) {
	            return;
	        }
	
	        if (width <= 0 || height <= 0) {
	            return;
	        }
	
	        if (!ctx) {
	            ctx = host.getContext("2d");
	        }
	        ctx.save();
	        ctx.beginPath();
	
	        ctx.clearRect(0, 0, width, height);
	
	        if (self.shapes.length === 0) {
	            ctx.restore();
	            return;
	        }
	
	        if (!clipRect) {
	            clipRect = new Rect(0, 0, width, height);
	        }
	        ctx.rect(clipRect.x, clipRect.y, clipRect.width, clipRect.height);
	        ctx.clip();
	
	        self.paintLayerShapes(ctx, clipRect);
	        ctx.restore();
	       
	    },
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	    getConnectionPointLocation: function (point, shape) {
	        point.x = fixNumber(point.x);
	        point.y = fixNumber(point.y);
	        var cornerPoints = shape.getActualCornerPoints();
	        var minX = keyword_null, minY = keyword_null, maxX = keyword_null, maxY = keyword_null;
	        cornerPoints.forEach(function (pt) {
	            if (minX === keyword_null || pt.x < minX) {
	                minX = pt.x;
	            }
	            if (maxX === keyword_null || pt.x > maxX) {
	                maxX = pt.x;
	            }
	            if (minY === keyword_null || pt.y < minY) {
	                minY = pt.y;
	            }
	            if (maxY === keyword_null || pt.y > maxY) {
	                maxY = pt.y;
	            }
	        });
	        var centerX = fixNumber((minX + maxX) / 2);
	        var centerY = fixNumber((minY + maxY) / 2);
	
	        var p = cornerPoints[0];
	        var x = p.x, y = p.y, x2 = p.x, y2 = p.y;
	        var left = 0, top = 0, right = 0, bottom = 0;
	        for (var i = 0, len = arrayHelper_getLength(cornerPoints); i < len; i++) {
	            p = cornerPoints[i];
	            if (point.x < p.x + 2 && point.x < centerX) {
	                left++;
	            }
	            if (point.y < p.y + 2 && point.y < centerY) {
	                top++;
	            }
	            if (point.x > p.x - 2 && point.x > centerX) {
	                right++;
	            }
	            if (point.y > p.y - 2 && point.y > centerY) {
	                bottom++;
	            }
	
	            if (x > p.x) {
	                x = p.x;
	            }
	            if (y > p.y) {
	                y = p.y;
	            }
	            if (x2 < p.x) {
	                x2 = p.x;
	            }
	            if (y2 < p.y) {
	                y2 = p.y;
	            }
	        }
	
	        return { left: left, top: top, right: right, bottom: bottom, x: x, y: y, width: x2 - x, height: y2 - y };
	    },
	    layoutConnectionLine: function (line) {
	        var self = this, zoom = 1;
	        var wrap = line._shapeWrapper;
	        if(wrap && wrap._sheet) {
	            zoom = wrap._sheet.zoom();
	        }
	        var gap = 20 * zoom;
	        if (!line.parent && line.angle !== 0) {
	            line.setAngle(0);
	        }
	       
	       
	       
	       
	
	        var p1, p2, sp1, pLocation1, r1, points, adjustLocation;
	        var startConnector = line.startConnector, endConnector = line.endConnector;
	        if (startConnector || endConnector) {
	            if (startConnector) {
	                sp1 = self.getShapeById(startConnector.id);
	                var sp1ConnectPoints = sp1.getActualConnectorPoints();
	                if (!sp1ConnectPoints || arrayHelper_getLength(sp1ConnectPoints) === 0 || arrayHelper_getLength(sp1ConnectPoints) <= line.startConnector.index) {
	                    return;
	                }
	                p1 = sp1ConnectPoints[startConnector.index];
	                pLocation1 = self.getConnectionPointLocation(p1, sp1);
	            } else {
	                p1 = line.getStartPoint();
	               
	                pLocation1 = { x: p1.x, y: p1.y, width: 0, height: 0 };
	                adjustLocation = pLocation1;
	            }
	            var pLocation2, sp2;
	            if (endConnector) {
	                sp2 = self.getShapeById(endConnector.id);
	                var sp2ConnectPoints = sp2.getActualConnectorPoints();
	                if (!sp2ConnectPoints || arrayHelper_getLength(sp2ConnectPoints) === 0 || arrayHelper_getLength(sp2ConnectPoints) <= line.endConnector.index) {
	                    return;
	                }
	                p2 = sp2ConnectPoints[endConnector.index];
	                pLocation2 = self.getConnectionPointLocation(p2, sp2);
	            } else {
	                p2 = line.getEndPoint();
	               
	                pLocation2 = { x: p2.x, y: p2.y, width: 0, height: 0 };
	                adjustLocation = pLocation2;
	            }
	            
	            r1 = { left: pLocation1.x, top: pLocation1.y, width: pLocation1.width, height: pLocation1.height, right: pLocation1.x + pLocation1.width, bottom: pLocation1.y + pLocation1.height};
	            var r2 = { left: pLocation2.x, top: pLocation2.y, width: pLocation2.width, height: pLocation2.height, right: pLocation2.x + pLocation2.width, bottom: pLocation2.y + pLocation2.height };
	            
	            points = [p1];
	            
	            var r1Top = r1.top - gap, r1Left = r1.left - gap, r1Right = r1.left + r1.width + gap, r1Bottom = r1.top + r1.height + gap;
	            var r2Top = r2.top - gap, r2Left = r2.left - gap, r2Right = r2.left + r2.width + gap, r2Bottom = r2.top + r2.height + gap;
	            
	            var x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, y3, y4, x3, x4;
	
	           
	            if (adjustLocation) {
	                var refLocation, x, rect;
	                if (adjustLocation === pLocation1) {
	                    refLocation = pLocation2;
	                    x = x1;
	                    rect = r2;
	                 } else {
	                     refLocation = pLocation1;
	                     x = x2;
	                     rect = r1;
	                 }
	                if (y1 < y2) {
	                    if (x > rect.right) {
	                       
	                       
	                       
	                            adjustLocation.left = 2;
	                       
	                    } else if (x < rect.left) {
	                        if (refLocation.right >= 2 || refLocation.top >= 2) {
	                            adjustLocation.right = 2;
	                        } else {
	                            adjustLocation.bottom = 2;
	                        }
	                    } else {
	                        adjustLocation.bottom = 2;
	                    }
	                } else {
	                    if (x > rect.right) {   
	                        if (refLocation.right >= 2 || refLocation.top >= 2) {
	                            adjustLocation.top = 2;
	                        } else {
	                            adjustLocation.left = 2;
	                        }
	                    } else if (x < rect.left) {
	                        if (refLocation.right >= 2 || refLocation.bottom >= 2) {
	                            adjustLocation.right = 2;
	                        } else {
	                            adjustLocation.top = 2;
	                        }
	                    } else {
	                        adjustLocation.top = 2;
	                    }
	                }
	            }
	            
	            if (x1 > x2) {
	                if (y1 < y2) {
	                    if (pLocation1.top >= 2) {
	                       
	                        y3 = Math_min(y1 - gap, r1Top);
	                        if (pLocation2.left >= 2) {
	                           
	                            x3 = Math_min(r1Left, r2Left, x2 - gap);
	                            y3 = Math_min(r1Top, r2Top);
	                            arrayPush(points, { x: x1, y: y3 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x3, y: y2 });
	                        } else if (pLocation2.top >= 2) {
	                            if (x2 > r1.left) {
	                               
	                                y3 = Math_max(y1 - gap, r1Top);
	                                arrayPush(points, { x: x1, y: y3 });
	                                x3 = Math_max(r1Right, r2Right, x2 + gap);
	                                arrayPush(points, { x: x3, y: y3 });
	                                y4 = (r1Bottom + r2Top) / 2;
	                                arrayPush(points, { x: x3, y: y4 });
	                                arrayPush(points, { x: x2, y: y4 });
	                            }
	                        } else if (pLocation2.right >= 2) {
	                            y3 = Math_max(y1 - gap, r1Top);
	                            if (x2 < r1.left) {
	                               
	                                x3 = (r2Right + r1Left) / 2;
	                            } else {
	                               
	                                x3 = Math_max(r1Right, r2Right, x2 + gap);
	                            }
	                            arrayPush(points, { x: x1, y: y3 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x3, y: y2 });
	                        } else {
	                           
	                            if (r2.right < r1.left) {
	                                x3 = (r2.right + r1.left) / 2;
	                            } else {
	                                x3 = Math_min(r1Left, r2Left, x2 - gap);
	                            }
	                            y4 = y2 + gap;
	                            arrayPush(points, { x: x1, y: y3 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x3, y: y4 });
	                            arrayPush(points, { x: x2, y: y4 });
	                        }
	                        if (points.length === 1) {
	                            arrayPush(points, { x: x1, y: y3 });
	                            arrayPush(points, { x: x2, y: y3 });
	                        }
	                    } else if (pLocation1.right >= 2) {
	                       
	                        x3 = Math_max(r1Right, x1 + gap);
	                        if (pLocation2.right >= 2) {
	                           
	                            if (y2 < r1.bottom) { 
	                                y3 = r1Bottom;
	                                x4 = (r1.left + r2.right) / 2;
	                                arrayPush(points, { x: x3, y: y1 });
	                                arrayPush(points, { x: x3, y: y3 });
	                                arrayPush(points, { x: x4, y: y3 });
	                                arrayPush(points, { x: x4, y: y2 });
	                            } else {
	                                arrayPush(points, { x: x3, y: y1 });
	                                arrayPush(points, { x: x3, y: y2 });
	                            }
	
	                        } else if (pLocation2.left >= 2) {
	                           
	                            if (r2.top < r1.bottom && r2.top > r1.top) {
	                                y3 = Math_min(r1Top, r2Top);
	                            } else {
	                                y3 = (r1Bottom + r2Top) / 2;
	                            }
	
	                            x4 = x2 - gap;
	                            arrayPush(points, { x: x3, y: y1 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x4, y: y3 });
	                            arrayPush(points, { x: x4, y: y2 });
	                        } else if (pLocation2.bottom >= 2) {
	                            if (x1 < r2.right) {
	                               x3 = Math_max(r2Right, r1Right);
	                            }
	                            y3 = Math_max(r2Bottom, r1Bottom);
	                        } else {
	                            if ((r2.top < r1.bottom && x2 < r1Left) || (r2.top < r1.bottom && r1.top < r2.bottom && x2 < r1.right && x2 > r1.left)) {
	                                y3 = Math_min(r1Top, r2Top);
	                                arrayPush(points, { x: x1 + gap, y: y1 });
	                                arrayPush(points, { x: x1 + gap, y: y3 });
	                                arrayPush(points, { x: x2, y: y3 });
	                                arrayPush(points, { x: x2, y: y2 });
	                            }
	                            y3 = (r1Bottom + r2Top) / 2;
	                        }
	                        if (points.length === 1) {
	                            arrayPush(points, { x: x3, y: y1 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x2, y: y3 });
	                        }
	                    } else if (pLocation1.bottom >= 2) {
	                       
	                        y3 = (y1 + r2.top) / 2;
	                        if (pLocation2.right >= 2) {
	                            arrayPush(points, { x: x1, y: y2 });
	                        } else if (pLocation2.bottom >= 2) {
	                           
	                            y4 = y2 + gap;
	                            if (x1 < r2.right) {
	                               
	                                x3 = r2Right;
	                                arrayPush(points, { x: x1, y: y3 });
	                                arrayPush(points, { x: x3, y: y3 });
	                                arrayPush(points, { x: x3, y: y4 });
	                                arrayPush(points, { x: x2, y: y4 });
	                            } else {
	                                arrayPush(points, { x: x1, y: y4 });
	                                arrayPush(points, { x: x2, y: y4 });
	                            }
	                        } else if (pLocation2.left >= 2) {
	                            if (r1.top < y2) {
	                               
	                                y3 = Math_max(r1Bottom, r2Bottom);
	                            } else {
	                               
	                                x3 = x2 - gap;
	                            }
	                            if(r2.left < x1) {
	                                if (r2.top > r1.bottom) {
	                                    y3 = (r1.bottom + r2.top) / 2;
	                                }
	                                arrayPush(points, { x: x1, y: y3 });
	                                arrayPush(points, { x: x2 - gap, y: y3 });
	                                arrayPush(points, { x: x2 - gap, y: y2 });
	                            } else {
	                                arrayPush(points, { x: x1, y: y3 });
	                                arrayPush(points, { x: x3, y: y3 });
	                                arrayPush(points, { x: x3, y: y2 });
	                            }
	
	                        } else {
	                           
	                            arrayPush(points, { x: x1, y: y3 });
	                            arrayPush(points, { x: x2, y: y3 });
	                        }
	                    } else {
	                       
	                        if (pLocation2.right >= 2) {   
	                            x3 = (r1Left + r2Right) / 2;
	                            if (r2Right > r1Left) {
	                               
	                                y3 = Math.max(r2Top, (r2Top + r1Bottom) / 2);
	                                x3 = Math_min(r1Left, x1 - gap);
	                                x4 = x2 + gap;
	                                arrayPush(points, { x: x3, y: y1 });
	                                arrayPush(points, { x: x3, y: y3 });
	                                arrayPush(points, { x: x4, y: y3 });
	                                arrayPush(points, { x: x4, y: y2 });
	                            } else {
	                                arrayPush(points, { x: x3, y: y1 });
	                                arrayPush(points, { x: x3, y: y2 });
	                            }
	                        } else if (pLocation2.left >= 2) {
	                            x3 = Math_min(r1Left, r2Left, x2 - gap);
	                            if (r2.top < y1 && r1.left > r2.right) {
	                                x3 = (r1.left + r2.right) / 2;
	                                x4 = r2Left;
	                                arrayPush(points, { x: x3, y: y1 });
	                                arrayPush(points, { x: x3, y: r2Top });
	                                arrayPush(points, { x: x4, y: r2Top });
	                                arrayPush(points, { x: x4, y: y2 });
	                            } else {
	                                arrayPush(points, { x: x3, y: y1 });
	                                arrayPush(points, { x: x3, y: y2 });
	                            }
	
	                        } else if (pLocation2.bottom >= 2) {
	                            if (r2.right < r1.left) {
	                                x3 = (r1Left + r2Right) / 2;
	                            } else {
	                                x3 = Math_min(r1Left, r2Left);
	                            }
	                            y3 = Math.max(y2 + gap, r1.bottom);
	                            arrayPush(points, { x: x3, y: y1 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x2, y: y3 });
	                        }
	                       
	                    }
	                } else {   
	                    if (pLocation1.top >= 2) { 
	                       
	                        y3 = (y1 + y2) / 2;
	                        if (pLocation2.left >= 2) {
	                           
	                            x3 = x2 - gap;
	                            if (r2.bottom > y1) {
	                                y3 = r2Top;
	                            } else {
	                                y3 = (r2.bottom + y1) / 2;
	                            }
	                            arrayPush(points, { x: x1, y: y3 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x3, y: y2 });
	                        } else if (pLocation2.top >= 2) {
	                           
	                            y3 = Math_min(y2 - gap, r1Top);
	                            if (x1 < r2.right) {
	                                x3 = Math_min(r2Left, x1 - gap);
	                                y3 = (y1 + r2Bottom) / 2;
	                                arrayPush(points, { x: x1, y: y3 });
	                                arrayPush(points, { x: x3, y: y3 });
	                                arrayPush(points, { x: x3, y: y2 - gap });
	                                arrayPush(points, { x: x2, y: y2 - gap });
	                            }
	                        } else if (pLocation2.right >= 2) {
	                            arrayPush(points, { x: x1, y: y2 });
	                        }
	                        if (points.length === 1) {
	                            arrayPush(points, { x: x1, y: y3 });
	                            arrayPush(points, { x: x2, y: y3 });
	                        }
	                    } else if (pLocation1.right >= 2) {
	                       
	                        x3 = Math_max(r1Right, x1 + gap);
	                        if (pLocation2.right >= 2) {
	                            arrayPush(points, { x: x3, y: y1 });
	                            if ((r2Bottom > y1) && (r1.left > r2.right)) {
	                                x4 = (r1Left + r2Right) / 2;
	                                y3 = r1Bottom;
	                                arrayPush(points, { x: x3, y: y3 });
	                                arrayPush(points, { x: x4, y: y3 });
	                                arrayPush(points, { x: x4, y: y2 });
	                            } else {
	                               
	                                arrayPush(points, { x: x3, y: y2 });
	                            }
	                        } else if (pLocation2.left >= 2) {
	                           
	                            y3 = r2Top;
	                            x4 = x2 - gap;
	                            x3 = Math_max(r1Right, r2Right);
	                            arrayPush(points, { x: x3, y: y1 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x4, y: y3 });
	                            arrayPush(points, { x: x4, y: y2 });
	                        } else if (pLocation2.bottom >= 2) {
	                            if (r2.bottom < r1.top) {
	                                y3 = (r2Bottom + r1Top) / 2;
	                            } else {
	                                y3 = r1Bottom;
	                            }
	                            arrayPush(points, { x: x3, y: y1 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x2, y: y3 });
	                        } else {
	                            x3 = Math_max(r1Right, r2Right);
	                            y3 = Math_min(y2, r1.top) - gap;
	                            arrayPush(points, { x: x3, y: y1 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x2, y: y3 });
	                        }
	                    } else if (pLocation1.bottom >= 2) {
	                        if (pLocation2.right >= 2) {
	                            if (r2.right > r1.left) {
	                                x3 = r1Right;
	                            } else {
	                                x3 = (r1Left + r2Right) / 2;
	                            }
	                            y3 = r1Bottom;
	                            arrayPush(points, { x: x1, y: y3 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x3, y: y2 });
	                        } else if (pLocation2.bottom >= 2) {
	                           
	                            y3 = r1Bottom;
	                            if (x2 > r1.left) {
	                               
	                                x3 = r1Left;
	                                arrayPush(points, { x: x1, y: y3 });
	                                arrayPush(points, { x: x3, y: y3 });
	                                if (r2.bottom > r1.top) {
	                                   
	                                    arrayPush(points, { x: x3, y: y2 });
	                                } else {
	                                    y4 = (r2Bottom + r1Top) / 2;
	                                    arrayPush(points, { x: x3, y: y4 });
	                                    arrayPush(points, { x: x2, y: y4 });
	                                }
	                            } else {
	                                arrayPush(points, { x: x1, y: y3 });
	                                arrayPush(points, { x: x2, y: y3 });
	                            }
	                        } else if (pLocation2.left >= 2) {
	                            x3 = Math_min(r2Left, r1Left);
	                            y3 = Math_max(r1Bottom, r2Bottom);
	                            arrayPush(points, { x: x1, y: y3 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x3, y: y2 });
	                        } else {
	                           
	                            if (r1.left < r2.right) {
	                                x3 = Math_min(r1Left, r2Left);
	                            } else {
	                                x3 = (r1.left + r2.right) / 2;
	                            }
	                            arrayPush(points, { x: x1, y: y1 + gap });
	                            arrayPush(points, { x: x3, y: y1 + gap });
	                            arrayPush(points, { x: x3, y: y2 - gap });
	                            arrayPush(points, { x: x2, y: y2 - gap });
	                           
	                           
	                        }
	                    } else {
	                       
	                        if (pLocation2.right >= 2) {   
	                            x3 = (r1Left + r2Right) / 2;
	                            if (r2.right > r1.left) {
	                               
	                                y3 = Math.max(r2Top, (r2Top + r1Bottom) / 2);
	                                x3 = Math_min(r1Left, x1 - gap);
	                                x4 = x2 + gap;
	                                arrayPush(points, { x: x3, y: y1 });
	                                arrayPush(points, { x: x3, y: y3 });
	                                arrayPush(points, { x: x4, y: y3 });
	                                arrayPush(points, { x: x4, y: y2 });
	                            } else {
	                                arrayPush(points, { x: x3, y: y1 });
	                                arrayPush(points, { x: x3, y: y2 });
	                            }
	                        } else if (pLocation2.left >= 2) {
	                            x3 = Math_min(r1Left, r2Left, x2 - gap);
	
	                            if(r2.bottom > y1 && r2.right < r1.left) {
	                                x3 = (r2.right + r1.left) / 2;
	                                x4 = Math_min(r1Left, r2Left, x2 - gap);
	                                arrayPush(points, { x: x3, y: y1 });
	                                arrayPush(points, { x: x3, y: r1Bottom });
	                                arrayPush(points, { x: x4, y: r1Bottom });
	                                arrayPush(points, { x: x4, y: y2 });
	                            } else {
	                                arrayPush(points, { x: x3, y: y1 });
	                                arrayPush(points, { x: x3, y: y2 });
	                            }
	                        } else if (pLocation2.bottom >= 2) {
	                            if (r2.right < r1.left) {
	                                x3 = (r1Left + r2Right) / 2;
	                            } else {
	                                x3 = x2 - gap;
	                            }
	                            y3 = Math.max(y2 + gap, r1.bottom);
	                            if(x2 > r1.left) {
	                                arrayPush(points, { x: x3, y: y1 });
	                                arrayPush(points, { x: x3, y: y3 });
	                                arrayPush(points, { x: x2, y: y3 });
	                            } else {
	                                arrayPush(points, { x: x2, y: y1 });
	                            }
	
	                        } else {
	                            y3 = r1Top;
	                            x3 = r2Left;
	                            arrayPush(points, { x: x3, y: y1 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x2, y: y3 });
	                        }
	                    }
	                }
	            } else {   
	                if (y1 < y2) { 
	                    if (pLocation1.top >= 2) {
	                       
	                        y3 = r1Top;
	                        if (pLocation2.left >= 2) {
	                           
	                            if (r1.right < r2.left) {
	                                x3 = (r1Right + r2Left) / 2;
	                            } else {
	                                x3 = r1Left;
	                            }
	                            arrayPush(points, { x: x1, y: y3 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x3, y: y2 });
	                        } else if (pLocation2.top >= 2) {
	                            if (x2 < r1Right) {
	                               
	                                arrayPush(points, { x: x1, y: y3 });
	                                x3 = r1Right;
	                                arrayPush(points, { x: x3, y: y3 });
	                                y4 = (r1Bottom + r2Top) / 2;
	                                arrayPush(points, { x: x3, y: y4 });
	                                arrayPush(points, { x: x2, y: y4 });
	                            }
	                        } else if (pLocation2.right >= 2) {
	                            y3 = Math_min(r2Top, r1Top);
	                            x3 = Math_max(r1Right, x2 + gap);
	                            arrayPush(points, { x: x1, y: y3 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x3, y: y2 });
	                        } else {
	                           
	                            if (r2Left > r1Right) {
	                                x3 = (r1Right + r2Left) / 2;
	                            } else {
	                                x3 = r2Right;
	                            }
	                            y4 = y2 + gap;
	                            arrayPush(points, { x: x1, y: y3 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x3, y: y4 });
	                            arrayPush(points, { x: x2, y: y4 });
	                        }
	                        if (points.length === 1) {
	                            arrayPush(points, { x: x1, y: y3 });
	                            arrayPush(points, { x: x2, y: y3 });
	                        }
	                    } else if (pLocation1.right >= 2) {
	                       
	                        x3 = Math_max(r1Right, r2Right);
	                        if (pLocation2.right >= 2) {
	                           
	                            if ((r2.top < y1) && (r1.right < r2.left)) {
	                               
	                                x3 = (r1Right + r2Left) / 2;
	                                y3 = r2Bottom;
	                                x4 = r2Right;
	                                arrayPush(points, { x: x3, y: y1 });
	                                arrayPush(points, { x: x3, y: y3 });
	                                arrayPush(points, { x: x4, y: y3 });
	                                arrayPush(points, { x: x4, y: y2 });
	                            } else {
	                               
	                                arrayPush(points, { x: x3, y: y1 });
	                                arrayPush(points, { x: x3, y: y2 });
	                            }
	                        } else if (pLocation2.left >= 2) {
	                            x3 = (x1 + x2) / 2;
	                            arrayPush(points, { x: x3, y: y1 });
	                            arrayPush(points, { x: x3, y: y2 });
	                        } else if (pLocation2.bottom >= 2) {
	                            if (r1.right < r2.left) {
	                                x3 = (r1Right + r2Left) / 2;
	                            } else {
	                                x3 = r2Right;
	                            }
	                            y3 = r2Bottom;
	                            arrayPush(points, { x: x3, y: y1 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x2, y: y3 });
	                        } else {
	                            arrayPush(points, { x: x2, y: y1 });
	                        }
	                    } else if (pLocation1.bottom >= 2) {
	                       
	                        if (pLocation2.right >= 2) {
	                            if (r1.bottom < r2.top) {
	                                y3 = (r1Bottom + r2Top) / 2;
	                            } else {
	                                y3 = r2Bottom;
	                            }
	                            x3 = r2Right;
	                            arrayPush(points, { x: x1, y: y3 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x3, y: y2 });
	                        } else if (pLocation2.bottom >= 2) {
	                           
	                            y3 = r2Bottom;
	                            if (x1 > r2.left) {
	                                x3 = Math_min(r1Left, r2Left);
	                                if (r1.bottom < r2.top) {
	                                    y3 = (r1.bottom + r2.top) / 2;
	                                } else {
	                                    y3 = (r2.bottom + r1.top) / 2;
	                                }
	                                y4 = Math_max(r2Bottom, r1Bottom);
	                                arrayPush(points, { x: x1, y: y3 });
	                                arrayPush(points, { x: x3, y: y3 });
	                                arrayPush(points, { x: x3, y: y4 });
	                                arrayPush(points, { x: x2, y: y4 });
	                            } else {
	                                arrayPush(points, { x: x1, y: y3 });
	                                arrayPush(points, { x: x2, y: y3 });
	                            }
	
	                        } else if (pLocation2.left >= 2) {
	                            arrayPush(points, { x: x1, y: y2 });
	                        } else {
	                           
	                            y3 = (y1 + y2) / 2;
	                            arrayPush(points, { x: x1, y: y3 });
	                            arrayPush(points, { x: x2, y: y3 });
	                        }
	                    } else {
	                       
	                        x3 = r1Left;
	                        if (pLocation2.right >= 2) {   
	                            if (r1.bottom < r2.top) {
	                                y3 = (r1Bottom + r2Top) / 2;
	                            } else {
	                                y3 = r2Bottom;
	                            }
	                            x4 = r2Right;
	                            arrayPush(points, { x: x3, y: y1 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x4, y: y3 });
	                            arrayPush(points, { x: x4, y: y2 });
	                        } else if (pLocation2.left >= 2) {
	                            x4 = (r1.right + r2.left) / 2;
	                            if (r1.right < r2.left && y2 < r1.bottom) {
	                                arrayPush(points, { x: x3, y: y1 });
	                                arrayPush(points, { x: x3, y: r1Bottom });
	                                arrayPush(points, { x: x4, y: r1Bottom });
	                                arrayPush(points, { x: x4, y: y2 });
	                            } else {
	                                arrayPush(points, { x: x3, y: y1 });
	                                arrayPush(points, { x: x3, y: y2 });
	                            }
	
	                        } else if (pLocation2.bottom >= 2) {
	                            y3 = Math_max(r1Bottom, r2Bottom);
	                            x3 = Math_min(r1Left, r2Left);
	                            arrayPush(points, { x: x3, y: y1 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x2, y: y3 });
	                        } else {
	                           
	                            if (r1.bottom < r2.top) {
	                                y3 = (r1Bottom + r2Top) / 2;
	                            } else {
	                                y3 = r1Top;
	                            }
	                            arrayPush(points, { x: x3, y: y1 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x2, y: y3 });
	                        }
	                    }
	                } else {   
	                    if (pLocation1.top >= 2) { 
	                       
	                        if (pLocation2.left >= 2) {
	                            arrayPush(points, { x: x1, y: y2 });
	                        } else if (pLocation2.top >= 2) {
	                           
	                            y3 = r2Top;
	                            if (x1 > r2.left) {
	                                y3 = (r2Bottom + r1Top) / 2;
	                                arrayPush(points, { x: x1, y: y3 });
	                                arrayPush(points, { x: r1Left, y: y3 });
	                                arrayPush(points, { x: r1Left, y: y2 - gap});
	                                arrayPush(points, { x: x2, y: y2 - gap});
	                            }
	                        } else if (pLocation2.right >= 2) {
	                            if (r2.bottom < r1.top) {
	                                y3 = (r2Bottom + r1Top) / 2;
	                            } else {
	                                y3 = r2Top;
	                            }
	                            x3 = r2Right;
	                            arrayPush(points, { x: x1, y: y3 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x3, y: y2 });
	                        } else {
	                           
	                            y3 = (y1 + y2) / 2;
	                        }
	                        if (points.length === 1) {
	                            arrayPush(points, { x: x1, y: y3 });
	                            arrayPush(points, { x: x2, y: y3 });
	                        }
	                    } else if (pLocation1.right >= 2) {
	                       
	                        x3 = r2Right;
	                        if (pLocation2.right >= 2) {
	                            if ((r2Bottom > y1) && (r2.left > r1.right)) {
	                               
	                                x3 = (r2Left + r1Right) / 2;
	                                y3 = r2Top;
	                                x4 = r2Right;
	                                arrayPush(points, { x: x3, y: y1 });
	                                arrayPush(points, { x: x3, y: y3 });
	                                arrayPush(points, { x: x4, y: y3 });
	                                arrayPush(points, { x: x4, y: y2 });
	                            } else {
	                               
	                                arrayPush(points, { x: x3, y: y1 });
	                                arrayPush(points, { x: x3, y: y2 });
	                            }
	                        } else if (pLocation2.left >= 2) {
	                           
	                            x3 = (x1 + x2) / 2;
	                            arrayPush(points, { x: x3, y: y1 });
	                            arrayPush(points, { x: x3, y: y2 });
	                        } else if (pLocation2.bottom >= 2) {
	                            arrayPush(points, { x: x2, y: y1 });
	                        } else {
	                            y3 = Math_min(r1Top, r2Top);
	                            if (r2.left > r1.right) {
	                                x3 = (r2Left + r1Right) / 2;
	                            } else {
	                                x3 = r2Right;
	                            }
	                            arrayPush(points, { x: x3, y: y1 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x2, y: y3 });
	                        }
	                    } else if (pLocation1.bottom >= 2) {
	                        if (pLocation2.right >= 2) {
	                            y3 = Math_max(r1Bottom, r2Bottom);
	                            x3 = Math_max(r1Right, r2Right);
	                            arrayPush(points, { x: x1, y: y3 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x3, y: y2 });
	                        } else if (pLocation2.bottom >= 2) {
	                           
	                            y3 = r1Bottom;
	
	                            if (x1 > r2.left) {
	                                x3 = Math_min(r1Left, r2Left);
	                                if (r1.bottom < r2.top) {
	                                    y4 = (r1.bottom + r2.top) / 2;
	                                } else {
	                                    y4 = (r2.bottom + r1.top) / 2;
	                                }
	                                arrayPush(points, { x: x1, y: y3 });
	                                arrayPush(points, { x: x3, y: y3 });
	                                arrayPush(points, { x: x3, y: y4 });
	                                arrayPush(points, { x: x2, y: y4 });
	
	                            } else {
	                                arrayPush(points, { x: x1, y: y3 });
	                                arrayPush(points, { x: x2, y: y3 });
	                            }
	                        } else if (pLocation2.left >= 2) {
	                            if (r2.left > r1.right) {
	                                x3 = (r2Left + r1Right) / 2;
	                            } else {
	                                x3 = r1Left;
	                            }
	                            y3 = r1Bottom;
	                            arrayPush(points, { x: x1, y: y3 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x3, y: y2 });
	                        } else {
	                           
	                            if (r2.left > r1.right) {
	                                x3 = (r2Left + r1Right) / 2;
	                            } else {
	                                x3 = r2Right;
	                            }
	                            y3 = r1Bottom;
	                            y4 = r2Top;
	                            arrayPush(points, { x: x1, y: y3 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x3, y: y4 });
	                            arrayPush(points, { x: x2, y: y4 });
	                        }
	                    } else {
	                       
	                        if (pLocation2.right >= 2) {   
	                            x3 = r1Left;
	                            x4 = r2Right;
	                            if (r1.top > r2.bottom) {
	                                y3 = (r1.top + r2.bottom) / 2;
	                            } else {
	                                y3 = Math_min(r1Top, r2Top);
	                            }
	
	                            arrayPush(points, { x: x3, y: y1 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x4, y: y3 });
	                            arrayPush(points, { x: x4, y: y2 });
	                        } else if (pLocation2.left >= 2) {
	                            x3 = r1Left;
	                            if ((r2.left > r1.right) && (y2 > r1.top)) {
	                                x4 = (r1Right + r2Left) / 2;
	                                y3 = r1Top;
	                                arrayPush(points, { x: x3, y: y1 });
	                                arrayPush(points, { x: x3, y: y3 });
	                                arrayPush(points, { x: x4, y: y3 });
	                                arrayPush(points, { x: x4, y: y2 });
	                            } else {
	                                arrayPush(points, { x: x3, y: y1 });
	                                arrayPush(points, { x: x3, y: y2 });
	                            }
	                        } else if (pLocation2.bottom >= 2) {
	                            if (r2.bottom < r1.top) {
	                                x3 = r1Left;
	                                y3 = (y2 + r1.top) / 2;
	                            } else {
	                                x3 = Math_min(r1Left, r2Left);
	                                y3 = Math_max(r1Bottom, r2Bottom);
	                            }
	                            arrayPush(points, { x: x3, y: y1 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x2, y: y3 });
	                        } else {
	                            x3 = r1Left;
	                            y3 = r2Top;
	                            arrayPush(points, { x: x3, y: y1 });
	                            arrayPush(points, { x: x3, y: y3 });
	                            arrayPush(points, { x: x2, y: y3 });
	                        }
	                    }
	                }
	            }
	
	            if (points.length === 1) {
	                arrayPush(points, {x: x2, y: y1});
	            }
	            arrayPush(points, p2);
	
	
	
	           
	           
	           
	                line.setPoints(points);
	           
	        }
	    },
	    updateConnectionLinesLayout: function (shape, isMoveShape, linesNeedMove) {
	        var self = this;
	        var connectionLines = self.getConnectionLines(shape);
	        if (connectionLines) {
	            var points = shape.getActualConnectorPoints(), id = shape.id;
	            connectionLines.forEach(function (line) {
	                if (!line) {
	                    return;
	                }
	                var point;
	                var isMoveStartPoint = isMoveShape && line.startConnector && line.startConnector.index >= 0 && line.startConnector.id === id,
	                    isMoveEndPoint = isMoveShape && line.endConnector && line.endConnector.index >= 0 && line.endConnector.id === id;
	               
	                if (line instanceof Shapes.Line) {
	                    if(isMoveStartPoint) {
	                        point = points[line.startConnector.index];
	                        line.moveStartPoint(point.x, point.y);
	                    }
	                    if (isMoveEndPoint) {
	                        point = points[line.endConnector.index];
	                        line.moveEndPoint(point.x, point.y);
	                    }
	                    return;
	                }
	               
	                if(!isMoveShape || line.startConnector || line.endConnector) {
	                    if (isMoveShape) {
	                       
	                        var findShapeInCollectionById = Shapes.findShapeInCollectionById;
	                        var selectedShapes = self._selectedShapes, tempId, shouldMoveLine = !findShapeInCollectionById(selectedShapes, line.id);
	                        var connector = line.startConnector;
	                        if (connector) {
	                            tempId = connector.id;
	                             if (id !== tempId && !findShapeInCollectionById(selectedShapes, tempId)) {
	                                self.layoutConnectionLine(line);
	                                shouldMoveLine = false;
	                             }
	                        }
	                        connector = line.endConnector;
	                        if (connector) {
	                            tempId = connector.id;
	                            if (id !== tempId && !findShapeInCollectionById(selectedShapes, tempId)) {
	                                self.layoutConnectionLine(line);
	                                shouldMoveLine = false;
	                            }
	                        }
	                        if (shouldMoveLine && linesNeedMove && linesNeedMove.indexOf(line) === -1) {
	                            linesNeedMove.push(line);
	                        }
	                    } else {
	                        self.layoutConnectionLine(line);
	                    }
	                } else if(isMoveStartPoint) {
	                    point = points[line.startConnector.index];
	                    line.moveStartPoint(point.x, point.y);
	                } else if (isMoveEndPoint) {
	                    point = points[line.endConnector.index];
	                    line.moveEndPoint(point.x, point.y);
	                }
	            });
	        }
	
	       
	        if (shape.shapes) {
	            shape.shapes.forEach(function (s) { self.updateConnectionLinesLayout(s, isMoveShape, linesNeedMove); });
	        }
	    },
	    getConnectionLines: function (shape) {
	        var self = this;
	        if (shape._shapeType === 1 ) {
	            return [];
	        }
	        var connectionLines = shape.connectionLines;
	        if (connectionLines) {
	            return connectionLines.map(function (id) { return self.getShapeById(id); });
	        }
	        return [];
	    },
	    getContainerAt: function (x, y, movingShape) {
	        var self = this;
	        var shape = movingShape.parent;
	        if (shape && shape.isContainer && shape.left <= x && x < shape.left + shape.width && shape.top <= y && y < shape.top + shape.height) {
	            return shape;
	        }
	        for (var i = 0; i < self.shapes.length; i++) {
	            shape = self.shapes[i];
	            if (shape !== movingShape && shape.isContainer && shape.left <= x && x < shape.left + shape.width && shape.top <= y && y < shape.top + shape.height) {
	                return shape;
	            }
	        }
	        return keyword_null;
	    },
	    moveShapes: function (e, shapes) {
	        var self = this;
	        if (shapes && shapes.length > 0) {
	            var p = self.getPointer(e);
	            var deltX = p.x - self.activeX;
	            var deltY = p.y - self.activeY;
	            if (deltX || deltY) {
	                var linesNeedMove = [];
	                shapes.forEach(function (sp) {
	                    self.moveShape(sp, deltX, deltY, linesNeedMove);
	                });
	                if (linesNeedMove.length) {
	                    linesNeedMove.forEach(function (ln) {
	                        ln.move(ln.left + deltX, ln.top + deltY);
	                    });
	                }
	
	                self.activeX = p.x;
	                self.activeY = p.y;
	            }
	        }
	    },
	    moveShape: function (sp, deltX, deltY, linesNeedMove) {
	        var self = this;
	
	
	        var target;
	       
	        if (sp && (!sp._shapeWrapper || sp._shapeWrapper.allowMove())) {
	            sp.move(sp.left + deltX, sp.top + deltY);
	            sp.updateCenterData();
	
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	
	           
	            if (sp.endConnector && sp.type !== 'callout') {
	                target = self.getShapeById(sp.endConnector.id);
	                target && target.removeConnectionLine(sp.id);
	                sp.endConnector = keyword_null;
	            }
	            if (sp.startConnector) {
	                target = self.getShapeById(sp.startConnector.id);
	                target && target.removeConnectionLine(sp.id);
	                sp.startConnector = keyword_null;
	            }
	
	           
	            self.updateConnectionLinesLayout(sp, true , linesNeedMove);
	           
	        }
	
	    },
	    resizeShapes: function (e, shapes) {
	        var self = this;
	        var p = self.getPointer(e);
	        var t = self.hitTestResult;
	       
	        if (t.endPoint) {
	           
	            self.resizeShape(self.hitTestResult.shape, p, "");
	        } else if (t.sizeRect) {
	            var resizeType = t.sizeRect.type;
	            var activeElement = t.shape;
	            var delt = self.getDelta(p, activeElement, resizeType);
	            var deltX = delt.x;
	            var deltY = delt.y;
	            var standardWidth = activeElement.width, standardHeight = activeElement.height;
	            shapes.forEach(function (sp) {
	               
	                if (sp._shapeType !== 1 ) {
	                    self.resizeShape(sp, p, resizeType, standardWidth === 0 ? 0 : (deltX * sp.width / standardWidth), standardHeight === 0 ? 0 : (deltY * sp.height / standardHeight));
	                }
	            });
	        }
	
	    },
	    resizeShape: function (sp, p, resizeType, deltX, deltY) {
	        var self = this;
	        if (sp) {
	            var target;
	            var t = self.hitTestResult;
	            if (!sp._shapeWrapper || sp._shapeWrapper.allowResize()) {
	                if (t.endPoint) {
	                   
	                    moveEndPoint(sp, t.endPoint, p.x, p.y);
	
	                   
	                    if (t.endPoint === "end" && sp.endConnector) {
	                        target = self.getShapeById(sp.endConnector.id);
	                        target && target.removeConnectionLine(sp.id);
	                        sp.endConnector = keyword_null;
	                    }
	                    if (t.endPoint === "begin" && sp.startConnector) {
	                        target = self.getShapeById(sp.startConnector.id);
	                        target && target.removeConnectionLine(sp.id);
	                        sp.startConnector = keyword_null;
	                    }
	
	                    self.layoutConnectionLine(sp);
	
	                } else if (t.sizeRect) {
	                   
	                   
	                   
	                   
	                    if (resizeType === "bottomright") {
	                        resizeShape(sp, deltX, deltY, false, false);
	                    } else if (resizeType === "topleft") {
	                        resizeShape(sp, -deltX, -deltY, true, true);
	                    } else if (resizeType === "topcenter") {
	                        resizeHeight(sp, -deltY, true);
	                    } else if (resizeType === "bottomcenter") {
	                        resizeHeight(sp, deltY, false);
	                    } else if (resizeType === "middleleft") {
	                        resizeWidth(sp, -deltX, true);
	                    } else if (resizeType === "middleright") {
	                        resizeWidth(sp, deltX, false);
	                    } else if (resizeType === "topright") {
	                        resizeShape(sp, deltX, -deltY, true, false);
	                    } else if (resizeType === "bottomleft") {
	                        resizeShape(sp, -deltX, deltY, false, true);
	                    }
	
	                   
	                    self.updateConnectionLinesLayout(sp);
	                }
	                sp.updateCenterData();
	            }
	
	           
	            sp.resetPathOffset();
	
	           
	        }
	
	        self.activeX = p.x;
	        self.activeY = p.y;
	    },
	    rotateShapes: function (e) {
	        var self = this;
	        var angle = self.rotateShape(e);
	        var len = self._selectedShapes.length;
	        var tempShape;
	        if (self._selectedShapes && len > 1) {
	            for(var i = 0;i < len;i++) {
	                tempShape = self._selectedShapes[i];
	                if (tempShape._shapeType !== 1 ) {
	                    tempShape.setAngle(angle);
	                }
	
	            }
	        }
	    },
	    rotateShape: function (e) {
	        var self = this;
	
	        var p = self.getPointer(e);
	        var t = self.hitTestResult;
	        var sp = t.shape, deltaAngle;
	        if (sp) {
	            var width = getOptionValue(sp.width, sp);
	            var height = getOptionValue(sp.height, sp);
	
	            var center = sp.getCenterPoint(width, height), cx = center.x, cy = center.y;
	
	            var prevAngle = Math.atan2(self.activeY - cy, self.activeX - cx);
	            var angle = Math.atan2(p.y - cy, p.x - cx);
	            var a = sp.angle + 180 * (angle - prevAngle) / Math.PI;
	
	            if (a < 0) {
	                a = 360 + a;
	            }
	            deltaAngle = a;
	
	            sp.setAngle(a % 360);
	
	            self.updateConnectionLinesLayout(sp);
	
	           
	        }
	
	        self.activeX = p.x;
	        self.activeY = p.y;
	        return deltaAngle;
	    },
	    changeVariablePoint: function (e) {
	        var self = this;
	
	        var p = self.getPointer(e);
	
	        var t = self.hitTestResult;
	        var sp = t.shape;
	        if (sp && sp.changeVariablePoint) {
	           
	           
	           
	
	           
	            sp.changeVariablePoint(p, t);
	
	           
	            self.updateConnectionLinesLayout(sp);
	
	            self.paint();
	        }
	
	        self.activeX = p.x;
	        self.activeY = p.y;
	    },
	    setSelect: function (shape, select, needEvent) {
	        if (shape) {
	            var shapeWrapper = shape._shapeWrapper;
	            if (shapeWrapper) {
	                needEvent = needEvent && shapeWrapper.isSelected() !== select;
	               
	                shapeWrapper._isSelected = select;
	                if(needEvent) {
	                    shapeWrapper._fireEvents("isSelected");
	                    shapeWrapper._fireSelectedEvents();
	                }
	            }
	            shape.isSelected = select;
	
	        }
	    },
	    group: function (shapes) {
	        var self = this;
	
	        if (shapes && arrayHelper_getLength(shapes) > 1) {
	            var cp = new Shapes.CompoundShape(shapes, {});
	            cp.id = self.getUniqueShapeId();
	            self.addShape(cp);
	
	            shapes.forEach(function (shape) {
	
	                self.setSelect(shape, false);
	                shape.parent = cp;
	            });
	
	            return cp;
	        }
	
	        return keyword_null;
	    },
	    ungroup: function (compoundShape) {
	        if (compoundShape && compoundShape.isCompoundShape) {
	            var self = this;
	            compoundShape.shapes.forEach(function (shape) {
	               
	               
	                var p = rotatePoint({ x: shape.left - compoundShape.left, y: shape.top - compoundShape.top }, { x: 0, y: 0 }, toRadius(compoundShape.angle));
	
	                shape.left = compoundShape.left + p.x;
	                shape.top = compoundShape.top + p.y;
	                shape.angle += compoundShape.angle;
	                shape.resetPathOffset();
	                if (shape.isCompoundShape) {
	                    shape.layoutChildren();
	                }
	
	                shape.parent = keyword_null;
	                self.addShape(shape);
	            });
	
	           
	           
	           
	            compoundShape.shapes.splice(0, compoundShape.shapes.length);
	            self.removeShape(compoundShape);
	        }
	    },
	    getCursorFromHitTest: getCursorFromHitTest,
	    getMoveShapesChanges: function (shapes, lines) {
	        var moveShapesChanges = [];
	        shapes.forEach(function (s) {
	            if (s && s._shapeWrapper) {
	                var tempArr = getAllChangesForResize(s, lines);
	                tempArr.forEach(function (item) {
	                    moveShapesChanges.push(item);
	                });
	            }
	        });
	        return moveShapesChanges;
	    },
	    doMouseMove: function (e) {
	        var self = this;
	        var hitTest = self.hitTestResult;
	        if (hitTest) {
	            var p = self.getPointer(e);
	           
	            if (hitTest.type === "rotate") {
	                self.rotateShapes(e);
	            } else if (hitTest.sizeRect || hitTest.endPoint) {
	                if (hitTest.endPoint) {
	                   
	                   
	                    var ret = keyword_null;
	                    self.shapes.forEach(function (shape) {
	                        if (shape._shapeType !== 1) {  
	                            var t = shape.hitTest(p.x, p.y);
	                            if (t && t.shape && t.shape !== hitTest.shape) {
	                                ret = t;
	                                return false;
	                            }
	                        }
	                    });
	
	                    var oldTarget = self.connectTarget;
	                    self.connectTarget = keyword_null;
	                    if (ret) {
	                        var target = ret.shape2 || ret.shape;  
	                        self.connectTarget = target;
	                        target.showConnectors = true;
	                    }
	                    if (oldTarget && self.connectTarget !== oldTarget) {
	                        oldTarget.showConnectors = false;
	                    }
	                }
	                self.resizeShapes(e, self._selectedShapes);
	               
	            } else if (hitTest.variableRect) {
	                self.changeVariablePoint(e);
	            } else {
	               
	                if(!self._isDragCopy && e.ctrlKey && (self.activeX - p.x !== 0 || self.activeY - p.y !== 0)) {
	                   
	                    var dragCopyOriginalShape = [], selectedShapes = [], cloneShapes = [], lineShapes = [], start, end;
	                    if (self._selectedShapes && self._selectedShapes.length) {
	                        self._selectedShapes.forEach(function (sp) {
	                            var wrap = sp._shapeWrapper;
	                            if (wrap) {
	                                var clone = wrap._clone();
	                                self.setSelect(clone._shapeUI, true);
	                                self.setSelect(wrap._shapeUI, false);
	                                wrap._sheet.shapes._add(clone);
	                                if(sp === hitTest.shape) {
	                                    hitTest.shape = clone._shapeUI;
	                                }
	                                dragCopyOriginalShape.push(wrap);
	                                cloneShapes.push(clone);
	                                selectedShapes.push(clone._shapeUI);
	
	                                if (clone._shapeType === 4 ) {
	                                    start = clone.startConnector();
	                                    end = clone.endConnector();
	                                    if (start || end) {
	                                        lineShapes.push(clone);
	                                    }
	                                }
	                                if (clone._shapeType === 3 ) {
	                                    lineShapes = lineShapes.concat(Shapes.getLineShapeInGroup(clone));
	                                }
	                            }
	
	                        });
	                       
	                        var originalNameList = Shapes.getShapeNameList(dragCopyOriginalShape);
	                        var newNameList = Shapes.getShapeNameList(cloneShapes);
	                        if (lineShapes && lineShapes.length) {
	                            var nameIndex;
	                            lineShapes.forEach(function (lineShape) {
	                                start = lineShape.startConnector();
	                                end = lineShape.endConnector();
	                                if (start) {
	                                    nameIndex = _inArray(start.name, originalNameList);
	                                    if (nameIndex > -1) {
	                                        start = {
	                                            name: newNameList[nameIndex],
	                                            index: start.index
	                                        };
	                                    } else if(_inArray(start.name, newNameList) > -1) {
	                                        start = {
	                                            name: start.name,
	                                            index: start.index
	                                        };
	                                    } else {
	                                        start = null;
	                                    }
	                                    lineShape.startConnector(start);
	                                }
	
	                                if (end) {
	                                    nameIndex = _inArray(end.name, originalNameList);
	                                    if (nameIndex > -1) {
	                                        end = {
	                                            name: newNameList[nameIndex],
	                                            index: end.index
	                                        };
	                                    } else if(_inArray(end.name, newNameList) > -1) {
	                                        end = {
	                                            name: end.name,
	                                            index: end.index
	                                        };
	                                    } else {
	                                        end = null;
	                                    }
	                                    lineShape.endConnector(end);
	                                }
	
	                            });
	                        }
	
	                        self._isDragCopy = true;
	                        self._selectedShapes = selectedShapes;
	                        self._dragCopyOriginalShapes = dragCopyOriginalShape;
	                    }
	                }
	               
	               
	               
	               
	               
	               
	                if (self._canMoveShape) {
	                    self.moveShapes(e, self._selectedShapes);
	                }
	
	               
	            }
	
	            var hitShape = hitTest.shape, hitShapeWrapper = hitShape && hitShape._shapeWrapper;
	            var sheet = hitShapeWrapper && hitShapeWrapper._sheet;
	            if (sheet) {
	                sheet._paintShapes();
	            } else {
	                self.paint();
	            }
	        } else {
	           
	            var canvas = self.host;
	            var hitInfo = self.hitTest(e);
	            canvas.style.cursor = getCursorFromHitTest(hitInfo);
	        }
	    },
	    doMouseDown: function (e) {
	        var self = this;
	        var p = self.getPointer(e);
	
	        self.activeX = p.x;
	        self.activeY = p.y;
	
	        var t = self.hitTest(e);
	
	        var activeElement = t ? t.shape : keyword_null;
	        if (activeElement) {
	            var selectStatus = activeElement.isSelected;
	            activeElement._oldSelectStatus = selectStatus;
	            self._oldActiveX = self.activeX;
	            self._oldActiveY = self.activeY;
	            if (!selectStatus) {
	                if (e.shiftKey || e.ctrlKey) {
	                    self.setSelect(activeElement, true, true );
	                } else {
	                    self.shapes.forEach(function (shape) {
	                        if(shape !== activeElement) {
	                            self.setSelect(shape, false, true );
	                        }
	                    });
	                    self.setSelect(activeElement, true, true );
	                }
	                if (self.onShapeSelected) {
	                    self.onShapeSelected();
	                }
	            }
	
	        }
	        if (e.button !== 2) {
	            self.hitTestResult = t;
	        }
	        self._selectedShapes = self.shapes.filter(function (shape) {
	            return shape.isSelected;
	        });
	        if (activeElement) {
	            self._canMoveShape = true;
	        }
	
	        self.paint();
	    },
	    doMouseUp: function (e) {
	        var self = this;
	        var sheet, tempArr;
	        var t = self.hitTestResult, p;
	        if (t && t.shape) {
	            var sp = t.shape;
	            var lines = self.getConnectionLines(sp);
	            lines = removeDuplicated(lines);
	            var wrapper = sp._shapeWrapper, shapeName = wrapper && wrapper.name();
	            sheet = wrapper && wrapper._sheet;
	            var sheetName = sheet && sheet.name(), commandManager = sheet && sheet._commandManager();
	            if (t.type === "rotate") {
	                self.setSelect(sp, true);
	                var rotateShapesChanges = [];
	                self._selectedShapes.forEach(function (s) {
	                    if (s && s._shapeWrapper) {
	                        tempArr = getAllChangesForRotate(s, lines);
	                        tempArr.forEach(function (item) {
	                            rotateShapesChanges.push(item);
	                        });
	                    }
	                });
	                if (wrapper) {
	                    commandManager.execute({
	                        cmd: 'rotateShapes',
	                        sheetName: sheetName,
	                        changes: rotateShapesChanges
	                    });
	                }
	            } else if (t.variableRect && wrapper) {
	               
	                var changes = sp.getAdjustChanges(), values = {}, cmdName;
	                values[shapeName] = changes;
	                if (changes) {
	                    if (sp._shapeType === 1 ) {
	                        cmdName = "updateConnectShapePoints";
	                    } else {
	                        cmdName = "updateShapes";
	                    }
	                    commandManager.execute({
	                        cmd: cmdName,
	                        sheetName: sheetName,
	                        shapes: [shapeName],
	                        values: values
	                    });
	                }
	
	            } else if (t.sizeRect) {
	                if (wrapper && wrapper.allowResize()) {
	                    var resizeShapesChanges = [];
	                    self._selectedShapes.forEach(function (s) {
	                        if (s && s._shapeWrapper) {
	                            tempArr = getAllChangesForResize(s, lines);
	                            tempArr.forEach(function (item) {
	                                resizeShapesChanges.push(item);
	                            });
	                        }
	                    });
	                    commandManager.execute({
	                        cmd: 'resizeShapes',
	                        sheetName: sheetName,
	                        changes: resizeShapesChanges
	                    });
	                }
	            } else if (!t.sizeRect && !t.endPoint && !t.variableRect && !(self._oldActiveX === self.activeX && self._oldActiveY === self.activeY)) {
	                if (wrapper && wrapper.allowMove() && !self._isDragCopy) {
	                    var moveShapesChanges = self.getMoveShapesChanges(self._selectedShapes, lines);
	                    commandManager.execute({
	                        cmd: 'moveShapes',
	                        sheetName: sheetName,
	                        changes: moveShapesChanges
	                    });
	                } else if(wrapper && wrapper.allowMove() && self._isDragCopy) {
	                    var dragCopyChanges = [];
	                    self._selectedShapes.forEach(function (s, oldShapeIndex) {
	                        if (s && s._shapeWrapper) {
	                            tempArr = getAllChangesForResize(s, lines);
	                            tempArr.forEach(function (item) {
	                                dragCopyChanges.push({
	                                    oldShapeName: self._dragCopyOriginalShapes[oldShapeIndex].name(),
	                                    name: item.name,
	                                    offsetX: item.offsetX,
	                                    offsetY: item.offsetY
	                                });
	                            });
	                        }
	                    });
	                    commandManager.execute({
	                        cmd: 'dragCopyShapes',
	                        sheetName: sheetName,
	                        changes: dragCopyChanges
	                    });
	                    self._isDragCopy = false;
	                    delete self._dragCopyOriginalShapes;
	                }
	            } else if (t.type === "move" && t.endPoint) {
	               
	               
	
	                for (var i = 0; i < self.shapes.length; i++) {
	                    var shape = self.shapes[i];
	                    if (shape === t.shape) {
	                        continue;
	                    }
	                    p = self.getPointer(e);
	                    var ht = shape.hitTest(p.x, p.y);
	                    if (ht && ht.shape === shape && ht.type === "connectPoint") {
	                       
	                        var line = t.shape;
	                        var targetShape = ht.shape2 || shape, id = targetShape.id, index = ht.index;
	
	                        if (t.endPoint === "end") {
	                            line.endConnector = { id: id, index: index };
	                        } else {
	                            line.startConnector = { id: id, index: index };
	                        }
	                        targetShape.addConnectionLine(line.id);
	                        self.layoutConnectionLine(line);
	                       
	                        break;
	                    }
	
	                }
	                if (wrapper && wrapper.allowResize()) {
	                    commandManager.execute({
	                        cmd: 'resizeShapes',
	                        sheetName: sheetName,
	                        changes: getAllChangesForResize(sp, lines)
	                    });
	                }
	            } else {
	               
	                if ((e.shiftKey || e.ctrlKey) && t.shape._oldSelectStatus) {
	                    self.setSelect(t.shape, false, true );
	                }
	               
	                p = self.getPointer(e);
	                var container = self.getContainerAt(p.x, p.y, sp);
	                if (sp !== container && container !== sp.parent) {
	                    if (sp.parent) {
	                        sp.parent.removeShape(sp, true);
	                    }
	                    if (container) {
	                        container.addShape(sp, p);
	                        container.resetPathOffset();
	                        sp.parent.recalcChildren();
	                    } else {
	                        self.addShape(sp);
	                    }
	                } else if (sp.parent && sp.parent.isContainer) {
	                    sp.parent.childMoved(sp, p);
	                    sp.parent.recalcChildren();
	                }
	            }
	        }
	
	        if (self.connectTarget) {
	            self.connectTarget.showConnectors = false;
	        }
	
	        self.hitTestResult = keyword_null;
	        delete self._selectedShapes;
	
	       
	       
	       
	       
	       
	       
	        self._canMoveShape = false;
	        if (sheet) {
	            sheet._paintShapes();
	        } else {
	            self.paint();
	        }
	    },
	    doMouseOut: function (e) {
	        this.doMouseUp(e);
	        this.hitTestResult = keyword_null;
	
	    }
	};
	
	function removeDuplicated(array) {
	    return array.filter(function(item, pos, self) {
	        return self.indexOf(item) === pos;
	    });
	}
	function getConnectorOption(sp, connector) {
	    if (connector && sp.service) {
	        var name = sp.service.getShapeById(connector.id)._shapeWrapper.name();
	        return {
	            name: name,
	            index: connector.index
	        };
	    }
	    return keyword_null;
	}
	function getChangeForResize(sp, includeConnectors) {
	    var wrapper = sp._shapeWrapper, zoomFactor = wrapper._sheet.zoom();
	    var change = {
	        name: wrapper.name(),
	        offsetX: sp.left / zoomFactor - wrapper.x(),
	        offsetY: sp.top / zoomFactor - wrapper.y(),
	        offsetWidth: sp.width / zoomFactor - wrapper.width(),
	        offsetHeight: sp.height / zoomFactor - wrapper.height()
	    };
	    var shapeType = sp._shapeType;
	    if (shapeType === 1 ) {
	        change.points = sp.getPoints().map(function (t) {
	            return {
	                x: t.x / zoomFactor,
	                y: t.y / zoomFactor
	            };
	        });
	
	        if (includeConnectors) {
	            change.startConnector = getConnectorOption(sp, sp.startConnector);
	            change.endConnector = getConnectorOption(sp, sp.endConnector);
	        }
	    } else if (shapeType === 2 ) {
	        var childrenChanges = [];
	        sp.shapes.forEach(function (childShape) {
	            if (childShape._shapeType === 1 ) {
	                childrenChanges.push({
	                    name: childShape._shapeWrapper.name(),
	                    points: childShape.getPoints().map(function (pt) {
	                        return {
	                            x: pt.x / zoomFactor,
	                            y: pt.y / zoomFactor
	                        };
	                    })
	                });
	            }
	        });
	        change.childrenChanges = childrenChanges;
	    }
	    return change;
	}
	function getAllChangesForResize(sp, lines) {
	    var changes = [];
	    var currentChange = getChangeForResize(sp, true );
	    if (currentChange.offsetX !== 0 || currentChange.offsetY !== 0 || currentChange.offsetWidth !== 0 || currentChange.offsetHeight !== 0 || currentChange.startConnector || currentChange.endConnector) {
	        if (lines) {
	            currentChange.lineChanges = lines.map(function(line) {
	                return getChangeForResize(line);
	            });
	        }
	        changes.push(currentChange);
	    }
	    return changes;
	}
	function getChangeForRotate(sp) {
	    var wrapper = sp._shapeWrapper, zoomFactor = wrapper._sheet.zoom();
	    var change = {
	        name: wrapper.name(),
	       
	       
	       
	       
	        rotate: sp.angle
	    };
	    if (sp._shapeType === 1 ) {
	        change.points = sp.getPoints().map(function (pt) {
	            return {
	                x: pt.x / zoomFactor,
	                y: pt.y / zoomFactor
	            };
	        });
	    }
	    return change;
	}
	function getAllChangesForRotate(sp, lines) {
	    var changes = [];
	    changes.push(getChangeForRotate(sp));
	    if (lines) {
	        lines.forEach(function(line) {
	            changes.push(getChangeForRotate(line));
	        });
	    }
	    return changes;
	}
	Shapes.createLine = function (type, model, service) {
	    var line = keyword_null;
	    if (type === "ZipLine") {
	        line = new Shapes.ZipLine(model, service);
	    } else if (type === "Line") {
	        line = new Shapes.Line(model, service);
	        var points = model && model.points;
	        line.setPoints(points);
	    }
	    return line;
	};
	
	Shapes.Canvas = Canvas;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var CalcEngine = __webpack_require__(13);
	    var Shapes = __webpack_require__(3);
	    var Math_sin = Math.sin, Math_cos = Math.cos, Math_atan2 = Math.atan2;
	
	    function setValueToObject(node, path, value) {
	        var t = path.split('.');
	        var n = node;
	        for (var i = 0, len = t.length; i < len - 1; i++) {
	            var k = t[i];
	            if (!n[k]) {
	                n[k] = {};
	            }
	            n = n[k];
	        }
	        n[t[len - 1]] = value;
	    }
	
	    function resolveName(context, name) {
	        var n = name.indexOf('#'), id;
	        if (n > 0) {
	            id = name.substring(0, n);
	            name = name.substring(n + 1);
	        } else {
	            id = context.id || context.calcSource.getCurrentObjectId();
	        }
	
	        name = name.replace(/V\./g, 'variables.');
	        return {
	            id: id, name: name
	        };
	    }
	
	   
	   
	
	    function BOUND(v, type, ignore, min, max) {
	        if (ignore) {
	            return v;
	        }
	
	        if (type === 2) {
	            return v;
	        } else if (type === 1) {
	            min += 1;
	            max -= 1;
	        }
	
	        return Math.max(min, Math.min(v, max));
	    }
	
	   
	   
	
	    function LISTORDER(ctx) {
	        var calcSource = ctx.calcSource;
	        var parentId = calcSource.getValue(ctx.id, 'parentId');
	        var parent = calcSource.getShapeById(parentId);
	        var shapes = parent && parent.shapes;
	        if (shapes) {
	            for (var i = 0, len = shapes.length; i < len; i++) {
	                if (shapes[i].id === ctx.id) {
	                    return i + 1;
	                }
	            }
	        }
	        return -1;
	    }
	
	   
	   
	    var ExcelDegreeToRadians = 60000 * 180 / Math.PI;
	    function CONVERTANGLE(radiusX, radiusY, angle) {
	        var radians = angle / ExcelDegreeToRadians;
	        return Math_atan2(radiusX * Math_sin(radians), radiusY * Math_cos(radians));
	    }
	
	   
	   
	
	    function GETCENTER(radius, coordinate, radians, isX) {
	        var fn = isX ? Math_cos : Math_sin;
	        return coordinate - radius * fn(radians);
	    }
	
	   
	   
	
	    function GETPOINT(coordinate, radius, radians, isX) {
	        var fn = isX ? Math_cos : Math_sin;
	        return coordinate + radius * fn(radians);
	    }
	
	    var PropertyContext = (function () {
	        function PropertyContext(calcSource, id) {
	            var self = this;
	            self.id = id;
	            self.calcSource = calcSource;
	        }
	
	        PropertyContext.prototype = {
	            setSource: function (source) {
	                this.calcSource = source;
	            },
	            getExternalSource: function (bookName, sheetName) {
	                return this.calcSource.getService().getExternalSource(bookName, sheetName);
	            },
	            getResolvers: function () {
	                return this.calcSource.getService().getResolvers();
	            },
	            getName: function (name) {
	                var self = this;
	                var t = resolveName(self, name);
	                if (t.id && t.name) {
	                    return {
	                        type: 2,
	                        value: self.calcSource.getValue(t.id, t.name)
	                    };
	                }
	
	                return { type: 5, value: "reference error" };
	            },
	            getFunction: function (name) {
	                if(!name) {
	                    return;
	                }
	                var fn = new CalcEngine.Functions.Function();
	                switch (name) {
	                    case 'BOUND':
	                        fn.evaluate = BOUND;
	                        break;
	                    case 'LISTORDER':
	                        fn.evaluate = LISTORDER;
	                        fn.isContextSensitive = function () {
	                            return true;
	                        };
	                        break;
	                    case 'A':
	                        fn.evaluate = CONVERTANGLE;
	                        break;
	                    case 'C':
	                        fn.evaluate = GETCENTER;
	                        break;
	                    case 'P':
	                        fn.evaluate = GETPOINT;
	                        break;
	                    default:
	                        fn = void 0; 
	                        break;
	                }
	                if (fn) {
	                   
	                    fn.minArgs = fn.maxArgs = fn.length;
	                }
	                return fn;
	            },
	
	            getExternalSourceToken: function (source) {
	                return source.getName();
	            },
	           
	            _isExpandArrayToMultiCall: function () {
	                return false;
	            },
	            _beginExpandArrayToMultiCall: function () {
	
	            },
	            _endExpandArrayToMultiCall: function () {
	
	            },
	           
	           
	            _getActualSource: function (source) {
	                return source === CalcEngine.BangSource ? this.calcSource : source;
	            },
	            getReference: function (source, identity) {
	                if (!source) {
	                    return CalcEngine.Errors.Reference;
	                }
	                return this._getActualSource(source).getReference(identity);
	            }
	           
	        };
	
	        return PropertyContext;
	    })();
	
	    Shapes.PropertyContext = PropertyContext;
	
	    function PathInfo(name, expr, source) {
	        this._name = name;
	        this._expr = expr;
	        this.source = source;
	    }
	
	    PathInfo.prototype = {
	        getName: function () {
	            return this._name;
	        },
	        getExpression: function () {
	            return this._expr;
	        }
	    };
	
	    var PropertySource = (function () {
	
	        function resolveDepends(expression, context) {
	            var bits = {};
	            var depExprList = resolveExpressions_(expression, null, true, bits, context);
	            if (depExprList.length === 0) {
	                return null;
	            }
	
	            return depExprList;
	        }
	
	        function referenceExpr(expr) {
	            return expr.type === 1 || expr.type === 8;
	        }
	
	        function binaryExpr(expr) {
	            return expr.type === 9;
	        }
	
	        function fnExpr(expr) {
	            return expr.type === 7;
	        }
	
	        function resolveExpressions_(expr, parentExpr, onlyDep, bits, context) {
	            var result = [];
	           
	            while (expr.type === 12 ) {
	                expr = expr.value;
	            }
	            while (expr.type === 10 ) {
	                expr = expr.value;
	            }
	            while (expr.type === 12 ) {
	                expr = expr.value;
	            }
	            if (referenceExpr(expr)) {
	                var sourceID = null;
	                if (expr.source) {
	                    sourceID = { id: expr.source.getName() };
	                }
	
	                var k = '';
	                if (expr.source && expr.source.getIdentity) {
	                    k = expr.source.getIdentity(expr.source, expr);
	                } else {
	                    var t = resolveName(sourceID || context, expr.value);
	                    k = t.id + '#' + t.name;
	                }
	
	                if (!bits[k]) {
	                    bits[k] = true;
	                    result.push({ expr: expr });
	                }
	            } else if (binaryExpr(expr)) {
	                if (!onlyDep) {
	                    result.push(expr);
	                }
	                result = result.concat(resolveExpressions_(expr.value, expr, onlyDep, bits, context));
	                if (expr.value2) {
	                    result = result.concat(resolveExpressions_(expr.value2, expr, onlyDep, bits, context));
	                }
	            } else if (fnExpr(expr)) {
	                if (!onlyDep) {
	                    result.push(expr);
	                }
	                var args = expr.arguments;
	                if (args && args.length > 0) {
	                    args.forEach(function (argExpr) {
	                        result = result.concat(resolveExpressions_(argExpr, expr, onlyDep, bits, context));
	                    });
	                }
	            }
	            return result;
	        }
	
	        function PropertySource(model) {
	            var self = this;
	            self.model = model;
	            self.parser_ = new CalcEngine.Parser();
	            self.context_ = new PropertyContext(model);
	            self.service = new CalcEngine.CalcService();
	            self.evaluator_ = new CalcEngine.Evaluator(self.service);
	            self.store_ = {};
	        }
	
	        PropertySource.prototype = {
	            getSource: function () {
	                return this.model;
	            },
	            getName: function () {
	                return this.model.name;
	            },
	            getCalcSourceModel: function () {
	                return this.sourceModel;
	            },
	            setCalcSourceModel: function (sourceModel) {
	                this.sourceModel = sourceModel;
	            },
	            getCalcService: function () {
	                return this.service;
	            },
	            setCalcService: function (service) {
	                this.service = service;
	            },
	            startCalculation: function () {
	            },
	            endCalculation: function () {
	            },
	            addDirtyNodesForCalc: function (dirtyAll, isAyncEvaluate) {
	                if (dirtyAll !== false) {
	                    this.dirtyAll();
	                }
	            },
	            _dealWithExpression: function(id, name, isAdd) {
	                var self = this;
	                var calcObj = self.getCalcObj(id, name, false);
	                var expression = calcObj && calcObj.expression;
	                if (!expression) {
	                    return;
	                }
	
	                var context = self.getContext(id);
	                var depends = resolveDepends(expression, context);
	
	                if (depends) {
	                    for (var i = 0, len = depends.length; i < len; i++) {
	                        var depCalcObj;
	                        var expr = depends[i].expr;
	                        var source = expr.source;
	                        if (source && source.getCalcSourceModel) {
	                            depCalcObj = source.getCalcSourceModel().getCalcObj(expr, true);
	                        } else {
	                            var sourceID = source ? { id: source.getName() } : null;
	                            var n = resolveName(sourceID || context, expr.value);
	                            depCalcObj = self.getCalcObjFromNode(n, true);
	                        }
	
	                        if (depCalcObj) {
	                            var depCalcObjs = [].concat(depCalcObj);  
	                            depCalcObjs.forEach(function(depCalc) { 
	                                depCalc._processListener('pathListeners', calcObj, isAdd);
	                            });
	                        }
	                    }
	                }
	            },
	            getParser: function () {
	                return this.parser_;
	            },
	            getEvaluator: function () {
	                return this.evaluator_;
	            },
	            getCurrentObjectId: function () {
	                return this.objectId_;
	            },
	            setCurrentObjectId: function (id) {
	                this.objectId_ = id;
	            },
	            getContext: function (id) {
	                var self = this;
	                if (id && id.length > 0) {
	                    return new PropertyContext(self.model, id);
	                }
	                return self.context_;
	            },
	            getEvaluatorContext: function () {
	                var self = this;
	                var name = self.getName();
	                return self.getContext(name);
	            },
	            getCustomName: function (path) {
	                var self = this;
	                var n = path.indexOf('#'), id;
	                if (n > 0) {
	                    id = path.substring(0, n);
	                    if (self.store_[id]) {
	                        return new PathInfo(path, { type: 8, name: path, source: self, value: path }, self);
	                    }
	                }
	            },
	            getKey: function (id, path) {
	                return id + "#" + path;
	            },
	            getNode: function (id, path, create) {
	                var self = this;
	                var pn = self.store_[id];
	                if (!pn && create) {
	                    pn = self.store_[id] = {};
	                }
	
	                var node = pn && pn[path];
	                if (!node && create) {
	                    node = pn[path] = {};
	                }
	                return node;
	            },
	            getNodeValue: function (id, path) {
	                var n = this.getNode(id, path);
	                return n && n.value;
	            },
	            setNodeValue: function (id, path, value, isFormula) {
	                var self = this;
	                var n = self.getNode(id, path, true);
	                var old = n.value;
	                n.value = value;
	                if (self.changed) {
	                    self.changed(id, path, value, old, isFormula);
	                }
	            },
	           
	           
	           
	           
	           
	           
	            getCalcObj: function (id, path, create) {
	                var self = this;
	                var n = self.getNode(id, path, create);
	                var calc = n && n.calc;
	                if (!calc && create) {
	                    calc = n.calc = new CalcEngine.PathCalc(self, id, path);
	                }
	                return calc;
	            },
	            getCalcObjFromNode: function (calcNode, create) {
	                var id = calcNode.id, path = calcNode.name;
	                return this.getCalcObj(id, path, create);
	            },
	            removeObject: function (id) {
	                var self = this;
	                var pn = self.store_[id], k;
	                for (k in pn) {
	                    if (pn.hasOwnProperty(k)) {
	                        self.removeFormula(id, k);
	                    }
	                }
	                for (k in pn) {
	                    if (pn.hasOwnProperty(k)) {
	                        delete pn[k];
	                    }
	                }
	                delete self.store_[id];
	            },
	            clearValues: function (id, path) {
	                var self = this, k;
	                var pn = self.store_[id];
	                for (k in pn) {
	                    if (pn.hasOwnProperty(k) && k.indexOf(path) === 0 && (k.length === path.length || k[path.length] === '.')) {
	                        self.removeFormula(id, k);
	                       
	                    }
	                }
	                for (k in pn) {
	                    if (pn.hasOwnProperty(k) && k.indexOf(path) === 0 && (k.length === path.length || k[path.length] === '.')) {
	                        delete pn[k];
	                    }
	                }
	            },
	            clear: function () {
	                this.store_ = {};
	            },
	            findListeners: function (calc, listeners) {
	                if (!calc) {
	                    return listeners;
	                }
	                var listenerTypes = calc._listeners;
	                for (var i = 0, len = listenerTypes.length; i < len; i++) {
	                    var listener = calc[listenerTypes[i]];
	                    if (listener) {
	                        for (var key in listener) {
	                            if (listener.hasOwnProperty(key)) {
	                                var l = listener[key];
	                                if (!listeners[key]) {
	                                    listeners[key] = l;
	                                    this.findListeners(l, listeners);
	                                }
	                            }
	                        }
	                    }
	                }
	            },
	            suspendCalc: function () {
	                this.calcSuspended = true;
	            },
	            resumeCalc: function () {
	                this.calcSuspended = false;
	                this.calculateAll();
	            },
	            calculateAll: function () {
	                var self = this;
	                if (self.calcSuspended) {
	                    return;
	                }
	                var store = self.store_;
	                for (var id in store) {
	                    if (store.hasOwnProperty(id)) {
	                        var pn = store[id];
	                        for (var t in pn) {
	                            if (pn.hasOwnProperty(t)) {
	                                var calc = pn[t].calc;
	                                if (calc && calc.dirty) {
	                                    self.calculate(calc.id, calc.name);
	                                }
	                            }
	                        }
	                    }
	                }
	            },
	            recalculateNode: function(node) {
	                var self = this;
	                var calcObj = self.getCalcObj(node.id, node.name);
	                var expression = calcObj.expression;
	                if (calcObj && expression) {
	                    var context = self.getContext(calcObj.id);
	                    var result = self.evaluator_.evaluateExpression(expression, context);
	                    self.setNodeValue(calcObj.id, calcObj.name, result, true );
	                }
	            },
	            addListenersToDirty: function (calcService, type) {
	                for (var path = calcService._heads[type]; path; path = path._nextDirty) {
	                    path._addListenersToDirty();
	                }
	            },
	            initDelay: function (calcService, type) {
	                for (var path = calcService._heads[type]; path; path = path._nextDirty) {
	                    path.delay = 0;
	                }
	            },
	            adjustDelayOfListeners: function (calcService, type, isIncrement) {
	                for (var path = calcService._heads[type]; path; path = path._nextDirty) {
	                    path._adjustDelayOfListeners(isIncrement);
	                }
	            },
	            calculateDirtyNodes: function (calcService, type) {
	                var progress = true;
	                for (var path = calcService._heads[type]; path; path = path._nextDirty) {
	                    if (path.delay === 0) {
	                        var source = path._sourceModel;
	                        source.recalculateNode(path);
	                        calcService._removeDirty(path, type );
	                        path._adjustDelayOfListeners(false);
	                        progress = true;
	                    }
	                }
	                return progress;
	            },
	            calculateIterations: function (calcService, type) {
	               
	            },
	            clearValueCache: function() {
	               
	            },
	            calculate: function (id, name) {
	                var self = this;
	                if (self.calcSuspended) {
	                    return;
	                }
	                var calcObj = self.getCalcObj(id, name);
	                if (calcObj) {
	                    calcObj._addToDirty();
	                    self.service.recalculateAll(false);
	                }
	            },
	            setValueOrFormula: function (id, path, value) {
	                var model = this;
	                if (value && value[0] === '=') {
	                    model.setFormula(id, path, value.substring(1));
	                } else {
	                    model.setValue(id, path, value);
	                }
	            },
	            setObject: function (id, path, options) {
	                if (!options) {
	                    return;
	                }
	                var model = this, p;
	                model.setCurrentObjectId(id);
	                var pathLength = path.length;
	                for (var k in options) {
	                    if (options.hasOwnProperty(k)) {
	                        var v = options[k];
	                        if (typeof v !== "object") {
	                            p = pathLength > 0 ? path + k : k;
	                            model.setValueOrFormula(id, p, v);
	                        } else if (v instanceof CalcEngine.Expression) {
	                            p = pathLength > 0 ? path + k : k;
	                            model.setExpression(id, p, v);
	                        } else {
	                            p = pathLength > 0 ? path + k + '.' : k + '.';
	                            model.setObject(id, p, v);
	                        }
	                    }
	                }
	                if (Array.isArray(options)) {
	                    model.setValue(id, path + 'isArray', true);
	                }
	            },
	            getExpressions: function (id, path) {
	                var self = this;
	                self.setCurrentObjectId(id);
	                var t = {};
	                var pn = self.store_[id];
	                if (pn) {
	                    t.id = id;
	                    for (var k in pn) {
	                        if (pn.hasOwnProperty(k) && (!path || k.indexOf(path) >= 0)) {
	                            self.ensureObjects(id, t, k);
	                            var v = self.getExpression(id, k);
	                            if (!v) {
	                                v = self.getValue(id, k);
	                            }
	                            if (v !== undefined) {
	                                setValueToObject(t, k, v);
	                            }
	                        }
	                    }
	                }
	                return t;
	            },
	            ensureObjects: function (id, node, path) {
	                var n = node;
	                var ps = path.split('.');
	                var p = '';
	                for (var i = 0; i < ps.length - 1; i++) {
	                    var key = ps[i];
	                    p += key;
	                    if (!n[key]) {
	                        var isArray = this.getValue(id, p + '.isArray');
	                        if (isArray) {
	                            n[key] = [];
	                        } else {
	                            n[key] = {};
	                        }
	                    }
	                    p += '.';
	                    n = n[key];
	                }
	            },
	            getValuesForObject: function (id, path, formula) {
	                var self = this;
	                self.setCurrentObjectId(id);
	                var t = {};
	                var pn = self.store_[id];
	                if (pn) {
	                    t.id = id;
	                    for (var k in pn) {
	                        if (pn.hasOwnProperty(k) && (!path || k.indexOf(path) >= 0)) {
	                            self.ensureObjects(id, t, k);
	                            var v = formula ? self.getFormula(id, k) : null;
	                            if (!v) {
	                                v = self.getValue(id, k);
	                            }
	                            if (v !== undefined) {
	                                setValueToObject(t, k, v);
	                            }
	                        }
	                    }
	                }
	
	                return t;
	            },
	            getValue: function (id, path) {
	                return this.getNodeValue(id, path);
	            },
	            setValue: function (id, path, value) {
	                var self = this;
	                var node = self.getNode(id, path);
	                var old, calc;
	                if (node) {
	                    old = node.value;
	                    calc = node.calc;
	                }
	               
	                if ((calc && calc.formula) || old !== value) {
	                    self.setCurrentObjectId(id);
	                    self.removeFormula(id, path);
	                    self.setNodeValue(id, path, value);
	                    self.dirty(id, path);
	                    self.calculate(id, path);
	                }
	            },
	            getExpression: function (id, path) {
	                var f = this.getCalcObj(id, path);
	                return f && f.expression;
	            },
	            getFormula: function (id, path) {
	                var f = this.getCalcObj(id, path);
	                if (f && f.formula) {
	                    return '=' + f.formula;
	                }
	            },
	            setFormula: function (id, path, formula, forceRecalc) {
	                var self = this;
	                var old = self.getFormula(id, path);
	                var t = formula;
	                if (t && t[0] !== '=') {
	                    t = '=' + t;
	                }
	                if (old === t) {
	                   
	                    if (forceRecalc) {
	                        self.dirty(id, path);
	                        self.calculate(id, path);
	                    }
	                    return;
	                }
	
	                self.removeFormula(id, path);
	
	                if (formula && formula.length > 0) {
	                    if (formula[0] === '=') {
	                        formula = formula.substring(1);
	                    }
	
	                    self.setCurrentObjectId(id);
	
	                    var context = self.getContext(id);
	                    var expression = self.parser_.parse(context, formula);
	                    if (expression) {
	                        self.setExpression(id, path, expression);
	                    }
	
	                   
	                   
	                }
	            },
	            removeFormula: function (id, name) {
	                var self = this;
	                var n = self.getNode(id, name);
	                var calc = n && n.calc;
	                if (calc) {
	                    calc._stopListening();
	                    delete calc.expression;
	                    delete calc.formula;
	                }
	            },
	            setExpression: function (id, name, expression) {
	                var self = this;
	                var calcObj;
	                if (self._onBackupFormula) {
	                    calcObj = self.getCalcObj(id, name);
	                    self._onBackupFormula({ id: id, name: name, expression: calcObj && calcObj.expression });
	                }
	
	                self.removeFormula(id, name);
	
	                if (!expression) {
	                    return null;
	                }
	
	                var formula = self.unparseFormula(expression);
	                calcObj = self.getCalcObj(id, name, true);
	
	                calcObj.formula = formula;
	                calcObj.expression = expression;
	                calcObj.isCalculating = false;
	                calcObj._startListening();
	
	                self.dirty(id, name);
	                self.calculate(id, name);
	            },
	           
	           
	           
	           
	           
	            unparseFormula: function (expr) {
	                var parser = this.getParser();
	                var ctx = this.getContext();
	                return parser.unparse(ctx, expr);
	            },
	            evaluateExpression: function (expr) {
	                var evaluator = this.getEvaluator();
	                var ctx = this.getContext();
	                return evaluator.evaluateExpression(expr, ctx);
	            },
	            evaluate: function (formula) {
	                var self = this;
	                var parser = self.getParser();
	                var ctx = self.getContext();
	                var exp = parser.parse(formula, ctx);
	                return exp && self.getEvaluator().evaluateExpression(exp, ctx);
	            },
	           
	           
	           
	           
	           
	           
	           
	           
	           
	            dirty: function (id, path) {
	                var calc = this.getCalcObj(id, path);
	                if (calc) {
	                    calc._addToDirty();
	                }
	            },
	            dirtyAll: function (id) {
	                var store = this.store_;
	                var pn = store[id];
	                if (pn) {
	                    for (var t in pn) {
	                        if (pn.hasOwnProperty(t)) {
	                            var calc = pn[t].calc;
	                            if (calc) {
	                                calc._addToDirty();
	                            }
	                        }
	                    }
	                }
	            }
	        };
	
	        return PropertySource;
	    })();
	
	    Shapes.PropertySource = PropertySource;
	
	    function PropertySourceModel(propertySource) {
	        this.propertySource = propertySource;
	        if (propertySource) {
	            propertySource.setCalcSourceModel(this);
	        }
	    }
	
	    PropertySourceModel.prototype = {
	        getSource: function () {
	            return this.propertySource;
	        },
	        addDirtyNodesForCalc: function (dirtyAll, isAyncEvaluate) {
	            this.propertySource.addDirtyNodesForCalc(dirtyAll, isAyncEvaluate);
	        },
	        _getAllVolatiles: function () {
	            return [];
	        },
	        _addVolatitlesToDirty: function () {
	        },
	        _checkAndUpdateVolatitles: function () {
	        },
	        getCalcObj: function(identity, create) {
	            var propertySource = this.propertySource;
	            var context = propertySource.getContext();
	            var sourceID = identity.source ? { id: identity.source.getName() } : null;
	            var n = resolveName(sourceID || context, identity.value);
	            return propertySource.getCalcObjFromNode(n, create);
	        },
	        _getNameCalc: function(path, create) {
	           
	            var self = this;
	            var id = null;
	            var n = path.indexOf('#');
	            if (n > 0) {
	                id = path.substring(0, n);
	                path = path.substring(n + 1);
	            } else {
	                id = self.propertySource.getCurrentObjectId();
	            }
	            return self.propertySource.getCalcObj(id, path, create);
	        },
	        setCalcService: function (service) {
	            this.propertySource.setCalcService(service);
	        },
	        getCalcService: function () {
	            return this.propertySource.getCalcService();
	        }
	    };
	
	    Shapes.PropertySourceModel = PropertySourceModel;
	}());

/***/ }),
/* 13 */
/***/ (function(module, exports) {

	module.exports = GC.Spread.CalcEngine;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	var Shapes = __webpack_require__(3);
	
	function findShapeRecursive(shape, id) {
	    if (id && shape.id === id) {
	        return shape;
	    }
	    var shapes = shape.shapes;
	    if (shapes) {
	        for (var i = 0, len = shapes.length; i < len; i++) {
	            var t = findShapeRecursive(shapes[i], id);
	            if (t) {
	                return t;
	            }
	        }
	    }
	}
	
	function findShapeInCollectionById(shapes, id) {
	    return findShapeRecursive({shapes: shapes}, id);
	}
	
	Shapes.findShapeInCollectionById = findShapeInCollectionById;
	
	function ShapeModel(name) {
	    var self = this;
	    self.name = name;
	    self.shapes = [];
	    self.derives = {};
	    self.calcSource_ = new Shapes.PropertySource(self);
	    self.calcSource_.changed = function (id, path, value, old, isFormula) {
	        self.changed && self.changed(id, path, value, old, isFormula);
	    };
	    self.setService(self.getService());
	    self.resetIDInfos();
	}
	
	function getKeyForShapeId(id) {
	    return 'shape' + id;
	}
	Shapes.getKeyForShapeId = getKeyForShapeId;
	
	ShapeModel.prototype = {
	    getName: function () {
	        return this.name;
	    },
	    getCalcService: function () {
	        return this.getService();
	    },
	    getService: function () {
	        return this.calcSource_.getCalcService();
	    },
	    getContext: function (id) {
	        return this.calcSource_.getContext(id);
	    },
	    setService: function (service) {
	        var self = this;
	        if (service) {
	            var name = self.getName();
	            self.calcModel_ = new Shapes.PropertySourceModel(self.calcSource_);
	            service.setSourceModel({ id: name }, self.calcModel_);
	        }
	    },
	    getExpressions: function (id, path) {
	        return this.calcSource_.getExpressions(id, path);
	    },
	    setExpressions: function (id, path, expressions) {
	        var self = this, calcSource_ = self.calcSource_;
	        calcSource_.calcSuspended = true;
	        self.setValues(id, path, expressions);
	        calcSource_.calcSuspended = false;
	        calcSource_.service.recalculateAll(false);
	    },
	    addShape: function (shape) {
	        var self = this;
	        var id = shape.id;
	        if (self.getShapeById(id)) {
	            return;
	        }
	        self.usedIDs[id] = shape;
	        self.attachShapeToModel(shape);
	        self.shapes.push(shape);
	
	        var parentShapeID = shape.parentShapeID;
	        if (parentShapeID) {
	            var derives = self.derives;
	            if (!derives[parentShapeID]) {
	                derives[parentShapeID] = [];
	            }
	            derives[parentShapeID].push(shape);
	        }
	    },
	    removeShape: function (shape, ignoreModel) {
	        var self = this;
	        Shapes.Common.Array_remove(self.shapes, shape);
	        delete self.usedIDs[shape.id];
	        if (!ignoreModel) {
	            self.detachShapeFromModel(shape);
	
	            var parentShapeID = shape.parentShapeID;
	            if (parentShapeID) {
	                var derives = self.derives[parentShapeID];
	                var n = derives.indexOf(shape);
	                if (n >= 0) {
	                    derives.splice(n, 1);
	                }
	            }
	        }
	    },
	    getShapes: function () {
	        return this.shapes;
	    },
	    getShapeById: function (id) {
	       
	        return this.usedIDs[id] || findShapeRecursive(this, id);
	    },
	    getUniqueShapeId: function (objResult) {
	       
	        var self = this;
	        var id = self.idCount, key;
	
	        do {
	            key = getKeyForShapeId(id);
	            id++;
	        } while (self.getShapeById(key));
	
	        self.idCount = id;
	
	       
	        if (objResult) {
	            return { id: id - 1, key: key };
	        }
	        return key;
	    },
	    resetIDInfos: function () {
	        var self = this;
	        self.usedIDs = {}; 
	        self.idMaps = {};  
	        self.idCount = 2;
	    },
	    ensureUniqueShapeId: function (id) {
	        var self = this;
	        var key = getKeyForShapeId(id);
	        if (self.getShapeById(key)) {
	           
	            var obj = self.getUniqueShapeId(true);
	            self.idMaps[id] = obj.id;
	            return obj;
	        }
	        self.updateIdCount(id);
	        return { id: id, key: getKeyForShapeId(id) };
	    },
	
	    updateIdCount: function (id) {
	        var self = this;
	        if (self.idCount <= id) {
	            self.idCount = id + 1;
	        }
	    },
	    detachShapeFromModel: function (shape) {
	        var self = this;
	        shape.setService(null);
	        self.remove(shape.id);
	
	        var shapes = shape.shapes;
	        if (shape.isCompoundShape && shapes) {
	            shapes.forEach(function (s) {
	                self.detachShapeFromModel(s);
	            });
	        }
	    },
	    attachShapeToModel: function (shape) {
	        var self = this, shapes = shape.shapes;
	        if (!shape.id) {
	            shape.id = self.getUniqueShapeId();
	        }
	        if (shape.getService() !== self) {
	            shape.setService(self);
	        }
	        if (shape.isCompoundShape && shapes) {
	            shapes.forEach(function (s) {
	                self.attachShapeToModel(s);
	            });
	        }
	    },
	    getCurrentObjectId: function () {
	        var s = this.calcSource_;
	        return s.getCurrentObjectId();
	    },
	    setCurrentObjectId: function (id) {
	        var s = this.calcSource_;
	        s.setCurrentObjectId(id);
	    },
	    add: function (id, options) {
	        this.setValues(id, "", options);
	    },
	    remove: function (id) {
	        var s = this.calcSource_;
	
	        s.removeObject(id);
	    },
	    getValues: function (id, path, formula) {
	        var s = this.calcSource_;
	        return s.getValuesForObject(id, path, formula);
	    },
	    setValues: function (id, path, value, overwrite) {
	        var s = this.calcSource_;
	        if (!overwrite) {
	            s.clearValues(id, path);
	        }
	        if (path && path.length > 0 && path[path.length - 1] !== '.') {
	            path += '.';
	        }
	        s.setObject(id, path, value);
	    },
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	    getValue: function (id, path) {
	        var s = this.calcSource_;
	        return s.getValue(id, path);
	    },
	    setValue: function (id, path, value) {
	        var s = this.calcSource_;
	        s.setValue(id, path, value);
	    },
	    getFormula: function (id, path) {
	        var s = this.calcSource_;
	        return s.getFormula(id, path);
	    },
	    setFormula: function (id, path, formula, forceRecalc) {
	        var s = this.calcSource_;
	        s.setFormula(id, path, formula, forceRecalc);
	    },
	    removeFormula: function (id, path) {
	        var s = this.calcSource_;
	        s.removeFormula(id, path);
	    },
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	    clearValues: function (id, path) {
	        var s = this.calcSource_;
	        s.clearValues(id, path);
	    },
	    clear: function () {
	        var s = this.calcSource_;
	        s.clear();
	        this.shapes = [];
	    },
	    dirty: function (id, path) {
	        var s = this.calcSource_;
	        s.dirty(id, path);
	    },
	    dirtyAll: function (id) {
	        var s = this.calcSource_;
	        s.dirtyAll(id);
	    },
	    setValueOrFormula: function (id, path, value, forceRecalc) {
	        var model = this;
	        if (value && value[0] === '=') {
	            model.setFormula(id, path, value.substring(1), forceRecalc);
	        } else {
	            model.setValue(id, path, value);
	        }
	    },
	    setAngle: function (id, value) {
	        this.setValueOrFormula(id, 'angle', value);
	    },
	    setOptions: function (id, value) {
	        this.setValues(id, 'options', value);
	    },
	    setPath: function (id, value) {
	        this.setValues(id, 'path', value);
	    },
	    setControls: function (id, value) {
	        this.setValues(id, 'controls', value);
	    },
	    setConnectionPoints: function (id, value) {
	        this.setValues(id, 'connectionPoints', value);
	    },
	    setConnectionLines: function (id, value) {
	        this.setValues(id, 'connectionLines', value);
	    },
	    getConnectionLines: function (id, formula) {
	        var t = this.getValues(id, 'connectionLines', formula);
	        return t && t['connectionLines'];
	    },
	    getConnectionPoints: function (id, formula) {
	        var t = this.getValues(id, 'connectionPoints', formula);
	        return t && t['connectionPoints'];
	    },
	    getControls: function (id, formula) {
	        var t = this.getValues(id, 'controls', formula);
	        return t && t['controls'];
	    },
	    getPath: function (id, formula) {
	        var t = this.getValues(id, 'path', formula);
	        return t && t['path'];
	    },
	    getOptions: function (id, formula) {
	        var t = this.getValues(id, 'options', formula);
	        return t && t['options'];
	    },
	    suspendCalc: function () {
	        var s = this.calcSource_;
	        s.suspendCalc();
	    },
	    resumeCalc: function () {
	        var s = this.calcSource_;
	        s.resumeCalc();
	    }
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	
	   
	   
	
	   
	   
	   
	   
	
	   
	   
	   
	
	   
	   
	   
	   
	   
	
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	
	   
	   
	
	   
	   
	   
	   
	   
	
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	
	   
	   
	   
	   
	   
	   
	   
	   
	   
	
	   
	   
	   
	   
	};
	
	Shapes.ShapeModel = ShapeModel;
	
	module.exports = Shapes;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var Shapes = __webpack_require__(1);
	
	    var Sheets = __webpack_require__(16), $ = Sheets.GC$;
	    var DRAWING_MODULE = __webpack_require__(17).Drawing;
	    Shapes.ChartUtility = DRAWING_MODULE.ChartUtility;
	    Shapes.defineProperty = Shapes.ChartUtility.defineProperty;
	    var colorFormatToString = Shapes.ChartUtility.colorFormatToString;
	
	   
	    
	    Shapes.AutoShapeType = {
	       
	        none: 0,
	        
	        rectangle: 1,
	        
	        parallelogram: 2,
	        
	        trapezoid: 3,
	        
	        diamond: 4,
	        
	        roundedRectangle: 5,
	        
	        octagon: 6,
	        
	        isoscelesTriangle: 7,
	        
	        rightTriangle: 8,
	        
	        oval: 9,
	        
	        hexagon: 10,
	        
	        cross: 11,
	        
	        regularPentagon: 12,
	        
	        can: 13,
	        
	        cube: 14,
	        
	        bevel: 15,
	        
	        foldedCorner: 16,
	        
	        smileyFace: 17,
	        
	        donut: 18,
	        
	        noSymbol: 19,
	        
	        blockArc: 20,
	        
	        heart: 21,
	        
	        lightningBolt: 22,
	        
	        sun: 23,
	        
	        moon: 24,
	        
	        arc: 25,
	        
	        doubleBracket: 26,
	        
	        doubleBrace: 27,
	        
	        plaque: 28,
	        
	        leftBracket: 29,
	        
	        rightBracket: 30,
	        
	        leftBrace: 31,
	        
	        rightBrace: 32,
	        
	        rightArrow: 33,
	        
	        leftArrow: 34,
	        
	        upArrow: 35,
	        
	        downArrow: 36,
	        
	        leftRightArrow: 37,
	        
	        upDownArrow: 38,
	        
	        quadArrow: 39,
	        
	        leftRightUpArrow: 40,
	        
	        bentArrow: 41,
	        
	        uTurnArrow: 42,
	        
	        leftUpArrow: 43,
	        
	        bentUpArrow: 44,
	        
	        curvedRightArrow: 45,
	        
	        curvedLeftArrow: 46,
	        
	        curvedUpArrow: 47,
	        
	        curvedDownArrow: 48,
	        
	        stripedRightArrow: 49,
	        
	        notchedRightArrow: 50,
	        
	        pentagon: 51,
	        
	        chevron: 52,
	        
	        rightArrowCallout: 53,
	        
	        leftArrowCallout: 54,
	        
	        upArrowCallout: 55,
	        
	        downArrowCallout: 56,
	        
	        leftRightArrowCallout: 57,
	        
	        upDownArrowCallout: 58,
	        
	        quadArrowCallout: 59,
	        
	        circularArrow: 60,
	        
	        flowchartProcess: 61,
	        
	        flowchartAlternateProcess: 62,
	        
	        flowchartDecision: 63,
	        
	        flowchartData: 64,
	        
	        flowchartPredefinedProcess: 65,
	        
	        flowchartInternalStorage: 66,
	        
	        flowchartDocument: 67,
	        
	        flowchartMultidocument: 68,
	        
	        flowchartTerminator: 69,
	        
	        flowchartPreparation: 70,
	        
	        flowchartManualInput: 71,
	        
	        flowchartManualOperation: 72,
	        
	        flowchartConnector: 73,
	        
	        flowchartOffpageConnector: 74,
	        
	        flowchartCard: 75,
	        
	        flowchartPunchedTape: 76,
	        
	        flowchartSummingJunction: 77,
	        
	        flowchartOr: 78,
	        
	        flowchartCollate: 79,
	        
	        flowchartSort: 80,
	        
	        flowchartExtract: 81,
	        
	        flowchartMerge: 82,
	        
	        flowchartStoredData: 83,
	        
	        flowchartDelay: 84,
	        
	        flowchartSequentialAccessStorage: 85,
	        
	        flowchartMagneticDisk: 86,
	        
	        flowchartDirectAccessStorage: 87,
	        
	        flowchartDisplay: 88,
	        
	        explosion1: 89,
	        
	        explosion2: 90,
	        
	        shape4pointStar: 91,
	        
	        shape5pointStar: 92,
	        
	        shape8pointStar: 93,
	        
	        shape16pointStar: 94,
	        
	        shape24pointStar: 95,
	        
	        shape32pointStar: 96,
	        
	        upRibbon: 97,
	        
	        downRibbon: 98,
	        
	        curvedUpRibbon: 99,
	        
	        curvedDownRibbon: 100,
	        
	        verticalScroll: 101,
	        
	        horizontalScroll: 102,
	        
	        wave: 103,
	        
	        doubleWave: 104,
	        
	        rectangularCallout: 105,
	        
	        roundedRectangularCallout: 106,
	        
	        ovalCallout: 107,
	        
	        cloudCallout: 108,
	        
	        lineCallout1: 109,
	        
	        lineCallout2: 110,
	        
	        lineCallout3: 111,
	        
	        lineCallout4: 112,
	        
	        lineCallout1AccentBar: 113,
	        
	        lineCallout2AccentBar: 114,
	        
	        lineCallout3AccentBar: 115,
	        
	        lineCallout4AccentBar: 116,
	        
	        lineCallout1NoBorder: 117,
	        
	        lineCallout2NoBorder: 118,
	        
	        lineCallout3NoBorder: 119,
	        
	        lineCallout4NoBorder: 120,
	        
	        lineCallout1BorderandAccentBar: 121,
	        
	        lineCallout2BorderandAccentBar: 122,
	        
	        lineCallout3BorderandAccentBar: 123,
	        
	        lineCallout4BorderandAccentBar: 124,
	        
	        actionButtonCustom: 125,
	        
	        actionButtonHome: 126,
	        
	        actionButtonHelp: 127,
	        
	        actionButtonInformation: 128,
	        
	        actionButtonBackorPrevious: 129,
	        
	        actionButtonForwardorNext: 130,
	        
	        actionButtonBeginning: 131,
	        
	        actionButtonEnd: 132,
	        
	        actionButtonReturn: 133,
	        
	        actionButtonDocument: 134,
	        
	        actionButtonSound: 135,
	        
	        actionButtonMovie: 136,
	        
	        balloon: 137,
	        
	        flowchartOfflineStorage: 138,
	        
	        leftRightRibbon: 139,
	        
	        diagonalStripe: 140,
	        
	        pie: 141,
	        
	        nonIsoscelesTrapezoid: 142,
	        
	        decagon: 143,
	        
	        heptagon: 144,
	        
	        dodecagon: 145,
	        
	        star6Point: 146,
	        
	        star7Point: 147,
	        
	        star10Point: 148,
	        
	        star12Point: 149,
	        
	        round1Rectangle: 150,
	        
	        round2SameRectangle: 151,
	        
	        round2DiagRectangle: 152,
	        
	        snipRoundRectangle: 153,
	        
	        snip1Rectangle: 154,
	        
	        snip2SameRectangle: 155,
	        
	        snip2DiagRectangle: 156,
	        
	        frame: 157,
	        
	        halfFrame: 158,
	        
	        tear: 159,
	        
	        chord: 160,
	        
	        corner: 161,
	        
	        mathPlus: 162,
	        
	        mathMinus: 163,
	        
	        mathMultiply: 164,
	        
	        mathDivide: 165,
	        
	        mathEqual: 166,
	        
	        mathNotEqual: 167,
	        
	        cornerTabs: 168,
	        
	        squareTabs: 169,
	        
	        plaqueTabs: 170,
	        
	        gear6: 171,
	        
	        gear9: 172,
	        
	        funnel: 173,
	        
	        pieWedge: 174,
	        
	        leftCircularArrow: 175,
	        
	        leftRightCircularArrow: 176,
	        
	        swooshArrow: 177,
	        
	        cloud: 178,
	        
	        chartX: 179,
	        
	        chartStar: 180,
	        
	        chartPlus: 181,
	        
	        lineInverse: 182,
	    };
	
	    Shapes.ShapeType = {
	       
	       
	       
	        AutoShape: 0,
	       
	       
	       
	        Chart: 1,
	       
	       
	       
	        Comment: 2,
	       
	       
	       
	        Group: 3,
	       
	       
	       
	        Picture: 4,
	       
	       
	       
	        Slicer: 5,
	    };
	
	    Shapes.ThemeColor = {
	       
	       
	       
	        None: -1,
	       
	       
	       
	        Light1: 0,
	       
	       
	       
	        Dark1: 1,
	       
	       
	       
	        Light2: 2,
	       
	       
	       
	        Dark2: 3,
	       
	       
	       
	        Accent1: 4,
	       
	       
	       
	        Accent2: 5,
	       
	       
	       
	        Accent3: 6,
	       
	       
	       
	        Accent4: 7,
	       
	       
	       
	        Accent5: 8,
	       
	       
	       
	        Accent6: 9,
	       
	       
	       
	        Hyperlink: 10,
	       
	       
	       
	        FollowedHyperlink: 11,
	    };
	
	    Shapes.ThemeFont = DRAWING_MODULE.ThemeFont;
	
	    Shapes.SolidColorType = DRAWING_MODULE.SolidColorType;
	
	   
	
	    Shapes.DrawingType = DRAWING_MODULE.DrawingType;
	
	    Shapes.FillType = DRAWING_MODULE.FillType;
	
	    Shapes.ThreeDFormatStates = DRAWING_MODULE.ThreeDFormatStates;
	
	    Shapes.FillFormat = DRAWING_MODULE.FillFormat;
	
	    Shapes.PictureFormat = DRAWING_MODULE.PictureFormat;
	
	    Shapes.LineFormat = DRAWING_MODULE.LineFormat;
	
	    Shapes.FontFormat = DRAWING_MODULE.FontFormat;
	
	    Shapes.DrawingText = DRAWING_MODULE.DrawingText;
	
	    Shapes.ShadowFormat = DRAWING_MODULE.ShadowFormat;
	
	    Shapes.GlowFormat = DRAWING_MODULE.GlowFormat;
	
	    Shapes.SoftEdgeFormat = DRAWING_MODULE.SoftEdgeFormat;
	
	    Shapes.ReflectionFormat = DRAWING_MODULE.ReflectionFormat;
	
	    Shapes.ThreeDFormat = DRAWING_MODULE.ThreeDFormat;
	
	    Shapes.ARGBColor = DRAWING_MODULE.ARGBColor;
	
	    Shapes.StatefullBase = DRAWING_MODULE.StatefullBase;
	
	   
	    
	    Shapes.ConnectorType = {
	        
	        straight: 0,
	        
	        elbow: 1
	       
	       
	       
	       
	    };
	
	    Shapes.ST_FontCollectionIndex = DRAWING_MODULE.ST_FontCollectionIndex;
	
	    Shapes.ST_TextHorzOverflowType = {
	        overflow: 0,
	        clip: 1,
	    };
	
	    Shapes.ST_TextAnchoringType = {
	        t: 0,
	        ctr: 1,
	        b: 2,
	        just: 3,
	        dist: 4,
	    };
	
	   
	   
	   
	   
	   
	
	    Shapes.ST_ShapeType = {
	        line: 0,
	        lineInv: 1,
	        triangle: 2,
	        rtTriangle: 3,
	        rect: 4,
	        diamond: 5,
	        parallelogram: 6,
	        trapezoid: 7,
	        nonIsoscelesTrapezoid: 8,
	        pentagon: 9,
	        hexagon: 10,
	        heptagon: 11,
	        octagon: 12,
	        decagon: 13,
	        dodecagon: 14,
	        star4: 15,
	        star5: 16,
	        star6: 17,
	        star7: 18,
	        star8: 19,
	        star10: 20,
	        star12: 21,
	        star16: 22,
	        star24: 23,
	        star32: 24,
	        roundRect: 25,
	        round1Rect: 26,
	        round2SameRect: 27,
	        round2DiagRect: 28,
	        snipRoundRect: 29,
	        snip1Rect: 30,
	        snip2SameRect: 31,
	        snip2DiagRect: 32,
	        plaque: 33,
	        ellipse: 34,
	        teardrop: 35,
	        homePlate: 36,
	        chevron: 37,
	        pieWedge: 38,
	        pie: 39,
	        blockArc: 40,
	        donut: 41,
	        noSmoking: 42,
	        rightArrow: 43,
	        leftArrow: 44,
	        upArrow: 45,
	        downArrow: 46,
	        stripedRightArrow: 47,
	        notchedRightArrow: 48,
	        bentUpArrow: 49,
	        leftRightArrow: 50,
	        upDownArrow: 51,
	        leftUpArrow: 52,
	        leftRightUpArrow: 53,
	        quadArrow: 54,
	        leftArrowCallout: 55,
	        rightArrowCallout: 56,
	        upArrowCallout: 57,
	        downArrowCallout: 58,
	        leftRightArrowCallout: 59,
	        upDownArrowCallout: 60,
	        quadArrowCallout: 61,
	        bentArrow: 62,
	        uturnArrow: 63,
	        circularArrow: 64,
	        leftCircularArrow: 65,
	        leftRightCircularArrow: 66,
	        curvedRightArrow: 67,
	        curvedLeftArrow: 68,
	        curvedUpArrow: 69,
	        curvedDownArrow: 70,
	        swooshArrow: 71,
	        cube: 72,
	        can: 73,
	        lightningBolt: 74,
	        heart: 75,
	        sun: 76,
	        moon: 77,
	        smileyFace: 78,
	        irregularSeal1: 79,
	        irregularSeal2: 80,
	        foldedCorner: 81,
	        bevel: 82,
	        frame: 83,
	        halfFrame: 84,
	        corner: 85,
	        diagStripe: 86,
	        chord: 87,
	        arc: 88,
	        leftBracket: 89,
	        rightBracket: 90,
	        leftBrace: 91,
	        rightBrace: 92,
	        bracketPair: 93,
	        bracePair: 94,
	        straightConnector1: 95,
	        bentConnector2: 96,
	        bentConnector3: 97,
	        bentConnector4: 98,
	        bentConnector5: 99,
	        curvedConnector2: 100,
	        curvedConnector3: 101,
	        curvedConnector4: 102,
	        curvedConnector5: 103,
	        callout1: 104,
	        callout2: 105,
	        callout3: 106,
	        accentCallout1: 107,
	        accentCallout2: 108,
	        accentCallout3: 109,
	        borderCallout1: 110,
	        borderCallout2: 111,
	        borderCallout3: 112,
	        accentBorderCallout1: 113,
	        accentBorderCallout2: 114,
	        accentBorderCallout3: 115,
	        wedgeRectCallout: 116,
	        wedgeRoundRectCallout: 117,
	        wedgeEllipseCallout: 118,
	        cloudCallout: 119,
	        cloud: 120,
	        ribbon: 121,
	        ribbon2: 122,
	        ellipseRibbon: 123,
	        ellipseRibbon2: 124,
	        leftRightRibbon: 125,
	        verticalScroll: 126,
	        horizontalScroll: 127,
	        wave: 128,
	        doubleWave: 129,
	        plus: 130,
	        flowChartProcess: 131,
	        flowChartDecision: 132,
	        flowChartInputOutput: 133,
	        flowChartPredefinedProcess: 134,
	        flowChartInternalStorage: 135,
	        flowChartDocument: 136,
	        flowChartMultidocument: 137,
	        flowChartTerminator: 138,
	        flowChartPreparation: 139,
	        flowChartManualInput: 140,
	        flowChartManualOperation: 141,
	        flowChartConnector: 142,
	        flowChartPunchedCard: 143,
	        flowChartPunchedTape: 144,
	        flowChartSummingJunction: 145,
	        flowChartOr: 146,
	        flowChartCollate: 147,
	        flowChartSort: 148,
	        flowChartExtract: 149,
	        flowChartMerge: 150,
	        flowChartOfflineStorage: 151,
	        flowChartOnlineStorage: 152,
	        flowChartMagneticTape: 153,
	        flowChartMagneticDisk: 154,
	        flowChartMagneticDrum: 155,
	        flowChartDisplay: 156,
	        flowChartDelay: 157,
	        flowChartAlternateProcess: 158,
	        flowChartOffpageConnector: 159,
	        actionButtonBlank: 160,
	        actionButtonHome: 161,
	        actionButtonHelp: 162,
	        actionButtonInformation: 163,
	        actionButtonForwardNext: 164,
	        actionButtonBackPrevious: 165,
	        actionButtonEnd: 166,
	        actionButtonBeginning: 167,
	        actionButtonReturn: 168,
	        actionButtonDocument: 169,
	        actionButtonSound: 170,
	        actionButtonMovie: 171,
	        gear6: 172,
	        gear9: 173,
	        funnel: 174,
	        mathPlus: 175,
	        mathMinus: 176,
	        mathMultiply: 177,
	        mathDivide: 178,
	        mathEqual: 179,
	        mathNotEqual: 180,
	        cornerTabs: 181,
	        squareTabs: 182,
	        plaqueTabs: 183,
	        chartX: 184,
	        chartStar: 185,
	        chartPlus: 186,
	    };
	
	    Shapes.ST_SchemeColorVal = {
	        bg1: 0,
	        tx1: 1,
	        bg2: 2,
	        tx2: 3,
	        accent1: 4,
	        accent2: 5,
	        accent3: 6,
	        accent4: 7,
	        accent5: 8,
	        accent6: 9,
	        hlink: 10,
	        folHlink: 11,
	        phClr: 12,
	        dk1: 13,
	        lt1: 14,
	        dk2: 15,
	        lt2: 16,
	    };
	
	    Shapes.CT_ShapeType = {
	        CT_AlternateContent: 0,
	        CT_Picture: 1,
	        CT_GraphicalObjectFrame: 2,
	        CT_GroupShape: 3,
	        CT_Connector: 4,
	        CT_Shape: 5,
	        CT_SlicerShape: 6,
	    };
	
	   
	   
	   
	   
	   
	   
	   
	   
	   
	
	   
	        
	        Shapes.PresetLineDashStyle = {
	            
	            solid: 0,
	            
	            squareDot: 1,
	            
	            dash: 2,
	            
	            longDash: 3,
	            
	            dashDot: 4,
	            
	            longDashDot: 5,
	            
	            longDashDotDot: 6,
	            
	            sysDash: 7,
	            
	            sysDot: 8,
	            
	            sysDashDot: 9,
	            
	            dashDotDot: 10
	           
	           
	        };
	   
	    
	    Shapes.LineCapStyle = {
	        
	        flat: 2,
	        
	        square: 1,
	        
	        round: 0
	    };
	
	   
	    
	    Shapes.LineJoinStyle = {
	        
	        round: 0,
	        
	        miter: 1,
	        
	        bevel: 2
	    };
	
	    Shapes.ArrowheadStyle = DRAWING_MODULE.ArrowheadStyle;
	   
	    
	    var ArrowheadStyle = {   
	        
	        none: 0,
	                
	        triangle: 1,
	                
	        stealth: 2,
	                
	        diamond: 3,
	                
	        oval: 4,
	                
	        open: 5
	    };
	
	    Shapes.ArrowheadLength = DRAWING_MODULE.ArrowheadLength;
	   
	        
	    var ArrowheadLength = {  
	                
	        short: 0,
	                
	        medium: 1,
	                
	        long: 2
	    };
	
	    Shapes.ArrowheadWidth = DRAWING_MODULE.ArrowheadWidth;
	   
	    
	    var ArrowheadWidth = {   
	                
	        narrow: 0,
	                
	        medium: 1,
	                
	        wide: 2
	    };    
	
	    Shapes.ShapeConstants = DRAWING_MODULE.ShapeConstants;
	
	    function ShapeUtility() {
	    }
	    ShapeUtility.ToConnectorType = function (type ) {
	        var result = 2 ;
	        switch (type) {
	            case 95 :
	            case 0 :
	                result = 0 ;
	                break;
	            case 96 :
	            case 97 :
	            case 98 :
	            case 99 :
	                result = 1 ;
	                break;
	           
	           
	           
	           
	           
	           
	            default:
	                break;
	        }
	        return result;
	    };
	    ShapeUtility.GetConnectorPointNum = function (type ) {
	        switch (type) {
	            case 96 :
	            case 100 :
	                return 2;
	            case 97 :
	            case 101 :
	                return 3;
	            case 98 :
	            case 102 :
	                return 4;
	            case 99 :
	            case 103 :
	                return 5;
	            default:
	                return 2;
	        }
	    };
	    ShapeUtility.ToConnectorST_ShapeType = function (type, pointNum) {
	        var result = 0; 
	        switch (type) {
	            case 0 :
	                result = 95 ;
	                break;
	            case 1 :
	                if (pointNum >= 2 && pointNum <= 5) {
	                    result = 96 + (pointNum - 2);
	                } else {
	                    result = 97;
	                }
	                break;
	            case 2 :
	                if (pointNum >= 2 && pointNum <= 5) {
	                    result = 100 + (pointNum - 2);
	                } else {
	                    result = 101;
	                }
	                break;
	            default:
	                break;
	        }
	        return result;
	    };
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	    ShapeUtility.ToAutoShapeType = function (type ) {
	        switch (type) {
	            case 4 :
	                return 1 ;
	            case 6 :
	                return 2 ;
	            case 7 :
	                return 3 ;
	            case 5 :
	                return 4 ;
	            case 25 :
	                return 5 ;
	            case 12 :
	                return 6 ;
	            case 2 :
	                return 7 ;
	            case 3 :
	                return 8 ;
	            case 34 :
	                return 9 ;
	            case 10 :
	                return 10 ;
	            case 130 :
	                return 11 ;
	            case 9 :
	                return 12 ;
	            case 73 :
	                return 13 ;
	            case 72 :
	                return 14 ;
	            case 82 :
	                return 15 ;
	            case 81 :
	                return 16 ;
	            case 78 :
	                return 17 ;
	            case 41 :
	                return 18 ;
	            case 42 :
	                return 19 ;
	            case 40 :
	                return 20 ;
	            case 75 :
	                return 21 ;
	            case 74 :
	                return 22 ;
	            case 76 :
	                return 23 ;
	            case 77 :
	                return 24 ;
	            case 88 :
	                return 25 ;
	            case 93 :
	                return 26 ;
	            case 94 :
	                return 27 ;
	            case 33 :
	                return 28 ;
	            case 89 :
	                return 29 ;
	            case 90 :
	                return 30 ;
	            case 91 :
	                return 31 ;
	            case 92 :
	                return 32 ;
	            case 43 :
	                return 33 ;
	            case 44 :
	                return 34 ;
	            case 45 :
	                return 35 ;
	            case 46 :
	                return 36 ;
	            case 50 :
	                return 37 ;
	            case 51 :
	                return 38 ;
	            case 54 :
	                return 39 ;
	            case 53 :
	                return 40 ;
	            case 62 :
	                return 41 ;
	            case 63 :
	                return 42 ;
	            case 52 :
	                return 43 ;
	            case 49 :
	                return 44 ;
	            case 67 :
	                return 45 ;
	            case 68 :
	                return 46 ;
	            case 69 :
	                return 47 ;
	            case 70 :
	                return 48 ;
	            case 47 :
	                return 49 ;
	            case 48 :
	                return 50 ;
	            case 36 :
	                return 51 ;
	            case 37 :
	                return 52 ;
	            case 56 :
	                return 53 ;
	            case 55 :
	                return 54 ;
	            case 57 :
	                return 55 ;
	            case 58 :
	                return 56 ;
	            case 59 :
	                return 57 ;
	            case 60 :
	                return 58 ;
	            case 61 :
	                return 59 ;
	            case 64 :
	                return 60 ;
	            case 131 :
	                return 61 ;
	            case 158 :
	                return 62 ;
	            case 132 :
	                return 63 ;
	            case 133 :
	                return 64 ;
	            case 134 :
	                return 65 ;
	            case 135 :
	                return 66 ;
	            case 136 :
	                return 67 ;
	            case 137 :
	                return 68 ;
	            case 138 :
	                return 69 ;
	            case 139 :
	                return 70 ;
	            case 140 :
	                return 71 ;
	            case 141 :
	                return 72 ;
	            case 142 :
	                return 73 ;
	            case 159 :
	                return 74 ;
	            case 143 :
	                return 75 ;
	            case 144 :
	                return 76 ;
	            case 145 :
	                return 77 ;
	            case 146 :
	                return 78 ;
	            case 147 :
	                return 79 ;
	            case 148 :
	                return 80 ;
	            case 149 :
	                return 81 ;
	            case 150 :
	                return 82 ;
	            case 152 :
	                return 83 ;
	            case 157 :
	                return 84 ;
	            case 153 :
	                return 85 ;
	            case 154 :
	                return 86 ;
	            case 155 :
	                return 87 ;
	            case 156 :
	                return 88 ;
	            case 79 :
	                return 89 ;
	            case 80 :
	                return 90 ;
	            case 15 :
	                return 91 ;
	            case 16 :
	                return 92 ;
	            case 19 :
	                return 93 ;
	            case 22 :
	                return 94 ;
	            case 23 :
	                return 95 ;
	            case 24 :
	                return 96 ;
	            case 122 :
	                return 97 ;
	            case 121 :
	                return 98 ;
	            case 124 :
	                return 99 ;
	            case 123 :
	                return 100 ;
	            case 126 :
	                return 101 ;
	            case 127 :
	                return 102 ;
	            case 128 :
	                return 103 ;
	            case 129 :
	                return 104 ;
	            case 116 :
	                return 105 ;
	            case 117 :
	                return 106 ;
	            case 118 :
	                return 107 ;
	            case 119 :
	                return 108 ;
	            case 110 :
	                return 109 ;
	            case 111 :
	                return 111 ;
	            case 112 :
	                return 112 ;
	            case 104 :
	                return 113 ;
	            case 107 :
	                return 114 ;
	            case 108 :
	                return 115 ;
	            case 109 :
	                return 116 ;
	            case 105 :
	                return 119 ;
	            case 106 :
	                return 120 ;
	            case 113 :
	                return 122 ;
	            case 114 :
	                return 123 ;
	            case 115 :
	                return 124 ;
	            case 160 :
	                return 125 ;
	            case 161 :
	                return 126 ;
	            case 162 :
	                return 127 ;
	            case 163 :
	                return 128 ;
	            case 165 :
	                return 129 ;
	            case 164 :
	                return 130 ;
	            case 167 :
	                return 131 ;
	            case 166 :
	                return 132 ;
	            case 168 :
	                return 133 ;
	            case 169 :
	                return 134 ;
	            case 170 :
	                return 135 ;
	            case 171 :
	                return 136 ;
	            case 151 :
	                return 138 ;
	            case 125 :
	                return 139 ;
	            case 86 :
	                return 140 ;
	            case 39 :
	                return 141 ;
	            case 8 :
	                return 142 ;
	            case 13 :
	                return 143 ;
	            case 11 :
	                return 144 ;
	            case 14 :
	                return 145 ;
	            case 17 :
	                return 146 ;
	            case 18 :
	                return 147 ;
	            case 20 :
	                return 148 ;
	            case 21 :
	                return 149 ;
	            case 26 :
	                return 150 ;
	            case 27 :
	                return 151 ;
	            case 28 :
	                return 152 ;
	            case 29 :
	                return 153 ;
	            case 30 :
	                return 154 ;
	            case 31 :
	                return 155 ;
	            case 32 :
	                return 156 ;
	            case 83 :
	                return 157 ;
	            case 84 :
	                return 158 ;
	            case 35 :
	                return 159 ;
	            case 87 :
	                return 160 ;
	            case 85 :
	                return 161 ;
	            case 175 :
	                return 162 ;
	            case 176 :
	                return 163 ;
	            case 177 :
	                return 164 ;
	            case 178 :
	                return 165 ;
	            case 179 :
	                return 166 ;
	            case 180 :
	                return 167 ;
	            case 181 :
	                return 168 ;
	            case 182 :
	                return 169 ;
	            case 183 :
	                return 170 ;
	            case 172 :
	                return 171 ;
	            case 173 :
	                return 172 ;
	            case 174 :
	                return 173 ;
	            case 38 :
	                return 174 ;
	            case 65 :
	                return 175 ;
	            case 66 :
	                return 176 ;
	            case 71 :
	                return 177 ;
	            case 120 :
	                return 178 ;
	            case 184 :
	                return 179 ;
	            case 185 :
	                return 180 ;
	            case 186 :
	                return 181 ;
	            case 1 :
	                return 182 ;
	        }
	        return 0 ;
	    };
	    ShapeUtility.ToST_ShapeType = function (type ) {
	        switch (type) {
	            case 1 :
	                return 4 ;
	            case 2 :
	                return 6 ;
	            case 3 :
	                return 7 ;
	            case 4 :
	                return 5 ;
	            case 5 :
	                return 25 ;
	            case 6 :
	                return 12 ;
	            case 7 :
	                return 2 ;
	            case 8 :
	                return 3 ;
	            case 9 :
	                return 34 ;
	            case 10 :
	                return 10 ;
	            case 11 :
	                return 130 ;
	            case 12 :
	                return 9 ;
	            case 13 :
	                return 73 ;
	            case 14 :
	                return 72 ;
	            case 15 :
	                return 82 ;
	            case 16 :
	                return 81 ;
	            case 17 :
	                return 78 ;
	            case 18 :
	                return 41 ;
	            case 19 :
	                return 42 ;
	            case 20 :
	                return 40 ;
	            case 21 :
	                return 75 ;
	            case 22 :
	                return 74 ;
	            case 23 :
	                return 76 ;
	            case 24 :
	                return 77 ;
	            case 25 :
	                return 88 ;
	            case 26 :
	                return 93 ;
	            case 27 :
	                return 94 ;
	            case 28 :
	                return 33 ;
	            case 29 :
	                return 89 ;
	            case 30 :
	                return 90 ;
	            case 31 :
	                return 91 ;
	            case 32 :
	                return 92 ;
	            case 33 :
	                return 43 ;
	            case 34 :
	                return 44 ;
	            case 35 :
	                return 45 ;
	            case 36 :
	                return 46 ;
	            case 37 :
	                return 50 ;
	            case 38 :
	                return 51 ;
	            case 39 :
	                return 54 ;
	            case 40 :
	                return 53 ;
	            case 41 :
	                return 62 ;
	            case 42 :
	                return 63 ;
	            case 43 :
	                return 52 ;
	            case 44 :
	                return 49 ;
	            case 45 :
	                return 67 ;
	            case 46 :
	                return 68 ;
	            case 47 :
	                return 69 ;
	            case 48 :
	                return 70 ;
	            case 49 :
	                return 47 ;
	            case 50 :
	                return 48 ;
	            case 51 :
	                return 36 ;
	            case 52 :
	                return 37 ;
	            case 53 :
	                return 56 ;
	            case 54 :
	                return 55 ;
	            case 55 :
	                return 57 ;
	            case 56 :
	                return 58 ;
	            case 57 :
	                return 59 ;
	            case 58 :
	                return 60 ;
	            case 59 :
	                return 61 ;
	            case 60 :
	                return 64 ;
	            case 61 :
	                return 131 ;
	            case 62 :
	                return 158 ;
	            case 63 :
	                return 132 ;
	            case 64 :
	                return 133 ;
	            case 65 :
	                return 134 ;
	            case 66 :
	                return 135 ;
	            case 67 :
	                return 136 ;
	            case 68 :
	                return 137 ;
	            case 69 :
	                return 138 ;
	            case 70 :
	                return 139 ;
	            case 71 :
	                return 140 ;
	            case 72 :
	                return 141 ;
	            case 73 :
	                return 142 ;
	            case 74 :
	                return 159 ;
	            case 75 :
	                return 143 ;
	            case 76 :
	                return 144 ;
	            case 77 :
	                return 145 ;
	            case 78 :
	                return 146 ;
	            case 79 :
	                return 147 ;
	            case 80 :
	                return 148 ;
	            case 81 :
	                return 149 ;
	            case 82 :
	                return 150 ;
	            case 83 :
	                return 152 ;
	            case 84 :
	                return 157 ;
	            case 85 :
	                return 153 ;
	            case 86 :
	                return 154 ;
	            case 87 :
	                return 155 ;
	            case 88 :
	                return 156 ;
	            case 89 :
	                return 79 ;
	            case 90 :
	                return 80 ;
	            case 91 :
	                return 15 ;
	            case 92 :
	                return 16 ;
	            case 93 :
	                return 19 ;
	            case 94 :
	                return 22 ;
	            case 95 :
	                return 23 ;
	            case 96 :
	                return 24 ;
	            case 97 :
	                return 122 ;
	            case 98 :
	                return 121 ;
	            case 99 :
	                return 124 ;
	            case 100 :
	                return 123 ;
	            case 101 :
	                return 126 ;
	            case 102 :
	                return 127 ;
	            case 103 :
	                return 128 ;
	            case 104 :
	                return 129 ;
	            case 105 :
	                return 116 ;
	            case 106 :
	                return 117 ;
	            case 107 :
	                return 118 ;
	            case 108 :
	                return 119 ;
	            case 109 :
	                return 110 ;
	            case 110 :
	                return 110 ;
	            case 111 :
	                return 111 ;
	            case 112 :
	                return 112 ;
	            case 113 :
	                return 104 ;
	            case 114 :
	                return 107 ;
	            case 115 :
	                return 108 ;
	            case 116 :
	                return 109 ;
	            case 117 :
	                return 104 ;
	            case 118 :
	                return 104 ;
	            case 119 :
	                return 105 ;
	            case 120 :
	                return 106 ;
	            case 121 :
	                return 110 ;
	            case 122 :
	                return 113 ;
	            case 123 :
	                return 114 ;
	            case 124 :
	                return 115 ;
	            case 125 :
	                return 160 ;
	            case 126 :
	                return 161 ;
	            case 127 :
	                return 162 ;
	            case 128 :
	                return 163 ;
	            case 129 :
	                return 165 ;
	            case 130 :
	                return 164 ;
	            case 131 :
	                return 167 ;
	            case 132 :
	                return 166 ;
	            case 133 :
	                return 168 ;
	            case 134 :
	                return 169 ;
	            case 135 :
	                return 170 ;
	            case 136 :
	                return 171 ;
	            case 137 :
	                return 117 ;
	            case 138 :
	                return 151 ;
	            case 139 :
	                return 125 ;
	            case 140 :
	                return 86 ;
	            case 141 :
	                return 39 ;
	            case 142 :
	                return 8 ;
	            case 143 :
	                return 13 ;
	            case 144 :
	                return 11 ;
	            case 145 :
	                return 14 ;
	            case 146 :
	                return 17 ;
	            case 147 :
	                return 18 ;
	            case 148 :
	                return 20 ;
	            case 149 :
	                return 21 ;
	            case 150 :
	                return 26 ;
	            case 151 :
	                return 27 ;
	            case 152 :
	                return 28 ;
	            case 153 :
	                return 29 ;
	            case 154 :
	                return 30 ;
	            case 155 :
	                return 31 ;
	            case 156 :
	                return 32 ;
	            case 157 :
	                return 83 ;
	            case 158 :
	                return 84 ;
	            case 159 :
	                return 35 ;
	            case 160 :
	                return 87 ;
	            case 161 :
	                return 85 ;
	            case 162 :
	                return 175 ;
	            case 163 :
	                return 176 ;
	            case 164 :
	                return 177 ;
	            case 165 :
	                return 178 ;
	            case 166 :
	                return 179 ;
	            case 167 :
	                return 180 ;
	            case 168 :
	                return 181 ;
	            case 169 :
	                return 182 ;
	            case 170 :
	                return 183 ;
	            case 171 :
	                return 172 ;
	            case 172 :
	                return 173 ;
	            case 173 :
	                return 174 ;
	            case 174 :
	                return 38 ;
	            case 175 :
	                return 65 ;
	            case 176 :
	                return 66 ;
	            case 177 :
	                return 71 ;
	            case 178 :
	                return 120 ;
	            case 179 :
	                return 184 ;
	            case 180 :
	                return 185 ;
	            case 181 :
	                return 186 ;
	            case 182 :
	                return 1 ;
	        }
	        return 0 ;
	    };
	
	    function getAdjustValueFromFormula(formula) {
	        return +formula.split(' ')[1];
	    }
	
	    function convertFromExcelAdjustValueItem(item) {
	        return [item.name, getAdjustValueFromFormula(item.fmla)];
	    }
	
	    ShapeUtility.convertFromExcelAdjustValues = function (gdItems) {
	        if (gdItems && gdItems.length) {
	            return gdItems.map(convertFromExcelAdjustValueItem);
	        }
	    };
	
	    function convertToExcelAdjustValueItem(item) {
	        return {
	            name: item[0],
	            fmla: 'val ' + parseInt(item[1])   
	        };
	    }
	    ShapeUtility.convertToExcelAdjustValues = function (adjustValues) {
	        if (adjustValues && adjustValues.length) {
	            return adjustValues.map(convertToExcelAdjustValueItem);
	        }
	    };
	
	    function syncShapeAdjustValues(model, shapeData) {
	        var adjustValues = shapeData && shapeData.AdjustValues;
	        if (adjustValues && adjustValues.length) {
	            var variables = model.variables;
	            adjustValues.forEach(function (item) {
	                variables[item[0]] = item[1];
	            });
	        }
	    }
	    ShapeUtility.syncShapeAdjustValues = syncShapeAdjustValues;
	
	    function getShapeAdjustValues(shape) {
	        var shapeUI = shape._shapeUI,
	            adjustInfo = shapeUI._adjustInfo;
	        if (adjustInfo) {
	            var valueChanged = false;
	           
	            var adjustValues = adjustInfo.map(function (item) {
	                var name = item[0], defaultValue = item[1], value = shapeUI.getVariable(name);
	
	                if (defaultValue !== value) {
	                    valueChanged = true;
	                }
	
	                return [name, value];
	            });
	            return valueChanged && adjustValues;
	        }
	    }
	    ShapeUtility.getShapeAdjustValues = getShapeAdjustValues;
	
	    function convertFrom_ST_TextVerticalType(vert) {
	        
	       return { 
	           horz: vert < 3,
	           rotate: [270, 90][2 - vert] || 0
	       };
	    }
	
	    var ratioMarginInPixel = 96 / 914400;  
	
	    function getMarginValue(value, index) {
	        var v = +value;
	        if (isNaN(v)) {
	            v = index > 1 ? 45720 : 91440;
	        }
	        return v * ratioMarginInPixel;
	    }
	
	   
	   
	   
	   
	   
	   
	   
	    function getBodyProperties(textBody) {
	        var src = textBody && textBody._ooTextBody && textBody._ooTextBody.bodyPr;
	        var hAlign = 0, vAlign = 0, overflow = false, wrap = true, 
	            angle = 0, horz = true, margins, center = false;
	        if (src && Object.keys(src).length > 0) {  
	            var tmp = convertFrom_ST_TextVerticalType(src.vert || 0);
	            horz = tmp.horz;
	            angle = tmp.rotate;
	            margins = ([src.lIns, src.rIns, src.tIns, src.bIns]).map(getMarginValue).map(Math.round);
	            overflow = !src.horzOverflow; 
	            wrap = src.wrap !== 0 ;
	            var anchor = src.anchor || 0 ;
	            center = !!src.anchorCtr;
	            if (anchor > 2) {
	                 anchor = 1;   
	            }
	            var para = textBody._paragraphs[0]._ooTextPara, algn = para.pPr && para.pPr.algn || 0;
	            if (algn > 2) {
	                algn = 0;  
	            }
	            vAlign = anchor;
	            if (horz && angle !== 90) {
	                hAlign = algn; 
	            } else {
	                hAlign = 2 - algn;    
	            }
	        }
	
	        return {
	            center: center,
	            hAlign: hAlign,
	            vAlign: vAlign,
	            overflow: overflow,
	            wrap: wrap,
	            horz: horz,
	            angle: angle,
	            margins: margins
	        };
	    }
	
	    function getRGBAColor(colorFormat) {
	        return colorFormatToString(colorFormat, false , true );
	    }
	    ShapeUtility.getRGBAColor = getRGBAColor;
	
	    
	    function getColorInfo(colorFormat) {
	        var transparency = colorFormat && colorFormat.Color && colorFormat.Color.Transparency;
	        if (isNaN(transparency)) {
	            transparency = 0;
	        }
	        return {
	            color: colorFormatToString(colorFormat),
	            transparency: transparency
	        };
	    }
	    ShapeUtility.getColorInfo = getColorInfo;
	
	    function getFontFormatInfo(fontFormat) {
	        return {
	            fontSize: fontFormat.Size,
	            fontName: fontFormat.Name,
	            bold: !!fontFormat.Bold,
	            italic: !!fontFormat.Italic,
	            color: getRGBAColor(fontFormat)
	        };
	    }
	
	    function getFontInfo(textBody) {
	        var paragraph = textBody._paragraphs[0];
	        var fontFormat = (paragraph._elements && paragraph._elements[0] || paragraph).Font;
	
	        return getFontFormatInfo(fontFormat);
	    }
	
	    function getShapeTextInfo(drawingText) {
	        var text = drawingText.Text;
	        var formatInfo, fontInfo;
	       
	            var textBody = drawingText.TextBody;
	            formatInfo = getBodyProperties(textBody);
	            fontInfo = getFontInfo(textBody);
	       
	        return {
	            text: text,
	            formatInfo: formatInfo,
	            fontInfo: fontInfo
	        };
	    }
	    ShapeUtility.getShapeTextInfo = getShapeTextInfo;
	
	    function getFontString(fontInfo) {
	        var items = [];
	        if (fontInfo.italic) {
	            items.push('italic');
	        }
	        if (fontInfo.bold) {
	            items.push('bold');
	        }
	        items.push(fontInfo.fontSize + 'px');
	        items.push(fontInfo.fontName);
	
	        return items.join(' ');
	    }
	
	    function getFontOptions(fontFormat) {
	        var fontInfo = getFontFormatInfo(fontFormat);
	        return {
	            font: getFontString(fontInfo),
	            fill: {
	                type: 1 ,
	                color: fontInfo.color
	            }
	        };
	    }
	    ShapeUtility.getFontOptions = getFontOptions;
	
	    function getFontFromShapeData(shapeData) {
	        var fontInfo = getFontInfo(shapeData._drawingText.TextBody);
	        return getFontString(fontInfo);
	    }
	    ShapeUtility.getFontFromShapeData = getFontFromShapeData;
	
	    function getTextDirection(formatInfo) {
	        var horz = formatInfo.horz, angle = formatInfo.angle;
	        if (horz) {
	            return angle ? 'rotate' + angle : 'horizontal';
	        }
	        return "vertical";
	    }
	
	    function syncShapeTextFormatOptions(textFormatOptions, shapeData) {
	        var textInfo = getShapeTextInfo(shapeData && shapeData._drawingText);
	        var text = textInfo.text;
	        textFormatOptions.text = text;
	       
	            var fontInfo = textInfo.fontInfo;
	            textFormatOptions.font = getFontString(fontInfo);
	            textFormatOptions.fill = {
	                type: 1 ,
	                color: fontInfo.color
	            };
	            var formatInfo = textInfo.formatInfo, margins = formatInfo.margins;
	            if (margins) {
	                textFormatOptions.margins = {
	                    left: margins[0],
	                    right: margins[1],
	                    top: margins[2],
	                    bottom: margins[3]
	                };
	            }
	            textFormatOptions.textDirection = getTextDirection(formatInfo);
	            var hAlign = textFormatOptions.horizontalAlignment = formatInfo.horz && formatInfo.center ? 1 : formatInfo.hAlign;
	            var vAlign = textFormatOptions.verticalAlignment = formatInfo.vAlign;
	            textFormatOptions.wrapTextInShape = formatInfo.wrap;
	            if (isNaN(shapeData._vAlign)) {
	                shapeData._vAlign = vAlign;
	            }
	            if (isNaN(shapeData._hAlign)) {
	                shapeData._hAlign = hAlign;
	            }
	
	            textFormatOptions.allowTextToOverflowShape = formatInfo.overflow;
	           
	           
	            delete textFormatOptions.textDirection;
	            if (!formatInfo.horz || formatInfo.angle === 90) {
	                textFormatOptions.horizontalAlignment = 2 - formatInfo.hAlign;
	            }
	           
	       
	    }
	
	    ShapeUtility.syncShapeTextFormatOptions = syncShapeTextFormatOptions;
	
	    function getLineFormatInfo (lineFormat, includeArrowInfo) {
	        if (lineFormat) {
	            var colorInfo = getColorInfo(lineFormat);
	            var result = {
	                width: lineFormat.Weight,
	                capType: lineFormat.CapStyle,
	                joinType: lineFormat.JoinStyle,
	                lineStyle: lineFormat.DashStyle,
	                color: colorInfo.color,
	                transparency: colorInfo.transparency
	            };
	
	            if (includeArrowInfo) {
	                var style = lineFormat.BeginArrowheadStyle;
	                if (style) {
	                    result.beginArrow = {
	                        type: style,
	                        widthType: lineFormat.BeginArrowheadWidth,
	                        lengthType: lineFormat.BeginArrowheadLength
	                    };
	                }
	
	                style = lineFormat.EndArrowheadStyle;
	                if (style) {
	                    result.endArrow = {
	                        type: style,
	                        widthType: lineFormat.EndArrowheadWidth,
	                        lengthType: lineFormat.EndArrowheadLength
	                    };
	                }
	            }
	            
	            return result;
	        }
	    }
	    ShapeUtility.getLineFormatInfo = getLineFormatInfo;
	
	    var lineJoinValues = ["round", "miter", "bevel"];
	    var lineCapValues = ["round", "square", "butt"];
	    var presetLineDashs = ["solid", "dot", "dash", "lgDash", "dashDot", "lgDashDot", "lgDashDotDot", "sysDash", "sysDot", "sysDashDot", "sysDashDotDot"];
	    var excelBuildInDashs = {
	        solid: [],
	        dash: [4, 3],
	        dashDot: [4, 3, 1, 3],
	        dot: [1, 3],
	        lgDash: [8, 3],
	        lgDashDot: [8, 3, 1, 3],
	        lgDashDotDot: [8, 3, 1, 3, 1, 3],
	        sysDash: [3, 1],
	        sysDashDot: [3, 1, 1, 1],
	        sysDashDotDot: [3, 1, 1, 1, 1, 1],
	        sysDot: [1, 1]
	    };
	
	    function getLineDash(dashType, width) {
	        var baseDash = excelBuildInDashs[presetLineDashs[dashType]] || [];
	        return baseDash.map(function(n) { return n * width; });
	    }
	
	    function getLineCapValue(capType) {
	        return lineCapValues[capType];
	    }
	
	    function getLineJoinValue(joinType) {
	        return lineJoinValues[joinType];
	    }
	    
	    function syncShapeLineFormat(options, shapeData) {
	        var includeArrowInfo = !options.endPoints;
	        var lineInfo = getLineFormatInfo(shapeData && shapeData.Line, includeArrowInfo);
	        var stroke = options.stroke;
	        if (lineInfo) {
	            var width = lineInfo.width;
	            stroke.width = width;
	            stroke.capType = getLineCapValue(lineInfo.capType);
	            stroke.joinType = getLineJoinValue(lineInfo.joinType);
	            stroke.color = lineInfo.color;
	            stroke.transparency = lineInfo.transparency;
	            var dashType = lineInfo.lineStyle;
	            if (dashType && width) {
	                stroke.dashType = getLineDash(dashType, width);
	            } else {
	                stroke.dashType = [];
	            }
	            if (includeArrowInfo) {
	                var beginArrow = lineInfo.beginArrow, endArrow = lineInfo.endArrow;
	                if (beginArrow || endArrow) {
	                    options.endPoints = {
	                        beginArrow: beginArrow,
	                        endArrow: endArrow
	                    };
	                }
	            }
	        }
	    }
	    ShapeUtility.syncShapeLineFormat = syncShapeLineFormat;
	
	    function getFillFormatInfo(fillFormat) {
	        if (fillFormat) {
	            return getColorInfo(fillFormat);
	        }
	    }
	
	    function syncShapeFillFormat(fill, shapeData) {
	        var fillInfo = getFillFormatInfo(shapeData && shapeData.Fill);
	        if (fillInfo) {
	            fill.color = fillInfo.color;
	            fill.transparency = fillInfo.transparency;
	        }
	    }
	
	    function syncShapeOptions(model, shapeData, shapeLayer, isCustomShape) {
	       
	       
	       
	       
	        var key = model.id, id = +key || +shapeData.Id, idInfo;
	
	        if (isNaN(id)) {
	            idInfo = shapeLayer.getUniqueShapeId(true );
	           
	           
	           
	           
	            if (!key || !isNaN(key[0]) || shapeLayer.getShapeById(key)) {
	                key = idInfo.key;
	            }
	            id = idInfo.id;
	        } else {
	            id = parseInt(id);
	            idInfo = shapeLayer.ensureUniqueShapeId(id);
	            key = idInfo.key;
	            id = idInfo.id;
	        }
	        model.id = key;
	        shapeData.Id = id;
	
	       
	       
	       
	       
	        var options = isCustomShape ? {} : model.options;
	        if (options) {
	            var textFormatOptions = options.textFormatOptions;
	            if (!textFormatOptions) {
	                textFormatOptions = options.textFormatOptions = {};
	            }
	            syncShapeTextFormatOptions(textFormatOptions, shapeData);
	            var stroke = options.stroke;
	            if (!stroke) {
	                options.stroke = { type: 1 };
	            }
	            syncShapeLineFormat(options, shapeData);
	            var fill = options.fill;
	            if (!fill) {
	                fill = options.fill = { type: 1 };
	            } else if (isNaN(+fill.type)) {
	                fill.type = 1;
	            }
	            syncShapeFillFormat(fill, shapeData);
	        }
	        if (isCustomShape) {
	            $.extend(options, model.options);  
	            model.options = options;           
	        }
	    }
	    ShapeUtility.syncShapeOptions = syncShapeOptions;
	
	    Shapes.ShapeUtility = ShapeUtility;
	}());

/***/ }),
/* 16 */
/***/ (function(module, exports) {

	module.exports = GC.Spread.Sheets;

/***/ }),
/* 17 */
/***/ (function(module, exports) {

	module.exports = GC.Spread.Sheets.FloatingObjects;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var $ = __webpack_require__(16).GC$;
	    var Shapes = __webpack_require__(1);
	    var defineProperty = Shapes.defineProperty;
	
	    function createCT_ScRgbColor() {
	        return {
	            r: 0,
	            g: 0,
	            b: 0,
	            invGammaField: [],
	            gammaField: [],
	            blueOffField: [],
	            blueModField: [],
	            blueField: [],
	            greenOffField: [],
	            greenModField: [],
	            greenField: [],
	            redOffField: [],
	            redModField: [],
	            redField: [],
	            lumOffField: [],
	            lumModField: [],
	            lumField: [],
	            satOffField: [],
	            satModField: [],
	            satField: [],
	            hueOffField: [],
	            hueModField: [],
	            hueField: [],
	            alphaOffField: [],
	            alphaModField: [],
	            alphaField: [],
	            grayField: [],
	            invField: [],
	            compField: [],
	            shadeField: [],
	            tintField: []
	        };
	    }
	    var ShapeStyleData = (function (_super) {
	        $.inherit(ShapeStyleData, _super);
	        function ShapeStyleData(context, fillIdx, lineIdx, effectIdx, fontIdx) {
	            if (fillIdx === void 0) { fillIdx = 0; }
	            if (lineIdx === void 0) { lineIdx = 0; }
	            if (effectIdx === void 0) { effectIdx = 0; }
	            var _this = _super.call(this) || this;
	            _this._context = context;
	            _this._fillIdx = fillIdx;
	            _this._lineIdx = lineIdx;
	            _this._effectIdx = effectIdx;
	            _this._setDefaultFont(fontIdx);
	            return _this;
	        }
	
	        var shapeStylePrototype = ShapeStyleData.prototype;
	        defineProperty(shapeStylePrototype, "Fill", {
	            get: function () {
	                var self = this, fill = self._fill;
	                if (!fill) {
	                    fill = self._fill = new Shapes.FillFormat(self._context);
	                }
	                return fill;
	            }
	        });
	        defineProperty(shapeStylePrototype, "Line", {
	            get: function () {
	                var self = this, line = self._line;
	                if (!line) {
	                    line = self._line = new Shapes.LineFormat(self._context);
	                }
	                return line;
	            }
	        });
	        defineProperty(shapeStylePrototype, "Font", {
	            get: function () {
	                var self = this, font = self._font;
	                if (!font) {
	                    font = self._font = new Shapes.FontFormat(self._context);
	                }
	                return font;
	            }
	        });
	        shapeStylePrototype.FromOOModel = function (t ) {
	            if (!t) {
	                return;
	            }
	            var self = this;
	            self._oomodel = t;
	            self.FromFillFormat(t.fillRef);
	            self.FromLineFormat(t.lnRef);
	            self.FromFontFormat(t.fontRef);
	        };
	        shapeStylePrototype.ToOOModel = function (lossless) {
	            var self = this;
	            var shapeStyle = lossless !== false && self._oomodel || {} ;
	            shapeStyle.fillRef = self.ToFillFormat();
	            shapeStyle.lnRef = self.ToLineFormat();
	            shapeStyle.fontRef = self.ToFontFormat();
	            return shapeStyle;
	        };
	        shapeStylePrototype._setDefaultFont = function (idx) {
	            var font = this.Font;
	            if (idx === 0 ) {
	                font.ThemeFont = Shapes.ThemeFont.Major;
	            } else if (idx === 1 ) {
	                font.ThemeFont = Shapes.ThemeFont.Minor;
	            }
	            font.Size = 11 * 4 / 3;   
	        };
	        shapeStylePrototype.FromFontFormat = function (fontRef ) {
	            if (!fontRef) {
	                return;
	            }
	            this.Font.TextCharacterProperties_FromOOModel(fontRef.TextCharacterProperties);
	            this._setDefaultFont(fontRef.idx);
	        };
	        shapeStylePrototype.ToFontFormat = function () {
	            var fontReference = {} ;
	            var font = this.Font;
	            fontReference.TextCharacterProperties = font.TextCharacterProperties_ToOOModel();
	            if (font.ThemeFont === Shapes.ThemeFont.Major) {
	                fontReference.idx = Shapes.ST_FontCollectionIndex.major;
	            } else if (font.ThemeFont === Shapes.ThemeFont.Minor) {
	                fontReference.idx = Shapes.ST_FontCollectionIndex.minor;
	            }
	            return fontReference;
	        };
	        shapeStylePrototype.FromLineFormat = function (lnRef ) {
	            if (!lnRef) {
	                return;
	            }
	            var self = this;
	            self._lineIdx = lnRef.idx;
	            self.Line.FillInternal.FromOOModel(lnRef.ColorProp, 0 );
	            if (lnRef.idx === 0) {
	                self.Line.Color.ColorType = 0 ;
	            }
	        };
	        shapeStylePrototype.ToLineFormat = function () {
	            var self = this, line = self._oomodel && self._oomodel.lnRef ? self._oomodel.lnRef : {} ;
	            if (self.Line.Color.ColorType === 0 ) {
	                line.ColorProp = {colorFillType: 0 } ;
	                line.ColorProp.scrgbClr = createCT_ScRgbColor() ;
	            } else {
	                line.ColorProp = self.Line.FillInternal.ToOOModel();
	            }
	            line.idx = self._lineIdx;
	            return line;
	        };
	        shapeStylePrototype.FromFillFormat = function (fillRef ) {
	            if (!fillRef) {
	                return;
	            }
	            var self = this;
	            self._fillIdx = fillRef.idx;
	            if (fillRef.idx === 0) {
	                self.Fill.Color.ColorType = 0 ;
	            } else if (fillRef.idx === 1) {
	                self.Fill.FromOOModel(fillRef.ColorProp, 0 );
	            }
	        };
	        shapeStylePrototype.ToFillFormat = function () {
	            var self = this, fill = self._oomodel && self._oomodel.fillRef ? self._oomodel.fillRef : {} ;
	            if (self.Fill.Type === Shapes.FillType.Solid) {
	                if (self.Fill.Color.ColorType === 0 ) {
	                    fill.ColorProp = {colorFillType: 0 } ;
	                    fill.ColorProp.scrgbClr = createCT_ScRgbColor() ;
	                } else {
	                    fill.ColorProp = self.Fill.ToOOModel();
	                }
	            }
	            fill.idx = self._fillIdx;
	            return fill;
	        };
	        shapeStylePrototype.IsDirtyIncludingParent = function (includingParent) {
	            var self = this;
	            if (includingParent === void 0) { includingParent = false; }
	            if (self._fill && self._fill.IsDirtyIncludingParent()) {
	                return true;
	            }
	            if (self._line && self._line.IsDirtyIncludingParent()) {
	                return true;
	            }
	            if (self._font && self._font.IsDirtyIncludingParent()) {
	                return true;
	            }
	            return _super.prototype.IsDirtyIncludingParent.call(self, includingParent);
	        };
	        return ShapeStyleData;
	    }(Shapes.StatefullBase));
	    Shapes.ShapeStyleData = ShapeStyleData;
	}());

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var $ = __webpack_require__(16).GC$;
	    var Shapes = __webpack_require__(1);
	    var ChartUtility = Shapes.ChartUtility;
	    var ShapeUtility = Shapes.ShapeUtility;
	    var defineProperty = Shapes.defineProperty;
	    var deleteFillItems = ChartUtility._deleteFillItems;
	    var PositiveFixedAngleConvert = Shapes.ShapeConstants.PositiveFixedAngleConvert;
	    var keyword_null = null;
	
	    var Common = __webpack_require__(8);
	    var sR = function () {
	        return Common._getResource(Shapes.SR)();
	    };
	
	    function getX(worksheet, col, colOffset) {
	        var x = 0;
	        if (col >= 0) {
	            var index;
	            for (index = 0; index < col; index++) {
	                x += worksheet.getColumnWidth(index, 3);
	            }
	            if (worksheet.getColumnWidth(col, 3) > 0) {
	                x += colOffset;
	            }
	        }
	        return x;
	    }
	    function getY(worksheet, row, rowOffset) {
	        var y = 0;
	        if (row >= 0) {
	            var index;
	            for (index = 0; index < row; index++) {
	                y += worksheet.getRowHeight(index, 3);
	            }
	            if (worksheet.getRowHeight(row, 3) > 0) {
	                y += rowOffset;
	            }
	        }
	        return y;
	    }
	    function getColAndColOffset(worksheet, x, isFromJson) {
	        if(isNaN(x)) {
	            return { col: 0, colOffset: 0 };
	        }
	        var col = 0, colOffset = 0;
	        var tempX = 0, index, colWidth = 0, colCount = worksheet.getColumnCount();
	        for (index = 0; index < colCount; index++) {
	            colWidth = worksheet.getColumnWidth(index, 3);
	            if (tempX + colWidth > x) {
	                col = index;
	                colOffset = x - tempX;
	                break;
	            }
	            tempX += colWidth;
	        }
	        if (isFromJson && col === 0 && colOffset === 0) {
	            var defaultRowHeight = worksheet.defaults.colWidth;
	            while ((tempX + colWidth) < x) {
	                tempX += defaultRowHeight;
	                index++;
	            }
	            col = index;
	            colOffset = x - tempX;
	        }
	        return { col: col, colOffset: colOffset };
	    }
	    Shapes.getColAndColOffset = getColAndColOffset;
	
	    function getRowAndRowOffset(worksheet, y, isFromJson) {
	        var row = 0, rowOffset = 0;
	        var tempY = 0, index, rowHeight = 0, rowCount = worksheet.getRowCount();
	        for (index = 0; index < rowCount; index++) {
	            rowHeight = worksheet.getRowHeight(index, 3);
	            if (tempY + rowHeight > y) {
	                row = index;
	                rowOffset = y - tempY;
	                break;
	            }
	            tempY += rowHeight;
	        }
	        if (isFromJson && row === 0 && rowOffset === 0) {
	            var defaultRowHeight = worksheet.defaults.rowHeight;
	            while (tempY + rowHeight < y) {
	                tempY += defaultRowHeight;
	                index++;
	            }
	            row = index;
	            rowOffset = y - tempY;
	        }
	        return { row: row, rowOffset: rowOffset };
	    }
	    Shapes.getRowAndRowOffset = getRowAndRowOffset;
	
	    function getAvailableAngle(angle) {
	       
	       
	       
	       
	       
	       
	        var newAngle = angle % 360;
	        if (newAngle < 0) {
	            newAngle += 360;
	        }
	        if (45 <= newAngle && newAngle < 135) {
	            newAngle = 90;
	        } else if (135 <= newAngle && newAngle < 225) {
	            newAngle = 180;
	        } else if (225 <= newAngle && newAngle < 315) {
	            newAngle = 270;
	        } else {
	            newAngle = 0;
	        }
	        return newAngle;
	    }
	
	    function calcRotatedPosition(currentX, currentY, angle, centerX, centerY) {
	        currentX -= centerX;
	        currentY -= centerY;
	        angle = angle * Math.PI / 180;
	        var x = currentX * Math.cos(angle) - currentY * Math.sin(angle);
	        var y = currentX * Math.sin(angle) + currentY * Math.cos(angle);
	        return {
	            x: x + centerX,
	            y: y + centerY
	        };
	    }
	
	    var ShapeBaseData = (function () {
	        function ShapeBaseData(worksheet, name, left, top, width, height) {
	            var self = this;
	            self._topAnchorRow = -1;
	            self._leftAnchorCol = -1;
	            self._bottomAnchorRow = -1;
	            self._rightAnchorCol = -1;
	            self._isFlipH = false;
	            self._isFlipV = false;
	            self._placement = 0 ;
	            self._visible = true;
	            self._title = "";
	            self._rotation = 0;
	            self._locked = true;
	            self._isTextBox = false;
	            self._autoShapeType = 0 ;
	            self._worksheet = worksheet;
	            if (name) {
	                self.Name = name;
	            }
	            if (!isNaN(top)) {
	                self._top = top;
	                self._left = left;
	                self._width = width;
	                self._height = height;
	                self._updateStartPosition();
	                self._updateEndPosition();
	            }
	            self.InitFormat();
	        }
	        var shapeBaseDataPrototype = ShapeBaseData.prototype;
	        defineProperty(shapeBaseDataPrototype, "Parent", {
	            get: function () {
	                return this._worksheet;
	            }
	        });
	        defineProperty(shapeBaseDataPrototype, "Name", {
	            get: function () {
	                return this._name;
	            },
	            set: function (value) {
	                var self = this;
	                if (self._name !== value) {
	                    var rs = self.CheckNameUnique(value);
	                    if(rs) {
	                       
	                       return;
	                    }
	                    self._name = value;
	                }
	            }
	        });
	        defineProperty(shapeBaseDataPrototype, "Placement", {
	            get: function () {
	                return this._placement;
	            },
	            set: function (value) {
	                this._placement = value;
	            }
	        });
	        defineProperty(shapeBaseDataPrototype, "Title", {
	            get: function () {
	                return this._title;
	            },
	            set: function (value) {
	                this._title = value;
	            }
	        });
	        defineProperty(shapeBaseDataPrototype, "Rotation", {
	            get: function () {
	                return this._rotation;
	            },
	            set: function (value) {
	                this._rotation = value;
	            }
	        });
	        defineProperty(shapeBaseDataPrototype, "Locked", {
	            get: function () {
	                return this._locked;
	            },
	            set: function (value) {
	                this._locked = value;
	            }
	        });
	        defineProperty(shapeBaseDataPrototype, "AutoShapeType", {
	            get: function () {
	                return this._autoShapeType;
	            },
	            set: function (value) {
	                this._autoShapeType = value;
	            }
	        });
	        defineProperty(shapeBaseDataPrototype, "Connector", {
	            get: function () {
	                return false;
	            }
	        });
	        defineProperty(shapeBaseDataPrototype, "Fill", {
	            get: function () {
	                return this._fill;
	            }
	        });
	        defineProperty(shapeBaseDataPrototype, "Line", {
	            get: function () {
	                return this._line;
	            }
	        });
	        defineProperty(shapeBaseDataPrototype, "ParentGroup", {
	            get: function () {
	                return this._parentGroup;
	            }
	        });
	        shapeBaseDataPrototype._setParentGroup = function (parentGroup) {
	            this._parentGroup = parentGroup;
	        };
	       
	        shapeBaseDataPrototype._setName = function (newName) {
	            if (!this._name) {
	                this.Name = newName;
	            }
	        };
	        defineProperty(shapeBaseDataPrototype, "PictureFormat", {
	            get: function () {
	                var self = this, fill = self._fill;
	                if (fill && (fill.Type === 5  || fill.Type === 3 )) {
	                    return fill.PictureFormat;
	                }
	            }
	        });
	        defineProperty(shapeBaseDataPrototype, "ThreeD", {
	            get: function () {
	                return this._threeDFormat;
	            }
	        });
	        defineProperty(shapeBaseDataPrototype, "Visible", {
	            get: function () {
	                return this._visible;
	            },
	            set: function (value) {
	                this._visible = value;
	            }
	        });
	        defineProperty(shapeBaseDataPrototype, "ShapeStyle", {
	            get: function () {
	                return this._shapeStyle;
	            }
	        });
	        defineProperty(shapeBaseDataPrototype, "TopAnchorRow", {
	            get: function () {
	                return this._topAnchorRow;
	            }
	        });
	        defineProperty(shapeBaseDataPrototype, "TopAnchorRowOffset", {
	            get: function () {
	                return this._topAnchorRowOffset;
	            }
	        });
	        defineProperty(shapeBaseDataPrototype, "LeftAnchorCol", {
	            get: function () {
	                return this._leftAnchorCol;
	            }
	        });
	        defineProperty(shapeBaseDataPrototype, "LeftAnchorColOffset", {
	            get: function () {
	                return this._leftAnchorColOffset;
	            }
	        });
	        defineProperty(shapeBaseDataPrototype, "BottomAnchorRow", {
	            get: function () {
	                return this._bottomAnchorRow;
	            }
	        });
	        defineProperty(shapeBaseDataPrototype, "BottomAnchorRowOffset", {
	            get: function () {
	                return this._bottomAnchorRowOffset;
	            }
	        });
	        defineProperty(shapeBaseDataPrototype, "RightAnchorCol", {
	            get: function () {
	                return this._rightAnchorCol;
	            }
	        });
	        defineProperty(shapeBaseDataPrototype, "RightAnchorColOffset", {
	            get: function () {
	                return this._rightAnchorColOffset;
	            }
	        });
	        defineProperty(shapeBaseDataPrototype, "IsTextBox", {
	            get: function () {
	                return this._isTextBox;
	            }
	        });
	        shapeBaseDataPrototype.IsSpecialShape = function () {
	            var autoShapeType = this.AutoShapeType;
	            return autoShapeType === 25  ||
	                autoShapeType === 26  ||
	                autoShapeType === 27  ||
	                autoShapeType === 29  ||
	                autoShapeType === 30  ||
	                autoShapeType === 31  ||
	                autoShapeType === 32  ||
	                autoShapeType === 182  ;
	        };
	       
	       
	       
	        shapeBaseDataPrototype.InitFormat = function () {
	            var self = this, shapeStyle = self._shapeStyle = self.CreateDefaultShapeStyle();
	            self._fill = new Shapes.FillFormat(self, shapeStyle.Fill, keyword_null, self);
	            self._line = new Shapes.LineFormat(self, shapeStyle.Line);
	            var font = shapeStyle.Font;
	            self._drawingText = new Shapes.DrawingText(self, font, '' , { Size: font.Size }  );
	            self._threeDFormat = new Shapes.ThreeDFormat(self, self._parentGroup && self._parentGroup.ThreeD);
	            self._shadow = new Shapes.ShadowFormat(self);
	            self._glow = new Shapes.GlowFormat(self);
	            self._relfectionFormat = new Shapes.ReflectionFormat(self);
	            self._softEdge = new Shapes.SoftEdgeFormat();
	        };
	
	        shapeBaseDataPrototype.CheckNameUnique = function (value) {
	            if (this._worksheet.shapes.get(value)) {
	                if(this._groupItem) {
	                    return true;
	                }
	                throw new Error(sR().Exp_DuplicatedName);
	            }
	        };
	        shapeBaseDataPrototype.CreateDefaultShapeStyle = function () {
	            return new Shapes.ShapeStyleData(this, 1, 2, 0, 1 );
	        };
	        shapeBaseDataPrototype._updateLocation = function () {
	            var _this = this, worksheet = _this._worksheet;
	
	            var top = getY(worksheet, _this._topAnchorRow, _this._topAnchorRowOffset);
	            _this._top = top;
	
	            var left = getX(worksheet, _this._leftAnchorCol, _this._leftAnchorColOffset);
	            _this._left = left;
	        };
	        shapeBaseDataPrototype._updateSize = function () {
	            var _this = this, worksheet = _this._worksheet;
	
	            var height = getY(worksheet, _this._bottomAnchorRow, _this._bottomAnchorRowOffset) - _this._top;
	            _this._height = Math.max(0, height);
	
	            var width = getX(worksheet, _this._rightAnchorCol, _this._rightAnchorColOffset) - _this._left;
	            _this._width = Math.max(0, width);
	        };
	        shapeBaseDataPrototype.FromOOModel = function (anchor ) {
	            var self = this;
	            self._ctAnchor = anchor;
	            if (!anchor) {
	                return;
	            }
	            var anchorType = anchor.anchorType;
	            var startPoint, endPoint;
	            if (anchorType === 0 ) {
	                startPoint = anchor.startPoint;
	                endPoint = anchor.endPoint;
	                self._topAnchorRow = startPoint.row;
	                self._topAnchorRowOffset = startPoint.rowOffset;
	                self._leftAnchorCol = startPoint.col;
	                self._leftAnchorColOffset = startPoint.colOffset;
	                self._bottomAnchorRow = endPoint.row;
	                self._bottomAnchorRowOffset = endPoint.rowOffset;
	                self._rightAnchorCol = endPoint.col;
	                self._rightAnchorColOffset = endPoint.colOffset;
	                self._placement = anchor.editAs;
	                self._updateLocation();
	                self._updateSize();
	            } else if (anchorType === 1 ) {
	                startPoint = anchor.startPoint;
	                self._topAnchorRow = startPoint.row;
	                self._topAnchorRowOffset = startPoint.rowOffset;
	                self._leftAnchorCol = startPoint.col;
	                self._leftAnchorColOffset = startPoint.colOffset;
	                self._placement = 1 ;
	                self._width = anchor.width;
	                self._height = anchor.height;
	                self._updateLocation();
	
	            } else if (anchorType === 2 ) {
	                self._top = anchor.y;
	                self._left = anchor.x;
	                self._topAnchorRowOffset = 0;
	                self._leftAnchorColOffset = 0;
	                self._width = anchor.width;
	                self._height = anchor.height;
	                self._placement = 2 ;
	            }
	           
	           
	           
	           
	           
	           
	           
	        };
	        shapeBaseDataPrototype._updateStartPosition = function (isFromJson) {
	            var _this = this, worksheet = _this._worksheet;
	
	            var rowInfo = getRowAndRowOffset(worksheet, _this._top, isFromJson);
	            _this._topAnchorRow = rowInfo.row;
	            _this._topAnchorRowOffset = rowInfo.rowOffset;
	
	            var colInfo = getColAndColOffset(worksheet, _this._left, isFromJson);
	            _this._leftAnchorCol = colInfo.col;
	            _this._leftAnchorColOffset = colInfo.colOffset;
	        };
	        shapeBaseDataPrototype._updateEndPosition = function (isFromJson) {
	            var _this = this, worksheet = _this._worksheet;
	
	            var rowInfo = getRowAndRowOffset(worksheet, _this._height + _this._top, isFromJson);
	            _this._bottomAnchorRow = rowInfo.row;
	            _this._bottomAnchorRowOffset = rowInfo.rowOffset;
	
	            var colInfo = getColAndColOffset(worksheet, _this._width + _this._left, isFromJson);
	            _this._rightAnchorCol = colInfo.col;
	            _this._rightAnchorColOffset = colInfo.colOffset;
	        };
	        shapeBaseDataPrototype.ToOOModel = function (lossless) {
	            var self = this;
	            lossless = lossless !== false;
	            var anchor = lossless && self._ctAnchor || { anchorType: 0  } ;
	
	            var rotation = getAvailableAngle(self._rotation);
	            var topRow = self._topAnchorRow,
	                topRowOffset = self._topAnchorRowOffset,
	                leftCol = self._leftAnchorCol,
	                leftColOffset = self._leftAnchorColOffset,
	                bottomRow = self._bottomAnchorRow,
	                bottomRowOffset = self._bottomAnchorRowOffset,
	                rightCol = self._rightAnchorCol,
	                rightColOffset = self._rightAnchorColOffset;
	            if (rotation !== 0) {
	                var top = self._top, left = self._left, width = self._width, height = self._height,
	                    worksheet = self._worksheet;
	               
	                var point1 = calcRotatedPosition(left, top, rotation, left + width / 2, top + height / 2);
	                var point2 = calcRotatedPosition(left + width, top + height, rotation, left + width / 2, top + height / 2);
	               
	                var rowInfo = getRowAndRowOffset(worksheet, Math.min(point1.y, point2.y));
	                var colInfo = getColAndColOffset(worksheet, Math.min(point1.x, point2.x));
	                var endRowInfo = getRowAndRowOffset(worksheet, Math.max(point1.y, point2.y));
	                var endColInfo = getColAndColOffset(worksheet, Math.max(point1.x, point2.x));
	
	                topRow = rowInfo.row;
	                topRowOffset = rowInfo.rowOffset;
	                leftCol = colInfo.col;
	                leftColOffset = colInfo.colOffset;
	                bottomRow = endRowInfo.row;
	                bottomRowOffset = endRowInfo.rowOffset;
	                rightCol = endColInfo.col;
	                rightColOffset = endColInfo.colOffset;
	            }
	
	            var anchorType = anchor.anchorType;
	            if (anchorType === 0 ) {
	               
	               
	
	                anchor.startPoint = { row: topRow, col: leftCol, rowOffset: topRowOffset, colOffset: leftColOffset };
	                anchor.endPoint = { row: bottomRow, col: rightCol, rowOffset: bottomRowOffset, colOffset: rightColOffset };
	                anchor.editAs = self._placement;
	            } else if (anchorType === 1 ) {
	               
	
	                anchor.startPoint = { row: topRow, col: leftCol, rowOffset: topRowOffset, colOffset: leftColOffset };
	                anchor.ext = self.ToCT_PositiveSize2D();
	               
	               
	               
	            }
	            return anchor;
	        };
	        shapeBaseDataPrototype.FromCT_ShapeBase = function (sp ) {
	        };
	        shapeBaseDataPrototype.ToCT_ShapeBase = function (lossless) {  
	           
	           
	        };
	        shapeBaseDataPrototype.FromCT_ShapeProperties = function (shapeProp ) {
	            var self = this;
	            self.FromCT_Transform2D(shapeProp.xfrm);
	            var fill = self._fill;
	            if (shapeProp.solidFill) {
	                fill.FromOOModel(shapeProp.solidFill, 0);
	            } else if (shapeProp.grpFill) {
	                fill.FromOOModel(shapeProp.grpFill, 4);
	            } else if (shapeProp.pattFill) {
	                fill.FromOOModel(shapeProp.pattFill, 1);
	            } else if (shapeProp.gradFill) {
	                fill.FromOOModel(shapeProp.gradFill, 2);
	            } else if (shapeProp.blipFill) {
	                fill.FromOOModel(shapeProp.blipFill, 3);
	            } else if (shapeProp.noFill) {
	                fill.Color.ColorType = 0 ;
	            }
	            if (shapeProp.ln) {
	                self._line.FromOOModel(shapeProp.ln);
	            }
	            var rotation = shapeProp.xfrm.rot / PositiveFixedAngleConvert;
	            if(self._parentGroup) {
	                rotation += self._parentGroup.Rotation;
	            }
	            self.Rotation = rotation;
	            var prstGeom = shapeProp.prstGeom;
	            if (prstGeom) {
	                self.AutoShapeType = ShapeUtility.ToAutoShapeType(prstGeom.prst);
	                var avLst = prstGeom.avLst;
	                self.AdjustValues = ShapeUtility.convertFromExcelAdjustValues(avLst && avLst.gd);
	            } else {
	                self.AutoShapeType = 0 ;
	            }
	            self.FromThreeDFormat(shapeProp);
	            self.FromCT_EffectList(shapeProp.effectLst);
	        };
	        shapeBaseDataPrototype.ToCT_ShapeProperties = function (type, shapeProp , isPrstgeom, lossless) {
	            var self = this;
	            isPrstgeom = isPrstgeom !== false;
	            lossless = lossless !== false;
	            shapeProp.xfrm = self.ToCT_Transform2D();
	            if (isPrstgeom) {
	                shapeProp.prstGeom = self.ToCT_PresetGeometry2D(type, shapeProp.prstGeom);
	            }
	            shapeProp.extLst = {ext: []} ;
	            deleteFillItems(shapeProp);
	            var _fill = self._fill;
	            if (_fill.IsDirtyIncludingParent(true)) {
	                var fill = _fill.ToOOModel(), colorFillType = fill.colorFillType;
	                if (_fill.Visible) {
	                    if (colorFillType === 0 ) {
	                        shapeProp.solidFill = fill;
	                    } else if (colorFillType === 1 ) {
	                        shapeProp.pattFill = fill;
	                    } else if (colorFillType === 2 ) {
	                        shapeProp.gradFill = fill;
	                    } else if (colorFillType === 3 ) {
	                        shapeProp.blipFill = fill;
	                    } else if (colorFillType === 4 ) {
	                        shapeProp.grpFill = { colorFillType: 4  } ;
	                    } else if (colorFillType === 5 ) {
	                        shapeProp.noFill = true;
	                    }
	                } else {
	                    shapeProp.noFill = true;
	                    shapeProp.extLst.ext.push(self.ToFillProperties(fill));
	                }
	                delete fill.colorFillType;
	            }
	            var _line = self._line;
	            if (_line.IsDirtyIncludingParent(true)) {
	                var lineProperties = _line.ToOOModel();
	                if (_line.Visible) {
	                    shapeProp.ln = lineProperties;
	                } else {
	                    shapeProp.ln = {} ;
	                    shapeProp.ln.noFill = true;
	                    shapeProp.extLst.ext.push( { uri: OOXMLFileHelper.HiddenLineUri, Line: lineProperties });
	                }
	            }
	            shapeProp.effectLst = self.ToCT_EffectList(lossless);
	            var threeDFormat = self._threeDFormat.ToOOModel();
	            if (self._threeDFormat.Visible) {
	                shapeProp.scene3d = threeDFormat.Scene3D;
	                shapeProp.sp3d = threeDFormat.Shape3D;
	            } else {
	                var extlist = self.ToHiddenThreedFormatExt(threeDFormat);
	                [].push.apply(shapeProp.extLst.ext, extlist.ext);
	            }
	            return shapeProp;
	        };
	        shapeBaseDataPrototype.ToFillProperties = function (fill ) {
	            var hiddenFill = {} ;
	            hiddenFill.uri = OOXMLFileHelper.HiddenFillUri;
	            var fillProperties = hiddenFill.Fill = {} ;
	            var colorFillType = fill.colorFillType;
	            if (colorFillType === 0 ) {
	                fillProperties.solidFill = fill;
	            } else if (colorFillType === 1 ) {
	                fillProperties.pattFill = fill;
	            } else if (colorFillType === 2 ) {
	                fillProperties.gradFill = fill;
	            } else if (colorFillType === 3 ) {
	                fillProperties.blipFill = fill;
	            } else if (colorFillType === 4 ) {
	                fillProperties.grpFill = { colorFillType: 4  } ;
	            } else if (colorFillType === 5 ) {
	                fillProperties.noFill = true;
	            }
	            delete fill.colorFillType;
	            return hiddenFill;
	        };
	        shapeBaseDataPrototype.ToHiddenThreedFormatExt = function (threeDFormat ) {
	            var extList = {ext: []} ;
	            if (threeDFormat.Scene3D) {
	                var extScene3d = { hiddenExtensionType: 0  } ;
	                extScene3d.uri = OOXMLFileHelper.HiddenScene3dUri;
	                extScene3d.Scene3d = threeDFormat.Scene3D;
	                extList.ext.push(extScene3d);
	            }
	            if (threeDFormat.Shape3D) {
	                var extSp3d = { hiddenExtensionType: 3  } ;
	                extSp3d.uri = OOXMLFileHelper.HiddenSp3dUri;
	                extSp3d.Shape3d = threeDFormat.Shape3D;
	                extList.ext.push(extSp3d);
	            }
	            return extList;
	        };
	        shapeBaseDataPrototype.ToCT_OfficeArtExtensionList = function () {
	            return {ext: []} ;
	        };
	        shapeBaseDataPrototype.FromCT_EffectList = function (effect ) {
	            var self = this;
	            if (!effect) {
	                self._shadow = keyword_null;
	                self._glow = keyword_null;
	                self._softEdge = keyword_null;
	                self._relfectionFormat = keyword_null;
	                return;
	            }
	            if (effect.innerShdw) {
	                self._shadow.FromOOModel(effect.innerShdw);
	            } else if (effect.outerShdw) {
	                self._shadow.FromOOModel(effect.outerShdw);
	            } else if (effect.prstShdw) {
	                self._shadow.FromOOModel(effect.prstShdw);
	            } else {
	                self._shadow.FromOOModel();
	            }
	            self._glow.FromOOModel(effect.glow);
	            self._softEdge.FromOOModel(effect.softEdge);
	            self._relfectionFormat.FromOOModel(effect.reflection);
	        };
	        shapeBaseDataPrototype.ToCT_EffectList = function (lossless) { 
	            var self = this, shadow = self._shadow, glow = self._glow, softEdge = self._softEdge, relfectionFormat = self._relfectionFormat;
	            if (!shadow && !glow && !softEdge && !relfectionFormat) {
	                return;
	            }
	            var effect = {} ;
	            if (shadow) {
	                var shadowEffect = shadow.ToOOModel();
	                if (shadowEffect) {
	                    var shadowEffectType = shadowEffect.shadowEffectType;
	                    if (shadowEffectType === 0 ) {
	                        effect.outerShdw = shadowEffect;
	                    } else if (shadowEffectType === 1 ) {
	                        effect.innerShdw = shadowEffect;
	                    } else if (shadowEffectType === 2 ) {
	                        effect.prstShdw = shadowEffect;
	                    }
	                }
	            }
	            if (glow) {
	                effect.glow = glow.ToOOModel();
	            }
	            if (softEdge) {
	                effect.softEdge = softEdge.ToOOModel();
	            }
	            if (relfectionFormat) {
	                effect.reflection = relfectionFormat.ToOOModel();
	            }
	            return effect;
	        };
	        shapeBaseDataPrototype.FromThreeDFormat = function (shapeProp ) {
	            var threeDFormat = {} ;
	            var _threeDFormat = this._threeDFormat;
	            if (shapeProp.scene3d || shapeProp.sp3d) {
	                threeDFormat.Scene3D = shapeProp.scene3d;
	                threeDFormat.Shape3D = shapeProp.sp3d;
	            } else if (shapeProp.extLst && shapeProp.extLst.ext && shapeProp.extLst.ext.length !== 0) {
	                shapeProp.extLst.ext.forEach(function (item) {
	                    if (item.hiddenExtensionType === 0 ) {
	                        threeDFormat.Scene3D = item.Scene3d;
	                    } else if (item.hiddenExtensionType === 3 ) {
	                        threeDFormat.Shape3D = item.Shape3d;
	                    }
	                });
	                if (threeDFormat.Scene3D || threeDFormat.Shape3D) {
	                    _threeDFormat._InternalVisible = false;
	                    _threeDFormat.Dirty(Shapes.ThreeDFormatStates.Visible);
	                }
	            }
	            _threeDFormat.FromOOModel(threeDFormat);
	        };
	        shapeBaseDataPrototype.FromCT_Transform2D = function (xfrm ) {
	            if (!xfrm) {
	                return;
	            }
	            var self = this;
	            self._isFlipH = xfrm.flipH;
	            self._isFlipV = xfrm.flipV;
	            var rot = xfrm.rot;
	            if (!(rot || self.ParentGroup)) {
	                return;
	            }
	            self.FromCT_Point2D(xfrm.off);
	            self.FromCT_PositiveSize2D(xfrm.ext);
	
	           
	           
	            self._updateStartPosition();
	            self._updateEndPosition();
	        };
	        shapeBaseDataPrototype.ToCT_Transform2D = function () {
	            var self = this, rot;
	            if(self._parentGroup) {
	                rot = self.Rotation - self._parentGroup.Rotation;
	            } else {
	                rot = self.Rotation;
	            }
	            return {
	                flipH: self._isFlipH,
	                flipV: self._isFlipV,
	                rot: parseInt(rot * PositiveFixedAngleConvert),
	                off: self.ToCT_Point2D(),
	                ext: self.ToCT_PositiveSize2D()
	            };
	        };
	        shapeBaseDataPrototype.FromCT_PositiveSize2D = function (ext ) {
	            if (!ext) {
	                return;
	            }
	            var self = this;
	            var scaleWidth = 1;
	            var scaleHeight = 1;
	           
	            var baseOffset = self.baseOffset;
	            if (baseOffset) {
	                scaleWidth = baseOffset.scaleWidth;
	                scaleHeight = baseOffset.scaleHeight;
	            }
	           
	            self._width = (ext.cx * scaleWidth);
	            self._height = (ext.cy * scaleHeight);
	        };
	        shapeBaseDataPrototype.ToCT_PositiveSize2D = function () {
	            return {
	                cx: (this._width),
	                cy: (this._height)
	            };
	        };
	        shapeBaseDataPrototype.FromCT_Point2D = function (off ) {
	            if (!off) {
	                return;
	            }
	            var self = this;
	            var chOffX = 0, chOffY = 0;
	            var offX = 0, offY = 0;
	            var scaleWidth = 1, scaleHeight = 1;
	           
	            var baseOffset = self.baseOffset;
	            if (baseOffset) {
	                chOffX = baseOffset.chOffX;
	                chOffY = baseOffset.chOffY;
	                offX = baseOffset.offX;
	                offY = baseOffset.offY;
	                scaleWidth = baseOffset.scaleWidth;
	                scaleHeight = baseOffset.scaleHeight;
	            }
	           
	            self._left = ((off.x - chOffX) * scaleWidth + offX);
	            self._top = ((off.y - chOffY) * scaleHeight + offY);
	        };
	        shapeBaseDataPrototype.ToCT_Point2D = function () {
	            return {
	                x: (this._left),
	                y: (this._top)
	            };
	        };
	        shapeBaseDataPrototype.ToCT_PresetGeometry2D = function (type, geometry2D ) {
	            var self = this;
	            var presetGeometry2D = geometry2D || {} ;
	            presetGeometry2D.prst = type;
	            var avLst = presetGeometry2D.avLst = {};
	            var adjustValues = ShapeUtility.convertToExcelAdjustValues(self.AdjustValues);
	            if (adjustValues) {
	                avLst.gd = adjustValues;
	            }
	            return presetGeometry2D;
	        };
	        shapeBaseDataPrototype.FromCT_ShapeStyle = function (style ) {
	            if (!style) {
	                return;
	            }
	            this._shapeStyle.FromOOModel(style);
	        };
	        shapeBaseDataPrototype.ToCT_ShapeStyle = function (lossless) {
	            var self = this;
	            if (!self._shapeStyle.IsDirtyIncludingParent()) {
	                return;
	            }
	            var shapeStyle = self._shapeStyle.ToOOModel(lossless);
	            if (!shapeStyle.effectRef) {
	                shapeStyle.effectRef = self.ToCT_StyleMatrixReference(0, 4 , -1);
	            }
	            return shapeStyle;
	        };
	        shapeBaseDataPrototype.ToCT_StyleMatrixReference = function (idx, schemeIndex, shapeVal) {
	            var styleRef = {
	                idx : idx,
	                ColorProp: {
	                    colorFillType: 0,  
	                    schemeClr: {
	                        val: schemeIndex
	                    }
	                }
	            };
	            if (shapeVal !== -1) {
	                styleRef.ColorProp.schemeClr.alpha = { val: shapeVal };
	            }
	            return styleRef;
	        };
	        shapeBaseDataPrototype.FromCT_NonVisualDrawingProps = function (cNvPr ) {
	            if (!cNvPr) {
	                return;
	            }
	            var self = this;
	            self.Id = cNvPr.id;
	            self._setName(cNvPr.name);
	            self.Visible = !cNvPr.hidden;
	            self.Title = cNvPr.title;
	        };
	        shapeBaseDataPrototype.ToCT_NonVisualDrawingProps = function (props ) {
	            var self = this;
	            props.id = self.Id;
	            props.name = self._name;
	            props.hidden = !self.Visible;
	            props.title = self.Title;
	            return props;
	        };
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	        shapeBaseDataPrototype._ToARGBColor = function (styleColor) {
	            if (styleColor.ColorType === 2 ) {
	                return Shapes.ARGBColor.FromArgb(styleColor.Value);
	            }
	            var styleContext = this._worksheet;
	            if (styleContext) {
	                var currentTheme = styleContext.currentTheme();
	                return ChartUtility._ToARGBColor(currentTheme, styleColor);
	            }
	            return new Shapes.ARGBColor();
	        };
	        shapeBaseDataPrototype._ToFont = function (themeFont) {
	            var styleContext = this._worksheet;
	            if (styleContext) {
	                var currentTheme = styleContext.currentTheme();
	                return ChartUtility._ToFont(currentTheme, themeFont);
	            }
	            return "";
	        };
	        defineProperty(shapeBaseDataPrototype, "DrawingType", {
	            get: function () {
	                return 0 ;
	            }
	        });
	        return ShapeBaseData;
	    }());
	    Shapes.ShapeBaseData = ShapeBaseData;
	
	    
	    var ratioMarginInPixel = 96 / 914400;  
	    function applyTextBodyProperties(shapeData, textBody) {
	        var t;
	        var bodyPr = textBody.bodyPr;
	       
	
	       
	       
	       
	       
	       
	       
	       
	       
	       
	
	        t = shapeData._vAlign; 
	        if (t !== bodyPr.anchor) {
	            bodyPr.anchor = t;  
	        }
	        t = shapeData._margins;
	        if (t) {
	            bodyPr.lIns = parseInt(t.left / ratioMarginInPixel);
	            bodyPr.rIns = parseInt(t.right / ratioMarginInPixel);
	            bodyPr.tIns = parseInt(t.top / ratioMarginInPixel);
	            bodyPr.bIns = parseInt(t.bottom / ratioMarginInPixel);
	        }
	
	       
	        t = shapeData._hAlign; 
	        if (t) {
	            var paragraphs = textBody.p;
	            paragraphs.forEach(function (p) {
	                p.pPr.algn = t;
	            });
	        }
	
	       
	        if (isNaN(bodyPr.horzOverflow)) {
	            bodyPr.horzOverflow = 1; 
	        }
	        if (isNaN(bodyPr.vertOverflow)) {
	            bodyPr.vertOverflow = 2;    
	        }
	    }
	
	    var ShapeData = (function (_super) {
	        $.inherit(ShapeData, _super);
	        function ShapeData(worksheet, name, autoShapeType, left, top, width, height) {
	            var _this = this;
	            _super.call(_this, worksheet, name, left, top, width, height);
	            _this._autoShapeType = autoShapeType;
	            _this._shapeType = 0;
	           
	           
	           
	            _this.InitShapeFormat();
	            _this._placement = 0 ;
	        }
	        var ShapeDataPrototype = ShapeData.prototype;
	        defineProperty(ShapeDataPrototype, "Type", {
	            get: function () {
	                return 0 ;
	            }
	        });
	        ShapeDataPrototype.InitShapeFormat = function () {
	            var self = this;
	            self.InitFillFormat();
	            self.InitLineFormat();
	            self.InitFontFormat();
	        };
	        ShapeDataPrototype.FromOOModel = function (anchor ) {
	            var self = this;
	            _super.prototype.FromOOModel.call(self, anchor);
	            self.FromCT_ShapeBase(anchor.sp);
	            if (anchor.isVisible === false) {
	                self._visible = false;
	            }
	        };
	        ShapeDataPrototype.ToOOModel = function (lossless) {
	            var anchor = _super.prototype.ToOOModel.call(this, lossless);
	            anchor.sp = this.ToCT_ShapeBase(lossless);
	
	            return anchor;
	        };
	        ShapeDataPrototype.FromCT_ShapeBase = function (sp ) {
	            if (!sp) {
	                return;
	            }
	            var self = this;
	            var shape = self._shapeOOModel = sp;
	            self.FromCT_ShapeNonVisual(shape.nvSpPr);
	            self.FromCT_ShapeStyle(shape.style);
	            self.FromCT_ShapeProperties(shape.spPr);
	            self.FromCT_TextBody(shape.txBody, shape.textlink);
	        };
	        ShapeDataPrototype.ToCT_ShapeBase = function (lossless) {
	            var self = this;
	            lossless = lossless !== false;
	            var sp = lossless && self._shapeOOModel || { shapeType: 5  } ;
	            sp.nvSpPr = self.ToCT_ShapeNonVisual(lossless);
	            sp.spPr = self.ToCT_ShapeProperties(ShapeUtility.ToST_ShapeType(self.AutoShapeType), sp.spPr || {} , self.AutoShapeType !== 0 , lossless);
	            if (sp.spPr.prstGeom) {
	                sp.style = self.ToCT_ShapeStyle(lossless);
	                sp.txBody = self.ToCT_TextBody();
	                applyTextBodyProperties(self, sp.txBody);
	            }
	            return sp;
	        };
	        ShapeDataPrototype.FromCT_TextBody = function (txBody , textlink) {
	            if (!txBody) {
	                return;
	            }
	           
	            var firstParagraph = txBody.p && txBody.p[0];
	            if (firstParagraph) {
	                var pPr = firstParagraph.pPr;
	                if (pPr && !pPr.defRPr) {
	                    var firstElement = firstParagraph.elements && firstParagraph.elements[0];
	                    var rPr = firstElement && firstElement.rPr;
	                    if (rPr) {
	                        pPr.defRPr = rPr;
	                    }
	                }
	            }
	            var tx = { rich: txBody };
	            this._drawingText.FromOOModel(tx);
	            if (textlink) {
	                this._drawingText.UpdateFiledElementTextLink(textlink);
	            }
	        };
	        ShapeDataPrototype.ToCT_TextBody = function () {
	            var drawingText = this._drawingText;
	            if (drawingText) {
	                var tx = drawingText.ToOOModel();
	                return tx && tx.rich;
	            }
	        };
	        ShapeDataPrototype.ToCT_TextBodyProperties = function () {
	            return {
	                rotField: 0,
	                spcFirstLastParaField: false,
	                numColField: 0,
	                spcColField: 0,
	                rtlColField: false,
	                fromWordArtField: false,
	                forceAAField: false,
	                uprightField: false,
	                compatLnSpcField: false,
	                horzOverflow: 1 ,
	                rtlCol: false,
	                anchor: 0 
	            };
	        };
	        ShapeDataPrototype.ToCT_ShapeNonVisual = function (lossless) {
	            var self = this, shapeOOModel = self._shapeOOModel;
	            var nvSpPr = lossless !== false && shapeOOModel && shapeOOModel.nvSpPr || {} ;
	            var props = nvSpPr.cNvPr || {} ;
	            nvSpPr.cNvPr = self.ToCT_NonVisualDrawingProps(props);
	            nvSpPr.cNvSpPr = nvSpPr.cNvSpPr || {} ;
	            nvSpPr.cNvSpPr.txBox = self._isTextBox;
	            return nvSpPr;
	        };
	        ShapeDataPrototype.FromCT_ShapeNonVisual = function (nvSpPr ) {
	            if (!nvSpPr) {
	                return;
	            }
	            this.FromCT_NonVisualDrawingProps(nvSpPr.cNvPr);
	            this.FromCT_NonVisualDrawingShapeProps(nvSpPr.cNvSpPr);
	        };
	        ShapeDataPrototype.FromCT_NonVisualDrawingShapeProps = function (cNvSpPr ) {
	            if (!cNvSpPr) {
	                return;
	            }
	            this._isTextBox = cNvSpPr.txBox;
	        };
	        ShapeDataPrototype.InitFillFormat = function () {
	            var fill = this._fill;
	            if (this.IsSpecialShape()) {
	                fill.Color.ColorType = 0 ;
	            } else {
	                fill.Color.ObjectThemeColor = 4 ;
	            }
	            fill.PatternColor.ColorType = 3 ;
	            fill.PatternColor.ObjectThemeColor = 0 ;
	        };
	        ShapeDataPrototype.InitLineFormat = function () {
	            var line = this._line;
	            if (this.IsSpecialShape()) {
	                line.Color.ObjectThemeColor = 4 ;
	                line.Weight = 0.5;
	            } else {
	                line.Color.ObjectThemeColor = 4 ;
	                line.Color.TintAndShade = -0.5;
	                line.Weight = 1;
	            }
	            line.PatternColor.RGB = Shapes.ARGBColor.FromArgb(0xffffff);
	        };
	        ShapeDataPrototype.InitFontFormat = function () {
	            var self = this, autoShapeType = self.AutoShapeType, themeColor = autoShapeType === 20  || self.IsSpecialShape() ? 1 : 0 ;
	            self._shapeStyle.Font.Color.ObjectThemeColor = themeColor;
	            self._drawingText.Font.Color.ObjectThemeColor = themeColor;
	        };
	        return ShapeData;
	    }(ShapeBaseData));
	    Shapes.ShapeData = ShapeData;
	
	    var LosslessShapeData = (function (_super) {
	        $.inherit(LosslessShapeData, _super);
	        function LosslessShapeData(worksheet, name, left, top, width, heigt) {
	            _super.call(this, worksheet, name, left, top, width, heigt);
	        }
	        var LosslessShapeDataPrototype = LosslessShapeData.prototype;
	        LosslessShapeDataPrototype.FromCT_ShapeBase = function (sp ) {
	            this._ooModel = sp;
	        };
	        LosslessShapeDataPrototype.ToCT_ShapeBase = function (lossless) {
	            return lossless !== false && this._ooModel;
	        };
	        return LosslessShapeData;
	    }(ShapeBaseData));
	    Shapes.LosslessShapeData = LosslessShapeData;
	
	    function OOXMLFileHelper() {
	    }
	    OOXMLFileHelper.HiddenScene3dUri = "{31F19639-BCED-4A60-ADC4-E9642A236FB7}";
	    OOXMLFileHelper.HiddenSp3dUri = "{E45631CC-5BF2-4C18-A39C-3461C7D3F71A}";
	    OOXMLFileHelper.HiddenFillUri = "{909E8E84-426E-40DD-AFC4-6F175D3DCCD1}";
	    OOXMLFileHelper.HiddenLineUri = "{91240B29-F687-4F45-9708-019B960494DF}";
	    Shapes.OOXMLFileHelper = OOXMLFileHelper;
	}());

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var $ = __webpack_require__(16).GC$;
	    var Shapes = __webpack_require__(1);
	    var defineProperty = Shapes.defineProperty;
	    var deleteFillItems = Shapes.ChartUtility._deleteFillItems;
	    var PositiveFixedAngleConvert = Shapes.ShapeConstants.PositiveFixedAngleConvert;
	    var keyword_undefined = void 0;
	
	    var GroupShapeData = (function (_super) {
	        $.inherit(GroupShapeData, _super);
	        function GroupShapeData(worksheet, name, left, top, width, height) {
	            _super.call(this, worksheet, name, left, top, width, height);
	            this._shapeType = 2;
	        }
	        var GroupShapeDataPrototype = GroupShapeData.prototype;
	        defineProperty(GroupShapeDataPrototype, "GroupItems", {
	            get: function () {
	                var self = this;
	                if (!self._groupItems) {
	                    self._groupItems = new Shapes.GroupShapesData();
	                }
	                return self._groupItems;
	            }
	        });
	        defineProperty(GroupShapeDataPrototype, "DrawingType", {
	            get: function () {
	                return 4 ;
	            }
	        });
	        defineProperty(GroupShapeDataPrototype, "Type", {
	            get: function () {
	                return 3 ;
	            }
	        });
	        defineProperty(GroupShapeDataPrototype, "PictureFormat", {
	            get: function () {
	                return this.Fill.PictureFormat;
	            }
	        });
	        defineProperty(GroupShapeDataPrototype, "LosslessGroupItems", {
	            get: function () {
	                var self = this;
	                if (!self._losslessGroupItems) {
	                    self._losslessGroupItems = new Shapes.GroupShapesData();
	                }
	                return self._losslessGroupItems;
	            }
	        });
	        GroupShapeDataPrototype.FromOOModel = function (anchor ) {
	            var self = this;
	            _super.prototype.FromOOModel.call(self, anchor);
	            self.FromCT_ShapeBase(anchor.grpSp);
	            if (anchor.isVisible === false) {
	                self._visible = false;
	            }
	        };
	        GroupShapeDataPrototype.ToOOModel = function (lossless) {
	            lossless = lossless !== false;
	            var anchor = _super.prototype.ToOOModel.call(this, lossless);
	            anchor.grpSp = this.ToCT_ShapeBase(lossless);
	            return anchor;
	        };
	        GroupShapeDataPrototype.ToChildShapes = function (groupItems, lossless) {
	            lossless = lossless !== false;
	            var shapeBase = [], self = this;
	            groupItems.Items.forEach(function (item) {
	                item._setParentGroup(self);
	                shapeBase.push(item.ToCT_ShapeBase(lossless));
	            });
	            return shapeBase;
	        };
	        GroupShapeDataPrototype.FromChildShapes = function (childShaps) {
	            var self = this, worksheet = self._worksheet;
	            var baseOffset = self.baseOffset;
	            childShaps.forEach(function (item) {
	                var childShape = null;
	                var shapeType = item.shapeType, isGroupShape;
	                if (shapeType === 5 ) {
	                    childShape = new Shapes.ShapeData(worksheet);
	                } else if (shapeType === 3 ) {
	                    isGroupShape = true;
	                    childShape = new GroupShapeData(worksheet);
	                } else if (shapeType === 4 ) {
	                    childShape = new Shapes.ConnectorShapeData(worksheet);
	                } else if (shapeType === 0 ) {
	                    childShape = new Shapes.LosslessShapeData(worksheet);
	                }
	                if (childShape) {
	                    childShape._groupItem = true;
	                    childShape._setParentGroup(self);
	                    childShape.baseOffset = baseOffset;
	                    if (isGroupShape) { 
	                       
	                        childShape.FromOOModel({ grpSp: item });
	                    } else {
	                        childShape.FromCT_ShapeBase(item);
	                    }
	                    delete childShape._groupItem;
	                    self.GroupItems.Add(childShape, self);
	                }
	            });
	        };
	        GroupShapeDataPrototype.ToCT_GroupShapeProperties = function (lossless) {
	            var self = this;
	            lossless = lossless !== false;
	            var shapeProp = lossless && self._groupShapeOOModel && self._groupShapeOOModel.grpSpPr || {} ;
	            shapeProp.xfrm = self.ToCT_GroupTransform2D(lossless);
	            deleteFillItems(shapeProp);
	            var _fill = self._fill;
	            if (_fill) {
	                var fill = _fill.ToOOModel(lossless);
	                if (fill) {
	                    if (fill.colorFillType === 0 ) {
	                        shapeProp.solidFill = fill;
	                    } else if (fill.colorFillType === 1 ) {
	                        shapeProp.pattFill = fill;
	                    } else if (fill.colorFillType === 2 ) {
	                        shapeProp.gradFill = fill;
	                    } else if (fill.colorFillType === 3 ) {
	                        shapeProp.blipFill = fill;
	                    } else if (fill.colorFillType === 5 ) {
	                        shapeProp.noFill = true;
	                    } else {
	                        shapeProp.noFill = true;
	                    }
	                    delete fill.colorFillType;
	                }
	            }
	            shapeProp.effectLst = self.ToCT_EffectList(lossless);
	            var _threeDFormat = self._threeDFormat;
	            if (_threeDFormat.Visible) {
	                var threeDFormat = _threeDFormat.ToOOModel(lossless);
	                shapeProp.scene3d = threeDFormat.Scene3D;
	            }
	            return shapeProp;
	        };
	        GroupShapeDataPrototype.FromCT_GroupShapeProperties = function (grpSpPr ) {
	            var self = this;
	            self.FromCT_GroupTransform2D(grpSpPr.xfrm);
	            var _fill = self._fill;
	            _fill.ParentStateful = self._shapeStyle.Fill;
	            if (grpSpPr.solidFill) {
	                _fill.FromOOModel(grpSpPr.solidFill, 0);
	            } else if (grpSpPr.grpFill) {
	                _fill.FromOOModel(grpSpPr.grpFill, 4);
	            } else if (grpSpPr.pattFill) {
	                _fill.FromOOModel(grpSpPr.pattFill, 1);
	            } else if (grpSpPr.gradFill) {
	                _fill.FromOOModel(grpSpPr.gradFill, 2);
	            } else if (grpSpPr.blipFill) {
	                _fill.FromOOModel(grpSpPr.blipFill, 3);
	            } else if (grpSpPr.noFill) {
	                _fill.Color.ColorType = 0 ;
	            }
	            self.Rotation = grpSpPr.xfrm.rot / PositiveFixedAngleConvert;
	            self.FromGroupThreeDFormat(grpSpPr);
	            self.FromCT_EffectList(grpSpPr.effectLst);
	        };
	        GroupShapeDataPrototype.ToCT_GroupShapeNonVisual = function (lossless) {
	            var self = this;
	            lossless = lossless !== false;
	            var ooModel = lossless && self._groupShapeOOModel;
	            var groupShapeVisual = ooModel && ooModel.nvGrpSpPr || {};
	            groupShapeVisual.cNvPr = groupShapeVisual.cNvPr || {};
	            groupShapeVisual.cNvPr.name = self._name;
	            groupShapeVisual.cNvPr.id = self.Id;
	            groupShapeVisual.cNvPr.hidden = !self.Visible;
	            groupShapeVisual.cNvGrpSpPr = groupShapeVisual.cNvGrpSpPr || {};
	            return groupShapeVisual;
	        };
	        GroupShapeDataPrototype.FromCT_GroupShapeNonVisual = function (nvGrpSpPr ) {
	            var self = this, cNvPr = nvGrpSpPr.cNvPr;
	            self._setName(cNvPr.name);
	            self.Id = cNvPr.id;
	            self.Visible = !cNvPr.hidden;
	        };
	        GroupShapeDataPrototype.FromCT_GroupTransform2D = function (trans2d ) {
	            if (!trans2d) {
	                return;
	            }
	            var self = this;
	            self.Rotation = trans2d.rot / PositiveFixedAngleConvert;
	            self.FromCT_Point2D(trans2d.off);
	            self.FromCT_PositiveSize2D(trans2d.ext);
	            var scaleWidth = 1, scaleHeight = 1;
	            var baseOffset = self.baseOffset;
	            if (baseOffset) {
	               
	                scaleWidth = baseOffset.scaleWidth;
	                scaleHeight = baseOffset.scaleHeight;
	            }
	            
	           
	            self.baseOffset = {
	                chOffX: trans2d.chOff.x,
	                chOffY: trans2d.chOff.y,
	                offX: trans2d.off.x,
	                offY: trans2d.off.y,
	                scaleWidth: scaleWidth * trans2d.ext.cx / trans2d.chExt.cx,
	                scaleHeight: scaleHeight * trans2d.ext.cy / trans2d.chExt.cy,
	            };
	        };
	        GroupShapeDataPrototype.ToCT_GroupTransform2D = function (lossless) {
	            var self = this, ooModel = self._groupShapeOOModel;
	            lossless = lossless !== false;
	            var trans2d = lossless && ooModel && ooModel.grpSpPr && ooModel.grpSpPr.xfrm || {};
	            trans2d.rot = parseInt(self.Rotation * PositiveFixedAngleConvert);
	            trans2d.off = self.ToCT_Point2D();
	            trans2d.ext = self.ToCT_PositiveSize2D();
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	                trans2d.chOff =
	                    {
	                        x: trans2d.off.x,
	                        y: trans2d.off.y
	                    };
	                trans2d.chExt =
	                    {
	                        cx: trans2d.ext.cx,
	                        cy: trans2d.ext.cy
	                    };
	           
	            return trans2d;
	        };
	        GroupShapeDataPrototype.FromCT_ShapeBase = function (sp ) {
	            if (!sp) {
	                return;
	            }
	            var self = this;
	            var shape = self._groupShapeOOModel = sp;
	            self.FromCT_GroupShapeNonVisual(shape.nvGrpSpPr);
	            self.FromCT_GroupShapeProperties(shape.grpSpPr);
	            self.FromChildShapes(shape.sp);
	        };
	        GroupShapeDataPrototype.ToCT_ShapeBase = function (lossless) {
	            var self = this;
	            lossless = lossless !== false;
	            var groupShape = lossless && self._groupShapeOOModel || { shapeType: 3  };
	            groupShape.nvGrpSpPr = self.ToCT_GroupShapeNonVisual(lossless);
	            groupShape.grpSpPr = self.ToCT_GroupShapeProperties(lossless);
	            groupShape.sp = self.ToChildShapes(self.GroupItems, lossless);
	            return groupShape;
	        };
	        GroupShapeDataPrototype.FromGroupThreeDFormat = function (grpSpPr ) {
	            var threeDFormat = {};
	            var _threeDFormat = this._threeDFormat;
	            if (grpSpPr.scene3d) {
	                threeDFormat.Scene3D = grpSpPr.scene3d;
	            } else if (grpSpPr.extLst && grpSpPr.extLst.ext && grpSpPr.extLst.ext.length !== 0) {
	                grpSpPr.extLst.ext.forEach(function (item) {
	                    if (item.hiddenExtensionType === 0 ) {
	                        threeDFormat.Scene3D = item.Scene3d;
	                    }
	                });
	                if (threeDFormat.Scene3D) {
	                    _threeDFormat._InternalVisible = false;
	                    _threeDFormat.Dirty(Shapes.ThreeDFormatStates.Visible);
	                }
	            }
	            _threeDFormat.FromOOModel(threeDFormat);
	        };
	        GroupShapeDataPrototype.FromLosslessChildShapes = function (childShaps) {
	            var self = this;
	            childShaps.forEach(function (item) {
	                var childShape = null;
	                if (item.shapeType === 0 ) {
	                    childShape = new Shapes.LosslessShapeData(self._worksheet);
	                    childShape._setParentGroup(self);
	                    childShape.FromCT_ShapeBase(item);
	                    self.LosslessGroupItems.Add(childShape, self);
	                }
	            });
	        };
	        return GroupShapeData;
	    }(Shapes.ShapeBaseData));
	    Shapes.GroupShapeData = GroupShapeData;
	
	    var GroupShapesData  = (function () {
	        function GroupShapesData() {
	        }
	        var GroupShapesDataPrototype = GroupShapesData.prototype;
	        defineProperty(GroupShapesDataPrototype, "ChildList", {
	            get: function () {
	                var self = this;
	                if (!self._childList) {
	                    self._childList = [];
	                }
	                return self._childList;
	            }
	        });
	        defineProperty(GroupShapesDataPrototype, "Items", {
	            get: function () {
	                return this.ChildList;
	            }
	        });
	        GroupShapesDataPrototype.GetByIndex = function (index) {
	            return this.FindShapeByIndex(this, index);
	        };
	        GroupShapesDataPrototype.GetByName = function (name) {
	            return this.FindShapeByName(this, name);
	        };
	        GroupShapesDataPrototype.Add = function (child, parent) {
	            this.ChildList.push(child);
	           
	           
	           
	           
	            var parentBase = parent;
	            var childShapeStyle = child.ShapeStyle;
	            if (childShapeStyle.Fill) {
	                childShapeStyle.Fill.ParentStateful = parentBase.Fill;
	            }
	            if (childShapeStyle.Line) {
	                childShapeStyle.Line.ParentStateful = parentBase.Line;
	            }
	            var childThreedFormat = child.ThreeD;
	            if (childThreedFormat) {
	                childThreedFormat.ParentStateful = parentBase.ThreeD;
	            }
	            var childPictureFillFormat = child.Fill.PictureFormat;
	            if (childPictureFillFormat) {
	                childPictureFillFormat.ParentStateful = parentBase.Fill.PictureFormat;
	            }
	            var childPictureFormat = child.PictureFormat;
	            if (childPictureFormat) {
	                childPictureFormat.ParentStateful = parentBase.PictureFormat;
	            }
	            child._setParentGroup(this);
	        };
	        GroupShapesDataPrototype.Remove = function (shape) {
	            var self = this;
	            if (self.Count <= 0) {
	                return false;
	            }
	            var index = self.ChildList.indexOf(shape);
	            if (index === -1) {
	                return false;
	            }
	            self.ChildList.splice(index, 1);
	            delete shape._parentGroup;
	            return true;
	        };
	        defineProperty(GroupShapesDataPrototype, "Count", {
	            get: function () {
	                return this.GetGroupItemCount();
	            }
	        });
	        defineProperty(GroupShapesDataPrototype, "InternalCount", {
	            get: function () {
	                return this.ChildList.length;
	            }
	        });
	        GroupShapesDataPrototype.FindShapeByIndex = function (group, index, counter) {
	            if (counter === keyword_undefined) { counter = 0; }
	            var self = this;
	            group.ChildList.forEach(function (item) {
	                if (item._shapeType === 2 ) {
	                    var groupShape = item;
	                    var shape = self.FindShapeByIndex(groupShape.GroupItems, index, counter);
	                    if (shape) {
	                        return shape;
	                    }
	                    counter += groupShape.GroupItems.InternalCount;
	                } else {
	                    if (counter === index) {
	                        return item;
	                    }
	                    counter++;
	                }
	            });
	        };
	        GroupShapesDataPrototype.FindShapeByName = function (group, name) {
	            var self = this;
	            group.ChildList.forEach(function (item) {
	                if (item.Name === name) {
	                    return item;
	                } else if (item._shapeType === 2 ) {
	                    var groupShape = item;
	                    var result = self.FindShapeByName(groupShape.GroupItems, name);
	                    if (result) {
	                        return result;
	                    }
	                }
	            });
	        };
	        GroupShapesDataPrototype.GetGroupItemCount = function () {
	            var count = 0;
	            this.ChildList.forEach(function (item) {
	                if (item._shapeType === 2 ) {
	                    count += item.GroupItems.GetGroupItemCount();
	                } else {
	                    count += 1;
	                }
	            });
	            return count;
	        };
	        return GroupShapesData;
	    }());
	    Shapes.GroupShapesData = GroupShapesData;
	}());

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var $ = __webpack_require__(16).GC$;
	    var Shapes = __webpack_require__(1);
	    var defineProperty = Shapes.defineProperty;
	
	    var Common = __webpack_require__(8);
	    var sR = function () {
	        return Common._getResource(Shapes.SR)();
	    };
	
	    var math_min = Math.min, math_abs = Math.abs;
	    var SU = Shapes.ShapeUtility;
	
	    function findShapeDataByReferedId(shapeDatas, id, idMaps) {
	        id = idMaps[id] || id; 
	        for (var i = 0, count = shapeDatas.length; i < count; i++) {
	            var item = shapeDatas[i];
	            if (item.Id === id) {
	                return item;
	            }
	           
	            if (item.GroupItems) {
	                var t = findShapeDataByReferedId(item.GroupItems.Items, id, idMaps);
	                if (t) {
	                    return t;
	                }
	            }
	        }
	    }
	
	    var ConnectorFormatData
	        = (function () {
	            function ConnectorFormatData(worksheet, connectorShapeData) {
	                this._beginConnectionSite = -1;
	                this._endConnectionSite = -1;
	                this._worksheet = worksheet;
	                this._shapeData = connectorShapeData;  
	            }
	            var ConnectorFormatDataPrototype = ConnectorFormatData.prototype;
	            defineProperty(ConnectorFormatDataPrototype, "DrawingType", {
	                get: function () {
	                    return 3 ;
	                }
	            });
	            defineProperty(ConnectorFormatDataPrototype, "BeginConnected", {
	                get: function () {
	                    return this._beginShapeName;
	                },
	                set: function (value) {
	                    this._beginShapeName = value;
	                }
	            });
	            defineProperty(ConnectorFormatDataPrototype, "BeginConnectedShape", {
	                get: function () {
	                    var name = this._beginShapeName;
	                    return name && this._worksheet.shapes.get(name);
	                }
	            });
	            defineProperty(ConnectorFormatDataPrototype, "BeginConnectionSite", {
	                get: function () {
	                    return this._beginConnectionSite;
	                },
	                set: function (value) {
	                    this._beginConnectionSite = value;
	                }
	            });
	            defineProperty(ConnectorFormatDataPrototype, "EndConnected", {
	                get: function () {
	                    return this._endShapeName;
	                },
	                set: function (value) {
	                    this._endShapeName = value;
	                }
	            });
	            defineProperty(ConnectorFormatDataPrototype, "EndConnectedShape", {
	                get: function () {
	                    var name = this._endShapeName;
	                    return name && this._worksheet.shapes.get(name);
	                }
	            });
	            defineProperty(ConnectorFormatDataPrototype, "EndConnectionSite", {
	                get: function () {
	                    return this._endConnectionSite;
	                },
	                set: function (value) {
	                    this._endConnectionSite = value;
	                }
	            });
	            defineProperty(ConnectorFormatDataPrototype, "Type", {
	                get: function () {
	                    return this._type;
	                },
	                set: function (value) {
	                    this._type = value;
	                }
	            });
	            defineProperty(ConnectorFormatDataPrototype, "ConnectionSiteDic", {
	                get: function () {
	                    var self = this;
	                    if (!self._connectionSiteDic) {
	                        self.InitConnectionSiteDic();
	                    }
	                    return self._connectionSiteDic;
	                }
	            });
	            ConnectorFormatDataPrototype.InitConnectionSiteDic = function () {
	                var dic = this._connectionSiteDic = {};
	                dic[1] = 4;
	                dic[2] = 6;
	                dic[3] = 4;
	                dic[4] = 4;
	                dic[5] = 4;
	                dic[6] = 8;
	                dic[7] = 6;
	                dic[8] = 6;
	                dic[9] = 8;
	                dic[10] = 6;
	                dic[11] = 4;
	                dic[12] = 6;
	                dic[13] = 5;
	                dic[14] = 6;
	                dic[15] = 8;
	                dic[16] = 4;
	                dic[17] = 8;
	                dic[18] = 8;
	                dic[19] = 8;
	                dic[20] = 3;
	                dic[21] = 2;
	                dic[22] = 7;
	                dic[23] = 4;
	                dic[24] = 4;
	                dic[25] = 3;
	                dic[26] = 4;
	                dic[27] = 4;
	                dic[28] = 4;
	                dic[29] = 3;
	                dic[30] = 3;
	                dic[31] = 3;
	                dic[32] = 3;
	                dic[33] = 4;
	                dic[34] = 4;
	                dic[35] = 4;
	                dic[36] = 4;
	                dic[37] = 8;
	                dic[38] = 8;
	                dic[39] = 4;
	                dic[40] = 4;
	                dic[41] = 4;
	                dic[42] = 5;
	                dic[43] = 8;
	                dic[44] = 6;
	                dic[45] = 5;
	                dic[46] = 5;
	                dic[47] = 5;
	                dic[48] = 5;
	                dic[49] = 4;
	                dic[50] = 4;
	                dic[51] = 4;
	                dic[52] = 4;
	                dic[53] = 4;
	                dic[54] = 4;
	                dic[55] = 4;
	                dic[56] = 4;
	                dic[57] = 4;
	                dic[58] = 4;
	                dic[59] = 4;
	                dic[60] = 4;
	                dic[61] = 4;
	                dic[62] = 4;
	                dic[63] = 4;
	                dic[64] = 6;
	                dic[65] = 4;
	                dic[66] = 4;
	                dic[67] = 4;
	                dic[68] = 4;
	                dic[69] = 4;
	                dic[70] = 4;
	                dic[71] = 4;
	                dic[72] = 4;
	                dic[73] = 8;
	                dic[74] = 4;
	                dic[75] = 4;
	                dic[76] = 4;
	                dic[77] = 8;
	                dic[78] = 8;
	                dic[79] = 3;
	                dic[80] = 4;
	                dic[81] = 4;
	                dic[82] = 4;
	                dic[83] = 4;
	                dic[84] = 4;
	                dic[85] = 4;
	                dic[86] = 5;
	                dic[87] = 5;
	                dic[88] = 4;
	                dic[89] = 4;
	                dic[90] = 4;
	                dic[91] = 4;
	                dic[92] = 5;
	                dic[93] = 8;
	                dic[94] = 16;
	                dic[95] = 4;
	                dic[96] = 4;
	                dic[97] = 4;
	                dic[98] = 4;
	                dic[99] = 4;
	                dic[100] = 4;
	                dic[101] = 4;
	                dic[102] = 4;
	                dic[103] = 4;
	                dic[104] = 4;
	                dic[105] = 5;
	                dic[106] = 5;
	                dic[107] = 9;
	                dic[108] = 5;
	                dic[109] = 4;
	                dic[110] = 4;
	                dic[111] = 4;
	                dic[112] = 4;
	                dic[113] = 4;
	                dic[114] = 4;
	                dic[115] = 4;
	                dic[116] = 4;
	                dic[117] = 4;
	                dic[118] = 4;
	                dic[119] = 4;
	                dic[120] = 4;
	                dic[121] = 4;
	                dic[122] = 4;
	                dic[123] = 4;
	                dic[124] = 4;
	                dic[125] = 4;
	                dic[126] = 4;
	                dic[127] = 4;
	                dic[128] = 4;
	                dic[129] = 4;
	                dic[130] = 4;
	                dic[131] = 4;
	                dic[132] = 4;
	                dic[133] = 4;
	                dic[134] = 4;
	                dic[135] = 4;
	                dic[136] = 4;
	                dic[137] = 5;
	                dic[138] = 4;
	                dic[139] = 6;
	                dic[140] = 4;
	                dic[141] = 4;
	                dic[142] = 4;
	                dic[143] = 10;
	                dic[144] = 7;
	                dic[145] = 12;
	                dic[146] = 6;
	                dic[147] = 7;
	                dic[148] = 10;
	                dic[149] = 12;
	                dic[150] = 4;
	                dic[151] = 4;
	                dic[152] = 4;
	                dic[153] = 4;
	                dic[154] = 4;
	                dic[155] = 4;
	                dic[156] = 4;
	                dic[157] = 4;
	                dic[158] = 4;
	                dic[159] = 8;
	                dic[160] = 3;
	                dic[161] = 4;
	                dic[162] = 4;
	                dic[163] = 4;
	                dic[164] = 4;
	                dic[165] = 4;
	                dic[166] = 6;
	                dic[167] = 6;
	                dic[168] = 12;
	                dic[169] = 16;
	                dic[170] = 12;
	                dic[171] = 6;
	                dic[172] = 9;
	                dic[173] = 0;
	                dic[174] = 2;
	                dic[175] = 4;
	                dic[176] = 6;
	                dic[177] = 4;
	                dic[178] = 4;
	                dic[179] = 0;
	                dic[180] = 0;
	                dic[181] = 0;
	                dic[182] = 2;
	            };
	            ConnectorFormatDataPrototype.BeginConnect = function (ConnectedShape, ConnectionSite) {
	                var self = this;
	                self._beginShapeName = ConnectedShape.Name;
	                self._beginConnectionSite = ConnectionSite;
	                self.CheckConnectionSiteValid(ConnectedShape.AutoShapeType, ConnectionSite);
	            };
	            ConnectorFormatDataPrototype.CheckConnectionSiteValid = function (autoShapeType, connectionSite) {
	                if (connectionSite < 0 || connectionSite >= this.ConnectionSiteDic[autoShapeType]) {
	                    throw new Error(sR().Exp_InvalidConnectionSite);
	                }
	            };
	            ConnectorFormatDataPrototype.BeginDisconnect = function () {
	                this._beginShapeName = null;
	                this._beginConnectionSite = -1;
	            };
	            ConnectorFormatDataPrototype.EndConnect = function (ConnectedShape, ConnectionSite) {
	                var self = this;
	                self._endShapeName = ConnectedShape.Name;
	                self._endConnectionSite = ConnectionSite;
	                self.CheckConnectionSiteValid(ConnectedShape.AutoShapeType, ConnectionSite);
	            };
	            ConnectorFormatDataPrototype.EndDisconnect = function () {
	                this._endShapeName = null;
	                this._endConnectionSite = -1;
	            };
	            ConnectorFormatDataPrototype.FromOOModel = function (t ) {
	                var self = this, sheet = self._worksheet, idMaps = sheet.shapeLayers[0].model.idMaps;
	                var shapeDatas = sheet.shapes.all()
	                    .map(function (shape) {
	                        return shape._shapeData;
	                    });
	                if (t.stCxn) {
	                    self._beginConnectionSite = t.stCxn.idx;
	                    var shapeBegin = findShapeDataByReferedId(shapeDatas, t.stCxn.id, idMaps);
	                    if (shapeBegin) {
	                        self._beginShapeName = shapeBegin.Name;
	                    } else {
	                       
	                        sheet._delaySetConnectors.push({ target: self, beginId: t.stCxn.id, beginConnectionSite: t.stCxn.idx});
	                    }
	                }
	                if (t.endCxn) {
	                    self._endConnectionSite = t.endCxn.idx;
	                    var shapeEnd = findShapeDataByReferedId(shapeDatas, t.endCxn.id, idMaps);
	                    if (shapeEnd) {
	                        self._endShapeName = shapeEnd.Name;
	                    } else {
	                       
	                        sheet._delaySetConnectors.push({ target: self, endId: t.endCxn.id, endConnectionSite: t.endCxn.idx});
	                    }
	                }
	            };
	            ConnectorFormatDataPrototype.ToOOModel = function (lossless) {
	                var self = this, shape;
	                var connectorFormat = {};
	                var name = self._beginShapeName;
	                if (name) {
	                    shape = self._worksheet.shapes.get(name);
	                    if (shape) {
	                        connectorFormat.stCxn = { 
	                            idx: self._beginConnectionSite,
	                            id: shape._shapeData.Id
	                        };
	                    }
	                }
	                name = self._endShapeName;
	                if (name) {
	                    shape = self._worksheet.shapes.get(name);
	                    if (shape) {
	                        connectorFormat.endCxn = { 
	                            idx: self._endConnectionSite,
	                            id: shape._shapeData.Id
	                        };
	                    }
	                }
	                return connectorFormat;
	            };
	
	            return ConnectorFormatData;
	        }());
	    Shapes.ConnectorFormatData = ConnectorFormatData;
	
	    var ConnectorShapeData = (function (_super) {
	        $.inherit(ConnectorShapeData, _super);
	        function ConnectorShapeData(worksheet, name, connectorType, beginX, beginY, endX, endY) {
	            var _this = this;
	            _super.call(_this, worksheet, name, math_min(beginX, endX), math_min(beginY, endY), math_abs(beginX - endX), math_abs(beginY - endY));
	            _this._shapeType = 1;
	            _this._pointNum = 2;
	            _this._isFlipH = beginX > endX;
	            _this._isFlipV = beginY > endY;
	            _this._connectorFormat = new ConnectorFormatData(worksheet, _this);
	            _this.ConnectorFormat.Type = connectorType;
	            _this.InitLineFormat();
	            _this._pointNum = _this.GetPointNumByType(connectorType);
	        }
	        defineProperty(ConnectorShapeData.prototype, "ConnectorFormat", {
	            get: function () {
	                return this._connectorFormat;
	            }
	        });
	        defineProperty(ConnectorShapeData.prototype, "Connector", {
	            get: function () {
	                return true;
	            }
	        });
	        defineProperty(ConnectorShapeData.prototype, "Type", {
	            get: function () {
	                return 0 ;
	            }
	        });
	        ConnectorShapeData.prototype.ToOOModel = function (lossless) {
	            lossless = lossless !== false;
	            var anchor = _super.prototype.ToOOModel.call(this, lossless);
	            anchor.cxnSp = this.ToCT_ShapeBase(lossless);
	           
	            return anchor;
	        };
	        ConnectorShapeData.prototype.FromOOModel = function (anchor ) {
	            var self = this;
	            _super.prototype.FromOOModel.call(self, anchor);
	            self.FromCT_ShapeBase(anchor.cxnSp);
	            if (anchor.isVisible === false) {
	                self._visible = false;
	            }
	        };
	        ConnectorShapeData.prototype.ToCT_ConnectorNonVisual = function (lossless) {
	            var self = this;
	            lossless = lossless !== false;
	            var nvCxnSpPr = lossless && self._connectOOModel && self._connectOOModel.nvCxnSpPr || {};
	            var props = nvCxnSpPr.cNvPr || {};
	            nvCxnSpPr.cNvPr = self.ToCT_NonVisualDrawingProps(props);
	            nvCxnSpPr.cNvCxnSpPr = self.ConnectorFormat.ToOOModel(lossless);
	            return nvCxnSpPr;
	        };
	        ConnectorShapeData.prototype.FromCT_ConnectorNonVisual = function (nvCxnSpPr ) {
	            var self = this, cNvPr = nvCxnSpPr.cNvPr;
	            self._setName(cNvPr.name);
	            self.Id = cNvPr.id;
	            self.Visible = !cNvPr.hidden;
	            self._connectorFormat.FromOOModel(nvCxnSpPr.cNvCxnSpPr);
	        };
	        ConnectorShapeData.prototype.FromCT_ShapeBase = function (sp ) {
	            var self = this;
	            var shape = self._connectOOModel = sp;
	            self.FromCT_ConnectorNonVisual(shape.nvCxnSpPr);
	            _super.prototype.FromCT_ShapeStyle.call(self, shape.style);
	            _super.prototype.FromCT_ShapeProperties.call(self, shape.spPr);
	            var prst = shape.spPr.prstGeom.prst;
	            self._connectorFormat.Type = SU.ToConnectorType(prst);
	            self._pointNum = SU.GetConnectorPointNum(prst);
	        };
	        ConnectorShapeData.prototype.ToCT_ShapeBase = function (lossless) {
	            var self = this;
	            lossless = lossless !== false;
	            var connector = lossless && self._connectOOModel || { shapeType: 4  };
	            connector.nvCxnSpPr = self.ToCT_ConnectorNonVisual(lossless);
	            var shapeProp = connector.spPr || {};
	            connector.spPr = self.ToCT_ShapeProperties(SU.ToConnectorST_ShapeType(self.ConnectorFormat.Type, self._pointNum), shapeProp, true, lossless);
	            self.CorrectCT_Transform2D(connector.spPr.xfrm);
	            connector.style = self.ToCT_ShapeStyle(lossless);
	            return connector;
	        };
	        ConnectorShapeData.prototype.CorrectCT_Transform2D = function (xfrm ) {
	            xfrm.flipH = this._isFlipH;
	            xfrm.flipV = this._isFlipV;
	        };
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	        ConnectorShapeData.prototype.GetPointNumByType = function (connectorType) {
	            return connectorType === 2  || connectorType === 1  
	                ? 3 : 1;
	        };
	        ConnectorShapeData.prototype.InitLineFormat = function () {
	            var line = this.Line;
	            line.Color.ObjectThemeColor = 4 ;
	            line.Weight = 0.5;
	            line.PatternColor.RGB = 'white';
	        };
	        ConnectorShapeData.prototype.ConnectorFromOOModel = function () {
	            var self = this, connectOOModel = self._connectOOModel;
	            if (connectOOModel && connectOOModel.nvCxnSpPr && connectOOModel.nvCxnSpPr.cNvCxnSpPr) {
	                self._connectorFormat.FromOOModel(connectOOModel.nvCxnSpPr.cNvCxnSpPr);
	            }
	        };
	        ConnectorShapeData.prototype.CreateDefaultShapeStyle = function () {
	            return new Shapes.ShapeStyleData(this, 0, 1, 0, 1 );
	        };
	        return ConnectorShapeData;
	    }(Shapes.ShapeBaseData));
	    Shapes.ConnectorShapeData = ConnectorShapeData;
	}());

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
		'use strict';
	
		var Shapes = __webpack_require__(1);
		var w = "=width",
		h = "=height",
		s = "=MIN(width, height)",
	
		a = "=V.hc",
		b = "=V.vc",
		c = "=V.x1",
		d = "=V.x2",
		e = "=V.y1",
		f = "=V.y2",
	
		A = 3437746.770784939,
		B = 10800000,
		C = 5400000,
		D = 16200000,
		E = "=width/2",
		F = "=height/2";
	
		var presetShapeModels = {
			none: {
				variables: {
					l: 0,
					t: 0,
					r: w,
					b: h
				},
				connectionPoints: [{
						x: 0,
						y: 0
					}, {
						x: w,
						y: h
					}
				],
				path: [[["M", 0, 0], ["L", w, h], {}
					]]
			},
			rectangle: {
				variables: {
					hc: E,
					t: 0,
					l: 0,
					vc: F,
					b: h,
					r: w
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {}
					]]
			},
			parallelogram: {
				variables: {
					adj: 25000,
					ss: s,
					maxAdj: "=100000 * width / V.ss",
					a: "=MIN(MAX(0, V.adj), V.maxAdj)",
					x1: "=V.ss * V.a / 200000",
					x2: "=V.ss * V.a / 100000",
					r: w,
					x6: "=width - V.x1",
					x5: "=width - V.x2",
					x3: "=V.x5 / 2",
					x4: "=width - V.x3",
					wd2: E,
					il: "=V.wd2 * V.a / V.maxAdj",
					q1: "=5 * V.a / V.maxAdj",
					q2: "=(1 + V.q1) / 12",
					_il: "=V.q2 * width",
					it: "=V.q2 * height",
					ir: "=width - V._il",
					b: h,
					ib: "=height - V.it",
					hc: E,
					q3: "=height * V.hc / V.x2",
					y1: "=MIN(MAX(0, V.q3), height)",
					y2: "=height - V.y1",
					t: 0,
					vc: F,
					l: 0
				},
				adjustInfo: [["adj", 25000]],
				connectionPoints: [{
						x: a,
						y: f
					}, {
						x: "=V.x4",
						y: 0
					}, {
						x: "=V.x6",
						y: b
					}, {
						x: "=V.x3",
						y: h
					}, {
						x: a,
						y: e
					}, {
						x: c,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj",
						minX: 0,
						maxX: "maxAdj",
						position: {
							x: "x2",
							y: "t"
						},
						point: [d, 0]
					}
				],
				path: [[["M", 0, h], ["L", d, 0], ["L", w, 0], ["L", "=V.x5", h], ["Z"], {}
					]],
				textRect: {
					left: "=V._il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			trapezoid: {
				variables: {
					adj: 25000,
					ss: s,
					maxAdj: "=50000 * width / V.ss",
					a: "=MIN(MAX(0, V.adj), V.maxAdj)",
					x1: "=V.ss * V.a / 200000",
					x2: "=V.ss * V.a / 100000",
					r: w,
					x3: "=width - V.x2",
					x4: "=width - V.x1",
					wd3: "=width/3",
					il: "=V.wd3 * V.a / V.maxAdj",
					hd3: "=height/3",
					it: "=V.hd3 * V.a / V.maxAdj",
					ir: "=width - V.il",
					hc: E,
					t: 0,
					vc: F,
					b: h,
					l: 0
				},
				adjustInfo: [["adj", 25000]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: c,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: "=V.x4",
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj",
						minX: 0,
						maxX: "maxAdj",
						position: {
							x: "x2",
							y: "t"
						},
						point: [d, 0]
					}
				],
				path: [[["M", 0, h], ["L", d, 0], ["L", "=V.x3", 0], ["L", w, h], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: h
				}
			},
			diamond: {
				variables: {
					ir: "=width * 3 / 4",
					ib: "=height * 3 / 4",
					hc: E,
					t: 0,
					l: 0,
					vc: F,
					b: h,
					r: w,
					wd4: "=width/4",
					hd4: "=height/4"
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				path: [[["M", 0, b], ["L", a, 0], ["L", w, b], ["L", a, h], ["Z"], {}
					]],
				textRect: {
					left: "=V.wd4",
					top: "=V.hd4",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			roundedRectangle: {
				variables: {
					adj: 16667,
					a: "=MIN(MAX(0, V.adj), 50000)",
					ss: s,
					x1: "=V.ss * V.a / 100000",
					r: w,
					x2: "=width - V.x1",
					b: h,
					y2: "=height - V.x1",
					il: "=V.x1 * 29289 / 100000",
					ir: "=width - V.il",
					ib: "=height - V.il",
					hc: E,
					t: 0,
					l: 0,
					vc: F,
					cd2: B,
					cd4: C,
					cx1: "=C(V.x1,V.l,A(V.x1,V.x1,V.cd2),true)",
					cy1: "=C(V.x1,V.x1,A(V.x1,V.x1,V.cd2))",
					_3cd4: D,
					cx2: "=C(V.x1,V.x2,A(V.x1,V.x1,V._3cd4),true)",
					cy2: "=C(V.x1,V.t,A(V.x1,V.x1,V._3cd4))",
					cx3: "=C(V.x1,V.r,A(V.x1,V.x1,0),true)",
					cy3: "=C(V.x1,V.y2,A(V.x1,V.x1,0))",
					cx4: "=C(V.x1,V.x1,A(V.x1,V.x1,V.cd4),true)",
					cy4: "=C(V.x1,V.b,A(V.x1,V.x1,V.cd4))"
				},
				adjustInfo: [["adj", 16667]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj",
						minX: 0,
						maxX: 50000,
						position: {
							x: "x1",
							y: "t"
						},
						point: [c, 0]
					}
				],
				path: [[["M", 0, c], ["E", "=V.cx1", "=V.cy1", c, c, 0, "=A(V.x1,V.x1,V.cd2)", "=A(V.x1,V.x1,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", d, 0], ["E", "=V.cx2", "=V.cy2", c, c, 0, "=A(V.x1,V.x1,V._3cd4)", "=A(V.x1,V.x1,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", w, f], ["E", "=V.cx3", "=V.cy3", c, c, 0, "=A(V.x1,V.x1,0)", "=A(V.x1,V.x1,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", c, h], ["E", "=V.cx4", "=V.cy4", c, c, 0, "=A(V.x1,V.x1,V.cd4)", "=A(V.x1,V.x1,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.il",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			octagon: {
				variables: {
					adj: 29289,
					a: "=MIN(MAX(0, V.adj), 50000)",
					ss: s,
					x1: "=V.ss * V.a / 100000",
					r: w,
					x2: "=width - V.x1",
					b: h,
					y2: "=height - V.x1",
					il: "=V.x1 / 2",
					ir: "=width - V.il",
					ib: "=height - V.il",
					l: 0,
					t: 0
				},
				adjustInfo: [["adj", 29289]],
				connectionPoints: [{
						x: w,
						y: c
					}, {
						x: w,
						y: f
					}, {
						x: d,
						y: h
					}, {
						x: c,
						y: h
					}, {
						x: 0,
						y: f
					}, {
						x: 0,
						y: c
					}, {
						x: c,
						y: 0
					}, {
						x: d,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj",
						minX: 0,
						maxX: 50000,
						position: {
							x: "x1",
							y: "t"
						},
						point: [c, 0]
					}
				],
				path: [[["M", 0, c], ["L", c, 0], ["L", d, 0], ["L", w, c], ["L", w, f], ["L", d, h], ["L", c, h], ["L", 0, f], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.il",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			isoscelesTriangle: {
				variables: {
					adj: 50000,
					a: "=MIN(MAX(0, V.adj), 100000)",
					x1: "=width * V.a / 200000",
					x2: "=width * V.a / 100000",
					wd2: E,
					x3: "=V.x1 + V.wd2",
					t: 0,
					vc: F,
					l: 0,
					b: h,
					r: w
				},
				adjustInfo: [["adj", 50000]],
				connectionPoints: [{
						x: d,
						y: 0
					}, {
						x: c,
						y: b
					}, {
						x: 0,
						y: h
					}, {
						x: d,
						y: h
					}, {
						x: w,
						y: h
					}, {
						x: "=V.x3",
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj",
						minX: 0,
						maxX: 100000,
						position: {
							x: "x2",
							y: "t"
						},
						point: [d, 0]
					}
				],
				path: [[["M", 0, h], ["L", d, 0], ["L", w, h], ["Z"], {}
					]],
				textRect: {
					left: c,
					top: b,
					right: "=V.x3",
					bottom: h
				}
			},
			rightTriangle: {
				variables: {
					it: "=height * 7 / 12",
					ir: "=width * 7 / 12",
					ib: "=height * 11 / 12",
					l: 0,
					t: 0,
					vc: F,
					b: h,
					hc: E,
					r: w,
					wd12: "=width/12"
				},
				connectionPoints: [{
						x: 0,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: 0,
						y: h
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: h
					}, {
						x: a,
						y: b
					}
				],
				path: [[["M", 0, h], ["L", 0, 0], ["L", w, h], ["Z"], {}
					]],
				textRect: {
					left: "=V.wd12",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			oval: {
				variables: {
					wd2: E,
					d2r: A,
					idx: "=V.wd2 * COS(2700000 / V.d2r)",
					hd2: F,
					idy: "=V.hd2 * SIN(2700000 / V.d2r)",
					hc: E,
					il: "=V.hc - V.idx",
					ir: "=V.hc + V.idx",
					vc: F,
					it: "=V.vc - V.idy",
					ib: "=V.vc + V.idy",
					t: 0,
					l: 0,
					b: h,
					r: w,
					cd2: B,
					cd4: C,
					cx1: "=C(V.wd2,V.l,A(V.wd2,V.hd2,V.cd2),true)",
					cy1: "=C(V.hd2,V.vc,A(V.wd2,V.hd2,V.cd2))",
					_3cd4: D,
					cx2: "=C(V.wd2,P(V.cx1,V.wd2,A(V.wd2,V.hd2,(V.cd2 + V.cd4)),true),A(V.wd2,V.hd2,V._3cd4),true)",
					cy2: "=C(V.hd2,P(V.cy1,V.hd2,A(V.wd2,V.hd2,(V.cd2 + V.cd4))),A(V.wd2,V.hd2,V._3cd4))",
					cx3: "=C(V.wd2,P(V.cx2,V.wd2,A(V.wd2,V.hd2,(V._3cd4 + V.cd4)),true),A(V.wd2,V.hd2,0),true)",
					cy3: "=C(V.hd2,P(V.cy2,V.hd2,A(V.wd2,V.hd2,(V._3cd4 + V.cd4))),A(V.wd2,V.hd2,0))",
					cx4: "=C(V.wd2,P(V.cx3,V.wd2,A(V.wd2,V.hd2,(V.cd4)),true),A(V.wd2,V.hd2,V.cd4),true)",
					cy4: "=C(V.hd2,P(V.cy3,V.hd2,A(V.wd2,V.hd2,(V.cd4))),A(V.wd2,V.hd2,V.cd4))"
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: "=V.il",
						y: "=V.it"
					}, {
						x: 0,
						y: b
					}, {
						x: "=V.il",
						y: "=V.ib"
					}, {
						x: a,
						y: h
					}, {
						x: "=V.ir",
						y: "=V.ib"
					}, {
						x: w,
						y: b
					}, {
						x: "=V.ir",
						y: "=V.it"
					}
				],
				path: [[["M", 0, b], ["E", "=V.cx1", "=V.cy1", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.cd2)", "=A(V.wd2,V.hd2,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx2", "=V.cy2", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V._3cd4)", "=A(V.wd2,V.hd2,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx3", "=V.cy3", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,0)", "=A(V.wd2,V.hd2,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx4", "=V.cy4", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.cd4)", "=A(V.wd2,V.hd2,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			hexagon: {
				variables: {
					adj: 25000,
					vf: 115470,
					ss: s,
					maxAdj: "=50000 * width / V.ss",
					a: "=MIN(MAX(0, V.adj), V.maxAdj)",
					hd2: F,
					shd2: "=V.hd2 * V.vf / 100000",
					x1: "=V.ss * V.a / 100000",
					r: w,
					x2: "=width - V.x1",
					d2r: A,
					dy1: "=V.shd2 * SIN(3600000 / V.d2r)",
					vc: F,
					y1: "=V.vc - V.dy1",
					y2: "=V.vc + V.dy1",
					q1: "=V.maxAdj * -1 / 2",
					q2: "=V.a + V.q1",
					q3: "=IF(V.q2 > 0, 4, 2)",
					q4: "=IF(V.q2 > 0, 3, 2)",
					q5: "=IF(V.q2 > 0, V.q1, 0)",
					q6: "=(V.a + V.q5) / V.q1",
					q7: "=V.q6 * V.q4 / -1",
					q8: "=V.q3 + V.q7",
					il: "=width * V.q8 / 24",
					it: "=height * V.q8 / 24",
					ir: "=width - V.il",
					b: h,
					ib: "=height - V.it",
					l: 0,
					t: 0
				},
				adjustInfo: [["adj", 25000], ["vf", 115470]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: d,
						y: f
					}, {
						x: c,
						y: f
					}, {
						x: 0,
						y: b
					}, {
						x: c,
						y: e
					}, {
						x: d,
						y: e
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj",
						minX: 0,
						maxX: "maxAdj",
						position: {
							x: "x1",
							y: "t"
						},
						point: [c, 0]
					}
				],
				path: [[["M", 0, b], ["L", c, e], ["L", d, e], ["L", w, b], ["L", d, f], ["L", c, f], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			cross: {
				variables: {
					adj: 25000,
					a: "=MIN(MAX(0, V.adj), 50000)",
					ss: s,
					x1: "=V.ss * V.a / 100000",
					r: w,
					x2: "=width - V.x1",
					b: h,
					y2: "=height - V.x1",
					d: "=width - height",
					l: 0,
					il: "=IF(V.d > 0, V.l, V.x1)",
					ir: "=IF(V.d > 0, V.r, V.x2)",
					t: 0,
					it: "=IF(V.d > 0, V.x1, V.t)",
					ib: "=IF(V.d > 0, V.y2, V.b)",
					hc: E,
					vc: F
				},
				adjustInfo: [["adj", 25000]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj",
						minX: 0,
						maxX: 50000,
						position: {
							x: "x1",
							y: "t"
						},
						point: [c, 0]
					}
				],
				path: [[["M", 0, c], ["L", c, c], ["L", c, 0], ["L", d, 0], ["L", d, c], ["L", w, c], ["L", w, f], ["L", d, f], ["L", d, h], ["L", c, h], ["L", c, f], ["L", 0, f], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			regularPentagon: {
				variables: {
					hf: 105146,
					vf: 110557,
					wd2: E,
					swd2: "=V.wd2 * V.hf / 100000",
					hd2: F,
					shd2: "=V.hd2 * V.vf / 100000",
					vc: F,
					svc: "=V.vc * V.vf / 100000",
					d2r: A,
					dx1: "=V.swd2 * COS(1080000 / V.d2r)",
					dx2: "=V.swd2 * COS(18360000 / V.d2r)",
					dy1: "=V.shd2 * SIN(1080000 / V.d2r)",
					dy2: "=V.shd2 * SIN(18360000 / V.d2r)",
					hc: E,
					x1: "=V.hc - V.dx1",
					x2: "=V.hc - V.dx2",
					x3: "=V.hc + V.dx2",
					x4: "=V.hc + V.dx1",
					y1: "=V.svc - V.dy1",
					y2: "=V.svc - V.dy2",
					it: "=V.y1 * V.dx2 / V.dx1",
					t: 0,
					b: h
				},
				adjustInfo: [["hf", 105146], ["vf", 110557]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: c,
						y: e
					}, {
						x: d,
						y: f
					}, {
						x: a,
						y: h
					}, {
						x: "=V.x3",
						y: f
					}, {
						x: "=V.x4",
						y: e
					}
				],
				path: [[["M", c, e], ["L", a, 0], ["L", "=V.x4", e], ["L", "=V.x3", f], ["L", d, f], ["Z"], {}
					]],
				textRect: {
					left: d,
					top: "=V.it",
					right: "=V.x3",
					bottom: f
				}
			},
			can: {
				variables: {
					adj: 25000,
					ss: s,
					maxAdj: "=50000 * height / V.ss",
					a: "=MIN(MAX(0, V.adj), V.maxAdj)",
					y1: "=V.ss * V.a / 200000",
					y2: "=V.y1 + V.y1",
					b: h,
					y3: "=height - V.y1",
					hc: E,
					t: 0,
					l: 0,
					vc: F,
					r: w,
					wd2: E,
					cd2: B,
					cx1: "=C(V.wd2,V.l,A(V.wd2,V.y1,V.cd2),true)",
					cy1: "=C(V.y1,V.y1,A(V.wd2,V.y1,V.cd2))",
					cx2: "=C(V.wd2,V.r,A(V.wd2,V.y1,0),true)",
					cy2: "=C(V.y1,V.y3,A(V.wd2,V.y1,0))",
					cx3: "=C(V.wd2,V.l,A(V.wd2,V.y1,V.cd2),true)",
					cy3: "=C(V.y1,V.y1,A(V.wd2,V.y1,V.cd2))",
					cx4: "=C(V.wd2,P(V.cx3,V.wd2,A(V.wd2,V.y1,(V.cd2 + V.cd2)),true),A(V.wd2,V.y1,0),true)",
					cy4: "=C(V.y1,P(V.cy3,V.y1,A(V.wd2,V.y1,(V.cd2 + V.cd2))),A(V.wd2,V.y1,0))",
					cx5: "=C(V.wd2,V.r,A(V.wd2,V.y1,0),true)",
					cy5: "=C(V.y1,V.y1,A(V.wd2,V.y1,0))",
					cx6: "=C(V.wd2,P(V.cx5,V.wd2,A(V.wd2,V.y1,(V.cd2)),true),A(V.wd2,V.y1,V.cd2),true)",
					cy6: "=C(V.y1,P(V.cy5,V.y1,A(V.wd2,V.y1,(V.cd2))),A(V.wd2,V.y1,V.cd2))",
					cx7: "=C(V.wd2,V.r,A(V.wd2,V.y1,0),true)",
					cy7: "=C(V.y1,V.y3,A(V.wd2,V.y1,0))"
				},
				adjustInfo: [["adj", 25000]],
				connectionPoints: [{
						x: a,
						y: f
					}, {
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj",
						minY: 0,
						maxY: "maxAdj",
						position: {
							x: "hc",
							y: "y2"
						},
						point: [a, f]
					}
				],
				path: [[["M", 0, e], ["E", "=V.cx1", "=V.cy1", "=V.wd2", e, 0, "=A(V.wd2,V.y1,V.cd2)", "=A(V.wd2,V.y1,(V.cd2 + -10800000))", "=IF(-10800000 > 0, FALSE, TRUE)"], ["L", w, "=V.y3"], ["E", "=V.cx2", "=V.cy2", "=V.wd2", e, 0, "=A(V.wd2,V.y1,0)", "=A(V.wd2,V.y1,(V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", 0, e], ["E", "=V.cx3", "=V.cy3", "=V.wd2", e, 0, "=A(V.wd2,V.y1,V.cd2)", "=A(V.wd2,V.y1,(V.cd2 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["E", "=V.cx4", "=V.cy4", "=V.wd2", e, 0, "=A(V.wd2,V.y1,0)", "=A(V.wd2,V.y1,(V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["Z"], {
							fillMode: "lighten",
							strokeMode: "false"
						}
					], [["M", w, e], ["E", "=V.cx5", "=V.cy5", "=V.wd2", e, 0, "=A(V.wd2,V.y1,0)", "=A(V.wd2,V.y1,(V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["E", "=V.cx6", "=V.cy6", "=V.wd2", e, 0, "=A(V.wd2,V.y1,V.cd2)", "=A(V.wd2,V.y1,(V.cd2 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["L", w, "=V.y3"], ["E", "=V.cx7", "=V.cy7", "=V.wd2", e, 0, "=A(V.wd2,V.y1,0)", "=A(V.wd2,V.y1,(V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["L", 0, e], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: 0,
					top: f,
					right: w,
					bottom: "=V.y3"
				}
			},
			cube: {
				variables: {
					adj: 25000,
					a: "=MIN(MAX(0, V.adj), 100000)",
					ss: s,
					y1: "=V.ss * V.a / 100000",
					b: h,
					y4: "=height - V.y1",
					y2: "=V.y4 / 2",
					y3: "=(V.y1 + V.b) / 2",
					r: w,
					x4: "=width - V.y1",
					x2: "=V.x4 / 2",
					x3: "=(V.y1 + V.r) / 2",
					t: 0,
					l: 0
				},
				adjustInfo: [["adj", 25000]],
				connectionPoints: [{
						x: "=V.x3",
						y: 0
					}, {
						x: d,
						y: e
					}, {
						x: 0,
						y: "=V.y3"
					}, {
						x: d,
						y: h
					}, {
						x: "=V.x4",
						y: "=V.y3"
					}, {
						x: w,
						y: f
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj",
						minY: 0,
						maxY: 100000,
						position: {
							x: "l",
							y: "y1"
						},
						point: [0, e]
					}
				],
				path: [[["M", 0, e], ["L", "=V.x4", e], ["L", "=V.x4", h], ["L", 0, h], ["Z"], {
							strokeMode: "false"
						}
					], [["M", "=V.x4", e], ["L", w, 0], ["L", w, "=V.y4"], ["L", "=V.x4", h], ["Z"], {
							fillMode: "darkenLess",
							strokeMode: "false"
						}
					], [["M", 0, e], ["L", e, 0], ["L", w, 0], ["L", "=V.x4", e], ["Z"], {
							fillMode: "lightenLess",
							strokeMode: "false"
						}
					], [["M", 0, e], ["L", e, 0], ["L", w, 0], ["L", w, "=V.y4"], ["L", "=V.x4", h], ["L", 0, h], ["Z"], ["M", 0, e], ["L", "=V.x4", e], ["L", w, 0], ["M", "=V.x4", e], ["L", "=V.x4", h], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: 0,
					top: e,
					right: "=V.x4",
					bottom: h
				}
			},
			bevel: {
				variables: {
					adj: 12500,
					a: "=MIN(MAX(0, V.adj), 50000)",
					ss: s,
					x1: "=V.ss * V.a / 100000",
					r: w,
					x2: "=width - V.x1",
					b: h,
					y2: "=height - V.x1",
					vc: F,
					hc: E,
					l: 0,
					t: 0
				},
				adjustInfo: [["adj", 12500]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: d,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: a,
						y: f
					}, {
						x: 0,
						y: b
					}, {
						x: c,
						y: b
					}, {
						x: a,
						y: 0
					}, {
						x: a,
						y: c
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj",
						minX: 0,
						maxX: 50000,
						position: {
							x: "x1",
							y: "t"
						},
						point: [c, 0]
					}
				],
				path: [[["M", c, c], ["L", d, c], ["L", d, f], ["L", c, f], ["Z"], {
							strokeMode: "false"
						}
					], [["M", 0, 0], ["L", w, 0], ["L", d, c], ["L", c, c], ["Z"], {
							fillMode: "lightenLess",
							strokeMode: "false"
						}
					], [["M", 0, h], ["L", c, f], ["L", d, f], ["L", w, h], ["Z"], {
							fillMode: "darkenLess",
							strokeMode: "false"
						}
					], [["M", 0, 0], ["L", c, c], ["L", c, f], ["L", 0, h], ["Z"], {
							fillMode: "lighten",
							strokeMode: "false"
						}
					], [["M", w, 0], ["L", w, h], ["L", d, f], ["L", d, c], ["Z"], {
							fillMode: "darken",
							strokeMode: "false"
						}
					], [["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], ["M", c, c], ["L", d, c], ["L", d, f], ["L", c, f], ["Z"], ["M", 0, 0], ["L", c, c], ["M", 0, h], ["L", c, f], ["M", w, 0], ["L", d, c], ["M", w, h], ["L", d, f], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: c,
					top: c,
					right: d,
					bottom: f
				}
			},
			foldedCorner: {
				variables: {
					adj: 16667,
					a: "=MIN(MAX(0, V.adj), 50000)",
					ss: s,
					dy2: "=V.ss * V.a / 100000",
					dy1: "=V.dy2 / 5",
					r: w,
					x1: "=width - V.dy2",
					x2: "=V.x1 + V.dy1",
					b: h,
					y2: "=height - V.dy2",
					y1: "=V.y2 + V.dy1",
					hc: E,
					t: 0,
					l: 0,
					vc: F
				},
				adjustInfo: [["adj", 16667]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj",
						minX: 0,
						maxX: 50000,
						position: {
							x: "x1",
							y: "b"
						},
						point: [c, h]
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, f], ["L", c, h], ["L", 0, h], ["Z"], {
							strokeMode: "false"
						}
					], [["M", c, h], ["L", d, e], ["L", w, f], ["Z"], {
							fillMode: "darkenLess",
							strokeMode: "false"
						}
					], [["M", c, h], ["L", d, e], ["L", w, f], ["L", c, h], ["L", 0, h], ["L", 0, 0], ["L", w, 0], ["L", w, f], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: 0,
					top: 0,
					right: w,
					bottom: f
				}
			},
			smileyFace: {
				variables: {
					adj: 4653,
					a: "=MIN(MAX(-4653, V.adj), 4653)",
					x1: "=width * 4969 / 21699",
					x2: "=width * 6215 / 21600",
					x3: "=width * 13135 / 21600",
					x4: "=width * 16640 / 21600",
					y1: "=height * 7570 / 21600",
					y3: "=height * 16515 / 21600",
					dy2: "=height * V.a / 100000",
					y2: "=V.y3 - V.dy2",
					y4: "=V.y3 + V.dy2",
					dy3: "=height * V.a / 50000",
					y5: "=V.y4 + V.dy3",
					wd2: E,
					d2r: A,
					idx: "=V.wd2 * COS(2700000 / V.d2r)",
					hd2: F,
					idy: "=V.hd2 * SIN(2700000 / V.d2r)",
					hc: E,
					il: "=V.hc - V.idx",
					ir: "=V.hc + V.idx",
					vc: F,
					it: "=V.vc - V.idy",
					ib: "=V.vc + V.idy",
					wR: "=width * 1125 / 21600",
					hR: "=height * 1125 / 21600",
					t: 0,
					l: 0,
					b: h,
					r: w,
					cd2: B,
					cx1: "=C(V.wd2,V.l,A(V.wd2,V.hd2,V.cd2),true)",
					cy1: "=C(V.hd2,V.vc,A(V.wd2,V.hd2,V.cd2))",
					cx2: "=C(V.wR,V.x2,A(V.wR,V.hR,V.cd2),true)",
					cy2: "=C(V.hR,V.y1,A(V.wR,V.hR,V.cd2))",
					cx3: "=C(V.wR,V.x3,A(V.wR,V.hR,V.cd2),true)",
					cy3: "=C(V.hR,V.y1,A(V.wR,V.hR,V.cd2))",
					cx4: "=C(V.wd2,V.l,A(V.wd2,V.hd2,V.cd2),true)",
					cy4: "=C(V.hd2,V.vc,A(V.wd2,V.hd2,V.cd2))"
				},
				adjustInfo: [["adj", 4653]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: "=V.il",
						y: "=V.it"
					}, {
						x: 0,
						y: b
					}, {
						x: "=V.il",
						y: "=V.ib"
					}, {
						x: a,
						y: h
					}, {
						x: "=V.ir",
						y: "=V.ib"
					}, {
						x: w,
						y: b
					}, {
						x: "=V.ir",
						y: "=V.it"
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj",
						minY: -4653,
						maxY: 4653,
						position: {
							x: "hc",
							y: "y4"
						},
						point: [a, "=V.y4"]
					}
				],
				path: [[["M", 0, b], ["E", "=V.cx1", "=V.cy1", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.cd2)", "=(A(V.wd2,V.hd2,V.cd2)+ 2*PI())", "=IF(21600000 > 0, FALSE, TRUE)"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", d, e], ["E", "=V.cx2", "=V.cy2", "=V.wR", "=V.hR", 0, "=A(V.wR,V.hR,V.cd2)", "=(A(V.wR,V.hR,V.cd2)+ 2*PI())", "=IF(21600000 > 0, FALSE, TRUE)"], ["M", "=V.x3", e], ["E", "=V.cx3", "=V.cy3", "=V.wR", "=V.hR", 0, "=A(V.wR,V.hR,V.cd2)", "=(A(V.wR,V.hR,V.cd2)+ 2*PI())", "=IF(21600000 > 0, FALSE, TRUE)"], {
							fillMode: "darkenLess"
						}
					], [["M", c, f], ["Q", a, "=V.y5", "=V.x4", f], {
							fillMode: "none"
						}
					], [["M", 0, b], ["E", "=V.cx4", "=V.cy4", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.cd2)", "=(A(V.wd2,V.hd2,V.cd2)+ 2*PI())", "=IF(21600000 > 0, FALSE, TRUE)"], ["Z"], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			donut: {
				variables: {
					adj: 25000,
					a: "=MIN(MAX(0, V.adj), 50000)",
					ss: s,
					dr: "=V.ss * V.a / 100000",
					wd2: E,
					iwd2: "=V.wd2 - V.dr",
					hd2: F,
					ihd2: "=V.hd2 - V.dr",
					d2r: A,
					idx: "=V.wd2 * COS(2700000 / V.d2r)",
					idy: "=V.hd2 * SIN(2700000 / V.d2r)",
					hc: E,
					il: "=V.hc - V.idx",
					ir: "=V.hc + V.idx",
					vc: F,
					it: "=V.vc - V.idy",
					ib: "=V.vc + V.idy",
					t: 0,
					l: 0,
					b: h,
					r: w,
					cd2: B,
					cd4: C,
					cx1: "=C(V.wd2,V.l,A(V.wd2,V.hd2,V.cd2),true)",
					cy1: "=C(V.hd2,V.vc,A(V.wd2,V.hd2,V.cd2))",
					_3cd4: D,
					cx2: "=C(V.wd2,P(V.cx1,V.wd2,A(V.wd2,V.hd2,(V.cd2 + V.cd4)),true),A(V.wd2,V.hd2,V._3cd4),true)",
					cy2: "=C(V.hd2,P(V.cy1,V.hd2,A(V.wd2,V.hd2,(V.cd2 + V.cd4))),A(V.wd2,V.hd2,V._3cd4))",
					cx3: "=C(V.wd2,P(V.cx2,V.wd2,A(V.wd2,V.hd2,(V._3cd4 + V.cd4)),true),A(V.wd2,V.hd2,0),true)",
					cy3: "=C(V.hd2,P(V.cy2,V.hd2,A(V.wd2,V.hd2,(V._3cd4 + V.cd4))),A(V.wd2,V.hd2,0))",
					cx4: "=C(V.wd2,P(V.cx3,V.wd2,A(V.wd2,V.hd2,(V.cd4)),true),A(V.wd2,V.hd2,V.cd4),true)",
					cy4: "=C(V.hd2,P(V.cy3,V.hd2,A(V.wd2,V.hd2,(V.cd4))),A(V.wd2,V.hd2,V.cd4))",
					cx5: "=C(V.iwd2,V.dr,A(V.iwd2,V.ihd2,V.cd2),true)",
					cy5: "=C(V.ihd2,V.vc,A(V.iwd2,V.ihd2,V.cd2))",
					cx6: "=C(V.iwd2,P(V.cx5,V.iwd2,A(V.iwd2,V.ihd2,(V.cd2 + -5400000)),true),A(V.iwd2,V.ihd2,V.cd4),true)",
					cy6: "=C(V.ihd2,P(V.cy5,V.ihd2,A(V.iwd2,V.ihd2,(V.cd2 + -5400000))),A(V.iwd2,V.ihd2,V.cd4))",
					cx7: "=C(V.iwd2,P(V.cx6,V.iwd2,A(V.iwd2,V.ihd2,(V.cd4 + -5400000)),true),A(V.iwd2,V.ihd2,0),true)",
					cy7: "=C(V.ihd2,P(V.cy6,V.ihd2,A(V.iwd2,V.ihd2,(V.cd4 + -5400000))),A(V.iwd2,V.ihd2,0))",
					cx8: "=C(V.iwd2,P(V.cx7,V.iwd2,A(V.iwd2,V.ihd2,(-5400000)),true),A(V.iwd2,V.ihd2,V._3cd4),true)",
					cy8: "=C(V.ihd2,P(V.cy7,V.ihd2,A(V.iwd2,V.ihd2,(-5400000))),A(V.iwd2,V.ihd2,V._3cd4))"
				},
				adjustInfo: [["adj", 25000]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: "=V.il",
						y: "=V.it"
					}, {
						x: 0,
						y: b
					}, {
						x: "=V.il",
						y: "=V.ib"
					}, {
						x: a,
						y: h
					}, {
						x: "=V.ir",
						y: "=V.ib"
					}, {
						x: w,
						y: b
					}, {
						x: "=V.ir",
						y: "=V.it"
					}
				],
				controlsInfo: [{
						type: "ahPolar",
						gdRefR: "adj",
						minR: 0,
						maxR: 50000,
						position: {
							x: "dr",
							y: "vc"
						},
						point: ["=V.dr", b]
					}
				],
				path: [[["M", 0, b], ["E", "=V.cx1", "=V.cy1", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.cd2)", "=A(V.wd2,V.hd2,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx2", "=V.cy2", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V._3cd4)", "=A(V.wd2,V.hd2,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx3", "=V.cy3", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,0)", "=A(V.wd2,V.hd2,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx4", "=V.cy4", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.cd4)", "=A(V.wd2,V.hd2,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["Z"], ["M", "=V.dr", b], ["E", "=V.cx5", "=V.cy5", "=V.iwd2", "=V.ihd2", 0, "=A(V.iwd2,V.ihd2,V.cd2)", "=A(V.iwd2,V.ihd2,(V.cd2 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["E", "=V.cx6", "=V.cy6", "=V.iwd2", "=V.ihd2", 0, "=A(V.iwd2,V.ihd2,V.cd4)", "=A(V.iwd2,V.ihd2,(V.cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["E", "=V.cx7", "=V.cy7", "=V.iwd2", "=V.ihd2", 0, "=A(V.iwd2,V.ihd2,0)", "=A(V.iwd2,V.ihd2,(-5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["E", "=V.cx8", "=V.cy8", "=V.iwd2", "=V.ihd2", 0, "=A(V.iwd2,V.ihd2,V._3cd4)", "=A(V.iwd2,V.ihd2,(V._3cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			noSymbol: {
				variables: {
					adj: 18750,
					a: "=MIN(MAX(0, V.adj), 50000)",
					ss: s,
					dr: "=V.ss * V.a / 100000",
					wd2: E,
					iwd2: "=V.wd2 - V.dr",
					hd2: F,
					ihd2: "=V.hd2 - V.dr",
					d2r: A,
					ang: "=(ATAN2(width,height) * V.d2r)",
					ct: "=V.ihd2 * COS(V.ang / V.d2r)",
					st: "=V.iwd2 * SIN(V.ang / V.d2r)",
					m: "=SQRT(V.ct*V.ct + V.st*V.st)",
					n: "=V.iwd2 * V.ihd2 / V.m",
					drd2: "=V.dr / 2",
					dang: "=(ATAN2(V.n,V.drd2) * V.d2r)",
					"2dang": "=V.dang * 2",
					swAng: "=-10800000 + V.2dang",
					t3: "=(ATAN2(width,height) * V.d2r)",
					stAng1: "=V.t3 - V.dang",
					cd2: B,
					stAng2: "=V.stAng1 - V.cd2",
					ct1: "=V.ihd2 * COS(V.stAng1 / V.d2r)",
					st1: "=V.iwd2 * SIN(V.stAng1 / V.d2r)",
					m1: "=SQRT(V.ct1*V.ct1 + V.st1*V.st1)",
					n1: "=V.iwd2 * V.ihd2 / V.m1",
					dx1: "=V.n1 * COS(V.stAng1 / V.d2r)",
					dy1: "=V.n1 * SIN(V.stAng1 / V.d2r)",
					hc: E,
					x1: "=V.hc + V.dx1",
					vc: F,
					y1: "=V.vc + V.dy1",
					x2: "=V.hc - V.dx1",
					y2: "=V.vc - V.dy1",
					idx: "=V.wd2 * COS(2700000 / V.d2r)",
					idy: "=V.hd2 * SIN(2700000 / V.d2r)",
					il: "=V.hc - V.idx",
					ir: "=V.hc + V.idx",
					it: "=V.vc - V.idy",
					ib: "=V.vc + V.idy",
					t: 0,
					l: 0,
					b: h,
					r: w,
					cd4: C,
					cx1: "=C(V.wd2,V.l,A(V.wd2,V.hd2,V.cd2),true)",
					cy1: "=C(V.hd2,V.vc,A(V.wd2,V.hd2,V.cd2))",
					_3cd4: D,
					cx2: "=C(V.wd2,P(V.cx1,V.wd2,A(V.wd2,V.hd2,(V.cd2 + V.cd4)),true),A(V.wd2,V.hd2,V._3cd4),true)",
					cy2: "=C(V.hd2,P(V.cy1,V.hd2,A(V.wd2,V.hd2,(V.cd2 + V.cd4))),A(V.wd2,V.hd2,V._3cd4))",
					cx3: "=C(V.wd2,P(V.cx2,V.wd2,A(V.wd2,V.hd2,(V._3cd4 + V.cd4)),true),A(V.wd2,V.hd2,0),true)",
					cy3: "=C(V.hd2,P(V.cy2,V.hd2,A(V.wd2,V.hd2,(V._3cd4 + V.cd4))),A(V.wd2,V.hd2,0))",
					cx4: "=C(V.wd2,P(V.cx3,V.wd2,A(V.wd2,V.hd2,(V.cd4)),true),A(V.wd2,V.hd2,V.cd4),true)",
					cy4: "=C(V.hd2,P(V.cy3,V.hd2,A(V.wd2,V.hd2,(V.cd4))),A(V.wd2,V.hd2,V.cd4))",
					cx5: "=C(V.iwd2,V.x1,A(V.iwd2,V.ihd2,V.stAng1),true)",
					cy5: "=C(V.ihd2,V.y1,A(V.iwd2,V.ihd2,V.stAng1))",
					cx6: "=C(V.iwd2,V.x2,A(V.iwd2,V.ihd2,V.stAng2),true)",
					cy6: "=C(V.ihd2,V.y2,A(V.iwd2,V.ihd2,V.stAng2))"
				},
				adjustInfo: [["adj", 18750]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: "=V.il",
						y: "=V.it"
					}, {
						x: 0,
						y: b
					}, {
						x: "=V.il",
						y: "=V.ib"
					}, {
						x: a,
						y: h
					}, {
						x: "=V.ir",
						y: "=V.ib"
					}, {
						x: w,
						y: b
					}, {
						x: "=V.ir",
						y: "=V.it"
					}
				],
				controlsInfo: [{
						type: "ahPolar",
						gdRefR: "adj",
						minR: 0,
						maxR: 50000,
						position: {
							x: "dr",
							y: "vc"
						},
						point: ["=V.dr", b]
					}
				],
				path: [[["M", 0, b], ["E", "=V.cx1", "=V.cy1", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.cd2)", "=A(V.wd2,V.hd2,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx2", "=V.cy2", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V._3cd4)", "=A(V.wd2,V.hd2,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx3", "=V.cy3", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,0)", "=A(V.wd2,V.hd2,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx4", "=V.cy4", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.cd4)", "=A(V.wd2,V.hd2,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["Z"], ["M", c, e], ["E", "=V.cx5", "=V.cy5", "=V.iwd2", "=V.ihd2", 0, "=A(V.iwd2,V.ihd2,V.stAng1)", "=A(V.iwd2,V.ihd2,(V.stAng1 + V.swAng))", "=IF(V.swAng > 0, FALSE, TRUE)"], ["Z"], ["M", d, f], ["E", "=V.cx6", "=V.cy6", "=V.iwd2", "=V.ihd2", 0, "=A(V.iwd2,V.ihd2,V.stAng2)", "=A(V.iwd2,V.ihd2,(V.stAng2 + V.swAng))", "=IF(V.swAng > 0, FALSE, TRUE)"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			blockArc: {
				variables: {
					adj1: B,
					adj2: 0,
					adj3: 25000,
					stAng: "=MIN(MAX(0, V.adj1), 21599999)",
					istAng: "=MIN(MAX(0, V.adj2), 21599999)",
					a3: "=MIN(MAX(0, V.adj3), 50000)",
					sw11: "=V.istAng - V.stAng",
					sw12: "=V.sw11 + 21600000",
					swAng: "=IF(V.sw11 > 0, V.sw11, V.sw12)",
					iswAng: "=0 - V.swAng",
					wd2: E,
					d2r: A,
					wt1: "=V.wd2 * SIN(V.stAng / V.d2r)",
					hd2: F,
					ht1: "=V.hd2 * COS(V.stAng / V.d2r)",
					wt3: "=V.wd2 * SIN(V.istAng / V.d2r)",
					ht3: "=V.hd2 * COS(V.istAng / V.d2r)",
					dx1: "=V.wd2 * COS(ATAN2(V.ht1,V.wt1))",
					dy1: "=V.hd2 * SIN(ATAN2(V.ht1,V.wt1))",
					dx3: "=V.wd2 * COS(ATAN2(V.ht3,V.wt3))",
					dy3: "=V.hd2 * SIN(ATAN2(V.ht3,V.wt3))",
					hc: E,
					x1: "=V.hc + V.dx1",
					vc: F,
					y1: "=V.vc + V.dy1",
					x3: "=V.hc + V.dx3",
					y3: "=V.vc + V.dy3",
					ss: s,
					dr: "=V.ss * V.a3 / 100000",
					iwd2: "=V.wd2 - V.dr",
					ihd2: "=V.hd2 - V.dr",
					wt2: "=V.iwd2 * SIN(V.istAng / V.d2r)",
					ht2: "=V.ihd2 * COS(V.istAng / V.d2r)",
					wt4: "=V.iwd2 * SIN(V.stAng / V.d2r)",
					ht4: "=V.ihd2 * COS(V.stAng / V.d2r)",
					dx2: "=V.iwd2 * COS(ATAN2(V.ht2,V.wt2))",
					dy2: "=V.ihd2 * SIN(ATAN2(V.ht2,V.wt2))",
					dx4: "=V.iwd2 * COS(ATAN2(V.ht4,V.wt4))",
					dy4: "=V.ihd2 * SIN(ATAN2(V.ht4,V.wt4))",
					x2: "=V.hc + V.dx2",
					y2: "=V.vc + V.dy2",
					x4: "=V.hc + V.dx4",
					y4: "=V.vc + V.dy4",
					sw0: "=21600000 - V.stAng",
					da1: "=V.swAng - V.sw0",
					g1: "=MAX(V.x1, V.x2)",
					g2: "=MAX(V.x3, V.x4)",
					g3: "=MAX(V.g1, V.g2)",
					r: w,
					ir: "=IF(V.da1 > 0, V.r, V.g3)",
					cd4: C,
					sw1: "=V.cd4 - V.stAng",
					sw2: "=27000000 - V.stAng",
					sw3: "=IF(V.sw1 > 0, V.sw1, V.sw2)",
					da2: "=V.swAng - V.sw3",
					g5: "=MAX(V.y1, V.y2)",
					g6: "=MAX(V.y3, V.y4)",
					g7: "=MAX(V.g5, V.g6)",
					b: h,
					ib: "=IF(V.da2 > 0, V.b, V.g7)",
					cd2: B,
					sw4: "=V.cd2 - V.stAng",
					sw5: "=32400000 - V.stAng",
					sw6: "=IF(V.sw4 > 0, V.sw4, V.sw5)",
					da3: "=V.swAng - V.sw6",
					g9: "=MIN(V.x1, V.x2)",
					g10: "=MIN(V.x3, V.x4)",
					g11: "=MIN(V.g9, V.g10)",
					l: 0,
					il: "=IF(V.da3 > 0, V.l, V.g11)",
					_3cd4: D,
					sw7: "=V._3cd4 - V.stAng",
					sw8: "=37800000 - V.stAng",
					sw9: "=IF(V.sw7 > 0, V.sw7, V.sw8)",
					da4: "=V.swAng - V.sw9",
					g13: "=MIN(V.y1, V.y2)",
					g14: "=MIN(V.y3, V.y4)",
					g15: "=MIN(V.g13, V.g14)",
					t: 0,
					it: "=IF(V.da4 > 0, V.t, V.g15)",
					x5: "=(V.x1 + V.x4) / 2",
					y5: "=(V.y1 + V.y4) / 2",
					x6: "=(V.x3 + V.x2) / 2",
					y6: "=(V.y3 + V.y2) / 2",
					cang1: "=V.stAng - V.cd4",
					cang2: "=V.istAng + V.cd4",
					cang3: "=(V.cang1 + V.cang2) / 2",
					cx1: "=C(V.wd2,V.x1,A(V.wd2,V.hd2,V.stAng),true)",
					cy1: "=C(V.hd2,V.y1,A(V.wd2,V.hd2,V.stAng))",
					cx2: "=C(V.iwd2,V.x2,A(V.iwd2,V.ihd2,V.istAng),true)",
					cy2: "=C(V.ihd2,V.y2,A(V.iwd2,V.ihd2,V.istAng))"
				},
				adjustInfo: [["adj1", 10800000], ["adj2", 0], ["adj3", 25000]],
				connectionPoints: [{
						x: "=V.x5",
						y: "=V.y5"
					}, {
						x: "=V.x6",
						y: "=V.y6"
					}, {
						x: a,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahPolar",
						gdRefAng: "adj1",
						minAng: 0,
						maxAng: 21599999,
						position: {
							x: "x1",
							y: "y1"
						},
						point: [c, e]
					}, {
						type: "ahPolar",
						gdRefR: "adj3",
						minR: 0,
						maxR: 50000,
						gdRefAng: "adj2",
						minAng: 0,
						maxAng: 21599999,
						position: {
							x: "x2",
							y: "y2"
						},
						point: [d, f]
					}
				],
				path: [[["M", c, e], ["E", "=V.cx1", "=V.cy1", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.stAng)", "=A(V.wd2,V.hd2,(V.stAng + V.swAng))", "=IF(V.swAng > 0, FALSE, TRUE)"], ["L", d, f], ["E", "=V.cx2", "=V.cy2", "=V.iwd2", "=V.ihd2", 0, "=A(V.iwd2,V.ihd2,V.istAng)", "=A(V.iwd2,V.ihd2,(V.istAng + V.iswAng))", "=IF(V.iswAng > 0, FALSE, TRUE)"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			heart: {
				variables: {
					dx1: "=width * 49 / 48",
					dx2: "=width * 10 / 48",
					hc: E,
					x1: "=V.hc - V.dx1",
					x2: "=V.hc - V.dx2",
					x3: "=V.hc + V.dx2",
					x4: "=V.hc + V.dx1",
					t: 0,
					hd3: "=height/3",
					y1: "=0 - V.hd3",
					il: "=width / 6",
					ir: "=width * 5 / 6",
					ib: "=height * 2 / 3",
					hd4: "=height/4",
					b: h
				},
				connectionPoints: [{
						x: a,
						y: "=V.hd4"
					}, {
						x: a,
						y: h
					}
				],
				path: [[["M", a, "=V.hd4"], ["B", "=V.x3", e, "=V.x4", "=V.hd4", a, h], ["B", c, "=V.hd4", d, e, a, "=V.hd4"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.hd4",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			lightningBolt: {
				variables: {
					x1: "=width * 5022 / 21600",
					x3: "=width * 8472 / 21600",
					x4: "=width * 8757 / 21600",
					x5: "=width * 10012 / 21600",
					x8: "=width * 12860 / 21600",
					x9: "=width * 13917 / 21600",
					x11: "=width * 16577 / 21600",
					y1: "=height * 3890 / 21600",
					y2: "=height * 6080 / 21600",
					y4: "=height * 7437 / 21600",
					y6: "=height * 9705 / 21600",
					y7: "=height * 12007 / 21600",
					y10: "=height * 14277 / 21600",
					y11: "=height * 14915 / 21600",
					t: 0,
					l: 0,
					r: w,
					b: h,
					_scaleX1: "= width / 21600",
					_scaleY1: "= height / 21600"
				},
				connectionPoints: [{
						x: "=V.x3",
						y: 0
					}, {
						x: 0,
						y: e
					}, {
						x: c,
						y: "=V.y6"
					}, {
						x: "=V.x5",
						y: "=V.y11"
					}, {
						x: w,
						y: h
					}, {
						x: "=V.x11",
						y: "=V.y7"
					}, {
						x: "=V.x8",
						y: f
					}
				],
				path: [[["M", "=8472 * V._scaleX1", 0], ["L", "=12860 * V._scaleX1", "=6080 * V._scaleY1"], ["L", "=11050 * V._scaleX1", "=6797 * V._scaleY1"], ["L", "=16577 * V._scaleX1", "=12007 * V._scaleY1"], ["L", "=14767 * V._scaleX1", "=12877 * V._scaleY1"], ["L", w, h], ["L", "=10012 * V._scaleX1", "=14915 * V._scaleY1"], ["L", "=12222 * V._scaleX1", "=13987 * V._scaleY1"], ["L", "=5022 * V._scaleX1", "=9705 * V._scaleY1"], ["L", "=7602 * V._scaleX1", "=8382 * V._scaleY1"], ["L", 0, "=3890 * V._scaleY1"], ["Z"], {}
					]],
				textRect: {
					left: "=V.x4",
					top: "=V.y4",
					right: "=V.x9",
					bottom: "=V.y10"
				}
			},
			sun: {
				variables: {
					adj: 25000,
					a: "=MIN(MAX(12500, V.adj), 46875)",
					g0: "=50000 - V.a",
					g1: "=V.g0 * 30274 / 32768",
					g2: "=V.g0 * 12540 / 32768",
					g3: "=V.g1 + 50000",
					g4: "=V.g2 + 50000",
					g5: "=50000 - V.g1",
					g6: "=50000 - V.g2",
					g7: "=V.g0 * 23170 / 32768",
					g8: "=50000 + V.g7",
					g9: "=50000 - V.g7",
					g10: "=V.g5 * 3 / 4",
					g11: "=V.g6 * 3 / 4",
					g12: "=V.g10 + 3662",
					g13: "=V.g11 + 3662",
					g14: "=V.g11 + 12500",
					g15: "=100000 - V.g10",
					g16: "=100000 - V.g12",
					g17: "=100000 - V.g13",
					g18: "=100000 - V.g14",
					ox1: "=width * 18436 / 21600",
					oy1: "=height * 3163 / 21600",
					ox2: "=width * 3163 / 21600",
					oy2: "=height * 18436 / 21600",
					x8: "=width * V.g8 / 100000",
					x9: "=width * V.g9 / 100000",
					x10: "=width * V.g10 / 100000",
					x12: "=width * V.g12 / 100000",
					x13: "=width * V.g13 / 100000",
					x14: "=width * V.g14 / 100000",
					x15: "=width * V.g15 / 100000",
					x16: "=width * V.g16 / 100000",
					x17: "=width * V.g17 / 100000",
					x18: "=width * V.g18 / 100000",
					x19: "=width * V.a / 100000",
					wR: "=width * V.g0 / 100000",
					hR: "=height * V.g0 / 100000",
					y8: "=height * V.g8 / 100000",
					y9: "=height * V.g9 / 100000",
					y10: "=height * V.g10 / 100000",
					y12: "=height * V.g12 / 100000",
					y13: "=height * V.g13 / 100000",
					y14: "=height * V.g14 / 100000",
					y15: "=height * V.g15 / 100000",
					y16: "=height * V.g16 / 100000",
					y17: "=height * V.g17 / 100000",
					y18: "=height * V.g18 / 100000",
					hc: E,
					t: 0,
					l: 0,
					vc: F,
					b: h,
					r: w,
					cd2: B,
					cx1: "=C(V.wR,V.x19,A(V.wR,V.hR,V.cd2),true)",
					cy1: "=C(V.hR,V.vc,A(V.wR,V.hR,V.cd2))"
				},
				adjustInfo: [["adj", 25000]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj",
						minX: 12500,
						maxX: 46875,
						position: {
							x: "x19",
							y: "vc"
						},
						point: ["=V.x19", b]
					}
				],
				path: [[["M", w, b], ["L", "=V.x15", "=V.y18"], ["L", "=V.x15", "=V.y14"], ["Z"], ["M", "=V.ox1", "=V.oy1"], ["L", "=V.x16", "=V.y13"], ["L", "=V.x17", "=V.y12"], ["Z"], ["M", a, 0], ["L", "=V.x18", "=V.y10"], ["L", "=V.x14", "=V.y10"], ["Z"], ["M", "=V.ox2", "=V.oy1"], ["L", "=V.x13", "=V.y12"], ["L", "=V.x12", "=V.y13"], ["Z"], ["M", 0, b], ["L", "=V.x10", "=V.y14"], ["L", "=V.x10", "=V.y18"], ["Z"], ["M", "=V.ox2", "=V.oy2"], ["L", "=V.x12", "=V.y17"], ["L", "=V.x13", "=V.y16"], ["Z"], ["M", a, h], ["L", "=V.x14", "=V.y15"], ["L", "=V.x18", "=V.y15"], ["Z"], ["M", "=V.ox1", "=V.oy2"], ["L", "=V.x17", "=V.y16"], ["L", "=V.x16", "=V.y17"], ["Z"], ["M", "=V.x19", b], ["E", "=V.cx1", "=V.cy1", "=V.wR", "=V.hR", 0, "=A(V.wR,V.hR,V.cd2)", "=(A(V.wR,V.hR,V.cd2)+ 2*PI())", "=IF(21600000 > 0, FALSE, TRUE)"], ["Z"], {}
					]],
				textRect: {
					left: "=V.x9",
					top: "=V.y9",
					right: "=V.x8",
					bottom: "=V.y8"
				}
			},
			moon: {
				variables: {
					adj: 50000,
					a: "=MIN(MAX(0, V.adj), 87500)",
					ss: s,
					g0: "=V.ss * V.a / 100000",
					g0w: "=V.g0 * width / V.ss",
					g1: "=V.ss - V.g0",
					g2: "=V.g0 * V.g0 / V.g1",
					g3: "=V.ss * V.ss / V.g1",
					g4: "=V.g3 * 2",
					g5: "=V.g4 - V.g2",
					g6: "=V.g5 - V.g0",
					g6w: "=V.g6 * width / V.ss",
					g7: "=V.g5 / 2",
					g8: "=V.g7 - V.g0",
					hd2: F,
					dy1: "=V.g8 * V.hd2 / V.ss",
					vc: F,
					g10h: "=V.vc - V.dy1",
					g11h: "=V.vc + V.dy1",
					g12: "=V.g0 * 9598 / 32768",
					g12w: "=V.g12 * width / V.ss",
					g13: "=V.ss - V.g12",
					q1: "=V.ss * V.ss",
					q2: "=V.g13 * V.g13",
					q3: "=V.q1 - V.q2",
					q4: "=SQRT(V.q3)",
					dy4: "=V.q4 * V.hd2 / V.ss",
					g15h: "=V.vc - V.dy4",
					g16h: "=V.vc + V.dy4",
					g17w: "=V.g6w - V.g0w",
					g18w: "=V.g17w / 2",
					dx2p: "=V.g0w + V.g18w - width",
					dx2: "=V.dx2p * -1",
					dy2: "=V.hd2 * -1",
					d2r: A,
					stAng1: "=(ATAN2(V.dx2,V.dy2) * V.d2r)",
					enAngp1: "=(ATAN2(V.dx2,V.hd2) * V.d2r)",
					enAng1: "=V.enAngp1 - 21600000",
					swAng1: "=V.enAng1 - V.stAng1",
					r: w,
					t: 0,
					l: 0,
					b: h,
					cd4: C,
					cd2: B,
					cx1: "=C(width,V.r,A(width,V.hd2,V.cd4),true)",
					cy1: "=C(V.hd2,V.b,A(width,V.hd2,V.cd4))",
					cx2: "=C(V.g18w,P(V.cx1,width,A(width,V.hd2,(V.cd4 + V.cd2)),true),A(V.g18w,V.dy1,V.stAng1),true)",
					cy2: "=C(V.dy1,P(V.cy1,V.hd2,A(width,V.hd2,(V.cd4 + V.cd2))),A(V.g18w,V.dy1,V.stAng1))"
				},
				adjustInfo: [["adj", 50000]],
				connectionPoints: [{
						x: w,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: w,
						y: h
					}, {
						x: "=V.g0w",
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj",
						minX: 0,
						maxX: 87500,
						position: {
							x: "g0w",
							y: "vc"
						},
						point: ["=V.g0w", b]
					}
				],
				path: [[["M", w, h], ["E", "=V.cx1", "=V.cy1", w, "=V.hd2", 0, "=A(width,V.hd2,V.cd4)", "=A(width,V.hd2,(V.cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["E", "=V.cx2", "=V.cy2", "=V.g18w", "=V.dy1", 0, "=A(V.g18w,V.dy1,V.stAng1)", "=A(V.g18w,V.dy1,(V.stAng1 + V.swAng1))", "=IF(V.swAng1 > 0, FALSE, TRUE)"], ["Z"], {}
					]],
				textRect: {
					left: "=V.g12w",
					top: "=V.g15h",
					right: "=V.g0w",
					bottom: "=V.g16h"
				}
			},
			arc: {
				variables: {
					adj1: D,
					adj2: 0,
					stAng: "=MIN(MAX(0, V.adj1), 21599999)",
					enAng: "=MIN(MAX(0, V.adj2), 21599999)",
					sw11: "=V.enAng - V.stAng",
					sw12: "=V.sw11 + 21600000",
					swAng: "=IF(V.sw11 > 0, V.sw11, V.sw12)",
					wd2: E,
					d2r: A,
					wt1: "=V.wd2 * SIN(V.stAng / V.d2r)",
					hd2: F,
					ht1: "=V.hd2 * COS(V.stAng / V.d2r)",
					dx1: "=V.wd2 * COS(ATAN2(V.ht1,V.wt1))",
					dy1: "=V.hd2 * SIN(ATAN2(V.ht1,V.wt1))",
					wt2: "=V.wd2 * SIN(V.enAng / V.d2r)",
					ht2: "=V.hd2 * COS(V.enAng / V.d2r)",
					dx2: "=V.wd2 * COS(ATAN2(V.ht2,V.wt2))",
					dy2: "=V.hd2 * SIN(ATAN2(V.ht2,V.wt2))",
					hc: E,
					x1: "=V.hc + V.dx1",
					vc: F,
					y1: "=V.vc + V.dy1",
					x2: "=V.hc + V.dx2",
					y2: "=V.vc + V.dy2",
					sw0: "=21600000 - V.stAng",
					da1: "=V.swAng - V.sw0",
					g1: "=MAX(V.x1, V.x2)",
					r: w,
					ir: "=IF(V.da1 > 0, V.r, V.g1)",
					cd4: C,
					sw1: "=V.cd4 - V.stAng",
					sw2: "=27000000 - V.stAng",
					sw3: "=IF(V.sw1 > 0, V.sw1, V.sw2)",
					da2: "=V.swAng - V.sw3",
					g5: "=MAX(V.y1, V.y2)",
					b: h,
					ib: "=IF(V.da2 > 0, V.b, V.g5)",
					cd2: B,
					sw4: "=V.cd2 - V.stAng",
					sw5: "=32400000 - V.stAng",
					sw6: "=IF(V.sw4 > 0, V.sw4, V.sw5)",
					da3: "=V.swAng - V.sw6",
					g9: "=MIN(V.x1, V.x2)",
					l: 0,
					il: "=IF(V.da3 > 0, V.l, V.g9)",
					_3cd4: D,
					sw7: "=V._3cd4 - V.stAng",
					sw8: "=37800000 - V.stAng",
					sw9: "=IF(V.sw7 > 0, V.sw7, V.sw8)",
					da4: "=V.swAng - V.sw9",
					g13: "=MIN(V.y1, V.y2)",
					t: 0,
					it: "=IF(V.da4 > 0, V.t, V.g13)",
					cang1: "=V.stAng - V.cd4",
					cang2: "=V.enAng + V.cd4",
					cang3: "=(V.cang1 + V.cang2) / 2",
					cx1: "=C(V.wd2,V.x1,A(V.wd2,V.hd2,V.stAng),true)",
					cy1: "=C(V.hd2,V.y1,A(V.wd2,V.hd2,V.stAng))",
					cx2: "=C(V.wd2,V.x1,A(V.wd2,V.hd2,V.stAng),true)",
					cy2: "=C(V.hd2,V.y1,A(V.wd2,V.hd2,V.stAng))"
				},
				adjustInfo: [["adj1", 16200000], ["adj2", 0]],
				connectionPoints: [{
						x: c,
						y: e
					}, {
						x: a,
						y: b
					}, {
						x: d,
						y: f
					}
				],
				controlsInfo: [{
						type: "ahPolar",
						gdRefAng: "adj1",
						minAng: 0,
						maxAng: 21599999,
						position: {
							x: "x1",
							y: "y1"
						},
						point: [c, e]
					}, {
						type: "ahPolar",
						gdRefAng: "adj2",
						minAng: 0,
						maxAng: 21599999,
						position: {
							x: "x2",
							y: "y2"
						},
						point: [d, f]
					}
				],
				path: [[["M", c, e], ["E", "=V.cx1", "=V.cy1", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.stAng)", "=A(V.wd2,V.hd2,(V.stAng + V.swAng))", "=IF(V.swAng > 0, FALSE, TRUE)"], ["L", a, b], ["Z"], {
							strokeMode: "false"
						}
					], [["M", c, e], ["E", "=V.cx2", "=V.cy2", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.stAng)", "=A(V.wd2,V.hd2,(V.stAng + V.swAng))", "=IF(V.swAng > 0, FALSE, TRUE)"], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			doubleBracket: {
				variables: {
					adj: 16667,
					a: "=MIN(MAX(0, V.adj), 50000)",
					ss: s,
					x1: "=V.ss * V.a / 100000",
					r: w,
					x2: "=width - V.x1",
					b: h,
					y2: "=height - V.x1",
					il: "=V.x1 * 29289 / 100000",
					ir: "=width - V.il",
					ib: "=height - V.il",
					hc: E,
					t: 0,
					l: 0,
					vc: F,
					cd2: B,
					cd4: C,
					cx1: "=C(V.x1,V.l,A(V.x1,V.x1,V.cd2),true)",
					cy1: "=C(V.x1,V.x1,A(V.x1,V.x1,V.cd2))",
					_3cd4: D,
					cx2: "=C(V.x1,V.x2,A(V.x1,V.x1,V._3cd4),true)",
					cy2: "=C(V.x1,V.t,A(V.x1,V.x1,V._3cd4))",
					cx3: "=C(V.x1,V.r,A(V.x1,V.x1,0),true)",
					cy3: "=C(V.x1,V.y2,A(V.x1,V.x1,0))",
					cx4: "=C(V.x1,V.x1,A(V.x1,V.x1,V.cd4),true)",
					cy4: "=C(V.x1,V.b,A(V.x1,V.x1,V.cd4))",
					cx5: "=C(V.x1,V.x1,A(V.x1,V.x1,V.cd4),true)",
					cy5: "=C(V.x1,V.b,A(V.x1,V.x1,V.cd4))",
					cx6: "=C(V.x1,V.l,A(V.x1,V.x1,V.cd2),true)",
					cy6: "=C(V.x1,V.x1,A(V.x1,V.x1,V.cd2))",
					cx7: "=C(V.x1,V.x2,A(V.x1,V.x1,V._3cd4),true)",
					cy7: "=C(V.x1,V.t,A(V.x1,V.x1,V._3cd4))",
					cx8: "=C(V.x1,V.r,A(V.x1,V.x1,0),true)",
					cy8: "=C(V.x1,V.y2,A(V.x1,V.x1,0))"
				},
				adjustInfo: [["adj", 16667]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj",
						minY: 0,
						maxY: 50000,
						position: {
							x: "l",
							y: "x1"
						},
						point: [0, c]
					}
				],
				path: [[["M", 0, c], ["E", "=V.cx1", "=V.cy1", c, c, 0, "=A(V.x1,V.x1,V.cd2)", "=A(V.x1,V.x1,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", d, 0], ["E", "=V.cx2", "=V.cy2", c, c, 0, "=A(V.x1,V.x1,V._3cd4)", "=A(V.x1,V.x1,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", w, f], ["E", "=V.cx3", "=V.cy3", c, c, 0, "=A(V.x1,V.x1,0)", "=A(V.x1,V.x1,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", c, h], ["E", "=V.cx4", "=V.cy4", c, c, 0, "=A(V.x1,V.x1,V.cd4)", "=A(V.x1,V.x1,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", c, h], ["E", "=V.cx5", "=V.cy5", c, c, 0, "=A(V.x1,V.x1,V.cd4)", "=A(V.x1,V.x1,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", 0, c], ["E", "=V.cx6", "=V.cy6", c, c, 0, "=A(V.x1,V.x1,V.cd2)", "=A(V.x1,V.x1,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["M", d, 0], ["E", "=V.cx7", "=V.cy7", c, c, 0, "=A(V.x1,V.x1,V._3cd4)", "=A(V.x1,V.x1,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", w, f], ["E", "=V.cx8", "=V.cy8", c, c, 0, "=A(V.x1,V.x1,0)", "=A(V.x1,V.x1,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.il",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			doubleBrace: {
				variables: {
					adj: 8333,
					a: "=MIN(MAX(0, V.adj), 25000)",
					ss: s,
					x1: "=V.ss * V.a / 100000",
					x2: "=V.ss * V.a / 50000",
					r: w,
					x3: "=width - V.x2",
					x4: "=width - V.x1",
					vc: F,
					y2: "=V.vc - V.x1",
					y3: "=V.vc + V.x1",
					b: h,
					y4: "=height - V.x1",
					it: "=V.x1 * 29289 / 100000",
					il: "=V.x1 + V.it",
					ir: "=width - V.il",
					ib: "=height - V.it",
					hc: E,
					t: 0,
					l: 0,
					cd4: C,
					cx1: "=C(V.x1,V.x2,A(V.x1,V.x1,V.cd4),true)",
					cy1: "=C(V.x1,V.b,A(V.x1,V.x1,V.cd4))",
					cx2: "=C(V.x1,V.x1,A(V.x1,V.x1,0),true)",
					cy2: "=C(V.x1,V.y3,A(V.x1,V.x1,0))",
					cx3: "=C(V.x1,P(V.cx2,V.x1,A(V.x1,V.x1,(-5400000)),true),A(V.x1,V.x1,V.cd4),true)",
					cy3: "=C(V.x1,P(V.cy2,V.x1,A(V.x1,V.x1,(-5400000))),A(V.x1,V.x1,V.cd4))",
					cd2: B,
					cx4: "=C(V.x1,V.x1,A(V.x1,V.x1,V.cd2),true)",
					cy4: "=C(V.x1,V.x1,A(V.x1,V.x1,V.cd2))",
					_3cd4: D,
					cx5: "=C(V.x1,V.x3,A(V.x1,V.x1,V._3cd4),true)",
					cy5: "=C(V.x1,V.t,A(V.x1,V.x1,V._3cd4))",
					cx6: "=C(V.x1,V.x4,A(V.x1,V.x1,V.cd2),true)",
					cy6: "=C(V.x1,V.y2,A(V.x1,V.x1,V.cd2))",
					cx7: "=C(V.x1,P(V.cx6,V.x1,A(V.x1,V.x1,(V.cd2 + -5400000)),true),A(V.x1,V.x1,V._3cd4),true)",
					cy7: "=C(V.x1,P(V.cy6,V.x1,A(V.x1,V.x1,(V.cd2 + -5400000))),A(V.x1,V.x1,V._3cd4))",
					cx8: "=C(V.x1,V.x4,A(V.x1,V.x1,0),true)",
					cy8: "=C(V.x1,V.y4,A(V.x1,V.x1,0))",
					cx9: "=C(V.x1,V.x2,A(V.x1,V.x1,V.cd4),true)",
					cy9: "=C(V.x1,V.b,A(V.x1,V.x1,V.cd4))",
					cx10: "=C(V.x1,V.x1,A(V.x1,V.x1,0),true)",
					cy10: "=C(V.x1,V.y3,A(V.x1,V.x1,0))",
					cx11: "=C(V.x1,P(V.cx10,V.x1,A(V.x1,V.x1,(-5400000)),true),A(V.x1,V.x1,V.cd4),true)",
					cy11: "=C(V.x1,P(V.cy10,V.x1,A(V.x1,V.x1,(-5400000))),A(V.x1,V.x1,V.cd4))",
					cx12: "=C(V.x1,V.x1,A(V.x1,V.x1,V.cd2),true)",
					cy12: "=C(V.x1,V.x1,A(V.x1,V.x1,V.cd2))",
					cx13: "=C(V.x1,V.x3,A(V.x1,V.x1,V._3cd4),true)",
					cy13: "=C(V.x1,V.t,A(V.x1,V.x1,V._3cd4))",
					cx14: "=C(V.x1,V.x4,A(V.x1,V.x1,V.cd2),true)",
					cy14: "=C(V.x1,V.y2,A(V.x1,V.x1,V.cd2))",
					cx15: "=C(V.x1,P(V.cx14,V.x1,A(V.x1,V.x1,(V.cd2 + -5400000)),true),A(V.x1,V.x1,V._3cd4),true)",
					cy15: "=C(V.x1,P(V.cy14,V.x1,A(V.x1,V.x1,(V.cd2 + -5400000))),A(V.x1,V.x1,V._3cd4))",
					cx16: "=C(V.x1,V.x4,A(V.x1,V.x1,0),true)",
					cy16: "=C(V.x1,V.y4,A(V.x1,V.x1,0))"
				},
				adjustInfo: [["adj", 8333]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj",
						minY: 0,
						maxY: 25000,
						position: {
							x: "l",
							y: "x1"
						},
						point: [0, c]
					}
				],
				path: [[["M", d, h], ["E", "=V.cx1", "=V.cy1", c, c, 0, "=A(V.x1,V.x1,V.cd4)", "=A(V.x1,V.x1,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", c, "=V.y3"], ["E", "=V.cx2", "=V.cy2", c, c, 0, "=A(V.x1,V.x1,0)", "=A(V.x1,V.x1,(-5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["E", "=V.cx3", "=V.cy3", c, c, 0, "=A(V.x1,V.x1,V.cd4)", "=A(V.x1,V.x1,(V.cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", c, c], ["E", "=V.cx4", "=V.cy4", c, c, 0, "=A(V.x1,V.x1,V.cd2)", "=A(V.x1,V.x1,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.x3", 0], ["E", "=V.cx5", "=V.cy5", c, c, 0, "=A(V.x1,V.x1,V._3cd4)", "=A(V.x1,V.x1,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.x4", f], ["E", "=V.cx6", "=V.cy6", c, c, 0, "=A(V.x1,V.x1,V.cd2)", "=A(V.x1,V.x1,(V.cd2 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["E", "=V.cx7", "=V.cy7", c, c, 0, "=A(V.x1,V.x1,V._3cd4)", "=A(V.x1,V.x1,(V._3cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", "=V.x4", "=V.y4"], ["E", "=V.cx8", "=V.cy8", c, c, 0, "=A(V.x1,V.x1,0)", "=A(V.x1,V.x1,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", d, h], ["E", "=V.cx9", "=V.cy9", c, c, 0, "=A(V.x1,V.x1,V.cd4)", "=A(V.x1,V.x1,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", c, "=V.y3"], ["E", "=V.cx10", "=V.cy10", c, c, 0, "=A(V.x1,V.x1,0)", "=A(V.x1,V.x1,(-5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["E", "=V.cx11", "=V.cy11", c, c, 0, "=A(V.x1,V.x1,V.cd4)", "=A(V.x1,V.x1,(V.cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", c, c], ["E", "=V.cx12", "=V.cy12", c, c, 0, "=A(V.x1,V.x1,V.cd2)", "=A(V.x1,V.x1,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["M", "=V.x3", 0], ["E", "=V.cx13", "=V.cy13", c, c, 0, "=A(V.x1,V.x1,V._3cd4)", "=A(V.x1,V.x1,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.x4", f], ["E", "=V.cx14", "=V.cy14", c, c, 0, "=A(V.x1,V.x1,V.cd2)", "=A(V.x1,V.x1,(V.cd2 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["E", "=V.cx15", "=V.cy15", c, c, 0, "=A(V.x1,V.x1,V._3cd4)", "=A(V.x1,V.x1,(V._3cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", "=V.x4", "=V.y4"], ["E", "=V.cx16", "=V.cy16", c, c, 0, "=A(V.x1,V.x1,0)", "=A(V.x1,V.x1,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.il",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			plaque: {
				variables: {
					adj: 16667,
					a: "=MIN(MAX(0, V.adj), 50000)",
					ss: s,
					x1: "=V.ss * V.a / 100000",
					r: w,
					x2: "=width - V.x1",
					b: h,
					y2: "=height - V.x1",
					il: "=V.x1 * 70711 / 100000",
					ir: "=width - V.il",
					ib: "=height - V.il",
					hc: E,
					t: 0,
					l: 0,
					vc: F,
					cd4: C,
					cx1: "=C(V.x1,V.l,A(V.x1,V.x1,V.cd4),true)",
					cy1: "=C(V.x1,V.x1,A(V.x1,V.x1,V.cd4))",
					cd2: B,
					cx2: "=C(V.x1,V.x2,A(V.x1,V.x1,V.cd2),true)",
					cy2: "=C(V.x1,V.t,A(V.x1,V.x1,V.cd2))",
					_3cd4: D,
					cx3: "=C(V.x1,V.r,A(V.x1,V.x1,V._3cd4),true)",
					cy3: "=C(V.x1,V.y2,A(V.x1,V.x1,V._3cd4))",
					cx4: "=C(V.x1,V.x1,A(V.x1,V.x1,0),true)",
					cy4: "=C(V.x1,V.b,A(V.x1,V.x1,0))"
				},
				adjustInfo: [["adj", 16667]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj",
						minX: 0,
						maxX: 50000,
						position: {
							x: "x1",
							y: "t"
						},
						point: [c, 0]
					}
				],
				path: [[["M", 0, c], ["E", "=V.cx1", "=V.cy1", c, c, 0, "=A(V.x1,V.x1,V.cd4)", "=A(V.x1,V.x1,(V.cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", d, 0], ["E", "=V.cx2", "=V.cy2", c, c, 0, "=A(V.x1,V.x1,V.cd2)", "=A(V.x1,V.x1,(V.cd2 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", w, f], ["E", "=V.cx3", "=V.cy3", c, c, 0, "=A(V.x1,V.x1,V._3cd4)", "=A(V.x1,V.x1,(V._3cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", c, h], ["E", "=V.cx4", "=V.cy4", c, c, 0, "=A(V.x1,V.x1,0)", "=A(V.x1,V.x1,(-5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.il",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			leftBracket: {
				variables: {
					adj: 8333,
					ss: s,
					maxAdj: "=50000 * height / V.ss",
					a: "=MIN(MAX(0, V.adj), V.maxAdj)",
					y1: "=V.ss * V.a / 100000",
					b: h,
					y2: "=height - V.y1",
					d2r: A,
					dx1: "=width * COS(2700000 / V.d2r)",
					dy1: "=V.y1 * SIN(2700000 / V.d2r)",
					r: w,
					il: "=width - V.dx1",
					it: "=V.y1 - V.dy1",
					ib: "=height + V.dy1 - V.y1",
					t: 0,
					l: 0,
					vc: F,
					cd4: C,
					cx1: "=C(width,V.r,A(width,V.y1,V.cd4),true)",
					cy1: "=C(V.y1,V.b,A(width,V.y1,V.cd4))",
					cd2: B,
					cx2: "=C(width,V.l,A(width,V.y1,V.cd2),true)",
					cy2: "=C(V.y1,V.y1,A(width,V.y1,V.cd2))",
					cx3: "=C(width,V.r,A(width,V.y1,V.cd4),true)",
					cy3: "=C(V.y1,V.b,A(width,V.y1,V.cd4))",
					cx4: "=C(width,V.l,A(width,V.y1,V.cd2),true)",
					cy4: "=C(V.y1,V.y1,A(width,V.y1,V.cd2))"
				},
				adjustInfo: [["adj", 8333]],
				connectionPoints: [{
						x: w,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: w,
						y: h
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj",
						minY: 0,
						maxY: "maxAdj",
						position: {
							x: "l",
							y: "y1"
						},
						point: [0, e]
					}
				],
				path: [[["M", w, h], ["E", "=V.cx1", "=V.cy1", w, e, 0, "=A(width,V.y1,V.cd4)", "=A(width,V.y1,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", 0, e], ["E", "=V.cx2", "=V.cy2", w, e, 0, "=A(width,V.y1,V.cd2)", "=A(width,V.y1,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", w, h], ["E", "=V.cx3", "=V.cy3", w, e, 0, "=A(width,V.y1,V.cd4)", "=A(width,V.y1,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", 0, e], ["E", "=V.cx4", "=V.cy4", w, e, 0, "=A(width,V.y1,V.cd2)", "=A(width,V.y1,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: w,
					bottom: "=V.ib"
				}
			},
			rightBracket: {
				variables: {
					adj: 8333,
					ss: s,
					maxAdj: "=50000 * height / V.ss",
					a: "=MIN(MAX(0, V.adj), V.maxAdj)",
					y1: "=V.ss * V.a / 100000",
					b: h,
					y2: "=height - V.y1",
					d2r: A,
					dx1: "=width * COS(2700000 / V.d2r)",
					dy1: "=V.y1 * SIN(2700000 / V.d2r)",
					l: 0,
					ir: "=V.dx1",
					it: "=V.y1 - V.dy1",
					ib: "=height + V.dy1 - V.y1",
					t: 0,
					r: w,
					vc: F,
					_3cd4: D,
					cd4: C,
					cx1: "=C(width,V.l,A(width,V.y1,V._3cd4),true)",
					cy1: "=C(V.y1,V.t,A(width,V.y1,V._3cd4))",
					cx2: "=C(width,V.r,A(width,V.y1,0),true)",
					cy2: "=C(V.y1,V.y2,A(width,V.y1,0))",
					cx3: "=C(width,V.l,A(width,V.y1,V._3cd4),true)",
					cy3: "=C(V.y1,V.t,A(width,V.y1,V._3cd4))",
					cx4: "=C(width,V.r,A(width,V.y1,0),true)",
					cy4: "=C(V.y1,V.y2,A(width,V.y1,0))"
				},
				adjustInfo: [["adj", 8333]],
				connectionPoints: [{
						x: 0,
						y: 0
					}, {
						x: 0,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj",
						minY: 0,
						maxY: "maxAdj",
						position: {
							x: "r",
							y: "y1"
						},
						point: [w, e]
					}
				],
				path: [[["M", 0, 0], ["E", "=V.cx1", "=V.cy1", w, e, 0, "=A(width,V.y1,V._3cd4)", "=A(width,V.y1,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", w, f], ["E", "=V.cx2", "=V.cy2", w, e, 0, "=A(width,V.y1,0)", "=A(width,V.y1,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", 0, 0], ["E", "=V.cx3", "=V.cy3", w, e, 0, "=A(width,V.y1,V._3cd4)", "=A(width,V.y1,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", w, f], ["E", "=V.cx4", "=V.cy4", w, e, 0, "=A(width,V.y1,0)", "=A(width,V.y1,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: 0,
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			leftBrace: {
				variables: {
					adj1: 8333,
					adj2: 50000,
					a2: "=MIN(MAX(0, V.adj2), 100000)",
					q1: "=100000 - V.a2",
					q2: "=MIN(V.q1, V.a2)",
					q3: "=V.q2 / 2",
					ss: s,
					maxAdj1: "=V.q3 * height / V.ss",
					a1: "=MIN(MAX(0, V.adj1), V.maxAdj1)",
					y1: "=V.ss * V.a1 / 100000",
					y3: "=height * V.a2 / 100000",
					y4: "=V.y3 + V.y1",
					wd2: E,
					d2r: A,
					dx1: "=V.wd2 * COS(2700000 / V.d2r)",
					dy1: "=V.y1 * SIN(2700000 / V.d2r)",
					r: w,
					il: "=width - V.dx1",
					it: "=V.y1 - V.dy1",
					b: h,
					ib: "=height + V.dy1 - V.y1",
					t: 0,
					l: 0,
					hc: E,
					cd4: C,
					cx1: "=C(V.wd2,V.r,A(V.wd2,V.y1,V.cd4),true)",
					cy1: "=C(V.y1,V.b,A(V.wd2,V.y1,V.cd4))",
					cx2: "=C(V.wd2,V.hc,A(V.wd2,V.y1,0),true)",
					cy2: "=C(V.y1,V.y4,A(V.wd2,V.y1,0))",
					cx3: "=C(V.wd2,P(V.cx2,V.wd2,A(V.wd2,V.y1,(-5400000)),true),A(V.wd2,V.y1,V.cd4),true)",
					cy3: "=C(V.y1,P(V.cy2,V.y1,A(V.wd2,V.y1,(-5400000))),A(V.wd2,V.y1,V.cd4))",
					cd2: B,
					cx4: "=C(V.wd2,V.hc,A(V.wd2,V.y1,V.cd2),true)",
					cy4: "=C(V.y1,V.y1,A(V.wd2,V.y1,V.cd2))",
					cx5: "=C(V.wd2,V.r,A(V.wd2,V.y1,V.cd4),true)",
					cy5: "=C(V.y1,V.b,A(V.wd2,V.y1,V.cd4))",
					cx6: "=C(V.wd2,V.hc,A(V.wd2,V.y1,0),true)",
					cy6: "=C(V.y1,V.y4,A(V.wd2,V.y1,0))",
					cx7: "=C(V.wd2,P(V.cx6,V.wd2,A(V.wd2,V.y1,(-5400000)),true),A(V.wd2,V.y1,V.cd4),true)",
					cy7: "=C(V.y1,P(V.cy6,V.y1,A(V.wd2,V.y1,(-5400000))),A(V.wd2,V.y1,V.cd4))",
					cx8: "=C(V.wd2,V.hc,A(V.wd2,V.y1,V.cd2),true)",
					cy8: "=C(V.y1,V.y1,A(V.wd2,V.y1,V.cd2))"
				},
				adjustInfo: [["adj1", 8333], ["adj2", 50000]],
				connectionPoints: [{
						x: w,
						y: 0
					}, {
						x: 0,
						y: "=V.y3"
					}, {
						x: w,
						y: h
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: "maxAdj1",
						position: {
							x: "hc",
							y: "y1"
						},
						point: [a, e]
					}, {
						type: "ahXY",
						gdRefY: "adj2",
						minY: 0,
						maxY: 100000,
						position: {
							x: "l",
							y: "y3"
						},
						point: [0, "=V.y3"]
					}
				],
				path: [[["M", w, h], ["E", "=V.cx1", "=V.cy1", "=V.wd2", e, 0, "=A(V.wd2,V.y1,V.cd4)", "=A(V.wd2,V.y1,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", a, "=V.y4"], ["E", "=V.cx2", "=V.cy2", "=V.wd2", e, 0, "=A(V.wd2,V.y1,0)", "=A(V.wd2,V.y1,(-5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["E", "=V.cx3", "=V.cy3", "=V.wd2", e, 0, "=A(V.wd2,V.y1,V.cd4)", "=A(V.wd2,V.y1,(V.cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", a, e], ["E", "=V.cx4", "=V.cy4", "=V.wd2", e, 0, "=A(V.wd2,V.y1,V.cd2)", "=A(V.wd2,V.y1,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", w, h], ["E", "=V.cx5", "=V.cy5", "=V.wd2", e, 0, "=A(V.wd2,V.y1,V.cd4)", "=A(V.wd2,V.y1,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", a, "=V.y4"], ["E", "=V.cx6", "=V.cy6", "=V.wd2", e, 0, "=A(V.wd2,V.y1,0)", "=A(V.wd2,V.y1,(-5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["E", "=V.cx7", "=V.cy7", "=V.wd2", e, 0, "=A(V.wd2,V.y1,V.cd4)", "=A(V.wd2,V.y1,(V.cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", a, e], ["E", "=V.cx8", "=V.cy8", "=V.wd2", e, 0, "=A(V.wd2,V.y1,V.cd2)", "=A(V.wd2,V.y1,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: w,
					bottom: "=V.ib"
				}
			},
			rightBrace: {
				variables: {
					adj1: 8333,
					adj2: 50000,
					a2: "=MIN(MAX(0, V.adj2), 100000)",
					q1: "=100000 - V.a2",
					q2: "=MIN(V.q1, V.a2)",
					q3: "=V.q2 / 2",
					ss: s,
					maxAdj1: "=V.q3 * height / V.ss",
					a1: "=MIN(MAX(0, V.adj1), V.maxAdj1)",
					y1: "=V.ss * V.a1 / 100000",
					y3: "=height * V.a2 / 100000",
					y2: "=V.y3 - V.y1",
					b: h,
					y4: "=height - V.y1",
					wd2: E,
					d2r: A,
					dx1: "=V.wd2 * COS(2700000 / V.d2r)",
					dy1: "=V.y1 * SIN(2700000 / V.d2r)",
					l: 0,
					ir: "=V.dx1",
					it: "=V.y1 - V.dy1",
					ib: "=height + V.dy1 - V.y1",
					t: 0,
					r: w,
					hc: E,
					_3cd4: D,
					cd4: C,
					cx1: "=C(V.wd2,V.l,A(V.wd2,V.y1,V._3cd4),true)",
					cy1: "=C(V.y1,V.t,A(V.wd2,V.y1,V._3cd4))",
					cd2: B,
					cx2: "=C(V.wd2,V.hc,A(V.wd2,V.y1,V.cd2),true)",
					cy2: "=C(V.y1,V.y2,A(V.wd2,V.y1,V.cd2))",
					cx3: "=C(V.wd2,P(V.cx2,V.wd2,A(V.wd2,V.y1,(V.cd2 + -5400000)),true),A(V.wd2,V.y1,V._3cd4),true)",
					cy3: "=C(V.y1,P(V.cy2,V.y1,A(V.wd2,V.y1,(V.cd2 + -5400000))),A(V.wd2,V.y1,V._3cd4))",
					cx4: "=C(V.wd2,V.hc,A(V.wd2,V.y1,0),true)",
					cy4: "=C(V.y1,V.y4,A(V.wd2,V.y1,0))",
					cx5: "=C(V.wd2,V.l,A(V.wd2,V.y1,V._3cd4),true)",
					cy5: "=C(V.y1,V.t,A(V.wd2,V.y1,V._3cd4))",
					cx6: "=C(V.wd2,V.hc,A(V.wd2,V.y1,V.cd2),true)",
					cy6: "=C(V.y1,V.y2,A(V.wd2,V.y1,V.cd2))",
					cx7: "=C(V.wd2,P(V.cx6,V.wd2,A(V.wd2,V.y1,(V.cd2 + -5400000)),true),A(V.wd2,V.y1,V._3cd4),true)",
					cy7: "=C(V.y1,P(V.cy6,V.y1,A(V.wd2,V.y1,(V.cd2 + -5400000))),A(V.wd2,V.y1,V._3cd4))",
					cx8: "=C(V.wd2,V.hc,A(V.wd2,V.y1,0),true)",
					cy8: "=C(V.y1,V.y4,A(V.wd2,V.y1,0))"
				},
				adjustInfo: [["adj1", 8333], ["adj2", 50000]],
				connectionPoints: [{
						x: 0,
						y: 0
					}, {
						x: w,
						y: "=V.y3"
					}, {
						x: 0,
						y: h
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: "maxAdj1",
						position: {
							x: "hc",
							y: "y1"
						},
						point: [a, e]
					}, {
						type: "ahXY",
						gdRefY: "adj2",
						minY: 0,
						maxY: 100000,
						position: {
							x: "r",
							y: "y3"
						},
						point: [w, "=V.y3"]
					}
				],
				path: [[["M", 0, 0], ["E", "=V.cx1", "=V.cy1", "=V.wd2", e, 0, "=A(V.wd2,V.y1,V._3cd4)", "=A(V.wd2,V.y1,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", a, f], ["E", "=V.cx2", "=V.cy2", "=V.wd2", e, 0, "=A(V.wd2,V.y1,V.cd2)", "=A(V.wd2,V.y1,(V.cd2 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["E", "=V.cx3", "=V.cy3", "=V.wd2", e, 0, "=A(V.wd2,V.y1,V._3cd4)", "=A(V.wd2,V.y1,(V._3cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", a, "=V.y4"], ["E", "=V.cx4", "=V.cy4", "=V.wd2", e, 0, "=A(V.wd2,V.y1,0)", "=A(V.wd2,V.y1,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", 0, 0], ["E", "=V.cx5", "=V.cy5", "=V.wd2", e, 0, "=A(V.wd2,V.y1,V._3cd4)", "=A(V.wd2,V.y1,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", a, f], ["E", "=V.cx6", "=V.cy6", "=V.wd2", e, 0, "=A(V.wd2,V.y1,V.cd2)", "=A(V.wd2,V.y1,(V.cd2 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["E", "=V.cx7", "=V.cy7", "=V.wd2", e, 0, "=A(V.wd2,V.y1,V._3cd4)", "=A(V.wd2,V.y1,(V._3cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", a, "=V.y4"], ["E", "=V.cx8", "=V.cy8", "=V.wd2", e, 0, "=A(V.wd2,V.y1,0)", "=A(V.wd2,V.y1,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: 0,
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			rightArrow: {
				variables: {
					adj1: 50000,
					adj2: 50000,
					ss: s,
					maxAdj2: "=100000 * width / V.ss",
					a1: "=MIN(MAX(0, V.adj1), 100000)",
					a2: "=MIN(MAX(0, V.adj2), V.maxAdj2)",
					dx1: "=V.ss * V.a2 / 100000",
					r: w,
					x1: "=width - V.dx1",
					dy1: "=height * V.a1 / 200000",
					vc: F,
					y1: "=V.vc - V.dy1",
					y2: "=V.vc + V.dy1",
					hd2: F,
					dx2: "=V.y1 * V.dx1 / V.hd2",
					x2: "=V.x1 + V.dx2",
					t: 0,
					l: 0,
					b: h
				},
				adjustInfo: [["adj1", 50000], ["adj2", 50000]],
				connectionPoints: [{
						x: c,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: c,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: 100000,
						position: {
							x: "l",
							y: "y1"
						},
						point: [0, e]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: "maxAdj2",
						position: {
							x: "x1",
							y: "t"
						},
						point: [c, 0]
					}
				],
				path: [[["M", 0, e], ["L", c, e], ["L", c, 0], ["L", w, b], ["L", c, h], ["L", c, f], ["L", 0, f], ["Z"], {}
					]],
				textRect: {
					left: 0,
					top: e,
					right: d,
					bottom: f
				}
			},
			leftArrow: {
				variables: {
					adj1: 50000,
					adj2: 50000,
					ss: s,
					maxAdj2: "=100000 * width / V.ss",
					a1: "=MIN(MAX(0, V.adj1), 100000)",
					a2: "=MIN(MAX(0, V.adj2), V.maxAdj2)",
					dx2: "=V.ss * V.a2 / 100000",
					l: 0,
					x2: "=V.dx2",
					dy1: "=height * V.a1 / 200000",
					vc: F,
					y1: "=V.vc - V.dy1",
					y2: "=V.vc + V.dy1",
					hd2: F,
					dx1: "=V.y1 * V.dx2 / V.hd2",
					x1: "=V.x2 - V.dx1",
					t: 0,
					b: h,
					r: w
				},
				adjustInfo: [["adj1", 50000], ["adj2", 50000]],
				connectionPoints: [{
						x: d,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: d,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: 100000,
						position: {
							x: "r",
							y: "y1"
						},
						point: [w, e]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: "maxAdj2",
						position: {
							x: "x2",
							y: "t"
						},
						point: [d, 0]
					}
				],
				path: [[["M", 0, b], ["L", d, 0], ["L", d, e], ["L", w, e], ["L", w, f], ["L", d, f], ["L", d, h], ["Z"], {}
					]],
				textRect: {
					left: c,
					top: e,
					right: w,
					bottom: f
				}
			},
			upArrow: {
				variables: {
					adj1: 50000,
					adj2: 50000,
					ss: s,
					maxAdj2: "=100000 * height / V.ss",
					a1: "=MIN(MAX(0, V.adj1), 100000)",
					a2: "=MIN(MAX(0, V.adj2), V.maxAdj2)",
					dy1: "=V.ss * V.a2 / 100000",
					b: h,
					y1: "=height - V.dy1",
					dx1: "=width * V.a1 / 200000",
					hc: E,
					x1: "=V.hc - V.dx1",
					x2: "=V.hc + V.dx1",
					wd2: E,
					dy2: "=V.x1 * V.dy1 / V.wd2",
					y2: "=V.y1 + V.dy2",
					t: 0,
					l: 0,
					r: w
				},
				adjustInfo: [["adj1", 50000], ["adj2", 50000]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: e
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: e
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj1",
						minX: 0,
						maxX: 100000,
						position: {
							x: "x1",
							y: "b"
						},
						point: [c, h]
					}, {
						type: "ahXY",
						gdRefY: "adj2",
						minY: 0,
						maxY: "maxAdj2",
						position: {
							x: "l",
							y: "y1"
						},
						point: [0, e]
					}
				],
				path: [[["M", 0, e], ["L", a, 0], ["L", w, e], ["L", d, e], ["L", d, h], ["L", c, h], ["L", c, e], ["Z"], {}
					]],
				textRect: {
					left: c,
					top: 0,
					right: d,
					bottom: f
				}
			},
			downArrow: {
				variables: {
					adj1: 50000,
					adj2: 50000,
					ss: s,
					maxAdj2: "=100000 * height / V.ss",
					a1: "=MIN(MAX(0, V.adj1), 100000)",
					a2: "=MIN(MAX(0, V.adj2), V.maxAdj2)",
					dy1: "=V.ss * V.a2 / 100000",
					b: h,
					y1: "=height - V.dy1",
					dx1: "=width * V.a1 / 200000",
					hc: E,
					x1: "=V.hc - V.dx1",
					x2: "=V.hc + V.dx1",
					wd2: E,
					dy2: "=V.x1 * V.dy1 / V.wd2",
					y2: "=V.y1 + V.dy2",
					t: 0,
					l: 0,
					r: w
				},
				adjustInfo: [["adj1", 50000], ["adj2", 50000]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: e
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: e
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj1",
						minX: 0,
						maxX: 100000,
						position: {
							x: "x1",
							y: "t"
						},
						point: [c, 0]
					}, {
						type: "ahXY",
						gdRefY: "adj2",
						minY: 0,
						maxY: "maxAdj2",
						position: {
							x: "l",
							y: "y1"
						},
						point: [0, e]
					}
				],
				path: [[["M", 0, e], ["L", c, e], ["L", c, 0], ["L", d, 0], ["L", d, e], ["L", w, e], ["L", a, h], ["Z"], {}
					]],
				textRect: {
					left: c,
					top: 0,
					right: d,
					bottom: f
				}
			},
			leftRightArrow: {
				variables: {
					adj1: 50000,
					adj2: 50000,
					ss: s,
					maxAdj2: "=50000 * width / V.ss",
					a1: "=MIN(MAX(0, V.adj1), 100000)",
					a2: "=MIN(MAX(0, V.adj2), V.maxAdj2)",
					x2: "=V.ss * V.a2 / 100000",
					r: w,
					x3: "=width - V.x2",
					dy: "=height * V.a1 / 200000",
					vc: F,
					y1: "=V.vc - V.dy",
					y2: "=V.vc + V.dy",
					hd2: F,
					dx1: "=V.y1 * V.x2 / V.hd2",
					x1: "=V.x2 - V.dx1",
					x4: "=V.x3 + V.dx1",
					b: h,
					l: 0,
					t: 0
				},
				adjustInfo: [["adj1", 50000], ["adj2", 50000]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: "=V.x3",
						y: h
					}, {
						x: d,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: d,
						y: 0
					}, {
						x: "=V.x3",
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: 100000,
						position: {
							x: "x3",
							y: "y1"
						},
						point: ["=V.x3", e]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: "maxAdj2",
						position: {
							x: "x2",
							y: "t"
						},
						point: [d, 0]
					}
				],
				path: [[["M", 0, b], ["L", d, 0], ["L", d, e], ["L", "=V.x3", e], ["L", "=V.x3", 0], ["L", w, b], ["L", "=V.x3", h], ["L", "=V.x3", f], ["L", d, f], ["L", d, h], ["Z"], {}
					]],
				textRect: {
					left: c,
					top: e,
					right: "=V.x4",
					bottom: f
				}
			},
			upDownArrow: {
				variables: {
					adj1: 50000,
					adj2: 50000,
					ss: s,
					maxAdj2: "=50000 * height / V.ss",
					a1: "=MIN(MAX(0, V.adj1), 100000)",
					a2: "=MIN(MAX(0, V.adj2), V.maxAdj2)",
					y2: "=V.ss * V.a2 / 100000",
					b: h,
					y3: "=height - V.y2",
					dx1: "=width * V.a1 / 200000",
					hc: E,
					x1: "=V.hc - V.dx1",
					x2: "=V.hc + V.dx1",
					wd2: E,
					dy1: "=V.x1 * V.y2 / V.wd2",
					y1: "=V.y2 - V.dy1",
					y4: "=V.y3 + V.dy1",
					t: 0,
					l: 0,
					vc: F,
					r: w
				},
				adjustInfo: [["adj1", 50000], ["adj2", 50000]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: f
					}, {
						x: c,
						y: b
					}, {
						x: 0,
						y: "=V.y3"
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: "=V.y3"
					}, {
						x: d,
						y: b
					}, {
						x: w,
						y: f
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj1",
						minX: 0,
						maxX: 100000,
						position: {
							x: "x1",
							y: "y3"
						},
						point: [c, "=V.y3"]
					}, {
						type: "ahXY",
						gdRefY: "adj2",
						minY: 0,
						maxY: "maxAdj2",
						position: {
							x: "l",
							y: "y2"
						},
						point: [0, f]
					}
				],
				path: [[["M", 0, f], ["L", a, 0], ["L", w, f], ["L", d, f], ["L", d, "=V.y3"], ["L", w, "=V.y3"], ["L", a, h], ["L", 0, "=V.y3"], ["L", c, "=V.y3"], ["L", c, f], ["Z"], {}
					]],
				textRect: {
					left: c,
					top: e,
					right: d,
					bottom: "=V.y4"
				}
			},
			quadArrow: {
				variables: {
					adj1: 22500,
					adj2: 22500,
					adj3: 22500,
					a2: "=MIN(MAX(0, V.adj2), 50000)",
					maxAdj1: "=V.a2 * 2",
					a1: "=MIN(MAX(0, V.adj1), V.maxAdj1)",
					q1: "=100000 - V.maxAdj1",
					maxAdj3: "=V.q1 / 2",
					a3: "=MIN(MAX(0, V.adj3), V.maxAdj3)",
					ss: s,
					x1: "=V.ss * V.a3 / 100000",
					dx2: "=V.ss * V.a2 / 100000",
					hc: E,
					x2: "=V.hc - V.dx2",
					x5: "=V.hc + V.dx2",
					dx3: "=V.ss * V.a1 / 200000",
					x3: "=V.hc - V.dx3",
					x4: "=V.hc + V.dx3",
					r: w,
					x6: "=width - V.x1",
					vc: F,
					y2: "=V.vc - V.dx2",
					y5: "=V.vc + V.dx2",
					y3: "=V.vc - V.dx3",
					y4: "=V.vc + V.dx3",
					b: h,
					y6: "=height - V.x1",
					il: "=V.dx3 * V.x1 / V.dx2",
					ir: "=width - V.il",
					t: 0,
					l: 0
				},
				adjustInfo: [["adj1", 22500], ["adj2", 22500], ["adj3", 22500]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj1",
						minX: 0,
						maxX: "maxAdj1",
						position: {
							x: "x3",
							y: "x1"
						},
						point: ["=V.x3", c]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: 50000,
						position: {
							x: "x2",
							y: "t"
						},
						point: [d, 0]
					}, {
						type: "ahXY",
						gdRefY: "adj3",
						minY: 0,
						maxY: "maxAdj3",
						position: {
							x: "r",
							y: "x1"
						},
						point: [w, c]
					}
				],
				path: [[["M", 0, b], ["L", c, f], ["L", c, "=V.y3"], ["L", "=V.x3", "=V.y3"], ["L", "=V.x3", c], ["L", d, c], ["L", a, 0], ["L", "=V.x5", c], ["L", "=V.x4", c], ["L", "=V.x4", "=V.y3"], ["L", "=V.x6", "=V.y3"], ["L", "=V.x6", f], ["L", w, b], ["L", "=V.x6", "=V.y5"], ["L", "=V.x6", "=V.y4"], ["L", "=V.x4", "=V.y4"], ["L", "=V.x4", "=V.y6"], ["L", "=V.x5", "=V.y6"], ["L", a, h], ["L", d, "=V.y6"], ["L", "=V.x3", "=V.y6"], ["L", "=V.x3", "=V.y4"], ["L", c, "=V.y4"], ["L", c, "=V.y5"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.y3",
					right: "=V.ir",
					bottom: "=V.y4"
				}
			},
			leftRightUpArrow: {
				variables: {
					adj1: 25000,
					adj2: 25000,
					adj3: 25000,
					a2: "=MIN(MAX(0, V.adj2), 50000)",
					maxAdj1: "=V.a2 * 2",
					a1: "=MIN(MAX(0, V.adj1), V.maxAdj1)",
					q1: "=100000 - V.maxAdj1",
					maxAdj3: "=V.q1 / 2",
					a3: "=MIN(MAX(0, V.adj3), V.maxAdj3)",
					ss: s,
					x1: "=V.ss * V.a3 / 100000",
					dx2: "=V.ss * V.a2 / 100000",
					hc: E,
					x2: "=V.hc - V.dx2",
					x5: "=V.hc + V.dx2",
					dx3: "=V.ss * V.a1 / 200000",
					x3: "=V.hc - V.dx3",
					x4: "=V.hc + V.dx3",
					r: w,
					x6: "=width - V.x1",
					dy2: "=V.ss * V.a2 / 50000",
					b: h,
					y2: "=height - V.dy2",
					y4: "=height - V.dx2",
					y3: "=V.y4 - V.dx3",
					y5: "=V.y4 + V.dx3",
					il: "=V.dx3 * V.x1 / V.dx2",
					ir: "=width - V.il",
					t: 0,
					l: 0
				},
				adjustInfo: [["adj1", 25000], ["adj2", 25000], ["adj3", 25000]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: "=V.y4"
					}, {
						x: a,
						y: "=V.y5"
					}, {
						x: w,
						y: "=V.y4"
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj1",
						minX: 0,
						maxX: "maxAdj1",
						position: {
							x: "x3",
							y: "x1"
						},
						point: ["=V.x3", c]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: 50000,
						position: {
							x: "x2",
							y: "t"
						},
						point: [d, 0]
					}, {
						type: "ahXY",
						gdRefY: "adj3",
						minY: 0,
						maxY: "maxAdj3",
						position: {
							x: "r",
							y: "x1"
						},
						point: [w, c]
					}
				],
				path: [[["M", 0, "=V.y4"], ["L", c, f], ["L", c, "=V.y3"], ["L", "=V.x3", "=V.y3"], ["L", "=V.x3", c], ["L", d, c], ["L", a, 0], ["L", "=V.x5", c], ["L", "=V.x4", c], ["L", "=V.x4", "=V.y3"], ["L", "=V.x6", "=V.y3"], ["L", "=V.x6", f], ["L", w, "=V.y4"], ["L", "=V.x6", h], ["L", "=V.x6", "=V.y5"], ["L", c, "=V.y5"], ["L", c, h], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.y3",
					right: "=V.ir",
					bottom: "=V.y5"
				}
			},
			bentArrow: {
				variables: {
					adj1: 25000,
					adj2: 25000,
					adj3: 25000,
					adj4: 43750,
					a2: "=MIN(MAX(0, V.adj2), 50000)",
					maxAdj1: "=V.a2 * 2",
					a1: "=MIN(MAX(0, V.adj1), V.maxAdj1)",
					a3: "=MIN(MAX(0, V.adj3), 50000)",
					ss: s,
					th: "=V.ss * V.a1 / 100000",
					aw2: "=V.ss * V.a2 / 100000",
					th2: "=V.th / 2",
					dh2: "=V.aw2 - V.th2",
					ah: "=V.ss * V.a3 / 100000",
					r: w,
					bw: "=width - V.ah",
					b: h,
					bh: "=height - V.dh2",
					bs: "=MIN(V.bw, V.bh)",
					maxAdj4: "=100000 * V.bs / V.ss",
					a4: "=MIN(MAX(0, V.adj4), V.maxAdj4)",
					bd: "=V.ss * V.a4 / 100000",
					bd3: "=V.bd - V.th",
					bd2: "=MAX(V.bd3, 0)",
					x3: "=V.th + V.bd2",
					x4: "=width - V.ah",
					y3: "=V.dh2 + V.th",
					y4: "=V.y3 + V.dh2",
					y5: "=V.dh2 + V.bd",
					y6: "=V.y3 + V.bd2",
					t: 0,
					l: 0,
					cd2: B,
					cd4: C,
					cx1: "=C(V.bd,V.l,A(V.bd,V.bd,V.cd2),true)",
					cy1: "=C(V.bd,V.y5,A(V.bd,V.bd,V.cd2))",
					_3cd4: D,
					cx2: "=C(V.bd2,V.x3,A(V.bd2,V.bd2,V._3cd4),true)",
					cy2: "=C(V.bd2,V.y3,A(V.bd2,V.bd2,V._3cd4))"
				},
				adjustInfo: [["adj1", 25000], ["adj2", 25000], ["adj3", 25000], ["adj4", 43750]],
				connectionPoints: [{
						x: "=V.x4",
						y: 0
					}, {
						x: "=V.x4",
						y: "=V.y4"
					}, {
						x: "=V.th2",
						y: h
					}, {
						x: w,
						y: "=V.aw2"
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj1",
						minX: 0,
						maxX: "maxAdj1",
						position: {
							x: "th",
							y: "b"
						},
						point: ["=V.th", h]
					}, {
						type: "ahXY",
						gdRefY: "adj2",
						minY: 0,
						maxY: 50000,
						position: {
							x: "r",
							y: "y4"
						},
						point: [w, "=V.y4"]
					}, {
						type: "ahXY",
						gdRefX: "adj3",
						minX: 0,
						maxX: 50000,
						position: {
							x: "x4",
							y: "t"
						},
						point: ["=V.x4", 0]
					}, {
						type: "ahXY",
						gdRefX: "adj4",
						minX: 0,
						maxX: "maxAdj4",
						position: {
							x: "bd",
							y: "t"
						},
						point: ["=V.bd", 0]
					}
				],
				path: [[["M", 0, h], ["L", 0, "=V.y5"], ["E", "=V.cx1", "=V.cy1", "=V.bd", "=V.bd", 0, "=A(V.bd,V.bd,V.cd2)", "=A(V.bd,V.bd,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.x4", "=V.dh2"], ["L", "=V.x4", 0], ["L", w, "=V.aw2"], ["L", "=V.x4", "=V.y4"], ["L", "=V.x4", "=V.y3"], ["L", "=V.x3", "=V.y3"], ["E", "=V.cx2", "=V.cy2", "=V.bd2", "=V.bd2", 0, "=A(V.bd2,V.bd2,V._3cd4)", "=A(V.bd2,V.bd2,(V._3cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", "=V.th", h], ["Z"], {}
					]]
			},
			uTurnArrow: {
				variables: {
					adj1: 25000,
					adj2: 25000,
					adj3: 25000,
					adj4: 43750,
					adj5: 75000,
					a2: "=MIN(MAX(0, V.adj2), 25000)",
					maxAdj1: "=V.a2 * 2",
					a1: "=MIN(MAX(0, V.adj1), V.maxAdj1)",
					ss: s,
					q2: "=V.a1 * V.ss / height",
					q3: "=100000 - V.q2",
					maxAdj3: "=V.q3 * height / V.ss",
					a3: "=MIN(MAX(0, V.adj3), V.maxAdj3)",
					q1: "=V.a3 + V.a1",
					minAdj5: "=V.q1 * V.ss / height",
					a5: "=MIN(MAX(V.minAdj5, V.adj5), 100000)",
					th: "=V.ss * V.a1 / 100000",
					aw2: "=V.ss * V.a2 / 100000",
					th2: "=V.th / 2",
					dh2: "=V.aw2 - V.th2",
					y5: "=height * V.a5 / 100000",
					ah: "=V.ss * V.a3 / 100000",
					y4: "=V.y5 - V.ah",
					r: w,
					x9: "=width - V.dh2",
					bw: "=V.x9 / 2",
					bs: "=MIN(V.bw, V.y4)",
					maxAdj4: "=V.bs * 100000 / V.ss",
					a4: "=MIN(MAX(0, V.adj4), V.maxAdj4)",
					bd: "=V.ss * V.a4 / 100000",
					bd3: "=V.bd - V.th",
					bd2: "=MAX(V.bd3, 0)",
					x3: "=V.th + V.bd2",
					x8: "=width - V.aw2",
					x6: "=V.x8 - V.aw2",
					x7: "=V.x6 + V.dh2",
					x4: "=V.x9 - V.bd",
					x5: "=V.x7 - V.bd2",
					cx: "=(V.th + V.x7) / 2",
					t: 0,
					b: h,
					l: 0,
					cd2: B,
					cd4: C,
					cx1: "=C(V.bd,V.l,A(V.bd,V.bd,V.cd2),true)",
					cy1: "=C(V.bd,V.bd,A(V.bd,V.bd,V.cd2))",
					_3cd4: D,
					cx2: "=C(V.bd,V.x4,A(V.bd,V.bd,V._3cd4),true)",
					cy2: "=C(V.bd,V.t,A(V.bd,V.bd,V._3cd4))",
					cx3: "=C(V.bd2,V.x7,A(V.bd2,V.bd2,0),true)",
					cy3: "=C(V.bd2,V.x3,A(V.bd2,V.bd2,0))",
					cx4: "=C(V.bd2,V.x3,A(V.bd2,V.bd2,V._3cd4),true)",
					cy4: "=C(V.bd2,V.th,A(V.bd2,V.bd2,V._3cd4))"
				},
				adjustInfo: [["adj1", 25000], ["adj2", 25000], ["adj3", 25000], ["adj4", 43750], ["adj5", 75000]],
				connectionPoints: [{
						x: "=V.x6",
						y: "=V.y4"
					}, {
						x: "=V.x8",
						y: "=V.y5"
					}, {
						x: w,
						y: "=V.y4"
					}, {
						x: "=V.cx",
						y: 0
					}, {
						x: "=V.th2",
						y: h
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj1",
						minX: 0,
						maxX: "maxAdj1",
						position: {
							x: "th",
							y: "b"
						},
						point: ["=V.th", h]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: 25000,
						position: {
							x: "x6",
							y: "b"
						},
						point: ["=V.x6", h]
					}, {
						type: "ahXY",
						gdRefY: "adj3",
						minY: 0,
						maxY: "maxAdj3",
						position: {
							x: "x6",
							y: "y4"
						},
						point: ["=V.x6", "=V.y4"]
					}, {
						type: "ahXY",
						gdRefX: "adj4",
						minX: 0,
						maxX: "maxAdj4",
						position: {
							x: "bd",
							y: "t"
						},
						point: ["=V.bd", 0]
					}, {
						type: "ahXY",
						gdRefY: "adj5",
						minY: "minAdj5",
						maxY: 100000,
						position: {
							x: "r",
							y: "y5"
						},
						point: [w, "=V.y5"]
					}
				],
				path: [[["M", 0, h], ["L", 0, "=V.bd"], ["E", "=V.cx1", "=V.cy1", "=V.bd", "=V.bd", 0, "=A(V.bd,V.bd,V.cd2)", "=A(V.bd,V.bd,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.x4", 0], ["E", "=V.cx2", "=V.cy2", "=V.bd", "=V.bd", 0, "=A(V.bd,V.bd,V._3cd4)", "=A(V.bd,V.bd,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.x9", "=V.y4"], ["L", w, "=V.y4"], ["L", "=V.x8", "=V.y5"], ["L", "=V.x6", "=V.y4"], ["L", "=V.x7", "=V.y4"], ["L", "=V.x7", "=V.x3"], ["E", "=V.cx3", "=V.cy3", "=V.bd2", "=V.bd2", 0, "=A(V.bd2,V.bd2,0)", "=A(V.bd2,V.bd2,(-5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", "=V.x3", "=V.th"], ["E", "=V.cx4", "=V.cy4", "=V.bd2", "=V.bd2", 0, "=A(V.bd2,V.bd2,V._3cd4)", "=A(V.bd2,V.bd2,(V._3cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", "=V.th", h], ["Z"], {}
					]]
			},
			leftUpArrow: {
				variables: {
					adj1: 25000,
					adj2: 25000,
					adj3: 25000,
					a2: "=MIN(MAX(0, V.adj2), 50000)",
					maxAdj1: "=V.a2 * 2",
					a1: "=MIN(MAX(0, V.adj1), V.maxAdj1)",
					maxAdj3: "=100000 - V.maxAdj1",
					a3: "=MIN(MAX(0, V.adj3), V.maxAdj3)",
					ss: s,
					x1: "=V.ss * V.a3 / 100000",
					dx2: "=V.ss * V.a2 / 50000",
					r: w,
					x2: "=width - V.dx2",
					b: h,
					y2: "=height - V.dx2",
					dx4: "=V.ss * V.a2 / 100000",
					x4: "=width - V.dx4",
					y4: "=height - V.dx4",
					dx3: "=V.ss * V.a1 / 200000",
					x3: "=V.x4 - V.dx3",
					x5: "=V.x4 + V.dx3",
					y3: "=V.y4 - V.dx3",
					y5: "=V.y4 + V.dx3",
					il: "=V.dx3 * V.x1 / V.dx4",
					cx1: "=(V.x1 + V.x5) / 2",
					cy1: "=(V.x1 + V.y5) / 2",
					t: 0,
					l: 0
				},
				adjustInfo: [["adj1", 25000], ["adj2", 25000], ["adj3", 25000]],
				connectionPoints: [{
						x: "=V.x4",
						y: 0
					}, {
						x: d,
						y: c
					}, {
						x: c,
						y: f
					}, {
						x: 0,
						y: "=V.y4"
					}, {
						x: c,
						y: h
					}, {
						x: "=V.cx1",
						y: "=V.y5"
					}, {
						x: "=V.x5",
						y: "=V.cy1"
					}, {
						x: w,
						y: c
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: "maxAdj1",
						position: {
							x: "x3",
							y: "y3"
						},
						point: ["=V.x3", "=V.y3"]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: 50000,
						position: {
							x: "x2",
							y: "t"
						},
						point: [d, 0]
					}, {
						type: "ahXY",
						gdRefY: "adj3",
						minY: 0,
						maxY: "maxAdj3",
						position: {
							x: "x3",
							y: "x1"
						},
						point: ["=V.x3", c]
					}
				],
				path: [[["M", 0, "=V.y4"], ["L", c, f], ["L", c, "=V.y3"], ["L", "=V.x3", "=V.y3"], ["L", "=V.x3", c], ["L", d, c], ["L", "=V.x4", 0], ["L", w, c], ["L", "=V.x5", c], ["L", "=V.x5", "=V.y5"], ["L", c, "=V.y5"], ["L", c, h], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.y3",
					right: "=V.x4",
					bottom: "=V.y5"
				}
			},
			bentUpArrow: {
				variables: {
					adj1: 25000,
					adj2: 25000,
					adj3: 25000,
					a1: "=MIN(MAX(0, V.adj1), 50000)",
					a2: "=MIN(MAX(0, V.adj2), 50000)",
					a3: "=MIN(MAX(0, V.adj3), 50000)",
					ss: s,
					y1: "=V.ss * V.a3 / 100000",
					dx1: "=V.ss * V.a2 / 50000",
					r: w,
					x1: "=width - V.dx1",
					dx3: "=V.ss * V.a2 / 100000",
					x3: "=width - V.dx3",
					dx2: "=V.ss * V.a1 / 200000",
					x2: "=V.x3 - V.dx2",
					x4: "=V.x3 + V.dx2",
					dy2: "=V.ss * V.a1 / 100000",
					b: h,
					y2: "=height - V.dy2",
					x0: "=V.x4 / 2",
					y3: "=(V.y2 + V.b) / 2",
					y15: "=(V.y1 + V.b) / 2",
					t: 0,
					l: 0
				},
				adjustInfo: [["adj1", 25000], ["adj2", 25000], ["adj3", 25000]],
				connectionPoints: [{
						x: "=V.x3",
						y: 0
					}, {
						x: c,
						y: e
					}, {
						x: 0,
						y: "=V.y3"
					}, {
						x: "=V.x0",
						y: h
					}, {
						x: "=V.x4",
						y: "=V.y15"
					}, {
						x: w,
						y: e
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: 50000,
						position: {
							x: "l",
							y: "y2"
						},
						point: [0, f]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: 50000,
						position: {
							x: "x1",
							y: "t"
						},
						point: [c, 0]
					}, {
						type: "ahXY",
						gdRefY: "adj3",
						minY: 0,
						maxY: 50000,
						position: {
							x: "x2",
							y: "y1"
						},
						point: [d, e]
					}
				],
				path: [[["M", 0, f], ["L", d, f], ["L", d, e], ["L", c, e], ["L", "=V.x3", 0], ["L", w, e], ["L", "=V.x4", e], ["L", "=V.x4", h], ["L", 0, h], ["Z"], {}
					]],
				textRect: {
					left: 0,
					top: f,
					right: "=V.x4",
					bottom: h
				}
			},
			curvedRightArrow: {
				variables: {
					adj1: 25000,
					adj2: 50000,
					adj3: 25000,
					ss: s,
					maxAdj2: "=50000 * height / V.ss",
					a2: "=MIN(MAX(0, V.adj2), V.maxAdj2)",
					a1: "=MIN(MAX(0, V.adj1), V.a2)",
					th: "=V.ss * V.a1 / 100000",
					aw: "=V.ss * V.a2 / 100000",
					q1: "=(V.th + V.aw) / 4",
					hd2: F,
					hR: "=V.hd2 - V.q1",
					q7: "=V.hR * 2",
					q8: "=V.q7 * V.q7",
					q9: "=V.th * V.th",
					q10: "=V.q8 - V.q9",
					q11: "=SQRT(V.q10)",
					idx: "=V.q11 * width / V.q7",
					maxAdj3: "=100000 * V.idx / V.ss",
					a3: "=MIN(MAX(0, V.adj3), V.maxAdj3)",
					ah: "=V.ss * V.a3 / 100000",
					y3: "=V.hR + V.th",
					q2: "=width * width",
					q3: "=V.ah * V.ah",
					q4: "=V.q2 - V.q3",
					q5: "=SQRT(V.q4)",
					dy: "=V.q5 * V.hR / width",
					y5: "=V.hR + V.dy",
					y7: "=V.y3 + V.dy",
					q6: "=V.aw - V.th",
					dh: "=V.q6 / 2",
					y4: "=V.y5 - V.dh",
					y8: "=V.y7 + V.dh",
					aw2: "=V.aw / 2",
					b: h,
					y6: "=height - V.aw2",
					r: w,
					x1: "=width - V.ah",
					d2r: A,
					swAng: "=(ATAN2(V.ah,V.dy) * V.d2r)",
					cd2: B,
					stAng: "=V.cd2 - V.swAng",
					mswAng: "=0 - V.swAng",
					ix: "=width - V.idx",
					iy: "=(V.hR + V.y3) / 2",
					q12: "=V.th / 2",
					dang2: "=(ATAN2(V.idx,V.q12) * V.d2r)",
					cd4: C,
					swAng2: "=V.dang2 - V.cd4",
					swAng3: "=V.cd4 + V.dang2",
					stAng3: "=V.cd2 - V.dang2",
					l: 0,
					cx1: "=C(width,V.l,A(width,V.hR,V.cd2),true)",
					cy1: "=C(V.hR,V.hR,A(width,V.hR,V.cd2))",
					cx2: "=C(width,V.x1,A(width,V.hR,V.stAng),true)",
					cy2: "=C(V.hR,V.y7,A(width,V.hR,V.stAng))",
					_3cd4: D,
					cx3: "=C(width,V.r,A(width,V.hR,V._3cd4),true)",
					cy3: "=C(V.hR,V.th,A(width,V.hR,V._3cd4))",
					cx4: "=C(width,P(V.cx3,width,A(width,V.hR,(V._3cd4 + V.swAng2)),true),A(width,V.hR,V.stAng3),true)",
					cy4: "=C(V.hR,P(V.cy3,V.hR,A(width,V.hR,(V._3cd4 + V.swAng2))),A(width,V.hR,V.stAng3))",
					cx5: "=C(width,V.l,A(width,V.hR,V.cd2),true)",
					cy5: "=C(V.hR,V.hR,A(width,V.hR,V.cd2))",
					cx6: "=C(width,V.x1,A(width,V.hR,V.stAng),true)",
					cy6: "=C(V.hR,V.y7,A(width,V.hR,V.stAng))",
					cx7: "=C(width,V.l,A(width,V.hR,V.cd2),true)",
					cy7: "=C(V.hR,V.hR,A(width,V.hR,V.cd2))",
					cx8: "=C(width,V.r,A(width,V.hR,V._3cd4),true)",
					cy8: "=C(V.hR,V.th,A(width,V.hR,V._3cd4))"
				},
				adjustInfo: [["adj1", 25000], ["adj2", 50000], ["adj3", 25000]],
				connectionPoints: [{
						x: 0,
						y: "=V.iy"
					}, {
						x: c,
						y: "=V.y8"
					}, {
						x: w,
						y: "=V.y6"
					}, {
						x: c,
						y: "=V.y4"
					}, {
						x: w,
						y: "=V.q12"
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: "a2",
						position: {
							x: "x1",
							y: "y5"
						},
						point: [c, "=V.y5"]
					}, {
						type: "ahXY",
						gdRefY: "adj2",
						minY: 0,
						maxY: "maxAdj2",
						position: {
							x: "r",
							y: "y4"
						},
						point: [w, "=V.y4"]
					}, {
						type: "ahXY",
						gdRefX: "adj3",
						minX: 0,
						maxX: "maxAdj3",
						position: {
							x: "x1",
							y: "b"
						},
						point: [c, h]
					}
				],
				path: [[["M", 0, "=V.hR"], ["E", "=V.cx1", "=V.cy1", w, "=V.hR", 0, "=A(width,V.hR,V.cd2)", "=A(width,V.hR,(V.cd2 + V.mswAng))", "=IF(V.mswAng > 0, FALSE, TRUE)"], ["L", c, "=V.y4"], ["L", w, "=V.y6"], ["L", c, "=V.y8"], ["L", c, "=V.y7"], ["E", "=V.cx2", "=V.cy2", w, "=V.hR", 0, "=A(width,V.hR,V.stAng)", "=A(width,V.hR,(V.stAng + V.swAng))", "=IF(V.swAng > 0, FALSE, TRUE)"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", w, "=V.th"], ["E", "=V.cx3", "=V.cy3", w, "=V.hR", 0, "=A(width,V.hR,V._3cd4)", "=A(width,V.hR,(V._3cd4 + V.swAng2))", "=IF(V.swAng2 > 0, FALSE, TRUE)"], ["E", "=V.cx4", "=V.cy4", w, "=V.hR", 0, "=A(width,V.hR,V.stAng3)", "=A(width,V.hR,(V.stAng3 + V.swAng3))", "=IF(V.swAng3 > 0, FALSE, TRUE)"], ["Z"], {
							fillMode: "darkenLess",
							strokeMode: "false"
						}
					], [["M", 0, "=V.hR"], ["E", "=V.cx5", "=V.cy5", w, "=V.hR", 0, "=A(width,V.hR,V.cd2)", "=A(width,V.hR,(V.cd2 + V.mswAng))", "=IF(V.mswAng > 0, FALSE, TRUE)"], ["L", c, "=V.y4"], ["L", w, "=V.y6"], ["L", c, "=V.y8"], ["L", c, "=V.y7"], ["E", "=V.cx6", "=V.cy6", w, "=V.hR", 0, "=A(width,V.hR,V.stAng)", "=A(width,V.hR,(V.stAng + V.swAng))", "=IF(V.swAng > 0, FALSE, TRUE)"], ["L", 0, "=V.hR"], ["E", "=V.cx7", "=V.cy7", w, "=V.hR", 0, "=A(width,V.hR,V.cd2)", "=A(width,V.hR,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", w, "=V.th"], ["E", "=V.cx8", "=V.cy8", w, "=V.hR", 0, "=A(width,V.hR,V._3cd4)", "=A(width,V.hR,(V._3cd4 + V.swAng2))", "=IF(V.swAng2 > 0, FALSE, TRUE)"], {
							fillMode: "none"
						}
					]]
			},
			curvedLeftArrow: {
				variables: {
					adj1: 25000,
					adj2: 50000,
					adj3: 25000,
					ss: s,
					maxAdj2: "=50000 * height / V.ss",
					a2: "=MIN(MAX(0, V.adj2), V.maxAdj2)",
					a1: "=MIN(MAX(0, V.adj1), V.a2)",
					th: "=V.ss * V.a1 / 100000",
					aw: "=V.ss * V.a2 / 100000",
					q1: "=(V.th + V.aw) / 4",
					hd2: F,
					hR: "=V.hd2 - V.q1",
					q7: "=V.hR * 2",
					q8: "=V.q7 * V.q7",
					q9: "=V.th * V.th",
					q10: "=V.q8 - V.q9",
					q11: "=SQRT(V.q10)",
					idx: "=V.q11 * width / V.q7",
					maxAdj3: "=100000 * V.idx / V.ss",
					a3: "=MIN(MAX(0, V.adj3), V.maxAdj3)",
					ah: "=V.ss * V.a3 / 100000",
					y3: "=V.hR + V.th",
					q2: "=width * width",
					q3: "=V.ah * V.ah",
					q4: "=V.q2 - V.q3",
					q5: "=SQRT(V.q4)",
					dy: "=V.q5 * V.hR / width",
					y5: "=V.hR + V.dy",
					y7: "=V.y3 + V.dy",
					q6: "=V.aw - V.th",
					dh: "=V.q6 / 2",
					y4: "=V.y5 - V.dh",
					y8: "=V.y7 + V.dh",
					aw2: "=V.aw / 2",
					b: h,
					y6: "=height - V.aw2",
					l: 0,
					x1: "=V.ah",
					d2r: A,
					swAng: "=(ATAN2(V.ah,V.dy) * V.d2r)",
					mswAng: "=0 - V.swAng",
					ix: "=V.idx",
					iy: "=(V.hR + V.y3) / 2",
					q12: "=V.th / 2",
					dang2: "=(ATAN2(V.idx,V.q12) * V.d2r)",
					swAng2: "=V.dang2 - V.swAng",
					swAng3: "=V.swAng + V.dang2",
					stAng3: "=0 - V.dang2",
					r: w,
					cx1: "=C(width,V.x1,A(width,V.hR,V.swAng),true)",
					cy1: "=C(V.hR,V.y5,A(width,V.hR,V.swAng))",
					cx2: "=C(width,P(V.cx1,width,A(width,V.hR,(V.swAng + V.swAng2)),true),A(width,V.hR,V.stAng3),true)",
					cy2: "=C(V.hR,P(V.cy1,V.hR,A(width,V.hR,(V.swAng + V.swAng2))),A(width,V.hR,V.stAng3))",
					cx3: "=C(width,V.r,A(width,V.hR,0),true)",
					cy3: "=C(V.hR,V.y3,A(width,V.hR,0))",
					t: 0,
					_3cd4: D,
					cd4: C,
					cx4: "=C(width,V.l,A(width,V.hR,V._3cd4),true)",
					cy4: "=C(V.hR,V.t,A(width,V.hR,V._3cd4))",
					cx5: "=C(width,V.r,A(width,V.hR,0),true)",
					cy5: "=C(V.hR,V.y3,A(width,V.hR,0))",
					cx6: "=C(width,V.l,A(width,V.hR,V._3cd4),true)",
					cy6: "=C(V.hR,V.t,A(width,V.hR,V._3cd4))",
					cx7: "=C(width,V.r,A(width,V.hR,0),true)",
					cy7: "=C(V.hR,V.y3,A(width,V.hR,0))",
					cx8: "=C(width,V.x1,A(width,V.hR,V.swAng),true)",
					cy8: "=C(V.hR,V.y5,A(width,V.hR,V.swAng))"
				},
				adjustInfo: [["adj1", 25000], ["adj2", 50000], ["adj3", 25000]],
				connectionPoints: [{
						x: 0,
						y: "=V.q12"
					}, {
						x: c,
						y: "=V.y4"
					}, {
						x: 0,
						y: "=V.y6"
					}, {
						x: c,
						y: "=V.y8"
					}, {
						x: w,
						y: "=V.iy"
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: "a2",
						position: {
							x: "x1",
							y: "y5"
						},
						point: [c, "=V.y5"]
					}, {
						type: "ahXY",
						gdRefY: "adj2",
						minY: 0,
						maxY: "maxAdj2",
						position: {
							x: "r",
							y: "y4"
						},
						point: [w, "=V.y4"]
					}, {
						type: "ahXY",
						gdRefX: "adj3",
						minX: 0,
						maxX: "maxAdj3",
						position: {
							x: "x1",
							y: "b"
						},
						point: [c, h]
					}
				],
				path: [[["M", 0, "=V.y6"], ["L", c, "=V.y4"], ["L", c, "=V.y5"], ["E", "=V.cx1", "=V.cy1", w, "=V.hR", 0, "=A(width,V.hR,V.swAng)", "=A(width,V.hR,(V.swAng + V.swAng2))", "=IF(V.swAng2 > 0, FALSE, TRUE)"], ["E", "=V.cx2", "=V.cy2", w, "=V.hR", 0, "=A(width,V.hR,V.stAng3)", "=A(width,V.hR,(V.stAng3 + V.swAng3))", "=IF(V.swAng3 > 0, FALSE, TRUE)"], ["L", c, "=V.y8"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", w, "=V.y3"], ["E", "=V.cx3", "=V.cy3", w, "=V.hR", 0, "=A(width,V.hR,0)", "=A(width,V.hR,(-5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", 0, 0], ["E", "=V.cx4", "=V.cy4", w, "=V.hR", 0, "=A(width,V.hR,V._3cd4)", "=A(width,V.hR,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["Z"], {
							fillMode: "darkenLess",
							strokeMode: "false"
						}
					], [["M", w, "=V.y3"], ["E", "=V.cx5", "=V.cy5", w, "=V.hR", 0, "=A(width,V.hR,0)", "=A(width,V.hR,(-5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", 0, 0], ["E", "=V.cx6", "=V.cy6", w, "=V.hR", 0, "=A(width,V.hR,V._3cd4)", "=A(width,V.hR,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", w, "=V.y3"], ["E", "=V.cx7", "=V.cy7", w, "=V.hR", 0, "=A(width,V.hR,0)", "=A(width,V.hR,(V.swAng))", "=IF(V.swAng > 0, FALSE, TRUE)"], ["L", c, "=V.y8"], ["L", 0, "=V.y6"], ["L", c, "=V.y4"], ["L", c, "=V.y5"], ["E", "=V.cx8", "=V.cy8", w, "=V.hR", 0, "=A(width,V.hR,V.swAng)", "=A(width,V.hR,(V.swAng + V.swAng2))", "=IF(V.swAng2 > 0, FALSE, TRUE)"], {
							fillMode: "none"
						}
					]]
			},
			curvedUpArrow: {
				variables: {
					adj1: 25000,
					adj2: 50000,
					adj3: 25000,
					ss: s,
					maxAdj2: "=50000 * width / V.ss",
					a2: "=MIN(MAX(0, V.adj2), V.maxAdj2)",
					a1: "=MIN(MAX(0, V.adj1), 100000)",
					th: "=V.ss * V.a1 / 100000",
					aw: "=V.ss * V.a2 / 100000",
					q1: "=(V.th + V.aw) / 4",
					wd2: E,
					wR: "=V.wd2 - V.q1",
					q7: "=V.wR * 2",
					q8: "=V.q7 * V.q7",
					q9: "=V.th * V.th",
					q10: "=V.q8 - V.q9",
					q11: "=SQRT(V.q10)",
					idy: "=V.q11 * height / V.q7",
					maxAdj3: "=100000 * V.idy / V.ss",
					a3: "=MIN(MAX(0, V.adj3), V.maxAdj3)",
					ah: "=V.ss * V.adj3 / 100000",
					x3: "=V.wR + V.th",
					q2: "=height * height",
					q3: "=V.ah * V.ah",
					q4: "=V.q2 - V.q3",
					q5: "=SQRT(V.q4)",
					dx: "=V.q5 * V.wR / height",
					x5: "=V.wR + V.dx",
					x7: "=V.x3 + V.dx",
					q6: "=V.aw - V.th",
					dh: "=V.q6 / 2",
					x4: "=V.x5 - V.dh",
					x8: "=V.x7 + V.dh",
					aw2: "=V.aw / 2",
					r: w,
					x6: "=width - V.aw2",
					t: 0,
					y1: "=V.ah",
					d2r: A,
					swAng: "=(ATAN2(V.ah,V.dx) * V.d2r)",
					mswAng: "=0 - V.swAng",
					iy: "=V.idy",
					ix: "=(V.wR + V.x3) / 2",
					q12: "=V.th / 2",
					dang2: "=(ATAN2(V.idy,V.q12) * V.d2r)",
					swAng2: "=V.dang2 - V.swAng",
					mswAng2: "=0 - V.swAng2",
					cd4: C,
					stAng3: "=V.cd4 - V.swAng",
					swAng3: "=V.swAng + V.dang2",
					stAng2: "=V.cd4 - V.dang2",
					b: h,
					cx1: "=C(V.wR,V.x7,A(V.wR,height,V.stAng3),true)",
					cy1: "=C(height,V.y1,A(V.wR,height,V.stAng3))",
					cx2: "=C(V.wR,P(V.cx1,V.wR,A(V.wR,height,(V.stAng3 + V.swAng3)),true),A(V.wR,height,V.stAng2),true)",
					cy2: "=C(height,P(V.cy1,height,A(V.wR,height,(V.stAng3 + V.swAng3))),A(V.wR,height,V.stAng2))",
					cx3: "=C(V.wR,V.wR,A(V.wR,height,V.cd4),true)",
					cy3: "=C(height,V.b,A(V.wR,height,V.cd4))",
					cd2: B,
					cx4: "=C(V.wR,V.th,A(V.wR,height,V.cd2),true)",
					cy4: "=C(height,V.t,A(V.wR,height,V.cd2))",
					cx5: "=C(V.wR,V.ix,A(V.wR,height,V.stAng2),true)",
					cy5: "=C(height,V.iy,A(V.wR,height,V.stAng2))",
					cx6: "=C(V.wR,V.x7,A(V.wR,height,V.stAng3),true)",
					cy6: "=C(height,V.y1,A(V.wR,height,V.stAng3))",
					cx7: "=C(V.wR,V.wR,A(V.wR,height,V.cd4),true)",
					cy7: "=C(height,V.b,A(V.wR,height,V.cd4))",
					cx8: "=C(V.wR,V.th,A(V.wR,height,V.cd2),true)",
					cy8: "=C(height,V.t,A(V.wR,height,V.cd2))"
				},
				adjustInfo: [["adj1", 25000], ["adj2", 50000], ["adj3", 25000]],
				connectionPoints: [{
						x: "=V.x6",
						y: 0
					}, {
						x: "=V.x4",
						y: e
					}, {
						x: "=V.q12",
						y: 0
					}, {
						x: "=V.ix",
						y: h
					}, {
						x: "=V.x8",
						y: e
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj1",
						minX: 0,
						maxX: "a2",
						position: {
							x: "x7",
							y: "y1"
						},
						point: ["=V.x7", e]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: "maxAdj2",
						position: {
							x: "x4",
							y: "t"
						},
						point: ["=V.x4", 0]
					}, {
						type: "ahXY",
						gdRefY: "adj3",
						minY: 0,
						maxY: "maxAdj3",
						position: {
							x: "r",
							y: "y1"
						},
						point: [w, e]
					}
				],
				path: [[["M", "=V.x6", 0], ["L", "=V.x8", e], ["L", "=V.x7", e], ["E", "=V.cx1", "=V.cy1", "=V.wR", h, 0, "=A(V.wR,height,V.stAng3)", "=A(V.wR,height,(V.stAng3 + V.swAng3))", "=IF(V.swAng3 > 0, FALSE, TRUE)"], ["E", "=V.cx2", "=V.cy2", "=V.wR", h, 0, "=A(V.wR,height,V.stAng2)", "=A(V.wR,height,(V.stAng2 + V.swAng2))", "=IF(V.swAng2 > 0, FALSE, TRUE)"], ["L", "=V.x4", e], ["Z"], {
							strokeMode: "false"
						}
					], [["M", "=V.wR", h], ["E", "=V.cx3", "=V.cy3", "=V.wR", h, 0, "=A(V.wR,height,V.cd4)", "=A(V.wR,height,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.th", 0], ["E", "=V.cx4", "=V.cy4", "=V.wR", h, 0, "=A(V.wR,height,V.cd2)", "=A(V.wR,height,(V.cd2 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["Z"], {
							fillMode: "darkenLess",
							strokeMode: "false"
						}
					], [["M", "=V.ix", "=V.iy"], ["E", "=V.cx5", "=V.cy5", "=V.wR", h, 0, "=A(V.wR,height,V.stAng2)", "=A(V.wR,height,(V.stAng2 + V.swAng2))", "=IF(V.swAng2 > 0, FALSE, TRUE)"], ["L", "=V.x4", e], ["L", "=V.x6", 0], ["L", "=V.x8", e], ["L", "=V.x7", e], ["E", "=V.cx6", "=V.cy6", "=V.wR", h, 0, "=A(V.wR,height,V.stAng3)", "=A(V.wR,height,(V.stAng3 + V.swAng))", "=IF(V.swAng > 0, FALSE, TRUE)"], ["L", "=V.wR", h], ["E", "=V.cx7", "=V.cy7", "=V.wR", h, 0, "=A(V.wR,height,V.cd4)", "=A(V.wR,height,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.th", 0], ["E", "=V.cx8", "=V.cy8", "=V.wR", h, 0, "=A(V.wR,height,V.cd2)", "=A(V.wR,height,(V.cd2 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], {
							fillMode: "none"
						}
					]]
			},
			curvedDownArrow: {
				variables: {
					adj1: 25000,
					adj2: 50000,
					adj3: 25000,
					ss: s,
					maxAdj2: "=50000 * width / V.ss",
					a2: "=MIN(MAX(0, V.adj2), V.maxAdj2)",
					a1: "=MIN(MAX(0, V.adj1), 100000)",
					th: "=V.ss * V.a1 / 100000",
					aw: "=V.ss * V.a2 / 100000",
					q1: "=(V.th + V.aw) / 4",
					wd2: E,
					wR: "=V.wd2 - V.q1",
					q7: "=V.wR * 2",
					q8: "=V.q7 * V.q7",
					q9: "=V.th * V.th",
					q10: "=V.q8 - V.q9",
					q11: "=SQRT(V.q10)",
					idy: "=V.q11 * height / V.q7",
					maxAdj3: "=100000 * V.idy / V.ss",
					a3: "=MIN(MAX(0, V.adj3), V.maxAdj3)",
					ah: "=V.ss * V.adj3 / 100000",
					x3: "=V.wR + V.th",
					q2: "=height * height",
					q3: "=V.ah * V.ah",
					q4: "=V.q2 - V.q3",
					q5: "=SQRT(V.q4)",
					dx: "=V.q5 * V.wR / height",
					x5: "=V.wR + V.dx",
					x7: "=V.x3 + V.dx",
					q6: "=V.aw - V.th",
					dh: "=V.q6 / 2",
					x4: "=V.x5 - V.dh",
					x8: "=V.x7 + V.dh",
					aw2: "=V.aw / 2",
					r: w,
					x6: "=width - V.aw2",
					b: h,
					y1: "=height - V.ah",
					d2r: A,
					swAng: "=(ATAN2(V.ah,V.dx) * V.d2r)",
					mswAng: "=0 - V.swAng",
					iy: "=height - V.idy",
					ix: "=(V.wR + V.x3) / 2",
					q12: "=V.th / 2",
					dang2: "=(ATAN2(V.idy,V.q12) * V.d2r)",
					_3cd4: D,
					stAng: "=V._3cd4 + V.swAng",
					stAng2: "=V._3cd4 - V.dang2",
					cd4: C,
					swAng2: "=V.dang2 - V.cd4",
					swAng3: "=V.cd4 + V.dang2",
					t: 0,
					cx1: "=C(V.wR,V.x5,A(V.wR,height,V.stAng),true)",
					cy1: "=C(height,V.y1,A(V.wR,height,V.stAng))",
					cx2: "=C(V.wR,V.x3,A(V.wR,height,V._3cd4),true)",
					cy2: "=C(height,V.t,A(V.wR,height,V._3cd4))",
					cx3: "=C(V.wR,V.ix,A(V.wR,height,V.stAng2),true)",
					cy3: "=C(height,V.iy,A(V.wR,height,V.stAng2))",
					l: 0,
					cd2: B,
					cx4: "=C(V.wR,V.l,A(V.wR,height,V.cd2),true)",
					cy4: "=C(height,V.b,A(V.wR,height,V.cd2))",
					cx5: "=C(V.wR,V.ix,A(V.wR,height,V.stAng2),true)",
					cy5: "=C(height,V.iy,A(V.wR,height,V.stAng2))",
					cx6: "=C(V.wR,V.l,A(V.wR,height,V.cd2),true)",
					cy6: "=C(height,V.b,A(V.wR,height,V.cd2))",
					cx7: "=C(V.wR,V.x3,A(V.wR,height,V._3cd4),true)",
					cy7: "=C(height,V.t,A(V.wR,height,V._3cd4))",
					cx8: "=C(V.wR,V.x5,A(V.wR,height,V.stAng),true)",
					cy8: "=C(height,V.y1,A(V.wR,height,V.stAng))"
				},
				adjustInfo: [["adj1", 25000], ["adj2", 50000], ["adj3", 25000]],
				connectionPoints: [{
						x: "=V.ix",
						y: 0
					}, {
						x: "=V.q12",
						y: h
					}, {
						x: "=V.x4",
						y: e
					}, {
						x: "=V.x6",
						y: h
					}, {
						x: "=V.x8",
						y: e
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj1",
						minX: 0,
						maxX: "adj2",
						position: {
							x: "x7",
							y: "y1"
						},
						point: ["=V.x7", e]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: "maxAdj2",
						position: {
							x: "x4",
							y: "b"
						},
						point: ["=V.x4", h]
					}, {
						type: "ahXY",
						gdRefY: "adj3",
						minY: 0,
						maxY: "maxAdj3",
						position: {
							x: "r",
							y: "y1"
						},
						point: [w, e]
					}
				],
				path: [[["M", "=V.x6", h], ["L", "=V.x4", e], ["L", "=V.x5", e], ["E", "=V.cx1", "=V.cy1", "=V.wR", h, 0, "=A(V.wR,height,V.stAng)", "=A(V.wR,height,(V.stAng + V.mswAng))", "=IF(V.mswAng > 0, FALSE, TRUE)"], ["L", "=V.x3", 0], ["E", "=V.cx2", "=V.cy2", "=V.wR", h, 0, "=A(V.wR,height,V._3cd4)", "=A(V.wR,height,(V._3cd4 + V.swAng))", "=IF(V.swAng > 0, FALSE, TRUE)"], ["L", "=V.x8", e], ["Z"], {
							strokeMode: "false"
						}
					], [["M", "=V.ix", "=V.iy"], ["E", "=V.cx3", "=V.cy3", "=V.wR", h, 0, "=A(V.wR,height,V.stAng2)", "=A(V.wR,height,(V.stAng2 + V.swAng2))", "=IF(V.swAng2 > 0, FALSE, TRUE)"], ["L", 0, h], ["E", "=V.cx4", "=V.cy4", "=V.wR", h, 0, "=A(V.wR,height,V.cd2)", "=A(V.wR,height,(V.cd2 + V.swAng3))", "=IF(V.swAng3 > 0, FALSE, TRUE)"], ["Z"], {
							fillMode: "darkenLess",
							strokeMode: "false"
						}
					], [["M", "=V.ix", "=V.iy"], ["E", "=V.cx5", "=V.cy5", "=V.wR", h, 0, "=A(V.wR,height,V.stAng2)", "=A(V.wR,height,(V.stAng2 + V.swAng2))", "=IF(V.swAng2 > 0, FALSE, TRUE)"], ["L", 0, h], ["E", "=V.cx6", "=V.cy6", "=V.wR", h, 0, "=A(V.wR,height,V.cd2)", "=A(V.wR,height,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.x3", 0], ["E", "=V.cx7", "=V.cy7", "=V.wR", h, 0, "=A(V.wR,height,V._3cd4)", "=A(V.wR,height,(V._3cd4 + V.swAng))", "=IF(V.swAng > 0, FALSE, TRUE)"], ["L", "=V.x8", e], ["L", "=V.x6", h], ["L", "=V.x4", e], ["L", "=V.x5", e], ["E", "=V.cx8", "=V.cy8", "=V.wR", h, 0, "=A(V.wR,height,V.stAng)", "=A(V.wR,height,(V.stAng + V.mswAng))", "=IF(V.mswAng > 0, FALSE, TRUE)"], {
							fillMode: "none"
						}
					]]
			},
			stripedRightArrow: {
				variables: {
					adj1: 50000,
					adj2: 50000,
					ss: s,
					maxAdj2: "=84375 * width / V.ss",
					a1: "=MIN(MAX(0, V.adj1), 100000)",
					a2: "=MIN(MAX(0, V.adj2), V.maxAdj2)",
					x4: "=V.ss * 5 / 32",
					dx5: "=V.ss * V.a2 / 100000",
					r: w,
					x5: "=width - V.dx5",
					dy1: "=height * V.a1 / 200000",
					vc: F,
					y1: "=V.vc - V.dy1",
					y2: "=V.vc + V.dy1",
					hd2: F,
					dx6: "=V.dy1 * V.dx5 / V.hd2",
					x6: "=width - V.dx6",
					t: 0,
					l: 0,
					b: h,
					ssd32: "=V.ss / 32",
					ssd16: "=V.ss / 16",
					ssd8: "=V.ss / 8"
				},
				adjustInfo: [["adj1", 50000], ["adj2", 50000]],
				connectionPoints: [{
						x: "=V.x5",
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: "=V.x5",
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: 100000,
						position: {
							x: "l",
							y: "y1"
						},
						point: [0, e]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: "maxAdj2",
						position: {
							x: "x5",
							y: "t"
						},
						point: ["=V.x5", 0]
					}
				],
				path: [[["M", 0, e], ["L", "=V.ssd32", e], ["L", "=V.ssd32", f], ["L", 0, f], ["Z"], ["M", "=V.ssd16", e], ["L", "=V.ssd8", e], ["L", "=V.ssd8", f], ["L", "=V.ssd16", f], ["Z"], ["M", "=V.x4", e], ["L", "=V.x5", e], ["L", "=V.x5", 0], ["L", w, b], ["L", "=V.x5", h], ["L", "=V.x5", f], ["L", "=V.x4", f], ["Z"], {}
					]],
				textRect: {
					left: "=V.x4",
					top: e,
					right: "=V.x6",
					bottom: f
				}
			},
			notchedRightArrow: {
				variables: {
					adj1: 50000,
					adj2: 50000,
					ss: s,
					maxAdj2: "=100000 * width / V.ss",
					a1: "=MIN(MAX(0, V.adj1), 100000)",
					a2: "=MIN(MAX(0, V.adj2), V.maxAdj2)",
					dx2: "=V.ss * V.a2 / 100000",
					r: w,
					x2: "=width - V.dx2",
					dy1: "=height * V.a1 / 200000",
					vc: F,
					y1: "=V.vc - V.dy1",
					y2: "=V.vc + V.dy1",
					hd2: F,
					x1: "=V.dy1 * V.dx2 / V.hd2",
					x3: "=width - V.x1",
					t: 0,
					b: h,
					l: 0
				},
				adjustInfo: [["adj1", 50000], ["adj2", 50000]],
				connectionPoints: [{
						x: d,
						y: 0
					}, {
						x: c,
						y: b
					}, {
						x: d,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: 100000,
						position: {
							x: "r",
							y: "y1"
						},
						point: [w, e]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: "maxAdj2",
						position: {
							x: "x2",
							y: "t"
						},
						point: [d, 0]
					}
				],
				path: [[["M", 0, e], ["L", d, e], ["L", d, 0], ["L", w, b], ["L", d, h], ["L", d, f], ["L", 0, f], ["L", c, b], ["Z"], {}
					]],
				textRect: {
					left: c,
					top: e,
					right: "=V.x3",
					bottom: f
				}
			},
			pentagon: {
				variables: {
					adj: 50000,
					ss: s,
					maxAdj: "=100000 * width / V.ss",
					a: "=MIN(MAX(0, V.adj), V.maxAdj)",
					dx1: "=V.ss * V.a / 100000",
					r: w,
					x1: "=width - V.dx1",
					ir: "=(V.x1 + V.r) / 2",
					x2: "=V.x1 / 2",
					t: 0,
					l: 0,
					vc: F,
					b: h
				},
				adjustInfo: [["adj", 50000]],
				connectionPoints: [{
						x: d,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: c,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj",
						minX: 0,
						maxX: "maxAdj",
						position: {
							x: "x1",
							y: "t"
						},
						point: [c, 0]
					}
				],
				path: [[["M", 0, 0], ["L", c, 0], ["L", w, b], ["L", c, h], ["L", 0, h], ["Z"], {}
					]],
				textRect: {
					left: 0,
					top: 0,
					right: "=V.ir",
					bottom: h
				}
			},
			chevron: {
				variables: {
					adj: 50000,
					ss: s,
					maxAdj: "=100000 * width / V.ss",
					a: "=MIN(MAX(0, V.adj), V.maxAdj)",
					x1: "=V.ss * V.a / 100000",
					r: w,
					x2: "=width - V.x1",
					x3: "=V.x2 / 2",
					dx: "=V.x2 - V.x1",
					l: 0,
					il: "=IF(V.dx > 0, V.x1, V.l)",
					ir: "=IF(V.dx > 0, V.x2, V.r)",
					t: 0,
					vc: F,
					b: h
				},
				adjustInfo: [["adj", 50000]],
				connectionPoints: [{
						x: "=V.x3",
						y: 0
					}, {
						x: c,
						y: b
					}, {
						x: "=V.x3",
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj",
						minX: 0,
						maxX: "maxAdj",
						position: {
							x: "x2",
							y: "t"
						},
						point: [d, 0]
					}
				],
				path: [[["M", 0, 0], ["L", d, 0], ["L", w, b], ["L", d, h], ["L", 0, h], ["L", c, b], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: 0,
					right: "=V.ir",
					bottom: h
				}
			},
			rightArrowCallout: {
				variables: {
					adj1: 25000,
					adj2: 25000,
					adj3: 25000,
					adj4: 64977,
					ss: s,
					maxAdj2: "=50000 * height / V.ss",
					a2: "=MIN(MAX(0, V.adj2), V.maxAdj2)",
					maxAdj1: "=V.a2 * 2",
					a1: "=MIN(MAX(0, V.adj1), V.maxAdj1)",
					maxAdj3: "=100000 * width / V.ss",
					a3: "=MIN(MAX(0, V.adj3), V.maxAdj3)",
					q2: "=V.a3 * V.ss / width",
					maxAdj4: "=100000 - V.q2",
					a4: "=MIN(MAX(0, V.adj4), V.maxAdj4)",
					dy1: "=V.ss * V.a2 / 100000",
					dy2: "=V.ss * V.a1 / 200000",
					vc: F,
					y1: "=V.vc - V.dy1",
					y2: "=V.vc - V.dy2",
					y3: "=V.vc + V.dy2",
					y4: "=V.vc + V.dy1",
					dx3: "=V.ss * V.a3 / 100000",
					r: w,
					x3: "=width - V.dx3",
					x2: "=width * V.a4 / 100000",
					x1: "=V.x2 / 2",
					t: 0,
					l: 0,
					b: h
				},
				adjustInfo: [["adj1", 25000], ["adj2", 25000], ["adj3", 25000], ["adj4", 64977]],
				connectionPoints: [{
						x: c,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: c,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: "maxAdj1",
						position: {
							x: "x3",
							y: "y2"
						},
						point: ["=V.x3", f]
					}, {
						type: "ahXY",
						gdRefY: "adj2",
						minY: 0,
						maxY: "maxAdj2",
						position: {
							x: "r",
							y: "y1"
						},
						point: [w, e]
					}, {
						type: "ahXY",
						gdRefX: "adj3",
						minX: 0,
						maxX: "maxAdj3",
						position: {
							x: "x3",
							y: "t"
						},
						point: ["=V.x3", 0]
					}, {
						type: "ahXY",
						gdRefX: "adj4",
						minX: 0,
						maxX: "maxAdj4",
						position: {
							x: "x2",
							y: "b"
						},
						point: [d, h]
					}
				],
				path: [[["M", 0, 0], ["L", d, 0], ["L", d, f], ["L", "=V.x3", f], ["L", "=V.x3", e], ["L", w, b], ["L", "=V.x3", "=V.y4"], ["L", "=V.x3", "=V.y3"], ["L", d, "=V.y3"], ["L", d, h], ["L", 0, h], ["Z"], {}
					]],
				textRect: {
					left: 0,
					top: 0,
					right: d,
					bottom: h
				}
			},
			leftArrowCallout: {
				variables: {
					adj1: 25000,
					adj2: 25000,
					adj3: 25000,
					adj4: 64977,
					ss: s,
					maxAdj2: "=50000 * height / V.ss",
					a2: "=MIN(MAX(0, V.adj2), V.maxAdj2)",
					maxAdj1: "=V.a2 * 2",
					a1: "=MIN(MAX(0, V.adj1), V.maxAdj1)",
					maxAdj3: "=100000 * width / V.ss",
					a3: "=MIN(MAX(0, V.adj3), V.maxAdj3)",
					q2: "=V.a3 * V.ss / width",
					maxAdj4: "=100000 - V.q2",
					a4: "=MIN(MAX(0, V.adj4), V.maxAdj4)",
					dy1: "=V.ss * V.a2 / 100000",
					dy2: "=V.ss * V.a1 / 200000",
					vc: F,
					y1: "=V.vc - V.dy1",
					y2: "=V.vc - V.dy2",
					y3: "=V.vc + V.dy2",
					y4: "=V.vc + V.dy1",
					x1: "=V.ss * V.a3 / 100000",
					dx2: "=width * V.a4 / 100000",
					r: w,
					x2: "=width - V.dx2",
					x3: "=(V.x2 + V.r) / 2",
					t: 0,
					l: 0,
					b: h
				},
				adjustInfo: [["adj1", 25000], ["adj2", 25000], ["adj3", 25000], ["adj4", 64977]],
				connectionPoints: [{
						x: "=V.x3",
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: "=V.x3",
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: "maxAdj1",
						position: {
							x: "x1",
							y: "y2"
						},
						point: [c, f]
					}, {
						type: "ahXY",
						gdRefY: "adj2",
						minY: 0,
						maxY: "maxAdj2",
						position: {
							x: "l",
							y: "y1"
						},
						point: [0, e]
					}, {
						type: "ahXY",
						gdRefX: "adj3",
						minX: 0,
						maxX: "maxAdj3",
						position: {
							x: "x1",
							y: "t"
						},
						point: [c, 0]
					}, {
						type: "ahXY",
						gdRefX: "adj4",
						minX: 0,
						maxX: "maxAdj4",
						position: {
							x: "x2",
							y: "b"
						},
						point: [d, h]
					}
				],
				path: [[["M", 0, b], ["L", c, e], ["L", c, f], ["L", d, f], ["L", d, 0], ["L", w, 0], ["L", w, h], ["L", d, h], ["L", d, "=V.y3"], ["L", c, "=V.y3"], ["L", c, "=V.y4"], ["Z"], {}
					]],
				textRect: {
					left: d,
					top: 0,
					right: w,
					bottom: h
				}
			},
			upArrowCallout: {
				variables: {
					adj1: 25000,
					adj2: 25000,
					adj3: 25000,
					adj4: 64977,
					ss: s,
					maxAdj2: "=50000 * width / V.ss",
					a2: "=MIN(MAX(0, V.adj2), V.maxAdj2)",
					maxAdj1: "=V.a2 * 2",
					a1: "=MIN(MAX(0, V.adj1), V.maxAdj1)",
					maxAdj3: "=100000 * height / V.ss",
					a3: "=MIN(MAX(0, V.adj3), V.maxAdj3)",
					q2: "=V.a3 * V.ss / height",
					maxAdj4: "=100000 - V.q2",
					a4: "=MIN(MAX(0, V.adj4), V.maxAdj4)",
					dx1: "=V.ss * V.a2 / 100000",
					dx2: "=V.ss * V.a1 / 200000",
					hc: E,
					x1: "=V.hc - V.dx1",
					x2: "=V.hc - V.dx2",
					x3: "=V.hc + V.dx2",
					x4: "=V.hc + V.dx1",
					y1: "=V.ss * V.a3 / 100000",
					dy2: "=height * V.a4 / 100000",
					b: h,
					y2: "=height - V.dy2",
					y3: "=(V.y2 + V.b) / 2",
					t: 0,
					l: 0,
					r: w
				},
				adjustInfo: [["adj1", 25000], ["adj2", 25000], ["adj3", 25000], ["adj4", 64977]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: f
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: f
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj1",
						minX: 0,
						maxX: "maxAdj1",
						position: {
							x: "x2",
							y: "y1"
						},
						point: [d, e]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: "maxAdj2",
						position: {
							x: "x1",
							y: "t"
						},
						point: [c, 0]
					}, {
						type: "ahXY",
						gdRefY: "adj3",
						minY: 0,
						maxY: "maxAdj3",
						position: {
							x: "r",
							y: "y1"
						},
						point: [w, e]
					}, {
						type: "ahXY",
						gdRefY: "adj4",
						minY: 0,
						maxY: "maxAdj4",
						position: {
							x: "l",
							y: "y2"
						},
						point: [0, f]
					}
				],
				path: [[["M", 0, f], ["L", d, f], ["L", d, e], ["L", c, e], ["L", a, 0], ["L", "=V.x4", e], ["L", "=V.x3", e], ["L", "=V.x3", f], ["L", w, f], ["L", w, h], ["L", 0, h], ["Z"], {}
					]],
				textRect: {
					left: 0,
					top: f,
					right: w,
					bottom: h
				}
			},
			downArrowCallout: {
				variables: {
					adj1: 25000,
					adj2: 25000,
					adj3: 25000,
					adj4: 64977,
					ss: s,
					maxAdj2: "=50000 * width / V.ss",
					a2: "=MIN(MAX(0, V.adj2), V.maxAdj2)",
					maxAdj1: "=V.a2 * 2",
					a1: "=MIN(MAX(0, V.adj1), V.maxAdj1)",
					maxAdj3: "=100000 * height / V.ss",
					a3: "=MIN(MAX(0, V.adj3), V.maxAdj3)",
					q2: "=V.a3 * V.ss / height",
					maxAdj4: "=100000 - V.q2",
					a4: "=MIN(MAX(0, V.adj4), V.maxAdj4)",
					dx1: "=V.ss * V.a2 / 100000",
					dx2: "=V.ss * V.a1 / 200000",
					hc: E,
					x1: "=V.hc - V.dx1",
					x2: "=V.hc - V.dx2",
					x3: "=V.hc + V.dx2",
					x4: "=V.hc + V.dx1",
					dy3: "=V.ss * V.a3 / 100000",
					b: h,
					y3: "=height - V.dy3",
					y2: "=height * V.a4 / 100000",
					y1: "=V.y2 / 2",
					t: 0,
					l: 0,
					r: w
				},
				adjustInfo: [["adj1", 25000], ["adj2", 25000], ["adj3", 25000], ["adj4", 64977]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: e
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: e
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj1",
						minX: 0,
						maxX: "maxAdj1",
						position: {
							x: "x2",
							y: "y3"
						},
						point: [d, "=V.y3"]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: "maxAdj2",
						position: {
							x: "x1",
							y: "b"
						},
						point: [c, h]
					}, {
						type: "ahXY",
						gdRefY: "adj3",
						minY: 0,
						maxY: "maxAdj3",
						position: {
							x: "r",
							y: "y3"
						},
						point: [w, "=V.y3"]
					}, {
						type: "ahXY",
						gdRefY: "adj4",
						minY: 0,
						maxY: "maxAdj4",
						position: {
							x: "l",
							y: "y2"
						},
						point: [0, f]
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, f], ["L", "=V.x3", f], ["L", "=V.x3", "=V.y3"], ["L", "=V.x4", "=V.y3"], ["L", a, h], ["L", c, "=V.y3"], ["L", d, "=V.y3"], ["L", d, f], ["L", 0, f], ["Z"], {}
					]],
				textRect: {
					left: 0,
					top: 0,
					right: w,
					bottom: f
				}
			},
			leftRightArrowCallout: {
				variables: {
					adj1: 25000,
					adj2: 25000,
					adj3: 25000,
					adj4: 48123,
					ss: s,
					maxAdj2: "=50000 * height / V.ss",
					a2: "=MIN(MAX(0, V.adj2), V.maxAdj2)",
					maxAdj1: "=V.a2 * 2",
					a1: "=MIN(MAX(0, V.adj1), V.maxAdj1)",
					maxAdj3: "=50000 * width / V.ss",
					a3: "=MIN(MAX(0, V.adj3), V.maxAdj3)",
					wd2: E,
					q2: "=V.a3 * V.ss / V.wd2",
					maxAdj4: "=100000 - V.q2",
					a4: "=MIN(MAX(0, V.adj4), V.maxAdj4)",
					dy1: "=V.ss * V.a2 / 100000",
					dy2: "=V.ss * V.a1 / 200000",
					vc: F,
					y1: "=V.vc - V.dy1",
					y2: "=V.vc - V.dy2",
					y3: "=V.vc + V.dy2",
					y4: "=V.vc + V.dy1",
					x1: "=V.ss * V.a3 / 100000",
					r: w,
					x4: "=width - V.x1",
					dx2: "=width * V.a4 / 200000",
					hc: E,
					x2: "=V.hc - V.dx2",
					x3: "=V.hc + V.dx2",
					t: 0,
					l: 0,
					b: h
				},
				adjustInfo: [["adj1", 25000], ["adj2", 25000], ["adj3", 25000], ["adj4", 48123]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: "maxAdj1",
						position: {
							x: "x1",
							y: "y2"
						},
						point: [c, f]
					}, {
						type: "ahXY",
						gdRefY: "adj2",
						minY: 0,
						maxY: "maxAdj2",
						position: {
							x: "l",
							y: "y1"
						},
						point: [0, e]
					}, {
						type: "ahXY",
						gdRefX: "adj3",
						minX: 0,
						maxX: "maxAdj3",
						position: {
							x: "x1",
							y: "t"
						},
						point: [c, 0]
					}, {
						type: "ahXY",
						gdRefX: "adj4",
						minX: 0,
						maxX: "maxAdj4",
						position: {
							x: "x2",
							y: "b"
						},
						point: [d, h]
					}
				],
				path: [[["M", 0, b], ["L", c, e], ["L", c, f], ["L", d, f], ["L", d, 0], ["L", "=V.x3", 0], ["L", "=V.x3", f], ["L", "=V.x4", f], ["L", "=V.x4", e], ["L", w, b], ["L", "=V.x4", "=V.y4"], ["L", "=V.x4", "=V.y3"], ["L", "=V.x3", "=V.y3"], ["L", "=V.x3", h], ["L", d, h], ["L", d, "=V.y3"], ["L", c, "=V.y3"], ["L", c, "=V.y4"], ["Z"], {}
					]],
				textRect: {
					left: d,
					top: 0,
					right: "=V.x3",
					bottom: h
				}
			},
			upDownArrowCallout: {
				variables: {
					adj1: 25000,
					adj2: 25000,
					adj3: 25000,
					adj4: 48123,
					ss: s,
					maxAdj2: "=50000 * width / V.ss",
					a2: "=MIN(MAX(0, V.adj2), V.maxAdj2)",
					maxAdj1: "=V.a2 * 2",
					a1: "=MIN(MAX(0, V.adj1), V.maxAdj1)",
					maxAdj3: "=50000 * height / V.ss",
					a3: "=MIN(MAX(0, V.adj3), V.maxAdj3)",
					hd2: F,
					q2: "=V.a3 * V.ss / V.hd2",
					maxAdj4: "=100000 - V.q2",
					a4: "=MIN(MAX(0, V.adj4), V.maxAdj4)",
					dx1: "=V.ss * V.a2 / 100000",
					dx2: "=V.ss * V.a1 / 200000",
					hc: E,
					x1: "=V.hc - V.dx1",
					x2: "=V.hc - V.dx2",
					x3: "=V.hc + V.dx2",
					x4: "=V.hc + V.dx1",
					y1: "=V.ss * V.a3 / 100000",
					b: h,
					y4: "=height - V.y1",
					dy2: "=height * V.a4 / 200000",
					vc: F,
					y2: "=V.vc - V.dy2",
					y3: "=V.vc + V.dy2",
					t: 0,
					l: 0,
					r: w
				},
				adjustInfo: [["adj1", 25000], ["adj2", 25000], ["adj3", 25000], ["adj4", 48123]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj1",
						minX: 0,
						maxX: "maxAdj1",
						position: {
							x: "x2",
							y: "y1"
						},
						point: [d, e]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: "maxAdj2",
						position: {
							x: "x1",
							y: "t"
						},
						point: [c, 0]
					}, {
						type: "ahXY",
						gdRefY: "adj3",
						minY: 0,
						maxY: "maxAdj3",
						position: {
							x: "r",
							y: "y1"
						},
						point: [w, e]
					}, {
						type: "ahXY",
						gdRefY: "adj4",
						minY: 0,
						maxY: "maxAdj4",
						position: {
							x: "l",
							y: "y2"
						},
						point: [0, f]
					}
				],
				path: [[["M", 0, f], ["L", d, f], ["L", d, e], ["L", c, e], ["L", a, 0], ["L", "=V.x4", e], ["L", "=V.x3", e], ["L", "=V.x3", f], ["L", w, f], ["L", w, "=V.y3"], ["L", "=V.x3", "=V.y3"], ["L", "=V.x3", "=V.y4"], ["L", "=V.x4", "=V.y4"], ["L", a, h], ["L", c, "=V.y4"], ["L", d, "=V.y4"], ["L", d, "=V.y3"], ["L", 0, "=V.y3"], ["Z"], {}
					]],
				textRect: {
					left: 0,
					top: f,
					right: w,
					bottom: "=V.y3"
				}
			},
			quadArrowCallout: {
				variables: {
					adj1: 18515,
					adj2: 18515,
					adj3: 18515,
					adj4: 48123,
					a2: "=MIN(MAX(0, V.adj2), 50000)",
					maxAdj1: "=V.a2 * 2",
					a1: "=MIN(MAX(0, V.adj1), V.maxAdj1)",
					maxAdj3: "=50000 - V.a2",
					a3: "=MIN(MAX(0, V.adj3), V.maxAdj3)",
					q2: "=V.a3 * 2",
					maxAdj4: "=100000 - V.q2",
					a4: "=MIN(MAX(V.a1, V.adj4), V.maxAdj4)",
					ss: s,
					dx2: "=V.ss * V.a2 / 100000",
					dx3: "=V.ss * V.a1 / 200000",
					ah: "=V.ss * V.a3 / 100000",
					dx1: "=width * V.a4 / 200000",
					dy1: "=height * V.a4 / 200000",
					r: w,
					x8: "=width - V.ah",
					hc: E,
					x2: "=V.hc - V.dx1",
					x7: "=V.hc + V.dx1",
					x3: "=V.hc - V.dx2",
					x6: "=V.hc + V.dx2",
					x4: "=V.hc - V.dx3",
					x5: "=V.hc + V.dx3",
					b: h,
					y8: "=height - V.ah",
					vc: F,
					y2: "=V.vc - V.dy1",
					y7: "=V.vc + V.dy1",
					y3: "=V.vc - V.dx2",
					y6: "=V.vc + V.dx2",
					y4: "=V.vc - V.dx3",
					y5: "=V.vc + V.dx3",
					t: 0,
					l: 0
				},
				adjustInfo: [["adj1", 18515], ["adj2", 18515], ["adj3", 18515], ["adj4", 48123]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj1",
						minX: 0,
						maxX: "maxAdj1",
						position: {
							x: "x4",
							y: "ah"
						},
						point: ["=V.x4", "=V.ah"]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: 50000,
						position: {
							x: "x3",
							y: "t"
						},
						point: ["=V.x3", 0]
					}, {
						type: "ahXY",
						gdRefY: "adj3",
						minY: 0,
						maxY: "maxAdj3",
						position: {
							x: "r",
							y: "ah"
						},
						point: [w, "=V.ah"]
					}, {
						type: "ahXY",
						gdRefY: "adj4",
						minY: "a1",
						maxY: "maxAdj4",
						position: {
							x: "l",
							y: "y2"
						},
						point: [0, f]
					}
				],
				path: [[["M", 0, b], ["L", "=V.ah", "=V.y3"], ["L", "=V.ah", "=V.y4"], ["L", d, "=V.y4"], ["L", d, f], ["L", "=V.x4", f], ["L", "=V.x4", "=V.ah"], ["L", "=V.x3", "=V.ah"], ["L", a, 0], ["L", "=V.x6", "=V.ah"], ["L", "=V.x5", "=V.ah"], ["L", "=V.x5", f], ["L", "=V.x7", f], ["L", "=V.x7", "=V.y4"], ["L", "=V.x8", "=V.y4"], ["L", "=V.x8", "=V.y3"], ["L", w, b], ["L", "=V.x8", "=V.y6"], ["L", "=V.x8", "=V.y5"], ["L", "=V.x7", "=V.y5"], ["L", "=V.x7", "=V.y7"], ["L", "=V.x5", "=V.y7"], ["L", "=V.x5", "=V.y8"], ["L", "=V.x6", "=V.y8"], ["L", a, h], ["L", "=V.x3", "=V.y8"], ["L", "=V.x4", "=V.y8"], ["L", "=V.x4", "=V.y7"], ["L", d, "=V.y7"], ["L", d, "=V.y5"], ["L", "=V.ah", "=V.y5"], ["L", "=V.ah", "=V.y6"], ["Z"], {}
					]],
				textRect: {
					left: d,
					top: f,
					right: "=V.x7",
					bottom: "=V.y7"
				}
			},
			circularArrow: {
				variables: {
					adj1: 12500,
					adj2: 1142319,
					adj3: 20457681,
					adj4: B,
					adj5: 12500,
					a5: "=MIN(MAX(0, V.adj5), 25000)",
					maxAdj1: "=V.a5 * 2",
					a1: "=MIN(MAX(0, V.adj1), V.maxAdj1)",
					enAng: "=MIN(MAX(1, V.adj3), 21599999)",
					stAng: "=MIN(MAX(0, V.adj4), 21599999)",
					ss: s,
					th: "=V.ss * V.a1 / 100000",
					thh: "=V.ss * V.a5 / 100000",
					th2: "=V.th / 2",
					wd2: E,
					rw1: "=V.wd2 + V.th2 - V.thh",
					hd2: F,
					rh1: "=V.hd2 + V.th2 - V.thh",
					rw2: "=V.rw1 - V.th",
					rh2: "=V.rh1 - V.th",
					rw3: "=V.rw2 + V.th2",
					rh3: "=V.rh2 + V.th2",
					d2r: A,
					wtH: "=V.rw3 * SIN(V.enAng / V.d2r)",
					htH: "=V.rh3 * COS(V.enAng / V.d2r)",
					dxH: "=V.rw3 * COS(ATAN2(V.htH,V.wtH))",
					dyH: "=V.rh3 * SIN(ATAN2(V.htH,V.wtH))",
					hc: E,
					xH: "=V.hc + V.dxH",
					vc: F,
					yH: "=V.vc + V.dyH",
					rI: "=MIN(V.rw2, V.rh2)",
					u1: "=V.dxH * V.dxH",
					u2: "=V.dyH * V.dyH",
					u3: "=V.rI * V.rI",
					u4: "=V.u1 - V.u3",
					u5: "=V.u2 - V.u3",
					u6: "=V.u4 * V.u5 / V.u1",
					u7: "=V.u6 / V.u2",
					u8: "=1 - V.u7",
					u9: "=SQRT(V.u8)",
					u10: "=V.u4 / V.dxH",
					u11: "=V.u10 / V.dyH",
					u12: "=(1 + V.u9) / V.u11",
					u13: "=(ATAN2(1,V.u12) * V.d2r)",
					u14: "=V.u13 + 21600000",
					u15: "=IF(V.u13 > 0, V.u13, V.u14)",
					u16: "=V.u15 - V.enAng",
					u17: "=V.u16 + 21600000",
					u18: "=IF(V.u16 > 0, V.u16, V.u17)",
					cd2: B,
					u19: "=V.u18 - V.cd2",
					u20: "=V.u18 - 21600000",
					u21: "=IF(V.u19 > 0, V.u20, V.u18)",
					maxAng: "=ABS(V.u21)",
					aAng: "=MIN(MAX(0, V.adj2), V.maxAng)",
					ptAng: "=V.enAng + V.aAng",
					wtA: "=V.rw3 * SIN(V.ptAng / V.d2r)",
					htA: "=V.rh3 * COS(V.ptAng / V.d2r)",
					dxA: "=V.rw3 * COS(ATAN2(V.htA,V.wtA))",
					dyA: "=V.rh3 * SIN(ATAN2(V.htA,V.wtA))",
					xA: "=V.hc + V.dxA",
					yA: "=V.vc + V.dyA",
					wtE: "=V.rw1 * SIN(V.stAng / V.d2r)",
					htE: "=V.rh1 * COS(V.stAng / V.d2r)",
					dxE: "=V.rw1 * COS(ATAN2(V.htE,V.wtE))",
					dyE: "=V.rh1 * SIN(ATAN2(V.htE,V.wtE))",
					xE: "=V.hc + V.dxE",
					yE: "=V.vc + V.dyE",
					dxG: "=V.thh * COS(V.ptAng / V.d2r)",
					dyG: "=V.thh * SIN(V.ptAng / V.d2r)",
					xG: "=V.xH + V.dxG",
					yG: "=V.yH + V.dyG",
					dxB: "=V.thh * COS(V.ptAng / V.d2r)",
					dyB: "=V.thh * SIN(V.ptAng / V.d2r)",
					xB: "=V.xH - V.dxB",
					yB: "=V.yH - V.dyB",
					sx1: "=V.xB - V.hc",
					sy1: "=V.yB - V.vc",
					sx2: "=V.xG - V.hc",
					sy2: "=V.yG - V.vc",
					rO: "=MIN(V.rw1, V.rh1)",
					x1O: "=V.sx1 * V.rO / V.rw1",
					y1O: "=V.sy1 * V.rO / V.rh1",
					x2O: "=V.sx2 * V.rO / V.rw1",
					y2O: "=V.sy2 * V.rO / V.rh1",
					dxO: "=V.x2O - V.x1O",
					dyO: "=V.y2O - V.y1O",
					dO: "=SQRT(V.dxO*V.dxO + V.dyO*V.dyO)",
					q1: "=V.x1O * V.y2O",
					q2: "=V.x2O * V.y1O",
					DO: "=V.q1 - V.q2",
					q3: "=V.rO * V.rO",
					q4: "=V.dO * V.dO",
					q5: "=V.q3 * V.q4",
					q6: "=V.DO * V.DO",
					q7: "=V.q5 - V.q6",
					q8: "=MAX(V.q7, 0)",
					sdelO: "=SQRT(V.q8)",
					ndyO: "=V.dyO * -1",
					sdyO: "=IF(V.ndyO > 0, -1, 1)",
					q9: "=V.sdyO * V.dxO",
					q10: "=V.q9 * V.sdelO",
					q11: "=V.DO * V.dyO",
					dxF1: "=(V.q11 + V.q10) / V.q4",
					q12: "=V.q11 - V.q10",
					dxF2: "=V.q12 / V.q4",
					adyO: "=ABS(V.dyO)",
					q13: "=V.adyO * V.sdelO",
					q14: "=V.DO * V.dxO / -1",
					dyF1: "=(V.q14 + V.q13) / V.q4",
					q15: "=V.q14 - V.q13",
					dyF2: "=V.q15 / V.q4",
					q16: "=V.x2O - V.dxF1",
					q17: "=V.x2O - V.dxF2",
					q18: "=V.y2O - V.dyF1",
					q19: "=V.y2O - V.dyF2",
					q20: "=SQRT(V.q16*V.q16 + V.q18*V.q18)",
					q21: "=SQRT(V.q17*V.q17 + V.q19*V.q19)",
					q22: "=V.q21 - V.q20",
					dxF: "=IF(V.q22 > 0, V.dxF1, V.dxF2)",
					dyF: "=IF(V.q22 > 0, V.dyF1, V.dyF2)",
					sdxF: "=V.dxF * V.rw1 / V.rO",
					sdyF: "=V.dyF * V.rh1 / V.rO",
					xF: "=V.hc + V.sdxF",
					yF: "=V.vc + V.sdyF",
					x1I: "=V.sx1 * V.rI / V.rw2",
					y1I: "=V.sy1 * V.rI / V.rh2",
					x2I: "=V.sx2 * V.rI / V.rw2",
					y2I: "=V.sy2 * V.rI / V.rh2",
					dxI: "=V.x2I - V.x1I",
					dyI: "=V.y2I - V.y1I",
					dI: "=SQRT(V.dxI*V.dxI + V.dyI*V.dyI)",
					v1: "=V.x1I * V.y2I",
					v2: "=V.x2I * V.y1I",
					DI: "=V.v1 - V.v2",
					v3: "=V.rI * V.rI",
					v4: "=V.dI * V.dI",
					v5: "=V.v3 * V.v4",
					v6: "=V.DI * V.DI",
					v7: "=V.v5 - V.v6",
					v8: "=MAX(V.v7, 0)",
					sdelI: "=SQRT(V.v8)",
					v9: "=V.sdyO * V.dxI",
					v10: "=V.v9 * V.sdelI",
					v11: "=V.DI * V.dyI",
					dxC1: "=(V.v11 + V.v10) / V.v4",
					v12: "=V.v11 - V.v10",
					dxC2: "=V.v12 / V.v4",
					adyI: "=ABS(V.dyI)",
					v13: "=V.adyI * V.sdelI",
					v14: "=V.DI * V.dxI / -1",
					dyC1: "=(V.v14 + V.v13) / V.v4",
					v15: "=V.v14 - V.v13",
					dyC2: "=V.v15 / V.v4",
					v16: "=V.x1I - V.dxC1",
					v17: "=V.x1I - V.dxC2",
					v18: "=V.y1I - V.dyC1",
					v19: "=V.y1I - V.dyC2",
					v20: "=SQRT(V.v16*V.v16 + V.v18*V.v18)",
					v21: "=SQRT(V.v17*V.v17 + V.v19*V.v19)",
					v22: "=V.v21 - V.v20",
					dxC: "=IF(V.v22 > 0, V.dxC1, V.dxC2)",
					dyC: "=IF(V.v22 > 0, V.dyC1, V.dyC2)",
					sdxC: "=V.dxC * V.rw2 / V.rI",
					sdyC: "=V.dyC * V.rh2 / V.rI",
					xC: "=V.hc + V.sdxC",
					yC: "=V.vc + V.sdyC",
					ist0: "=(ATAN2(V.sdxC,V.sdyC) * V.d2r)",
					ist1: "=V.ist0 + 21600000",
					istAng: "=IF(V.ist0 > 0, V.ist0, V.ist1)",
					isw1: "=V.stAng - V.istAng",
					isw2: "=V.isw1 - 21600000",
					iswAng: "=IF(V.isw1 > 0, V.isw2, V.isw1)",
					p1: "=V.xF - V.xC",
					p2: "=V.yF - V.yC",
					p3: "=SQRT(V.p1*V.p1 + V.p2*V.p2)",
					p4: "=V.p3 / 2",
					p5: "=V.p4 - V.thh",
					xGp: "=IF(V.p5 > 0, V.xF, V.xG)",
					yGp: "=IF(V.p5 > 0, V.yF, V.yG)",
					xBp: "=IF(V.p5 > 0, V.xC, V.xB)",
					yBp: "=IF(V.p5 > 0, V.yC, V.yB)",
					en0: "=(ATAN2(V.sdxF,V.sdyF) * V.d2r)",
					en1: "=V.en0 + 21600000",
					en2: "=IF(V.en0 > 0, V.en0, V.en1)",
					sw0: "=V.en2 - V.stAng",
					sw1: "=V.sw0 + 21600000",
					swAng: "=IF(V.sw0 > 0, V.sw0, V.sw1)",
					wtI: "=V.rw3 * SIN(V.stAng / V.d2r)",
					htI: "=V.rh3 * COS(V.stAng / V.d2r)",
					_dxI: "=V.rw3 * COS(ATAN2(V.htI,V.wtI))",
					_dyI: "=V.rh3 * SIN(ATAN2(V.htI,V.wtI))",
					xI: "=V.hc + V._dxI",
					yI: "=V.vc + V._dyI",
					cd4: C,
					aI: "=V.stAng - V.cd4",
					aA: "=V.ptAng + V.cd4",
					aB: "=V.ptAng + V.cd2",
					idx: "=V.rw1 * COS(2700000 / V.d2r)",
					idy: "=V.rh1 * SIN(2700000 / V.d2r)",
					il: "=V.hc - V.idx",
					ir: "=V.hc + V.idx",
					it: "=V.vc - V.idy",
					ib: "=V.vc + V.idy",
					cx1: "=C(V.rw1,V.xE,A(V.rw1,V.rh1,V.stAng),true)",
					cy1: "=C(V.rh1,V.yE,A(V.rw1,V.rh1,V.stAng))",
					cx2: "=C(V.rw2,V.xC,A(V.rw2,V.rh2,V.istAng),true)",
					cy2: "=C(V.rh2,V.yC,A(V.rw2,V.rh2,V.istAng))"
				},
				adjustInfo: [["adj1", 12500], ["adj2", 1142319], ["adj3", 20457681], ["adj4", 10800000], ["adj5", 12500]],
				connectionPoints: [{
						x: "=V.xI",
						y: "=V.yI"
					}, {
						x: "=V.xGp",
						y: "=V.yGp"
					}, {
						x: "=V.xA",
						y: "=V.yA"
					}, {
						x: "=V.xBp",
						y: "=V.yBp"
					}
				],
				controlsInfo: [{
						type: "ahPolar",
						gdRefAng: "adj2",
						minAng: 0,
						maxAng: "maxAng",
						position: {
							x: "xA",
							y: "yA"
						},
						point: ["=V.xA", "=V.yA"]
					}, {
						type: "ahPolar",
						gdRefAng: "adj4",
						minAng: 0,
						maxAng: 21599999,
						position: {
							x: "xE",
							y: "yE"
						},
						point: ["=V.xE", "=V.yE"]
					}, {
						type: "ahPolar",
						gdRefR: "adj1",
						minR: 0,
						maxR: "maxAdj1",
						gdRefAng: "adj3",
						minAng: 0,
						maxAng: 21599999,
						position: {
							x: "xF",
							y: "yF"
						},
						point: ["=V.xF", "=V.yF"]
					}, {
						type: "ahPolar",
						gdRefR: "adj5",
						minR: 0,
						maxR: 25000,
						position: {
							x: "xB",
							y: "yB"
						},
						point: ["=V.xB", "=V.yB"]
					}
				],
				path: [[["M", "=V.xE", "=V.yE"], ["E", "=V.cx1", "=V.cy1", "=V.rw1", "=V.rh1", 0, "=A(V.rw1,V.rh1,V.stAng)", "=A(V.rw1,V.rh1,(V.stAng + V.swAng))", "=IF(V.swAng > 0, FALSE, TRUE)"], ["L", "=V.xGp", "=V.yGp"], ["L", "=V.xA", "=V.yA"], ["L", "=V.xBp", "=V.yBp"], ["L", "=V.xC", "=V.yC"], ["E", "=V.cx2", "=V.cy2", "=V.rw2", "=V.rh2", 0, "=A(V.rw2,V.rh2,V.istAng)", "=A(V.rw2,V.rh2,(V.istAng + V.iswAng))", "=IF(V.iswAng > 0, FALSE, TRUE)"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			flowchartProcess: {
				variables: {
					hc: E,
					t: 0,
					l: 0,
					vc: F,
					b: h,
					r: w,
					_scaleX1: "= width",
					_scaleY1: "= height"
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {}
					]]
			},
			flowchartAlternateProcess: {
				variables: {
					r: w,
					ss: s,
					ssd6: "=V.ss / 6",
					x2: "=width - V.ssd6",
					b: h,
					y2: "=height - V.ssd6",
					il: "=V.ssd6 * 29289 / 100000",
					ir: "=width - V.il",
					ib: "=height - V.il",
					hc: E,
					t: 0,
					l: 0,
					vc: F,
					cd2: B,
					cd4: C,
					cx1: "=C(V.ssd6,V.l,A(V.ssd6,V.ssd6,V.cd2),true)",
					cy1: "=C(V.ssd6,V.ssd6,A(V.ssd6,V.ssd6,V.cd2))",
					_3cd4: D,
					cx2: "=C(V.ssd6,V.x2,A(V.ssd6,V.ssd6,V._3cd4),true)",
					cy2: "=C(V.ssd6,V.t,A(V.ssd6,V.ssd6,V._3cd4))",
					cx3: "=C(V.ssd6,V.r,A(V.ssd6,V.ssd6,0),true)",
					cy3: "=C(V.ssd6,V.y2,A(V.ssd6,V.ssd6,0))",
					cx4: "=C(V.ssd6,V.ssd6,A(V.ssd6,V.ssd6,V.cd4),true)",
					cy4: "=C(V.ssd6,V.b,A(V.ssd6,V.ssd6,V.cd4))"
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				path: [[["M", 0, "=V.ssd6"], ["E", "=V.cx1", "=V.cy1", "=V.ssd6", "=V.ssd6", 0, "=A(V.ssd6,V.ssd6,V.cd2)", "=A(V.ssd6,V.ssd6,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", d, 0], ["E", "=V.cx2", "=V.cy2", "=V.ssd6", "=V.ssd6", 0, "=A(V.ssd6,V.ssd6,V._3cd4)", "=A(V.ssd6,V.ssd6,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", w, f], ["E", "=V.cx3", "=V.cy3", "=V.ssd6", "=V.ssd6", 0, "=A(V.ssd6,V.ssd6,0)", "=A(V.ssd6,V.ssd6,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.ssd6", h], ["E", "=V.cx4", "=V.cy4", "=V.ssd6", "=V.ssd6", 0, "=A(V.ssd6,V.ssd6,V.cd4)", "=A(V.ssd6,V.ssd6,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.il",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			flowchartDecision: {
				variables: {
					ir: "=width * 3 / 4",
					ib: "=height * 3 / 4",
					hc: E,
					t: 0,
					l: 0,
					vc: F,
					b: h,
					r: w,
					_scaleX1: "= width / 2",
					_scaleY1: "= height / 2",
					wd4: "=width/4",
					hd4: "=height/4"
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				path: [[["M", 0, F], ["L", E, 0], ["L", w, F], ["L", E, h], ["Z"], {}
					]],
				textRect: {
					left: "=V.wd4",
					top: "=V.hd4",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			flowchartData: {
				variables: {
					x3: "=width * 2 / 5",
					x4: "=width * 3 / 5",
					x5: "=width * 4 / 5",
					x6: "=width * 9 / 10",
					t: 0,
					hc: E,
					wd10: "=width/10",
					vc: F,
					b: h,
					_scaleX1: "= width / 5",
					_scaleY1: "= height / 5",
					wd5: "=width/5"
				},
				connectionPoints: [{
						x: "=V.x4",
						y: 0
					}, {
						x: a,
						y: 0
					}, {
						x: "=V.wd10",
						y: b
					}, {
						x: "=V.x3",
						y: h
					}, {
						x: a,
						y: h
					}, {
						x: "=V.x6",
						y: b
					}
				],
				path: [[["M", 0, h], ["L", "=V._scaleX1", 0], ["L", w, 0], ["L", "=4 * V._scaleX1", h], ["Z"], {}
					]],
				textRect: {
					left: "=V.wd5",
					top: 0,
					right: "=V.x5",
					bottom: h
				}
			},
			flowchartPredefinedProcess: {
				variables: {
					x2: "=width * 7 / 8",
					hc: E,
					t: 0,
					l: 0,
					vc: F,
					b: h,
					r: w,
					_scaleX1: "= width",
					_scaleY1: "= height",
					_scaleX2: "= width / 8",
					_scaleY2: "= height / 8",
					_scaleX3: "= width",
					_scaleY3: "= height",
					wd8: "=width/8"
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {
							strokeMode: "false"
						}
					], [["M", "=V._scaleX2", 0], ["L", "=V._scaleX2", h], ["M", "=7 * V._scaleX2", 0], ["L", "=7 * V._scaleX2", h], {
							fillMode: "none"
						}
					], [["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: "=V.wd8",
					top: 0,
					right: d,
					bottom: h
				}
			},
			flowchartInternalStorage: {
				variables: {
					hc: E,
					t: 0,
					l: 0,
					vc: F,
					b: h,
					r: w,
					_scaleX1: "= width",
					_scaleY1: "= height",
					_scaleX2: "= width / 8",
					_scaleY2: "= height / 8",
					_scaleX3: "= width",
					_scaleY3: "= height",
					wd8: "=width/8",
					hd8: "=height/8"
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {
							strokeMode: "false"
						}
					], [["M", "=V._scaleX2", 0], ["L", "=V._scaleX2", h], ["M", 0, "=V._scaleY2"], ["L", w, "=V._scaleY2"], {
							fillMode: "none"
						}
					], [["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: "=V.wd8",
					top: "=V.hd8",
					right: w,
					bottom: h
				}
			},
			flowchartDocument: {
				variables: {
					y1: "=height * 17322 / 21600",
					y2: "=height * 20172 / 21600",
					hc: E,
					t: 0,
					l: 0,
					vc: F,
					r: w,
					_scaleX1: "= width / 21600",
					_scaleY1: "= height / 21600"
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: f
					}, {
						x: w,
						y: b
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, "=17322 * V._scaleY1"], ["B", E, "=17322 * V._scaleY1", E, "=23922 * V._scaleY1", 0, "=20172 * V._scaleY1"], ["Z"], {}
					]],
				textRect: {
					left: 0,
					top: 0,
					right: w,
					bottom: e
				}
			},
			flowchartMultidocument: {
				variables: {
					y2: "=height * 3675 / 21600",
					y8: "=height * 20782 / 21600",
					x3: "=width * 9298 / 21600",
					x4: "=width * 12286 / 21600",
					x5: "=width * 18595 / 21600",
					t: 0,
					l: 0,
					vc: F,
					r: w,
					_scaleX1: "= width / 21600",
					_scaleY1: "= height / 21600",
					_scaleX2: "= width / 21600",
					_scaleY2: "= height / 21600",
					_scaleX3: "= width / 21600",
					_scaleY3: "= height / 21600"
				},
				connectionPoints: [{
						x: "=V.x4",
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: "=V.x3",
						y: "=V.y8"
					}, {
						x: w,
						y: b
					}
				],
				path: [[["M", 0, "=20782 * V._scaleY1"], ["B", "=9298 * V._scaleX1", "=23542 * V._scaleY1", "=9298 * V._scaleX1", "=18022 * V._scaleY1", "=18595 * V._scaleX1", "=18022 * V._scaleY1"], ["L", "=18595 * V._scaleX1", "=3675 * V._scaleY1"], ["L", 0, "=3675 * V._scaleY1"], ["Z"], ["M", "=1532 * V._scaleX1", "=3675 * V._scaleY1"], ["L", "=1532 * V._scaleX1", "=1815 * V._scaleY1"], ["L", "=20000 * V._scaleX1", "=1815 * V._scaleY1"], ["L", "=20000 * V._scaleX1", "=16252 * V._scaleY1"], ["B", "=19298 * V._scaleX1", "=16252 * V._scaleY1", "=18595 * V._scaleX1", "=16352 * V._scaleY1", "=18595 * V._scaleX1", "=16352 * V._scaleY1"], ["L", "=18595 * V._scaleX1", "=3675 * V._scaleY1"], ["Z"], ["M", "=2972 * V._scaleX1", "=1815 * V._scaleY1"], ["L", "=2972 * V._scaleX1", 0], ["L", w, 0], ["L", w, "=14392 * V._scaleY1"], ["B", "=20800 * V._scaleX1", "=14392 * V._scaleY1", "=20000 * V._scaleX1", "=14467 * V._scaleY1", "=20000 * V._scaleX1", "=14467 * V._scaleY1"], ["L", "=20000 * V._scaleX1", "=1815 * V._scaleY1"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", 0, "=3675 * V._scaleY2"], ["L", "=18595 * V._scaleX2", "=3675 * V._scaleY2"], ["L", "=18595 * V._scaleX2", "=18022 * V._scaleY2"], ["B", "=9298 * V._scaleX2", "=18022 * V._scaleY2", "=9298 * V._scaleX2", "=23542 * V._scaleY2", 0, "=20782 * V._scaleY2"], ["Z"], ["M", "=1532 * V._scaleX2", "=3675 * V._scaleY2"], ["L", "=1532 * V._scaleX2", "=1815 * V._scaleY2"], ["L", "=20000 * V._scaleX2", "=1815 * V._scaleY2"], ["L", "=20000 * V._scaleX2", "=16252 * V._scaleY2"], ["B", "=19298 * V._scaleX2", "=16252 * V._scaleY2", "=18595 * V._scaleX2", "=16352 * V._scaleY2", "=18595 * V._scaleX2", "=16352 * V._scaleY2"], ["M", "=2972 * V._scaleX2", "=1815 * V._scaleY2"], ["L", "=2972 * V._scaleX2", 0], ["L", w, 0], ["L", w, "=14392 * V._scaleY2"], ["B", "=20800 * V._scaleX2", "=14392 * V._scaleY2", "=20000 * V._scaleX2", "=14467 * V._scaleY2", "=20000 * V._scaleX2", "=14467 * V._scaleY2"], {
							fillMode: "none"
						}
					], [["M", 0, "=20782 * V._scaleY3"], ["B", "=9298 * V._scaleX3", "=23542 * V._scaleY3", "=9298 * V._scaleX3", "=18022 * V._scaleY3", "=18595 * V._scaleX3", "=18022 * V._scaleY3"], ["L", "=18595 * V._scaleX3", "=16352 * V._scaleY3"], ["B", "=18595 * V._scaleX3", "=16352 * V._scaleY3", "=19298 * V._scaleX3", "=16252 * V._scaleY3", "=20000 * V._scaleX3", "=16252 * V._scaleY3"], ["L", "=20000 * V._scaleX3", "=14467 * V._scaleY3"], ["B", "=20000 * V._scaleX3", "=14467 * V._scaleY3", "=20800 * V._scaleX3", "=14392 * V._scaleY3", w, "=14392 * V._scaleY3"], ["L", w, 0], ["L", "=2972 * V._scaleX3", 0], ["L", "=2972 * V._scaleX3", "=1815 * V._scaleY3"], ["L", "=1532 * V._scaleX3", "=1815 * V._scaleY3"], ["L", "=1532 * V._scaleX3", "=3675 * V._scaleY3"], ["L", 0, "=3675 * V._scaleY3"], ["Z"], {
							fillMode: "none",
							strokeMode: "false"
						}
					]],
				textRect: {
					left: 0,
					top: f,
					right: "=V.x5",
					bottom: "=V.y8"
				}
			},
			flowchartTerminator: {
				variables: {
					il: "=width * 1018 / 21600",
					ir: "=width * 20582 / 21600",
					it: "=height * 3163 / 21600",
					ib: "=height * 18437 / 21600",
					hc: E,
					t: 0,
					l: 0,
					vc: F,
					b: h,
					r: w,
					_scaleX1: "= width / 21600",
					_scaleY1: "= height / 21600",
					_3cd4: D,
					cd2: B,
					cx1: "=C(3475,18125,A(3475,10800,V._3cd4),true)",
					cy1: "=C(10800,0,A(3475,10800,V._3cd4))",
					cd4: C,
					cx2: "=C(3475,3475,A(3475,10800,V.cd4),true)",
					cy2: "=C(10800,21600,A(3475,10800,V.cd4))"
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				path: [[["M", "=3475 * V._scaleX1", 0], ["L", "=18125 * V._scaleX1", 0], ["E", "=V.cx1 * V._scaleX1", "=V.cy1 * V._scaleY1", "=3475 * V._scaleX1", F, 0, "=A(3475,10800,V._3cd4)", "=A(3475,10800,(V._3cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["L", "=3475 * V._scaleX1", h], ["E", "=V.cx2 * V._scaleX1", "=V.cy2 * V._scaleY1", "=3475 * V._scaleX1", F, 0, "=A(3475,10800,V.cd4)", "=A(3475,10800,(V.cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			flowchartPreparation: {
				variables: {
					x2: "=width * 4 / 5",
					hc: E,
					t: 0,
					l: 0,
					vc: F,
					b: h,
					r: w,
					_scaleX1: "= width / 10",
					_scaleY1: "= height / 10",
					wd5: "=width/5"
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				path: [[["M", 0, F], ["L", "=2 * V._scaleX1", 0], ["L", "=8 * V._scaleX1", 0], ["L", w, F], ["L", "=8 * V._scaleX1", h], ["L", "=2 * V._scaleX1", h], ["Z"], {}
					]],
				textRect: {
					left: "=V.wd5",
					top: 0,
					right: d,
					bottom: h
				}
			},
			flowchartManualInput: {
				variables: {
					hc: E,
					hd10: "=height/10",
					l: 0,
					vc: F,
					b: h,
					r: w,
					_scaleX1: "= width / 5",
					_scaleY1: "= height / 5",
					hd5: "=height/5"
				},
				connectionPoints: [{
						x: a,
						y: "=V.hd10"
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				path: [[["M", 0, "=V._scaleY1"], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {}
					]],
				textRect: {
					left: 0,
					top: "=V.hd5",
					right: w,
					bottom: h
				}
			},
			flowchartManualOperation: {
				variables: {
					x3: "=width * 4 / 5",
					x4: "=width * 9 / 10",
					hc: E,
					t: 0,
					wd10: "=width/10",
					vc: F,
					b: h,
					_scaleX1: "= width / 5",
					_scaleY1: "= height / 5",
					wd5: "=width/5"
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: "=V.wd10",
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: "=V.x4",
						y: b
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", "=4 * V._scaleX1", h], ["L", "=V._scaleX1", h], ["Z"], {}
					]],
				textRect: {
					left: "=V.wd5",
					top: 0,
					right: "=V.x3",
					bottom: h
				}
			},
			flowchartConnector: {
				variables: {
					wd2: E,
					d2r: A,
					idx: "=V.wd2 * COS(2700000 / V.d2r)",
					hd2: F,
					idy: "=V.hd2 * SIN(2700000 / V.d2r)",
					hc: E,
					il: "=V.hc - V.idx",
					ir: "=V.hc + V.idx",
					vc: F,
					it: "=V.vc - V.idy",
					ib: "=V.vc + V.idy",
					t: 0,
					l: 0,
					b: h,
					r: w,
					cd2: B,
					cd4: C,
					cx1: "=C(V.wd2,V.l,A(V.wd2,V.hd2,V.cd2),true)",
					cy1: "=C(V.hd2,V.vc,A(V.wd2,V.hd2,V.cd2))",
					_3cd4: D,
					cx2: "=C(V.wd2,P(V.cx1,V.wd2,A(V.wd2,V.hd2,(V.cd2 + V.cd4)),true),A(V.wd2,V.hd2,V._3cd4),true)",
					cy2: "=C(V.hd2,P(V.cy1,V.hd2,A(V.wd2,V.hd2,(V.cd2 + V.cd4))),A(V.wd2,V.hd2,V._3cd4))",
					cx3: "=C(V.wd2,P(V.cx2,V.wd2,A(V.wd2,V.hd2,(V._3cd4 + V.cd4)),true),A(V.wd2,V.hd2,0),true)",
					cy3: "=C(V.hd2,P(V.cy2,V.hd2,A(V.wd2,V.hd2,(V._3cd4 + V.cd4))),A(V.wd2,V.hd2,0))",
					cx4: "=C(V.wd2,P(V.cx3,V.wd2,A(V.wd2,V.hd2,(V.cd4)),true),A(V.wd2,V.hd2,V.cd4),true)",
					cy4: "=C(V.hd2,P(V.cy3,V.hd2,A(V.wd2,V.hd2,(V.cd4))),A(V.wd2,V.hd2,V.cd4))"
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: "=V.il",
						y: "=V.it"
					}, {
						x: 0,
						y: b
					}, {
						x: "=V.il",
						y: "=V.ib"
					}, {
						x: a,
						y: h
					}, {
						x: "=V.ir",
						y: "=V.ib"
					}, {
						x: w,
						y: b
					}, {
						x: "=V.ir",
						y: "=V.it"
					}
				],
				path: [[["M", 0, b], ["E", "=V.cx1", "=V.cy1", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.cd2)", "=A(V.wd2,V.hd2,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx2", "=V.cy2", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V._3cd4)", "=A(V.wd2,V.hd2,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx3", "=V.cy3", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,0)", "=A(V.wd2,V.hd2,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx4", "=V.cy4", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.cd4)", "=A(V.wd2,V.hd2,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			flowchartOffpageConnector: {
				variables: {
					y1: "=height * 4 / 5",
					hc: E,
					t: 0,
					l: 0,
					vc: F,
					b: h,
					r: w,
					_scaleX1: "= width / 10",
					_scaleY1: "= height / 10"
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, "=8 * V._scaleY1"], ["L", E, h], ["L", 0, "=8 * V._scaleY1"], ["Z"], {}
					]],
				textRect: {
					left: 0,
					top: 0,
					right: w,
					bottom: e
				}
			},
			flowchartCard: {
				variables: {
					hc: E,
					t: 0,
					l: 0,
					vc: F,
					b: h,
					r: w,
					_scaleX1: "= width / 5",
					_scaleY1: "= height / 5",
					hd5: "=height/5"
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				path: [[["M", 0, "=V._scaleY1"], ["L", "=V._scaleX1", 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {}
					]],
				textRect: {
					left: 0,
					top: "=V.hd5",
					right: w,
					bottom: h
				}
			},
			flowchartPunchedTape: {
				variables: {
					y2: "=height * 9 / 10",
					ib: "=height * 4 / 5",
					hc: E,
					hd10: "=height/10",
					l: 0,
					vc: F,
					r: w,
					_scaleX1: "= width / 20",
					_scaleY1: "= height / 20",
					cd2: B,
					cx1: "=C(5,0,A(5,2,V.cd2),true)",
					cy1: "=C(2,2,A(5,2,V.cd2))",
					cx2: "=C(5,P(V.cx1,5,A(5,2,(V.cd2 + -10800000)),true),A(5,2,V.cd2),true)",
					cy2: "=C(2,P(V.cy1,2,A(5,2,(V.cd2 + -10800000))),A(5,2,V.cd2))",
					cx3: "=C(5,20,A(5,2,0),true)",
					cy3: "=C(2,18,A(5,2,0))",
					cx4: "=C(5,P(V.cx3,5,A(5,2,(-10800000)),true),A(5,2,0),true)",
					cy4: "=C(2,P(V.cy3,2,A(5,2,(-10800000))),A(5,2,0))",
					hd5: "=height/5"
				},
				connectionPoints: [{
						x: a,
						y: "=V.hd10"
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: f
					}, {
						x: w,
						y: b
					}
				],
				path: [[["M", 0, "=2 * V._scaleY1"], ["E", "=V.cx1 * V._scaleX1", "=V.cy1 * V._scaleY1", "=5 * V._scaleX1", "=2 * V._scaleY1", 0, "=A(5,2,V.cd2)", "=A(5,2,(V.cd2 + -10800000))", "=IF(-10800000 > 0, FALSE, TRUE)"], ["E", "=V.cx2 * V._scaleX1", "=V.cy2 * V._scaleY1", "=5 * V._scaleX1", "=2 * V._scaleY1", 0, "=A(5,2,V.cd2)", "=A(5,2,(V.cd2 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["L", w, "=18 * V._scaleY1"], ["E", "=V.cx3 * V._scaleX1", "=V.cy3 * V._scaleY1", "=5 * V._scaleX1", "=2 * V._scaleY1", 0, "=A(5,2,0)", "=A(5,2,(-10800000))", "=IF(-10800000 > 0, FALSE, TRUE)"], ["E", "=V.cx4 * V._scaleX1", "=V.cy4 * V._scaleY1", "=5 * V._scaleX1", "=2 * V._scaleY1", 0, "=A(5,2,0)", "=A(5,2,(V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["Z"], {}
					]],
				textRect: {
					left: 0,
					top: "=V.hd5",
					right: w,
					bottom: "=V.ib"
				}
			},
			flowchartSummingJunction: {
				variables: {
					wd2: E,
					d2r: A,
					idx: "=V.wd2 * COS(2700000 / V.d2r)",
					hd2: F,
					idy: "=V.hd2 * SIN(2700000 / V.d2r)",
					hc: E,
					il: "=V.hc - V.idx",
					ir: "=V.hc + V.idx",
					vc: F,
					it: "=V.vc - V.idy",
					ib: "=V.vc + V.idy",
					t: 0,
					l: 0,
					b: h,
					r: w,
					cd2: B,
					cd4: C,
					cx1: "=C(V.wd2,V.l,A(V.wd2,V.hd2,V.cd2),true)",
					cy1: "=C(V.hd2,V.vc,A(V.wd2,V.hd2,V.cd2))",
					_3cd4: D,
					cx2: "=C(V.wd2,P(V.cx1,V.wd2,A(V.wd2,V.hd2,(V.cd2 + V.cd4)),true),A(V.wd2,V.hd2,V._3cd4),true)",
					cy2: "=C(V.hd2,P(V.cy1,V.hd2,A(V.wd2,V.hd2,(V.cd2 + V.cd4))),A(V.wd2,V.hd2,V._3cd4))",
					cx3: "=C(V.wd2,P(V.cx2,V.wd2,A(V.wd2,V.hd2,(V._3cd4 + V.cd4)),true),A(V.wd2,V.hd2,0),true)",
					cy3: "=C(V.hd2,P(V.cy2,V.hd2,A(V.wd2,V.hd2,(V._3cd4 + V.cd4))),A(V.wd2,V.hd2,0))",
					cx4: "=C(V.wd2,P(V.cx3,V.wd2,A(V.wd2,V.hd2,(V.cd4)),true),A(V.wd2,V.hd2,V.cd4),true)",
					cy4: "=C(V.hd2,P(V.cy3,V.hd2,A(V.wd2,V.hd2,(V.cd4))),A(V.wd2,V.hd2,V.cd4))",
					cx5: "=C(V.wd2,V.l,A(V.wd2,V.hd2,V.cd2),true)",
					cy5: "=C(V.hd2,V.vc,A(V.wd2,V.hd2,V.cd2))",
					cx6: "=C(V.wd2,P(V.cx5,V.wd2,A(V.wd2,V.hd2,(V.cd2 + V.cd4)),true),A(V.wd2,V.hd2,V._3cd4),true)",
					cy6: "=C(V.hd2,P(V.cy5,V.hd2,A(V.wd2,V.hd2,(V.cd2 + V.cd4))),A(V.wd2,V.hd2,V._3cd4))",
					cx7: "=C(V.wd2,P(V.cx6,V.wd2,A(V.wd2,V.hd2,(V._3cd4 + V.cd4)),true),A(V.wd2,V.hd2,0),true)",
					cy7: "=C(V.hd2,P(V.cy6,V.hd2,A(V.wd2,V.hd2,(V._3cd4 + V.cd4))),A(V.wd2,V.hd2,0))",
					cx8: "=C(V.wd2,P(V.cx7,V.wd2,A(V.wd2,V.hd2,(V.cd4)),true),A(V.wd2,V.hd2,V.cd4),true)",
					cy8: "=C(V.hd2,P(V.cy7,V.hd2,A(V.wd2,V.hd2,(V.cd4))),A(V.wd2,V.hd2,V.cd4))"
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: "=V.il",
						y: "=V.it"
					}, {
						x: 0,
						y: b
					}, {
						x: "=V.il",
						y: "=V.ib"
					}, {
						x: a,
						y: h
					}, {
						x: "=V.ir",
						y: "=V.ib"
					}, {
						x: w,
						y: b
					}, {
						x: "=V.ir",
						y: "=V.it"
					}
				],
				path: [[["M", 0, b], ["E", "=V.cx1", "=V.cy1", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.cd2)", "=A(V.wd2,V.hd2,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx2", "=V.cy2", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V._3cd4)", "=A(V.wd2,V.hd2,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx3", "=V.cy3", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,0)", "=A(V.wd2,V.hd2,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx4", "=V.cy4", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.cd4)", "=A(V.wd2,V.hd2,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", "=V.il", "=V.it"], ["L", "=V.ir", "=V.ib"], ["M", "=V.ir", "=V.it"], ["L", "=V.il", "=V.ib"], {
							fillMode: "none"
						}
					], [["M", 0, b], ["E", "=V.cx5", "=V.cy5", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.cd2)", "=A(V.wd2,V.hd2,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx6", "=V.cy6", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V._3cd4)", "=A(V.wd2,V.hd2,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx7", "=V.cy7", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,0)", "=A(V.wd2,V.hd2,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx8", "=V.cy8", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.cd4)", "=A(V.wd2,V.hd2,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["Z"], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			flowchartOr: {
				variables: {
					wd2: E,
					d2r: A,
					idx: "=V.wd2 * COS(2700000 / V.d2r)",
					hd2: F,
					idy: "=V.hd2 * SIN(2700000 / V.d2r)",
					hc: E,
					il: "=V.hc - V.idx",
					ir: "=V.hc + V.idx",
					vc: F,
					it: "=V.vc - V.idy",
					ib: "=V.vc + V.idy",
					t: 0,
					l: 0,
					b: h,
					r: w,
					cd2: B,
					cd4: C,
					cx1: "=C(V.wd2,V.l,A(V.wd2,V.hd2,V.cd2),true)",
					cy1: "=C(V.hd2,V.vc,A(V.wd2,V.hd2,V.cd2))",
					_3cd4: D,
					cx2: "=C(V.wd2,P(V.cx1,V.wd2,A(V.wd2,V.hd2,(V.cd2 + V.cd4)),true),A(V.wd2,V.hd2,V._3cd4),true)",
					cy2: "=C(V.hd2,P(V.cy1,V.hd2,A(V.wd2,V.hd2,(V.cd2 + V.cd4))),A(V.wd2,V.hd2,V._3cd4))",
					cx3: "=C(V.wd2,P(V.cx2,V.wd2,A(V.wd2,V.hd2,(V._3cd4 + V.cd4)),true),A(V.wd2,V.hd2,0),true)",
					cy3: "=C(V.hd2,P(V.cy2,V.hd2,A(V.wd2,V.hd2,(V._3cd4 + V.cd4))),A(V.wd2,V.hd2,0))",
					cx4: "=C(V.wd2,P(V.cx3,V.wd2,A(V.wd2,V.hd2,(V.cd4)),true),A(V.wd2,V.hd2,V.cd4),true)",
					cy4: "=C(V.hd2,P(V.cy3,V.hd2,A(V.wd2,V.hd2,(V.cd4))),A(V.wd2,V.hd2,V.cd4))",
					cx5: "=C(V.wd2,V.l,A(V.wd2,V.hd2,V.cd2),true)",
					cy5: "=C(V.hd2,V.vc,A(V.wd2,V.hd2,V.cd2))",
					cx6: "=C(V.wd2,P(V.cx5,V.wd2,A(V.wd2,V.hd2,(V.cd2 + V.cd4)),true),A(V.wd2,V.hd2,V._3cd4),true)",
					cy6: "=C(V.hd2,P(V.cy5,V.hd2,A(V.wd2,V.hd2,(V.cd2 + V.cd4))),A(V.wd2,V.hd2,V._3cd4))",
					cx7: "=C(V.wd2,P(V.cx6,V.wd2,A(V.wd2,V.hd2,(V._3cd4 + V.cd4)),true),A(V.wd2,V.hd2,0),true)",
					cy7: "=C(V.hd2,P(V.cy6,V.hd2,A(V.wd2,V.hd2,(V._3cd4 + V.cd4))),A(V.wd2,V.hd2,0))",
					cx8: "=C(V.wd2,P(V.cx7,V.wd2,A(V.wd2,V.hd2,(V.cd4)),true),A(V.wd2,V.hd2,V.cd4),true)",
					cy8: "=C(V.hd2,P(V.cy7,V.hd2,A(V.wd2,V.hd2,(V.cd4))),A(V.wd2,V.hd2,V.cd4))"
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: "=V.il",
						y: "=V.it"
					}, {
						x: 0,
						y: b
					}, {
						x: "=V.il",
						y: "=V.ib"
					}, {
						x: a,
						y: h
					}, {
						x: "=V.ir",
						y: "=V.ib"
					}, {
						x: w,
						y: b
					}, {
						x: "=V.ir",
						y: "=V.it"
					}
				],
				path: [[["M", 0, b], ["E", "=V.cx1", "=V.cy1", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.cd2)", "=A(V.wd2,V.hd2,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx2", "=V.cy2", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V._3cd4)", "=A(V.wd2,V.hd2,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx3", "=V.cy3", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,0)", "=A(V.wd2,V.hd2,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx4", "=V.cy4", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.cd4)", "=A(V.wd2,V.hd2,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", a, 0], ["L", a, h], ["M", 0, b], ["L", w, b], {
							fillMode: "none"
						}
					], [["M", 0, b], ["E", "=V.cx5", "=V.cy5", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.cd2)", "=A(V.wd2,V.hd2,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx6", "=V.cy6", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V._3cd4)", "=A(V.wd2,V.hd2,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx7", "=V.cy7", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,0)", "=A(V.wd2,V.hd2,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx8", "=V.cy8", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.cd4)", "=A(V.wd2,V.hd2,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["Z"], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			flowchartCollate: {
				variables: {
					ir: "=width * 3 / 4",
					ib: "=height * 3 / 4",
					hc: E,
					t: 0,
					vc: F,
					b: h,
					_scaleX1: "= width / 2",
					_scaleY1: "= height / 2",
					wd4: "=width/4",
					hd4: "=height/4"
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: a,
						y: b
					}, {
						x: a,
						y: h
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", E, F], ["L", w, h], ["L", 0, h], ["L", E, F], ["Z"], {}
					]],
				textRect: {
					left: "=V.wd4",
					top: "=V.hd4",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			flowchartSort: {
				variables: {
					ir: "=width * 3 / 4",
					ib: "=height * 3 / 4",
					hc: E,
					t: 0,
					l: 0,
					vc: F,
					b: h,
					r: w,
					_scaleX1: "= width / 2",
					_scaleY1: "= height / 2",
					_scaleX2: "= width / 2",
					_scaleX3: "= width / 2",
					_scaleY3: "= height / 2",
					wd4: "=width/4",
					hd4: "=height/4"
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				path: [[["M", 0, F], ["L", E, 0], ["L", w, F], ["L", E, h], ["Z"], {
							strokeMode: "false"
						}
					], [["M", 0, F], ["L", w, F], {
							fillMode: "none"
						}
					], [["M", 0, F], ["L", E, 0], ["L", w, F], ["L", E, h], ["Z"], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: "=V.wd4",
					top: "=V.hd4",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			flowchartExtract: {
				variables: {
					x2: "=width * 3 / 4",
					hc: E,
					t: 0,
					wd4: "=width/4",
					vc: F,
					b: h,
					_scaleX1: "= width / 2",
					_scaleY1: "= height / 2"
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: "=V.wd4",
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: d,
						y: b
					}
				],
				path: [[["M", 0, h], ["L", E, 0], ["L", w, h], ["Z"], {}
					]],
				textRect: {
					left: "=V.wd4",
					top: b,
					right: d,
					bottom: h
				}
			},
			flowchartMerge: {
				variables: {
					x2: "=width * 3 / 4",
					hc: E,
					t: 0,
					wd4: "=width/4",
					vc: F,
					b: h,
					_scaleX1: "= width / 2",
					_scaleY1: "= height / 2"
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: "=V.wd4",
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: d,
						y: b
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", E, h], ["Z"], {}
					]],
				textRect: {
					left: "=V.wd4",
					top: 0,
					right: d,
					bottom: b
				}
			},
			flowchartStoredData: {
				variables: {
					x2: "=width * 5 / 6",
					hc: E,
					t: 0,
					l: 0,
					vc: F,
					b: h,
					_scaleX1: "= width / 6",
					_scaleY1: "= height / 6",
					_3cd4: D,
					cx1: "=C(1,6,A(1,3,V._3cd4),true)",
					cy1: "=C(3,0,A(1,3,V._3cd4))",
					cd4: C,
					cd2: B,
					cx2: "=C(1,1,A(1,3,V.cd4),true)",
					cy2: "=C(3,6,A(1,3,V.cd4))",
					wd6: "=width/6"
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: d,
						y: b
					}
				],
				path: [[["M", "=V._scaleX1", 0], ["L", w, 0], ["E", "=V.cx1 * V._scaleX1", "=V.cy1 * V._scaleY1", "=V._scaleX1", F, 0, "=A(1,3,V._3cd4)", "=A(1,3,(V._3cd4 + -10800000))", "=IF(-10800000 > 0, FALSE, TRUE)"], ["L", "=V._scaleX1", h], ["E", "=V.cx2 * V._scaleX1", "=V.cy2 * V._scaleY1", "=V._scaleX1", F, 0, "=A(1,3,V.cd4)", "=A(1,3,(V.cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["Z"], {}
					]],
				textRect: {
					left: "=V.wd6",
					top: 0,
					right: d,
					bottom: h
				}
			},
			flowchartDelay: {
				variables: {
					wd2: E,
					d2r: A,
					idx: "=V.wd2 * COS(2700000 / V.d2r)",
					hd2: F,
					idy: "=V.hd2 * SIN(2700000 / V.d2r)",
					hc: E,
					ir: "=V.hc + V.idx",
					vc: F,
					it: "=V.vc - V.idy",
					ib: "=V.vc + V.idy",
					t: 0,
					l: 0,
					b: h,
					r: w,
					_3cd4: D,
					cd2: B,
					cx1: "=C(V.wd2,V.hc,A(V.wd2,V.hd2,V._3cd4),true)",
					cy1: "=C(V.hd2,V.t,A(V.wd2,V.hd2,V._3cd4))"
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				path: [[["M", 0, 0], ["L", a, 0], ["E", "=V.cx1", "=V.cy1", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V._3cd4)", "=A(V.wd2,V.hd2,(V._3cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["L", 0, h], ["Z"], {}
					]],
				textRect: {
					left: 0,
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			flowchartSequentialAccessStorage: {
				variables: {
					wd2: E,
					d2r: A,
					idx: "=V.wd2 * COS(2700000 / V.d2r)",
					hd2: F,
					idy: "=V.hd2 * SIN(2700000 / V.d2r)",
					hc: E,
					il: "=V.hc - V.idx",
					ir: "=V.hc + V.idx",
					vc: F,
					it: "=V.vc - V.idy",
					ib: "=V.vc + V.idy",
					ang1: "=(ATAN2(width,height) * V.d2r)",
					t: 0,
					l: 0,
					b: h,
					r: w,
					cd4: C,
					cx1: "=C(V.wd2,V.hc,A(V.wd2,V.hd2,V.cd4),true)",
					cy1: "=C(V.hd2,V.b,A(V.wd2,V.hd2,V.cd4))",
					cd2: B,
					cx2: "=C(V.wd2,P(V.cx1,V.wd2,A(V.wd2,V.hd2,(V.cd4 + V.cd4)),true),A(V.wd2,V.hd2,V.cd2),true)",
					cy2: "=C(V.hd2,P(V.cy1,V.hd2,A(V.wd2,V.hd2,(V.cd4 + V.cd4))),A(V.wd2,V.hd2,V.cd2))",
					_3cd4: D,
					cx3: "=C(V.wd2,P(V.cx2,V.wd2,A(V.wd2,V.hd2,(V.cd2 + V.cd4)),true),A(V.wd2,V.hd2,V._3cd4),true)",
					cy3: "=C(V.hd2,P(V.cy2,V.hd2,A(V.wd2,V.hd2,(V.cd2 + V.cd4))),A(V.wd2,V.hd2,V._3cd4))",
					cx4: "=C(V.wd2,P(V.cx3,V.wd2,A(V.wd2,V.hd2,(V._3cd4 + V.cd4)),true),A(V.wd2,V.hd2,0),true)",
					cy4: "=C(V.hd2,P(V.cy3,V.hd2,A(V.wd2,V.hd2,(V._3cd4 + V.cd4))),A(V.wd2,V.hd2,0))"
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				path: [[["M", a, h], ["E", "=V.cx1", "=V.cy1", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.cd4)", "=A(V.wd2,V.hd2,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx2", "=V.cy2", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.cd2)", "=A(V.wd2,V.hd2,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx3", "=V.cy3", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V._3cd4)", "=A(V.wd2,V.hd2,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx4", "=V.cy4", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,0)", "=A(V.wd2,V.hd2,(V.ang1))", "=IF(V.ang1 > 0, FALSE, TRUE)"], ["L", w, "=V.ib"], ["L", w, h], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			flowchartMagneticDisk: {
				variables: {
					y3: "=height * 5 / 6",
					hc: E,
					hd3: "=height/3",
					t: 0,
					l: 0,
					vc: F,
					b: h,
					r: w,
					_scaleX1: "= width / 6",
					_scaleY1: "= height / 6",
					cd2: B,
					cx1: "=C(3,0,A(3,1,V.cd2),true)",
					cy1: "=C(1,1,A(3,1,V.cd2))",
					cx2: "=C(3,6,A(3,1,0),true)",
					cy2: "=C(1,5,A(3,1,0))",
					_scaleX2: "= width / 6",
					_scaleY2: "= height / 6",
					cx3: "=C(3,6,A(3,1,0),true)",
					cy3: "=C(1,1,A(3,1,0))",
					_scaleX3: "= width / 6",
					_scaleY3: "= height / 6",
					cx4: "=C(3,0,A(3,1,V.cd2),true)",
					cy4: "=C(1,1,A(3,1,V.cd2))",
					cx5: "=C(3,6,A(3,1,0),true)",
					cy5: "=C(1,5,A(3,1,0))"
				},
				connectionPoints: [{
						x: a,
						y: "=V.hd3"
					}, {
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				path: [[["M", 0, "=V._scaleY1"], ["E", "=V.cx1 * V._scaleX1", "=V.cy1 * V._scaleY1", E, "=V._scaleY1", 0, "=A(3,1,V.cd2)", "=A(3,1,(V.cd2 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["L", w, "=5 * V._scaleY1"], ["E", "=V.cx2 * V._scaleX1", "=V.cy2 * V._scaleY1", E, "=V._scaleY1", 0, "=A(3,1,0)", "=A(3,1,(V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", w, "=V._scaleY2"], ["E", "=V.cx3 * V._scaleX2", "=V.cy3 * V._scaleY2", E, "=V._scaleY2", 0, "=A(3,1,0)", "=A(3,1,(V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], {
							fillMode: "none"
						}
					], [["M", 0, "=V._scaleY3"], ["E", "=V.cx4 * V._scaleX3", "=V.cy4 * V._scaleY3", E, "=V._scaleY3", 0, "=A(3,1,V.cd2)", "=A(3,1,(V.cd2 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["L", w, "=5 * V._scaleY3"], ["E", "=V.cx5 * V._scaleX3", "=V.cy5 * V._scaleY3", E, "=V._scaleY3", 0, "=A(3,1,0)", "=A(3,1,(V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["Z"], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: 0,
					top: "=V.hd3",
					right: w,
					bottom: "=V.y3"
				}
			},
			flowchartDirectAccessStorage: {
				variables: {
					x2: "=width * 2 / 3",
					hc: E,
					t: 0,
					l: 0,
					vc: F,
					b: h,
					r: w,
					_scaleX1: "= width / 6",
					_scaleY1: "= height / 6",
					_3cd4: D,
					cd2: B,
					cx1: "=C(1,5,A(1,3,V._3cd4),true)",
					cy1: "=C(3,0,A(1,3,V._3cd4))",
					cd4: C,
					cx2: "=C(1,1,A(1,3,V.cd4),true)",
					cy2: "=C(3,6,A(1,3,V.cd4))",
					_scaleX2: "= width / 6",
					_scaleY2: "= height / 6",
					cx3: "=C(1,5,A(1,3,V.cd4),true)",
					cy3: "=C(3,6,A(1,3,V.cd4))",
					_scaleX3: "= width / 6",
					_scaleY3: "= height / 6",
					cx4: "=C(1,5,A(1,3,V._3cd4),true)",
					cy4: "=C(3,0,A(1,3,V._3cd4))",
					cx5: "=C(1,1,A(1,3,V.cd4),true)",
					cy5: "=C(3,6,A(1,3,V.cd4))",
					wd6: "=width/6"
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: d,
						y: b
					}, {
						x: w,
						y: b
					}
				],
				path: [[["M", "=V._scaleX1", 0], ["L", "=5 * V._scaleX1", 0], ["E", "=V.cx1 * V._scaleX1", "=V.cy1 * V._scaleY1", "=V._scaleX1", F, 0, "=A(1,3,V._3cd4)", "=A(1,3,(V._3cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["L", "=V._scaleX1", h], ["E", "=V.cx2 * V._scaleX1", "=V.cy2 * V._scaleY1", "=V._scaleX1", F, 0, "=A(1,3,V.cd4)", "=A(1,3,(V.cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", "=5 * V._scaleX2", h], ["E", "=V.cx3 * V._scaleX2", "=V.cy3 * V._scaleY2", "=V._scaleX2", F, 0, "=A(1,3,V.cd4)", "=A(1,3,(V.cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], {
							fillMode: "none"
						}
					], [["M", "=V._scaleX3", 0], ["L", "=5 * V._scaleX3", 0], ["E", "=V.cx4 * V._scaleX3", "=V.cy4 * V._scaleY3", "=V._scaleX3", F, 0, "=A(1,3,V._3cd4)", "=A(1,3,(V._3cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["L", "=V._scaleX3", h], ["E", "=V.cx5 * V._scaleX3", "=V.cy5 * V._scaleY3", "=V._scaleX3", F, 0, "=A(1,3,V.cd4)", "=A(1,3,(V.cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["Z"], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: "=V.wd6",
					top: 0,
					right: d,
					bottom: h
				}
			},
			flowchartDisplay: {
				variables: {
					x2: "=width * 5 / 6",
					hc: E,
					t: 0,
					l: 0,
					vc: F,
					b: h,
					r: w,
					_scaleX1: "= width / 6",
					_scaleY1: "= height / 6",
					_3cd4: D,
					cd2: B,
					cx1: "=C(1,5,A(1,3,V._3cd4),true)",
					cy1: "=C(3,0,A(1,3,V._3cd4))",
					wd6: "=width/6"
				},
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				path: [[["M", 0, F], ["L", "=V._scaleX1", 0], ["L", "=5 * V._scaleX1", 0], ["E", "=V.cx1 * V._scaleX1", "=V.cy1 * V._scaleY1", "=V._scaleX1", F, 0, "=A(1,3,V._3cd4)", "=A(1,3,(V._3cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["L", "=V._scaleX1", h], ["Z"], {}
					]],
				textRect: {
					left: "=V.wd6",
					top: 0,
					right: d,
					bottom: h
				}
			},
			explosion1: {
				variables: {
					x5: "=width * 4627 / 21600",
					x12: "=width * 8485 / 21600",
					x21: "=width * 16702 / 21600",
					x24: "=width * 14522 / 21600",
					y3: "=height * 6320 / 21600",
					y6: "=height * 8615 / 21600",
					y9: "=height * 13937 / 21600",
					y18: "=height * 13290 / 21600",
					t: 0,
					l: 0,
					b: h,
					r: w,
					_scaleX1: "= width / 21600",
					_scaleY1: "= height / 21600"
				},
				connectionPoints: [{
						x: "=V.x24",
						y: 0
					}, {
						x: 0,
						y: "=V.y6"
					}, {
						x: "=V.x12",
						y: h
					}, {
						x: w,
						y: "=V.y18"
					}
				],
				path: [[["M", E, "=5800 * V._scaleY1"], ["L", "=14522 * V._scaleX1", 0], ["L", "=14155 * V._scaleX1", "=5325 * V._scaleY1"], ["L", "=18380 * V._scaleX1", "=4457 * V._scaleY1"], ["L", "=16702 * V._scaleX1", "=7315 * V._scaleY1"], ["L", "=21097 * V._scaleX1", "=8137 * V._scaleY1"], ["L", "=17607 * V._scaleX1", "=10475 * V._scaleY1"], ["L", w, "=13290 * V._scaleY1"], ["L", "=16837 * V._scaleX1", "=12942 * V._scaleY1"], ["L", "=18145 * V._scaleX1", "=18095 * V._scaleY1"], ["L", "=14020 * V._scaleX1", "=14457 * V._scaleY1"], ["L", "=13247 * V._scaleX1", "=19737 * V._scaleY1"], ["L", "=10532 * V._scaleX1", "=14935 * V._scaleY1"], ["L", "=8485 * V._scaleX1", h], ["L", "=7715 * V._scaleX1", "=15627 * V._scaleY1"], ["L", "=4762 * V._scaleX1", "=17617 * V._scaleY1"], ["L", "=5667 * V._scaleX1", "=13937 * V._scaleY1"], ["L", "=135 * V._scaleX1", "=14587 * V._scaleY1"], ["L", "=3722 * V._scaleX1", "=11775 * V._scaleY1"], ["L", 0, "=8615 * V._scaleY1"], ["L", "=4627 * V._scaleX1", "=7617 * V._scaleY1"], ["L", "=370 * V._scaleX1", "=2295 * V._scaleY1"], ["L", "=7312 * V._scaleX1", "=6320 * V._scaleY1"], ["L", "=8352 * V._scaleX1", "=2295 * V._scaleY1"], ["Z"], {}
					]],
				textRect: {
					left: "=V.x5",
					top: "=V.y3",
					right: "=V.x21",
					bottom: "=V.y9"
				}
			},
			explosion2: {
				variables: {
					x2: "=width * 9722 / 21600",
					x5: "=width * 5372 / 21600",
					x16: "=width * 11612 / 21600",
					x19: "=width * 14640 / 21600",
					y2: "=height * 1887 / 21600",
					y3: "=height * 6382 / 21600",
					y8: "=height * 12877 / 21600",
					y14: "=height * 19712 / 21600",
					y16: "=height * 18842 / 21600",
					y17: "=height * 15935 / 21600",
					y24: "=height * 6645 / 21600",
					l: 0,
					r: w,
					_scaleX1: "= width / 21600",
					_scaleY1: "= height / 21600"
				},
				connectionPoints: [{
						x: d,
						y: f
					}, {
						x: 0,
						y: "=V.y8"
					}, {
						x: "=V.x16",
						y: "=V.y16"
					}, {
						x: w,
						y: "=V.y24"
					}
				],
				path: [[["M", "=11462 * V._scaleX1", "=4342 * V._scaleY1"], ["L", "=14790 * V._scaleX1", 0], ["L", "=14525 * V._scaleX1", "=5777 * V._scaleY1"], ["L", "=18007 * V._scaleX1", "=3172 * V._scaleY1"], ["L", "=16380 * V._scaleX1", "=6532 * V._scaleY1"], ["L", w, "=6645 * V._scaleY1"], ["L", "=16985 * V._scaleX1", "=9402 * V._scaleY1"], ["L", "=18270 * V._scaleX1", "=11290 * V._scaleY1"], ["L", "=16380 * V._scaleX1", "=12310 * V._scaleY1"], ["L", "=18877 * V._scaleX1", "=15632 * V._scaleY1"], ["L", "=14640 * V._scaleX1", "=14350 * V._scaleY1"], ["L", "=14942 * V._scaleX1", "=17370 * V._scaleY1"], ["L", "=12180 * V._scaleX1", "=15935 * V._scaleY1"], ["L", "=11612 * V._scaleX1", "=18842 * V._scaleY1"], ["L", "=9872 * V._scaleX1", "=17370 * V._scaleY1"], ["L", "=8700 * V._scaleX1", "=19712 * V._scaleY1"], ["L", "=7527 * V._scaleX1", "=18125 * V._scaleY1"], ["L", "=4917 * V._scaleX1", h], ["L", "=4805 * V._scaleX1", "=18240 * V._scaleY1"], ["L", "=1285 * V._scaleX1", "=17825 * V._scaleY1"], ["L", "=3330 * V._scaleX1", "=15370 * V._scaleY1"], ["L", 0, "=12877 * V._scaleY1"], ["L", "=3935 * V._scaleX1", "=11592 * V._scaleY1"], ["L", "=1172 * V._scaleX1", "=8270 * V._scaleY1"], ["L", "=5372 * V._scaleX1", "=7817 * V._scaleY1"], ["L", "=4502 * V._scaleX1", "=3625 * V._scaleY1"], ["L", "=8550 * V._scaleX1", "=6382 * V._scaleY1"], ["L", "=9722 * V._scaleX1", "=1887 * V._scaleY1"], ["Z"], {}
					]],
				textRect: {
					left: "=V.x5",
					top: "=V.y3",
					right: "=V.x19",
					bottom: "=V.y17"
				}
			},
			shape4pointStar: {
				variables: {
					adj: 12500,
					a: "=MIN(MAX(0, V.adj), 50000)",
					wd2: E,
					iwd2: "=V.wd2 * V.a / 50000",
					hd2: F,
					ihd2: "=V.hd2 * V.a / 50000",
					d2r: A,
					sdx: "=V.iwd2 * COS(2700000 / V.d2r)",
					sdy: "=V.ihd2 * SIN(2700000 / V.d2r)",
					hc: E,
					sx1: "=V.hc - V.sdx",
					sx2: "=V.hc + V.sdx",
					vc: F,
					sy1: "=V.vc - V.sdy",
					sy2: "=V.vc + V.sdy",
					yAdj: "=V.vc - V.ihd2",
					t: 0,
					l: 0,
					b: h,
					r: w
				},
				adjustInfo: [["adj", 12500]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj",
						minY: 0,
						maxY: 50000,
						position: {
							x: "hc",
							y: "yAdj"
						},
						point: [a, "=V.yAdj"]
					}
				],
				path: [[["M", 0, b], ["L", "=V.sx1", "=V.sy1"], ["L", a, 0], ["L", "=V.sx2", "=V.sy1"], ["L", w, b], ["L", "=V.sx2", "=V.sy2"], ["L", a, h], ["L", "=V.sx1", "=V.sy2"], ["Z"], {}
					]],
				textRect: {
					left: "=V.sx1",
					top: "=V.sy1",
					right: "=V.sx2",
					bottom: "=V.sy2"
				}
			},
			shape5pointStar: {
				variables: {
					adj: 19098,
					hf: 105146,
					vf: 110557,
					a: "=MIN(MAX(0, V.adj), 50000)",
					wd2: E,
					swd2: "=V.wd2 * V.hf / 100000",
					hd2: F,
					shd2: "=V.hd2 * V.vf / 100000",
					vc: F,
					svc: "=V.vc * V.vf / 100000",
					d2r: A,
					dx1: "=V.swd2 * COS(1080000 / V.d2r)",
					dx2: "=V.swd2 * COS(18360000 / V.d2r)",
					dy1: "=V.shd2 * SIN(1080000 / V.d2r)",
					dy2: "=V.shd2 * SIN(18360000 / V.d2r)",
					hc: E,
					x1: "=V.hc - V.dx1",
					x2: "=V.hc - V.dx2",
					x3: "=V.hc + V.dx2",
					x4: "=V.hc + V.dx1",
					y1: "=V.svc - V.dy1",
					y2: "=V.svc - V.dy2",
					iwd2: "=V.swd2 * V.a / 50000",
					ihd2: "=V.shd2 * V.a / 50000",
					sdx1: "=V.iwd2 * COS(20520000 / V.d2r)",
					sdx2: "=V.iwd2 * COS(3240000 / V.d2r)",
					sdy1: "=V.ihd2 * SIN(3240000 / V.d2r)",
					sdy2: "=V.ihd2 * SIN(20520000 / V.d2r)",
					sx1: "=V.hc - V.sdx1",
					sx2: "=V.hc - V.sdx2",
					sx3: "=V.hc + V.sdx2",
					sx4: "=V.hc + V.sdx1",
					sy1: "=V.svc - V.sdy1",
					sy2: "=V.svc - V.sdy2",
					sy3: "=V.svc + V.ihd2",
					yAdj: "=V.svc - V.ihd2",
					t: 0
				},
				adjustInfo: [["adj", 19098], ["hf", 105146], ["vf", 110557]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: c,
						y: e
					}, {
						x: d,
						y: f
					}, {
						x: "=V.x3",
						y: f
					}, {
						x: "=V.x4",
						y: e
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj",
						minY: 0,
						maxY: 50000,
						position: {
							x: "hc",
							y: "yAdj"
						},
						point: [a, "=V.yAdj"]
					}
				],
				path: [[["M", c, e], ["L", "=V.sx2", "=V.sy1"], ["L", a, 0], ["L", "=V.sx3", "=V.sy1"], ["L", "=V.x4", e], ["L", "=V.sx4", "=V.sy2"], ["L", "=V.x3", f], ["L", a, "=V.sy3"], ["L", d, f], ["L", "=V.sx1", "=V.sy2"], ["Z"], {}
					]],
				textRect: {
					left: "=V.sx1",
					top: "=V.sy1",
					right: "=V.sx4",
					bottom: "=V.sy3"
				}
			},
			shape8pointStar: {
				variables: {
					adj: 37500,
					a: "=MIN(MAX(0, V.adj), 50000)",
					wd2: E,
					d2r: A,
					dx1: "=V.wd2 * COS(2700000 / V.d2r)",
					hc: E,
					x1: "=V.hc - V.dx1",
					x2: "=V.hc + V.dx1",
					hd2: F,
					dy1: "=V.hd2 * SIN(2700000 / V.d2r)",
					vc: F,
					y1: "=V.vc - V.dy1",
					y2: "=V.vc + V.dy1",
					iwd2: "=V.wd2 * V.a / 50000",
					ihd2: "=V.hd2 * V.a / 50000",
					sdx1: "=V.iwd2 * 92388 / 100000",
					sdx2: "=V.iwd2 * 38268 / 100000",
					sdy1: "=V.ihd2 * 92388 / 100000",
					sdy2: "=V.ihd2 * 38268 / 100000",
					sx1: "=V.hc - V.sdx1",
					sx2: "=V.hc - V.sdx2",
					sx3: "=V.hc + V.sdx2",
					sx4: "=V.hc + V.sdx1",
					sy1: "=V.vc - V.sdy1",
					sy2: "=V.vc - V.sdy2",
					sy3: "=V.vc + V.sdy2",
					sy4: "=V.vc + V.sdy1",
					yAdj: "=V.vc - V.ihd2",
					r: w,
					b: h,
					l: 0,
					t: 0
				},
				adjustInfo: [["adj", 37500]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: d,
						y: f
					}, {
						x: a,
						y: h
					}, {
						x: c,
						y: f
					}, {
						x: 0,
						y: b
					}, {
						x: c,
						y: e
					}, {
						x: a,
						y: 0
					}, {
						x: d,
						y: e
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj",
						minY: 0,
						maxY: 50000,
						position: {
							x: "hc",
							y: "yAdj"
						},
						point: [a, "=V.yAdj"]
					}
				],
				path: [[["M", 0, b], ["L", "=V.sx1", "=V.sy2"], ["L", c, e], ["L", "=V.sx2", "=V.sy1"], ["L", a, 0], ["L", "=V.sx3", "=V.sy1"], ["L", d, e], ["L", "=V.sx4", "=V.sy2"], ["L", w, b], ["L", "=V.sx4", "=V.sy3"], ["L", d, f], ["L", "=V.sx3", "=V.sy4"], ["L", a, h], ["L", "=V.sx2", "=V.sy4"], ["L", c, f], ["L", "=V.sx1", "=V.sy3"], ["Z"], {}
					]],
				textRect: {
					left: "=V.sx1",
					top: "=V.sy1",
					right: "=V.sx4",
					bottom: "=V.sy4"
				}
			},
			shape16pointStar: {
				variables: {
					adj: 37500,
					a: "=MIN(MAX(0, V.adj), 50000)",
					wd2: E,
					dx1: "=V.wd2 * 92388 / 100000",
					dx2: "=V.wd2 * 70711 / 100000",
					dx3: "=V.wd2 * 38268 / 100000",
					hd2: F,
					dy1: "=V.hd2 * 92388 / 100000",
					dy2: "=V.hd2 * 70711 / 100000",
					dy3: "=V.hd2 * 38268 / 100000",
					hc: E,
					x1: "=V.hc - V.dx1",
					x2: "=V.hc - V.dx2",
					x3: "=V.hc - V.dx3",
					x4: "=V.hc + V.dx3",
					x5: "=V.hc + V.dx2",
					x6: "=V.hc + V.dx1",
					vc: F,
					y1: "=V.vc - V.dy1",
					y2: "=V.vc - V.dy2",
					y3: "=V.vc - V.dy3",
					y4: "=V.vc + V.dy3",
					y5: "=V.vc + V.dy2",
					y6: "=V.vc + V.dy1",
					iwd2: "=V.wd2 * V.a / 50000",
					ihd2: "=V.hd2 * V.a / 50000",
					sdx1: "=V.iwd2 * 98079 / 100000",
					sdx2: "=V.iwd2 * 83147 / 100000",
					sdx3: "=V.iwd2 * 55557 / 100000",
					sdx4: "=V.iwd2 * 19509 / 100000",
					sdy1: "=V.ihd2 * 98079 / 100000",
					sdy2: "=V.ihd2 * 83147 / 100000",
					sdy3: "=V.ihd2 * 55557 / 100000",
					sdy4: "=V.ihd2 * 19509 / 100000",
					sx1: "=V.hc - V.sdx1",
					sx2: "=V.hc - V.sdx2",
					sx3: "=V.hc - V.sdx3",
					sx4: "=V.hc - V.sdx4",
					sx5: "=V.hc + V.sdx4",
					sx6: "=V.hc + V.sdx3",
					sx7: "=V.hc + V.sdx2",
					sx8: "=V.hc + V.sdx1",
					sy1: "=V.vc - V.sdy1",
					sy2: "=V.vc - V.sdy2",
					sy3: "=V.vc - V.sdy3",
					sy4: "=V.vc - V.sdy4",
					sy5: "=V.vc + V.sdy4",
					sy6: "=V.vc + V.sdy3",
					sy7: "=V.vc + V.sdy2",
					sy8: "=V.vc + V.sdy1",
					d2r: A,
					idx: "=V.iwd2 * COS(2700000 / V.d2r)",
					idy: "=V.ihd2 * SIN(2700000 / V.d2r)",
					il: "=V.hc - V.idx",
					it: "=V.vc - V.idy",
					ir: "=V.hc + V.idx",
					ib: "=V.vc + V.idy",
					yAdj: "=V.vc - V.ihd2",
					r: w,
					b: h,
					l: 0,
					t: 0
				},
				adjustInfo: [["adj", 37500]],
				connectionPoints: [{
						x: "=V.x5",
						y: f
					}, {
						x: "=V.x6",
						y: "=V.y3"
					}, {
						x: w,
						y: b
					}, {
						x: "=V.x6",
						y: "=V.y4"
					}, {
						x: "=V.x5",
						y: "=V.y5"
					}, {
						x: "=V.x4",
						y: "=V.y6"
					}, {
						x: a,
						y: h
					}, {
						x: "=V.x3",
						y: "=V.y6"
					}, {
						x: d,
						y: "=V.y5"
					}, {
						x: c,
						y: "=V.y4"
					}, {
						x: 0,
						y: b
					}, {
						x: c,
						y: "=V.y3"
					}, {
						x: d,
						y: f
					}, {
						x: "=V.x3",
						y: e
					}, {
						x: a,
						y: 0
					}, {
						x: "=V.x4",
						y: e
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj",
						minY: 0,
						maxY: 50000,
						position: {
							x: "hc",
							y: "yAdj"
						},
						point: [a, "=V.yAdj"]
					}
				],
				path: [[["M", 0, b], ["L", "=V.sx1", "=V.sy4"], ["L", c, "=V.y3"], ["L", "=V.sx2", "=V.sy3"], ["L", d, f], ["L", "=V.sx3", "=V.sy2"], ["L", "=V.x3", e], ["L", "=V.sx4", "=V.sy1"], ["L", a, 0], ["L", "=V.sx5", "=V.sy1"], ["L", "=V.x4", e], ["L", "=V.sx6", "=V.sy2"], ["L", "=V.x5", f], ["L", "=V.sx7", "=V.sy3"], ["L", "=V.x6", "=V.y3"], ["L", "=V.sx8", "=V.sy4"], ["L", w, b], ["L", "=V.sx8", "=V.sy5"], ["L", "=V.x6", "=V.y4"], ["L", "=V.sx7", "=V.sy6"], ["L", "=V.x5", "=V.y5"], ["L", "=V.sx6", "=V.sy7"], ["L", "=V.x4", "=V.y6"], ["L", "=V.sx5", "=V.sy8"], ["L", a, h], ["L", "=V.sx4", "=V.sy8"], ["L", "=V.x3", "=V.y6"], ["L", "=V.sx3", "=V.sy7"], ["L", d, "=V.y5"], ["L", "=V.sx2", "=V.sy6"], ["L", c, "=V.y4"], ["L", "=V.sx1", "=V.sy5"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			shape24pointStar: {
				variables: {
					adj: 37500,
					a: "=MIN(MAX(0, V.adj), 50000)",
					wd2: E,
					d2r: A,
					dx1: "=V.wd2 * COS(900000 / V.d2r)",
					dx2: "=V.wd2 * COS(1800000 / V.d2r)",
					dx3: "=V.wd2 * COS(2700000 / V.d2r)",
					wd4: "=width/4",
					dx4: "=V.wd4",
					dx5: "=V.wd2 * COS(4500000 / V.d2r)",
					hd2: F,
					dy1: "=V.hd2 * SIN(4500000 / V.d2r)",
					dy2: "=V.hd2 * SIN(3600000 / V.d2r)",
					dy3: "=V.hd2 * SIN(2700000 / V.d2r)",
					hd4: "=height/4",
					dy4: "=V.hd4",
					dy5: "=V.hd2 * SIN(900000 / V.d2r)",
					hc: E,
					x1: "=V.hc - V.dx1",
					x2: "=V.hc - V.dx2",
					x3: "=V.hc - V.dx3",
					x4: "=V.hc - V.dx4",
					x5: "=V.hc - V.dx5",
					x6: "=V.hc + V.dx5",
					x7: "=V.hc + V.dx4",
					x8: "=V.hc + V.dx3",
					x9: "=V.hc + V.dx2",
					x10: "=V.hc + V.dx1",
					vc: F,
					y1: "=V.vc - V.dy1",
					y2: "=V.vc - V.dy2",
					y3: "=V.vc - V.dy3",
					y4: "=V.vc - V.dy4",
					y5: "=V.vc - V.dy5",
					y6: "=V.vc + V.dy5",
					y7: "=V.vc + V.dy4",
					y8: "=V.vc + V.dy3",
					y9: "=V.vc + V.dy2",
					y10: "=V.vc + V.dy1",
					iwd2: "=V.wd2 * V.a / 50000",
					ihd2: "=V.hd2 * V.a / 50000",
					sdx1: "=V.iwd2 * 99144 / 100000",
					sdx2: "=V.iwd2 * 92388 / 100000",
					sdx3: "=V.iwd2 * 79335 / 100000",
					sdx4: "=V.iwd2 * 60876 / 100000",
					sdx5: "=V.iwd2 * 38268 / 100000",
					sdx6: "=V.iwd2 * 13053 / 100000",
					sdy1: "=V.ihd2 * 99144 / 100000",
					sdy2: "=V.ihd2 * 92388 / 100000",
					sdy3: "=V.ihd2 * 79335 / 100000",
					sdy4: "=V.ihd2 * 60876 / 100000",
					sdy5: "=V.ihd2 * 38268 / 100000",
					sdy6: "=V.ihd2 * 13053 / 100000",
					sx1: "=V.hc - V.sdx1",
					sx2: "=V.hc - V.sdx2",
					sx3: "=V.hc - V.sdx3",
					sx4: "=V.hc - V.sdx4",
					sx5: "=V.hc - V.sdx5",
					sx6: "=V.hc - V.sdx6",
					sx7: "=V.hc + V.sdx6",
					sx8: "=V.hc + V.sdx5",
					sx9: "=V.hc + V.sdx4",
					sx10: "=V.hc + V.sdx3",
					sx11: "=V.hc + V.sdx2",
					sx12: "=V.hc + V.sdx1",
					sy1: "=V.vc - V.sdy1",
					sy2: "=V.vc - V.sdy2",
					sy3: "=V.vc - V.sdy3",
					sy4: "=V.vc - V.sdy4",
					sy5: "=V.vc - V.sdy5",
					sy6: "=V.vc - V.sdy6",
					sy7: "=V.vc + V.sdy6",
					sy8: "=V.vc + V.sdy5",
					sy9: "=V.vc + V.sdy4",
					sy10: "=V.vc + V.sdy3",
					sy11: "=V.vc + V.sdy2",
					sy12: "=V.vc + V.sdy1",
					idx: "=V.iwd2 * COS(2700000 / V.d2r)",
					idy: "=V.ihd2 * SIN(2700000 / V.d2r)",
					il: "=V.hc - V.idx",
					it: "=V.vc - V.idy",
					ir: "=V.hc + V.idx",
					ib: "=V.vc + V.idy",
					yAdj: "=V.vc - V.ihd2",
					t: 0,
					l: 0,
					b: h,
					r: w
				},
				adjustInfo: [["adj", 37500]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj",
						minY: 0,
						maxY: 50000,
						position: {
							x: "hc",
							y: "yAdj"
						},
						point: [a, "=V.yAdj"]
					}
				],
				path: [[["M", 0, b], ["L", "=V.sx1", "=V.sy6"], ["L", c, "=V.y5"], ["L", "=V.sx2", "=V.sy5"], ["L", d, "=V.y4"], ["L", "=V.sx3", "=V.sy4"], ["L", "=V.x3", "=V.y3"], ["L", "=V.sx4", "=V.sy3"], ["L", "=V.x4", f], ["L", "=V.sx5", "=V.sy2"], ["L", "=V.x5", e], ["L", "=V.sx6", "=V.sy1"], ["L", a, 0], ["L", "=V.sx7", "=V.sy1"], ["L", "=V.x6", e], ["L", "=V.sx8", "=V.sy2"], ["L", "=V.x7", f], ["L", "=V.sx9", "=V.sy3"], ["L", "=V.x8", "=V.y3"], ["L", "=V.sx10", "=V.sy4"], ["L", "=V.x9", "=V.y4"], ["L", "=V.sx11", "=V.sy5"], ["L", "=V.x10", "=V.y5"], ["L", "=V.sx12", "=V.sy6"], ["L", w, b], ["L", "=V.sx12", "=V.sy7"], ["L", "=V.x10", "=V.y6"], ["L", "=V.sx11", "=V.sy8"], ["L", "=V.x9", "=V.y7"], ["L", "=V.sx10", "=V.sy9"], ["L", "=V.x8", "=V.y8"], ["L", "=V.sx9", "=V.sy10"], ["L", "=V.x7", "=V.y9"], ["L", "=V.sx8", "=V.sy11"], ["L", "=V.x6", "=V.y10"], ["L", "=V.sx7", "=V.sy12"], ["L", a, h], ["L", "=V.sx6", "=V.sy12"], ["L", "=V.x5", "=V.y10"], ["L", "=V.sx5", "=V.sy11"], ["L", "=V.x4", "=V.y9"], ["L", "=V.sx4", "=V.sy10"], ["L", "=V.x3", "=V.y8"], ["L", "=V.sx3", "=V.sy9"], ["L", d, "=V.y7"], ["L", "=V.sx2", "=V.sy8"], ["L", c, "=V.y6"], ["L", "=V.sx1", "=V.sy7"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			shape32pointStar: {
				variables: {
					adj: 37500,
					a: "=MIN(MAX(0, V.adj), 50000)",
					wd2: E,
					dx1: "=V.wd2 * 98079 / 100000",
					dx2: "=V.wd2 * 92388 / 100000",
					dx3: "=V.wd2 * 83147 / 100000",
					d2r: A,
					dx4: "=V.wd2 * COS(2700000 / V.d2r)",
					dx5: "=V.wd2 * 55557 / 100000",
					dx6: "=V.wd2 * 38268 / 100000",
					dx7: "=V.wd2 * 19509 / 100000",
					hd2: F,
					dy1: "=V.hd2 * 98079 / 100000",
					dy2: "=V.hd2 * 92388 / 100000",
					dy3: "=V.hd2 * 83147 / 100000",
					dy4: "=V.hd2 * SIN(2700000 / V.d2r)",
					dy5: "=V.hd2 * 55557 / 100000",
					dy6: "=V.hd2 * 38268 / 100000",
					dy7: "=V.hd2 * 19509 / 100000",
					hc: E,
					x1: "=V.hc - V.dx1",
					x2: "=V.hc - V.dx2",
					x3: "=V.hc - V.dx3",
					x4: "=V.hc - V.dx4",
					x5: "=V.hc - V.dx5",
					x6: "=V.hc - V.dx6",
					x7: "=V.hc - V.dx7",
					x8: "=V.hc + V.dx7",
					x9: "=V.hc + V.dx6",
					x10: "=V.hc + V.dx5",
					x11: "=V.hc + V.dx4",
					x12: "=V.hc + V.dx3",
					x13: "=V.hc + V.dx2",
					x14: "=V.hc + V.dx1",
					vc: F,
					y1: "=V.vc - V.dy1",
					y2: "=V.vc - V.dy2",
					y3: "=V.vc - V.dy3",
					y4: "=V.vc - V.dy4",
					y5: "=V.vc - V.dy5",
					y6: "=V.vc - V.dy6",
					y7: "=V.vc - V.dy7",
					y8: "=V.vc + V.dy7",
					y9: "=V.vc + V.dy6",
					y10: "=V.vc + V.dy5",
					y11: "=V.vc + V.dy4",
					y12: "=V.vc + V.dy3",
					y13: "=V.vc + V.dy2",
					y14: "=V.vc + V.dy1",
					iwd2: "=V.wd2 * V.a / 50000",
					ihd2: "=V.hd2 * V.a / 50000",
					sdx1: "=V.iwd2 * 99518 / 100000",
					sdx2: "=V.iwd2 * 95694 / 100000",
					sdx3: "=V.iwd2 * 88192 / 100000",
					sdx4: "=V.iwd2 * 77301 / 100000",
					sdx5: "=V.iwd2 * 63439 / 100000",
					sdx6: "=V.iwd2 * 47140 / 100000",
					sdx7: "=V.iwd2 * 29028 / 100000",
					sdx8: "=V.iwd2 * 9802 / 100000",
					sdy1: "=V.ihd2 * 99518 / 100000",
					sdy2: "=V.ihd2 * 95694 / 100000",
					sdy3: "=V.ihd2 * 88192 / 100000",
					sdy4: "=V.ihd2 * 77301 / 100000",
					sdy5: "=V.ihd2 * 63439 / 100000",
					sdy6: "=V.ihd2 * 47140 / 100000",
					sdy7: "=V.ihd2 * 29028 / 100000",
					sdy8: "=V.ihd2 * 9802 / 100000",
					sx1: "=V.hc - V.sdx1",
					sx2: "=V.hc - V.sdx2",
					sx3: "=V.hc - V.sdx3",
					sx4: "=V.hc - V.sdx4",
					sx5: "=V.hc - V.sdx5",
					sx6: "=V.hc - V.sdx6",
					sx7: "=V.hc - V.sdx7",
					sx8: "=V.hc - V.sdx8",
					sx9: "=V.hc + V.sdx8",
					sx10: "=V.hc + V.sdx7",
					sx11: "=V.hc + V.sdx6",
					sx12: "=V.hc + V.sdx5",
					sx13: "=V.hc + V.sdx4",
					sx14: "=V.hc + V.sdx3",
					sx15: "=V.hc + V.sdx2",
					sx16: "=V.hc + V.sdx1",
					sy1: "=V.vc - V.sdy1",
					sy2: "=V.vc - V.sdy2",
					sy3: "=V.vc - V.sdy3",
					sy4: "=V.vc - V.sdy4",
					sy5: "=V.vc - V.sdy5",
					sy6: "=V.vc - V.sdy6",
					sy7: "=V.vc - V.sdy7",
					sy8: "=V.vc - V.sdy8",
					sy9: "=V.vc + V.sdy8",
					sy10: "=V.vc + V.sdy7",
					sy11: "=V.vc + V.sdy6",
					sy12: "=V.vc + V.sdy5",
					sy13: "=V.vc + V.sdy4",
					sy14: "=V.vc + V.sdy3",
					sy15: "=V.vc + V.sdy2",
					sy16: "=V.vc + V.sdy1",
					idx: "=V.iwd2 * COS(2700000 / V.d2r)",
					idy: "=V.ihd2 * SIN(2700000 / V.d2r)",
					il: "=V.hc - V.idx",
					it: "=V.vc - V.idy",
					ir: "=V.hc + V.idx",
					ib: "=V.vc + V.idy",
					yAdj: "=V.vc - V.ihd2",
					t: 0,
					l: 0,
					b: h,
					r: w
				},
				adjustInfo: [["adj", 37500]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj",
						minY: 0,
						maxY: 50000,
						position: {
							x: "hc",
							y: "yAdj"
						},
						point: [a, "=V.yAdj"]
					}
				],
				path: [[["M", 0, b], ["L", "=V.sx1", "=V.sy8"], ["L", c, "=V.y7"], ["L", "=V.sx2", "=V.sy7"], ["L", d, "=V.y6"], ["L", "=V.sx3", "=V.sy6"], ["L", "=V.x3", "=V.y5"], ["L", "=V.sx4", "=V.sy5"], ["L", "=V.x4", "=V.y4"], ["L", "=V.sx5", "=V.sy4"], ["L", "=V.x5", "=V.y3"], ["L", "=V.sx6", "=V.sy3"], ["L", "=V.x6", f], ["L", "=V.sx7", "=V.sy2"], ["L", "=V.x7", e], ["L", "=V.sx8", "=V.sy1"], ["L", a, 0], ["L", "=V.sx9", "=V.sy1"], ["L", "=V.x8", e], ["L", "=V.sx10", "=V.sy2"], ["L", "=V.x9", f], ["L", "=V.sx11", "=V.sy3"], ["L", "=V.x10", "=V.y3"], ["L", "=V.sx12", "=V.sy4"], ["L", "=V.x11", "=V.y4"], ["L", "=V.sx13", "=V.sy5"], ["L", "=V.x12", "=V.y5"], ["L", "=V.sx14", "=V.sy6"], ["L", "=V.x13", "=V.y6"], ["L", "=V.sx15", "=V.sy7"], ["L", "=V.x14", "=V.y7"], ["L", "=V.sx16", "=V.sy8"], ["L", w, b], ["L", "=V.sx16", "=V.sy9"], ["L", "=V.x14", "=V.y8"], ["L", "=V.sx15", "=V.sy10"], ["L", "=V.x13", "=V.y9"], ["L", "=V.sx14", "=V.sy11"], ["L", "=V.x12", "=V.y10"], ["L", "=V.sx13", "=V.sy12"], ["L", "=V.x11", "=V.y11"], ["L", "=V.sx12", "=V.sy13"], ["L", "=V.x10", "=V.y12"], ["L", "=V.sx11", "=V.sy14"], ["L", "=V.x9", "=V.y13"], ["L", "=V.sx10", "=V.sy15"], ["L", "=V.x8", "=V.y14"], ["L", "=V.sx9", "=V.sy16"], ["L", a, h], ["L", "=V.sx8", "=V.sy16"], ["L", "=V.x7", "=V.y14"], ["L", "=V.sx7", "=V.sy15"], ["L", "=V.x6", "=V.y13"], ["L", "=V.sx6", "=V.sy14"], ["L", "=V.x5", "=V.y12"], ["L", "=V.sx5", "=V.sy13"], ["L", "=V.x4", "=V.y11"], ["L", "=V.sx4", "=V.sy12"], ["L", "=V.x3", "=V.y10"], ["L", "=V.sx3", "=V.sy11"], ["L", d, "=V.y9"], ["L", "=V.sx2", "=V.sy10"], ["L", c, "=V.y8"], ["L", "=V.sx1", "=V.sy9"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			upRibbon: {
				variables: {
					adj1: 16667,
					adj2: 50000,
					a1: "=MIN(MAX(0, V.adj1), 33333)",
					a2: "=MIN(MAX(25000, V.adj2), 75000)",
					r: w,
					wd8: "=width/8",
					x10: "=width - V.wd8",
					dx2: "=width * V.a2 / 200000",
					hc: E,
					x2: "=V.hc - V.dx2",
					x9: "=V.hc + V.dx2",
					wd32: "=width/32",
					x3: "=V.x2 + V.wd32",
					x8: "=V.x9 - V.wd32",
					x5: "=V.x2 + V.wd8",
					x6: "=V.x9 - V.wd8",
					x4: "=V.x5 - V.wd32",
					x7: "=V.x6 + V.wd32",
					dy1: "=height * V.a1 / 200000",
					b: h,
					y1: "=height - V.dy1",
					dy2: "=height * V.a1 / 100000",
					y2: "=height - V.dy2",
					t: 0,
					y4: "=V.dy2",
					y3: "=(V.y4 + V.b) / 2",
					hR: "=height * V.a1 / 400000",
					y6: "=height - V.hR",
					y7: "=V.y1 - V.hR",
					l: 0,
					cd4: C,
					cx1: "=C(V.wd32,V.x4,A(V.wd32,V.hR,V.cd4),true)",
					cy1: "=C(V.hR,V.b,A(V.wd32,V.hR,V.cd4))",
					cd2: B,
					cx2: "=C(V.wd32,V.x3,A(V.wd32,V.hR,V.cd4),true)",
					cy2: "=C(V.hR,V.y1,A(V.wd32,V.hR,V.cd4))",
					_3cd4: D,
					cx3: "=C(V.wd32,V.x8,A(V.wd32,V.hR,V._3cd4),true)",
					cy3: "=C(V.hR,V.y2,A(V.wd32,V.hR,V._3cd4))",
					cx4: "=C(V.wd32,V.x7,A(V.wd32,V.hR,V._3cd4),true)",
					cy4: "=C(V.hR,V.y1,A(V.wd32,V.hR,V._3cd4))",
					cx5: "=C(V.wd32,V.x9,A(V.wd32,V.hR,0),true)",
					cy5: "=C(V.hR,V.hR,A(V.wd32,V.hR,0))",
					cx6: "=C(V.wd32,V.x3,A(V.wd32,V.hR,V._3cd4),true)",
					cy6: "=C(V.hR,V.t,A(V.wd32,V.hR,V._3cd4))",
					cx7: "=C(V.wd32,V.x5,A(V.wd32,V.hR,0),true)",
					cy7: "=C(V.hR,V.y6,A(V.wd32,V.hR,0))",
					cx8: "=C(V.wd32,V.x3,A(V.wd32,V.hR,V.cd4),true)",
					cy8: "=C(V.hR,V.y1,A(V.wd32,V.hR,V.cd4))",
					cx9: "=C(V.wd32,V.x6,A(V.wd32,V.hR,V.cd2),true)",
					cy9: "=C(V.hR,V.y6,A(V.wd32,V.hR,V.cd2))",
					cx10: "=C(V.wd32,V.x8,A(V.wd32,V.hR,V.cd4),true)",
					cy10: "=C(V.hR,V.y1,A(V.wd32,V.hR,V.cd4))",
					cx11: "=C(V.wd32,V.x2,A(V.wd32,V.hR,V.cd2),true)",
					cy11: "=C(V.hR,V.hR,A(V.wd32,V.hR,V.cd2))",
					cx12: "=C(V.wd32,V.x8,A(V.wd32,V.hR,V._3cd4),true)",
					cy12: "=C(V.hR,V.t,A(V.wd32,V.hR,V._3cd4))",
					cx13: "=C(V.wd32,V.x7,A(V.wd32,V.hR,V.cd4),true)",
					cy13: "=C(V.hR,V.b,A(V.wd32,V.hR,V.cd4))",
					cx14: "=C(V.wd32,V.x8,A(V.wd32,V.hR,V.cd4),true)",
					cy14: "=C(V.hR,V.y1,A(V.wd32,V.hR,V.cd4))",
					cx15: "=C(V.wd32,V.x3,A(V.wd32,V.hR,V._3cd4),true)",
					cy15: "=C(V.hR,V.y2,A(V.wd32,V.hR,V._3cd4))",
					cx16: "=C(V.wd32,V.x4,A(V.wd32,V.hR,V._3cd4),true)",
					cy16: "=C(V.hR,V.y1,A(V.wd32,V.hR,V._3cd4))"
				},
				adjustInfo: [["adj1", 16667], ["adj2", 50000]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: "=V.wd8",
						y: "=V.y3"
					}, {
						x: a,
						y: f
					}, {
						x: "=V.x10",
						y: "=V.y3"
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: 33333,
						position: {
							x: "hc",
							y: "y2"
						},
						point: [a, f]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 25000,
						maxX: 75000,
						position: {
							x: "x2",
							y: "b"
						},
						point: [d, h]
					}
				],
				path: [[["M", 0, h], ["L", "=V.x4", h], ["E", "=V.cx1", "=V.cy1", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V.cd4)", "=A(V.wd32,V.hR,(V.cd4 + -10800000))", "=IF(-10800000 > 0, FALSE, TRUE)"], ["L", "=V.x3", e], ["E", "=V.cx2", "=V.cy2", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V.cd4)", "=A(V.wd32,V.hR,(V.cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["L", "=V.x8", f], ["E", "=V.cx3", "=V.cy3", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V._3cd4)", "=A(V.wd32,V.hR,(V._3cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["L", "=V.x7", e], ["E", "=V.cx4", "=V.cy4", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V._3cd4)", "=A(V.wd32,V.hR,(V._3cd4 + -10800000))", "=IF(-10800000 > 0, FALSE, TRUE)"], ["L", w, h], ["L", "=V.x10", "=V.y3"], ["L", w, "=V.y4"], ["L", "=V.x9", "=V.y4"], ["L", "=V.x9", "=V.hR"], ["E", "=V.cx5", "=V.cy5", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,0)", "=A(V.wd32,V.hR,(-5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", "=V.x3", 0], ["E", "=V.cx6", "=V.cy6", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V._3cd4)", "=A(V.wd32,V.hR,(V._3cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", d, "=V.y4"], ["L", 0, "=V.y4"], ["L", "=V.wd8", "=V.y3"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", "=V.x5", "=V.y6"], ["E", "=V.cx7", "=V.cy7", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,0)", "=A(V.wd32,V.hR,(-5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", "=V.x3", e], ["E", "=V.cx8", "=V.cy8", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V.cd4)", "=A(V.wd32,V.hR,(V.cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["L", "=V.x5", f], ["Z"], ["M", "=V.x6", "=V.y6"], ["E", "=V.cx9", "=V.cy9", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V.cd2)", "=A(V.wd32,V.hR,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.x8", e], ["E", "=V.cx10", "=V.cy10", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V.cd4)", "=A(V.wd32,V.hR,(V.cd4 + -10800000))", "=IF(-10800000 > 0, FALSE, TRUE)"], ["L", "=V.x6", f], ["Z"], {
							fillMode: "darkenLess",
							strokeMode: "false"
						}
					], [["M", 0, h], ["L", "=V.wd8", "=V.y3"], ["L", 0, "=V.y4"], ["L", d, "=V.y4"], ["L", d, "=V.hR"], ["E", "=V.cx11", "=V.cy11", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V.cd2)", "=A(V.wd32,V.hR,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.x8", 0], ["E", "=V.cx12", "=V.cy12", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V._3cd4)", "=A(V.wd32,V.hR,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.x9", "=V.y4"], ["L", "=V.x9", "=V.y4"], ["L", w, "=V.y4"], ["L", "=V.x10", "=V.y3"], ["L", w, h], ["L", "=V.x7", h], ["E", "=V.cx13", "=V.cy13", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V.cd4)", "=A(V.wd32,V.hR,(V.cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["L", "=V.x8", e], ["E", "=V.cx14", "=V.cy14", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V.cd4)", "=A(V.wd32,V.hR,(V.cd4 + -10800000))", "=IF(-10800000 > 0, FALSE, TRUE)"], ["L", "=V.x3", f], ["E", "=V.cx15", "=V.cy15", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V._3cd4)", "=A(V.wd32,V.hR,(V._3cd4 + -10800000))", "=IF(-10800000 > 0, FALSE, TRUE)"], ["L", "=V.x4", e], ["E", "=V.cx16", "=V.cy16", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V._3cd4)", "=A(V.wd32,V.hR,(V._3cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["Z"], ["M", "=V.x5", f], ["L", "=V.x5", "=V.y6"], ["M", "=V.x6", "=V.y6"], ["L", "=V.x6", f], ["M", d, "=V.y7"], ["L", d, "=V.y4"], ["M", "=V.x9", "=V.y4"], ["L", "=V.x9", "=V.y7"], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: d,
					top: 0,
					right: "=V.x9",
					bottom: f
				}
			},
			downRibbon: {
				variables: {
					adj1: 16667,
					adj2: 50000,
					a1: "=MIN(MAX(0, V.adj1), 33333)",
					a2: "=MIN(MAX(25000, V.adj2), 75000)",
					r: w,
					wd8: "=width/8",
					x10: "=width - V.wd8",
					dx2: "=width * V.a2 / 200000",
					hc: E,
					x2: "=V.hc - V.dx2",
					x9: "=V.hc + V.dx2",
					wd32: "=width/32",
					x3: "=V.x2 + V.wd32",
					x8: "=V.x9 - V.wd32",
					x5: "=V.x2 + V.wd8",
					x6: "=V.x9 - V.wd8",
					x4: "=V.x5 - V.wd32",
					x7: "=V.x6 + V.wd32",
					y1: "=height * V.a1 / 200000",
					y2: "=height * V.a1 / 100000",
					b: h,
					y4: "=height - V.y2",
					y3: "=V.y4 / 2",
					hR: "=height * V.a1 / 400000",
					y5: "=height - V.hR",
					y6: "=V.y2 - V.hR",
					t: 0,
					l: 0,
					_3cd4: D,
					cd2: B,
					cx1: "=C(V.wd32,V.x4,A(V.wd32,V.hR,V._3cd4),true)",
					cy1: "=C(V.hR,V.t,A(V.wd32,V.hR,V._3cd4))",
					cx2: "=C(V.wd32,V.x3,A(V.wd32,V.hR,V._3cd4),true)",
					cy2: "=C(V.hR,V.y1,A(V.wd32,V.hR,V._3cd4))",
					cd4: C,
					cx3: "=C(V.wd32,V.x8,A(V.wd32,V.hR,V.cd4),true)",
					cy3: "=C(V.hR,V.y2,A(V.wd32,V.hR,V.cd4))",
					cx4: "=C(V.wd32,V.x7,A(V.wd32,V.hR,V.cd4),true)",
					cy4: "=C(V.hR,V.y1,A(V.wd32,V.hR,V.cd4))",
					cx5: "=C(V.wd32,V.x9,A(V.wd32,V.hR,0),true)",
					cy5: "=C(V.hR,V.y5,A(V.wd32,V.hR,0))",
					cx6: "=C(V.wd32,V.x3,A(V.wd32,V.hR,V.cd4),true)",
					cy6: "=C(V.hR,V.b,A(V.wd32,V.hR,V.cd4))",
					cx7: "=C(V.wd32,V.x5,A(V.wd32,V.hR,0),true)",
					cy7: "=C(V.hR,V.hR,A(V.wd32,V.hR,0))",
					cx8: "=C(V.wd32,V.x3,A(V.wd32,V.hR,V._3cd4),true)",
					cy8: "=C(V.hR,V.y1,A(V.wd32,V.hR,V._3cd4))",
					cx9: "=C(V.wd32,V.x6,A(V.wd32,V.hR,V.cd2),true)",
					cy9: "=C(V.hR,V.hR,A(V.wd32,V.hR,V.cd2))",
					cx10: "=C(V.wd32,V.x8,A(V.wd32,V.hR,V._3cd4),true)",
					cy10: "=C(V.hR,V.y1,A(V.wd32,V.hR,V._3cd4))",
					cx11: "=C(V.wd32,V.x4,A(V.wd32,V.hR,V._3cd4),true)",
					cy11: "=C(V.hR,V.t,A(V.wd32,V.hR,V._3cd4))",
					cx12: "=C(V.wd32,V.x3,A(V.wd32,V.hR,V._3cd4),true)",
					cy12: "=C(V.hR,V.y1,A(V.wd32,V.hR,V._3cd4))",
					cx13: "=C(V.wd32,V.x8,A(V.wd32,V.hR,V.cd4),true)",
					cy13: "=C(V.hR,V.y2,A(V.wd32,V.hR,V.cd4))",
					cx14: "=C(V.wd32,V.x7,A(V.wd32,V.hR,V.cd4),true)",
					cy14: "=C(V.hR,V.y1,A(V.wd32,V.hR,V.cd4))",
					cx15: "=C(V.wd32,V.x9,A(V.wd32,V.hR,0),true)",
					cy15: "=C(V.hR,V.y5,A(V.wd32,V.hR,0))",
					cx16: "=C(V.wd32,V.x3,A(V.wd32,V.hR,V.cd4),true)",
					cy16: "=C(V.hR,V.b,A(V.wd32,V.hR,V.cd4))"
				},
				adjustInfo: [["adj1", 16667], ["adj2", 50000]],
				connectionPoints: [{
						x: a,
						y: f
					}, {
						x: "=V.wd8",
						y: "=V.y3"
					}, {
						x: a,
						y: h
					}, {
						x: "=V.x10",
						y: "=V.y3"
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: 33333,
						position: {
							x: "hc",
							y: "y2"
						},
						point: [a, f]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 25000,
						maxX: 75000,
						position: {
							x: "x2",
							y: "t"
						},
						point: [d, 0]
					}
				],
				path: [[["M", 0, 0], ["L", "=V.x4", 0], ["E", "=V.cx1", "=V.cy1", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V._3cd4)", "=A(V.wd32,V.hR,(V._3cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["L", "=V.x3", e], ["E", "=V.cx2", "=V.cy2", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V._3cd4)", "=A(V.wd32,V.hR,(V._3cd4 + -10800000))", "=IF(-10800000 > 0, FALSE, TRUE)"], ["L", "=V.x8", f], ["E", "=V.cx3", "=V.cy3", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V.cd4)", "=A(V.wd32,V.hR,(V.cd4 + -10800000))", "=IF(-10800000 > 0, FALSE, TRUE)"], ["L", "=V.x7", e], ["E", "=V.cx4", "=V.cy4", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V.cd4)", "=A(V.wd32,V.hR,(V.cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["L", w, 0], ["L", "=V.x10", "=V.y3"], ["L", w, "=V.y4"], ["L", "=V.x9", "=V.y4"], ["L", "=V.x9", "=V.y5"], ["E", "=V.cx5", "=V.cy5", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,0)", "=A(V.wd32,V.hR,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.x3", h], ["E", "=V.cx6", "=V.cy6", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V.cd4)", "=A(V.wd32,V.hR,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", d, "=V.y4"], ["L", 0, "=V.y4"], ["L", "=V.wd8", "=V.y3"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", "=V.x5", "=V.hR"], ["E", "=V.cx7", "=V.cy7", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,0)", "=A(V.wd32,V.hR,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.x3", e], ["E", "=V.cx8", "=V.cy8", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V._3cd4)", "=A(V.wd32,V.hR,(V._3cd4 + -10800000))", "=IF(-10800000 > 0, FALSE, TRUE)"], ["L", "=V.x5", f], ["Z"], ["M", "=V.x6", "=V.hR"], ["E", "=V.cx9", "=V.cy9", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V.cd2)", "=A(V.wd32,V.hR,(V.cd2 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", "=V.x8", e], ["E", "=V.cx10", "=V.cy10", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V._3cd4)", "=A(V.wd32,V.hR,(V._3cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["L", "=V.x6", f], ["Z"], {
							fillMode: "darkenLess",
							strokeMode: "false"
						}
					], [["M", 0, 0], ["L", "=V.x4", 0], ["E", "=V.cx11", "=V.cy11", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V._3cd4)", "=A(V.wd32,V.hR,(V._3cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["L", "=V.x3", e], ["E", "=V.cx12", "=V.cy12", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V._3cd4)", "=A(V.wd32,V.hR,(V._3cd4 + -10800000))", "=IF(-10800000 > 0, FALSE, TRUE)"], ["L", "=V.x8", f], ["E", "=V.cx13", "=V.cy13", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V.cd4)", "=A(V.wd32,V.hR,(V.cd4 + -10800000))", "=IF(-10800000 > 0, FALSE, TRUE)"], ["L", "=V.x7", e], ["E", "=V.cx14", "=V.cy14", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V.cd4)", "=A(V.wd32,V.hR,(V.cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["L", w, 0], ["L", "=V.x10", "=V.y3"], ["L", w, "=V.y4"], ["L", "=V.x9", "=V.y4"], ["L", "=V.x9", "=V.y5"], ["E", "=V.cx15", "=V.cy15", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,0)", "=A(V.wd32,V.hR,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.x3", h], ["E", "=V.cx16", "=V.cy16", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V.cd4)", "=A(V.wd32,V.hR,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", d, "=V.y4"], ["L", 0, "=V.y4"], ["L", "=V.wd8", "=V.y3"], ["Z"], ["M", "=V.x5", "=V.hR"], ["L", "=V.x5", f], ["M", "=V.x6", f], ["L", "=V.x6", "=V.hR"], ["M", d, "=V.y4"], ["L", d, "=V.y6"], ["M", "=V.x9", "=V.y6"], ["L", "=V.x9", "=V.y4"], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: d,
					top: f,
					right: "=V.x9",
					bottom: h
				}
			},
			curvedUpRibbon: {
				variables: {
					adj1: 25000,
					adj2: 50000,
					adj3: 12500,
					a1: "=MIN(MAX(0, V.adj1), 100000)",
					a2: "=MIN(MAX(25000, V.adj2), 75000)",
					q10: "=100000 - V.a1",
					q11: "=V.q10 / 2",
					q12: "=V.a1 - V.q11",
					minAdj3: "=MAX(0, V.q12)",
					a3: "=MIN(MAX(V.minAdj3, V.adj3), V.a1)",
					dx2: "=width * V.a2 / 200000",
					hc: E,
					x2: "=V.hc - V.dx2",
					wd8: "=width/8",
					x3: "=V.x2 + V.wd8",
					r: w,
					x4: "=width - V.x3",
					x5: "=width - V.x2",
					x6: "=width - V.wd8",
					dy1: "=height * V.a3 / 100000",
					f1: "=4 * V.dy1 / width",
					q1: "=V.x3 * V.x3 / width",
					q2: "=V.x3 - V.q1",
					u1: "=V.f1 * V.q2",
					b: h,
					y1: "=height - V.u1",
					cx1: "=V.x3 / 2",
					cu1: "=V.f1 * V.cx1",
					cy1: "=height - V.cu1",
					cx2: "=width - V.cx1",
					_q1: "=height * V.a1 / 100000",
					dy3: "=V._q1 - V.dy1",
					q3: "=V.x2 * V.x2 / width",
					q4: "=V.x2 - V.q3",
					q5: "=V.f1 * V.q4",
					u3: "=V.q5 + V.dy3",
					y3: "=height - V.u3",
					q6: "=V.dy1 + V.dy3 - V.u3",
					q7: "=V.q6 + V.dy1",
					cu3: "=V.q7 + V.dy3",
					cy3: "=height - V.cu3",
					rh: "=height - V._q1",
					q8: "=V.dy1 * 14 / 16",
					u2: "=(V.q8 + V.rh) / 2",
					y2: "=height - V.u2",
					u5: "=V.q5 + V.rh",
					y5: "=height - V.u5",
					u6: "=V.u3 + V.rh",
					y6: "=height - V.u6",
					cx4: "=V.x2 / 2",
					q9: "=V.f1 * V.cx4",
					cu4: "=V.q9 + V.rh",
					cy4: "=height - V.cu4",
					cx5: "=width - V.cx4",
					cu6: "=V.cu3 + V.rh",
					cy6: "=height - V.cu6",
					u7: "=V.u1 + V.dy3",
					y7: "=height - V.u7",
					cu7: "=V._q1 + V._q1 - V.u7",
					cy7: "=height - V.cu7",
					t: 0,
					l: 0
				},
				adjustInfo: [["adj1", 25000], ["adj2", 50000], ["adj3", 12500]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: "=V.wd8",
						y: f
					}, {
						x: a,
						y: "=V.rh"
					}, {
						x: "=V.x6",
						y: f
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: 100000,
						position: {
							x: "hc",
							y: "rh"
						},
						point: [a, "=V.rh"]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 25000,
						maxX: 100000,
						position: {
							x: "x2",
							y: "t"
						},
						point: [d, 0]
					}, {
						type: "ahXY",
						gdRefY: "adj3",
						minY: "minAdj3",
						maxY: "a1",
						position: {
							x: "l",
							y: "dy1"
						},
						point: [0, "=V.dy1"]
					}
				],
				path: [[["M", 0, h], ["Q", "=V.cx1", "=V.cy1", "=V.x3", e], ["L", d, "=V.y3"], ["Q", a, "=V.cy3", "=V.x5", "=V.y3"], ["L", "=V.x4", e], ["Q", "=V.cx2", "=V.cy1", w, h], ["L", "=V.x6", f], ["L", w, "=V._q1"], ["Q", "=V.cx5", "=V.cy4", "=V.x5", "=V.y5"], ["L", "=V.x5", "=V.y6"], ["Q", a, "=V.cy6", d, "=V.y6"], ["L", d, "=V.y5"], ["Q", "=V.cx4", "=V.cy4", 0, "=V._q1"], ["L", "=V.wd8", f], ["Z"], {
							strokeMode: "false"
						}
					], [["M", "=V.x3", "=V.y7"], ["L", "=V.x3", e], ["L", d, "=V.y3"], ["Q", a, "=V.cy3", "=V.x5", "=V.y3"], ["L", "=V.x4", e], ["L", "=V.x4", "=V.y7"], ["Q", a, "=V.cy7", "=V.x3", "=V.y7"], ["Z"], {
							fillMode: "darkenLess",
							strokeMode: "false"
						}
					], [["M", 0, h], ["L", "=V.wd8", f], ["L", 0, "=V._q1"], ["Q", "=V.cx4", "=V.cy4", d, "=V.y5"], ["L", d, "=V.y6"], ["Q", a, "=V.cy6", "=V.x5", "=V.y6"], ["L", "=V.x5", "=V.y5"], ["Q", "=V.cx5", "=V.cy4", w, "=V._q1"], ["L", "=V.x6", f], ["L", w, h], ["Q", "=V.cx2", "=V.cy1", "=V.x4", e], ["L", "=V.x5", "=V.y3"], ["Q", a, "=V.cy3", d, "=V.y3"], ["L", "=V.x3", e], ["Q", "=V.cx1", "=V.cy1", 0, h], ["Z"], ["M", d, "=V.y3"], ["L", d, "=V.y5"], ["M", "=V.x5", "=V.y5"], ["L", "=V.x5", "=V.y3"], ["M", "=V.x3", "=V.y7"], ["L", "=V.x3", e], ["M", "=V.x4", e], ["L", "=V.x4", "=V.y7"], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: d,
					top: "=V.y6",
					right: "=V.x5",
					bottom: "=V.rh"
				}
			},
			curvedDownRibbon: {
				variables: {
					adj1: 25000,
					adj2: 50000,
					adj3: 12500,
					a1: "=MIN(MAX(0, V.adj1), 100000)",
					a2: "=MIN(MAX(25000, V.adj2), 75000)",
					q10: "=100000 - V.a1",
					q11: "=V.q10 / 2",
					q12: "=V.a1 - V.q11",
					minAdj3: "=MAX(0, V.q12)",
					a3: "=MIN(MAX(V.minAdj3, V.adj3), V.a1)",
					dx2: "=width * V.a2 / 200000",
					hc: E,
					x2: "=V.hc - V.dx2",
					wd8: "=width/8",
					x3: "=V.x2 + V.wd8",
					r: w,
					x4: "=width - V.x3",
					x5: "=width - V.x2",
					x6: "=width - V.wd8",
					dy1: "=height * V.a3 / 100000",
					f1: "=4 * V.dy1 / width",
					q1: "=V.x3 * V.x3 / width",
					q2: "=V.x3 - V.q1",
					y1: "=V.f1 * V.q2",
					cx1: "=V.x3 / 2",
					cy1: "=V.f1 * V.cx1",
					cx2: "=width - V.cx1",
					_q1: "=height * V.a1 / 100000",
					dy3: "=V._q1 - V.dy1",
					q3: "=V.x2 * V.x2 / width",
					q4: "=V.x2 - V.q3",
					q5: "=V.f1 * V.q4",
					y3: "=V.q5 + V.dy3",
					q6: "=V.dy1 + V.dy3 - V.y3",
					q7: "=V.q6 + V.dy1",
					cy3: "=V.q7 + V.dy3",
					b: h,
					rh: "=height - V._q1",
					q8: "=V.dy1 * 14 / 16",
					y2: "=(V.q8 + V.rh) / 2",
					y5: "=V.q5 + V.rh",
					y6: "=V.y3 + V.rh",
					cx4: "=V.x2 / 2",
					q9: "=V.f1 * V.cx4",
					cy4: "=V.q9 + V.rh",
					cx5: "=width - V.cx4",
					cy6: "=V.cy3 + V.rh",
					y7: "=V.y1 + V.dy3",
					cy7: "=V._q1 + V._q1 - V.y7",
					y8: "=height - V.dy1",
					l: 0,
					t: 0
				},
				adjustInfo: [["adj1", 25000], ["adj2", 50000], ["adj3", 12500]],
				connectionPoints: [{
						x: a,
						y: "=V._q1"
					}, {
						x: "=V.wd8",
						y: f
					}, {
						x: a,
						y: h
					}, {
						x: "=V.x6",
						y: f
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: 100000,
						position: {
							x: "hc",
							y: "_q1"
						},
						point: [a, "=V._q1"]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 25000,
						maxX: 75000,
						position: {
							x: "x2",
							y: "b"
						},
						point: [d, h]
					}, {
						type: "ahXY",
						gdRefY: "adj3",
						minY: "minAdj3",
						maxY: "a1",
						position: {
							x: "l",
							y: "y8"
						},
						point: [0, "=V.y8"]
					}
				],
				path: [[["M", 0, 0], ["Q", "=V.cx1", "=V.cy1", "=V.x3", e], ["L", d, "=V.y3"], ["Q", a, "=V.cy3", "=V.x5", "=V.y3"], ["L", "=V.x4", e], ["Q", "=V.cx2", "=V.cy1", w, 0], ["L", "=V.x6", f], ["L", w, "=V.rh"], ["Q", "=V.cx5", "=V.cy4", "=V.x5", "=V.y5"], ["L", "=V.x5", "=V.y6"], ["Q", a, "=V.cy6", d, "=V.y6"], ["L", d, "=V.y5"], ["Q", "=V.cx4", "=V.cy4", 0, "=V.rh"], ["L", "=V.wd8", f], ["Z"], {
							strokeMode: "false"
						}
					], [["M", "=V.x3", "=V.y7"], ["L", "=V.x3", e], ["L", d, "=V.y3"], ["Q", a, "=V.cy3", "=V.x5", "=V.y3"], ["L", "=V.x4", e], ["L", "=V.x4", "=V.y7"], ["Q", a, "=V.cy7", "=V.x3", "=V.y7"], ["Z"], {
							fillMode: "darkenLess",
							strokeMode: "false"
						}
					], [["M", 0, 0], ["Q", "=V.cx1", "=V.cy1", "=V.x3", e], ["L", d, "=V.y3"], ["Q", a, "=V.cy3", "=V.x5", "=V.y3"], ["L", "=V.x4", e], ["Q", "=V.cx2", "=V.cy1", w, 0], ["L", "=V.x6", f], ["L", w, "=V.rh"], ["Q", "=V.cx5", "=V.cy4", "=V.x5", "=V.y5"], ["L", "=V.x5", "=V.y6"], ["Q", a, "=V.cy6", d, "=V.y6"], ["L", d, "=V.y5"], ["Q", "=V.cx4", "=V.cy4", 0, "=V.rh"], ["L", "=V.wd8", f], ["Z"], ["M", d, "=V.y5"], ["L", d, "=V.y3"], ["M", "=V.x5", "=V.y3"], ["L", "=V.x5", "=V.y5"], ["M", "=V.x3", e], ["L", "=V.x3", "=V.y7"], ["M", "=V.x4", "=V.y7"], ["L", "=V.x4", e], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: d,
					top: "=V._q1",
					right: "=V.x5",
					bottom: "=V.y6"
				}
			},
			verticalScroll: {
				variables: {
					adj: 12500,
					a: "=MIN(MAX(0, V.adj), 25000)",
					ss: s,
					ch: "=V.ss * V.a / 100000",
					ch2: "=V.ch / 2",
					ch4: "=V.ch / 4",
					x3: "=V.ch + V.ch2",
					x4: "=V.ch + V.ch",
					r: w,
					x6: "=width - V.ch",
					x7: "=width - V.ch2",
					x5: "=V.x6 - V.ch2",
					b: h,
					y3: "=height - V.ch",
					y4: "=height - V.ch2",
					hc: E,
					t: 0,
					vc: F,
					l: 0,
					cd4: C,
					cx1: "=C(V.ch2,V.ch2,A(V.ch2,V.ch2,V.cd4),true)",
					cy1: "=C(V.ch2,V.b,A(V.ch2,V.ch2,V.cd4))",
					cx2: "=C(V.ch4,V.ch2,A(V.ch4,V.ch4,V.cd4),true)",
					cy2: "=C(V.ch4,V.y4,A(V.ch4,V.ch4,V.cd4))",
					cd2: B,
					cx3: "=C(V.ch2,V.ch,A(V.ch2,V.ch2,V.cd2),true)",
					cy3: "=C(V.ch2,V.ch2,A(V.ch2,V.ch2,V.cd2))",
					_3cd4: D,
					cx4: "=C(V.ch2,V.x7,A(V.ch2,V.ch2,V._3cd4),true)",
					cy4: "=C(V.ch2,V.t,A(V.ch2,V.ch2,V._3cd4))",
					cx5: "=C(V.ch2,V.x6,A(V.ch2,V.ch2,0),true)",
					cy5: "=C(V.ch2,V.y4,A(V.ch2,V.ch2,0))",
					cx6: "=C(V.ch2,V.x4,A(V.ch2,V.ch2,0),true)",
					cy6: "=C(V.ch2,V.ch2,A(V.ch2,V.ch2,0))",
					cx7: "=C(V.ch4,P(V.cx6,V.ch2,A(V.ch2,V.ch2,(V.cd4)),true),A(V.ch4,V.ch4,V.cd4),true)",
					cy7: "=C(V.ch4,P(V.cy6,V.ch2,A(V.ch2,V.ch2,(V.cd4))),A(V.ch4,V.ch4,V.cd4))",
					cx8: "=C(V.ch2,V.x4,A(V.ch2,V.ch2,0),true)",
					cy8: "=C(V.ch2,V.ch2,A(V.ch2,V.ch2,0))",
					cx9: "=C(V.ch4,P(V.cx8,V.ch2,A(V.ch2,V.ch2,(V.cd4)),true),A(V.ch4,V.ch4,V.cd4),true)",
					cy9: "=C(V.ch4,P(V.cy8,V.ch2,A(V.ch2,V.ch2,(V.cd4))),A(V.ch4,V.ch4,V.cd4))",
					cx10: "=C(V.ch2,V.ch,A(V.ch2,V.ch2,0),true)",
					cy10: "=C(V.ch2,V.y4,A(V.ch2,V.ch2,0))",
					cx11: "=C(V.ch4,P(V.cx10,V.ch2,A(V.ch2,V.ch2,(V._3cd4)),true),A(V.ch4,V.ch4,V._3cd4),true)",
					cy11: "=C(V.ch4,P(V.cy10,V.ch2,A(V.ch2,V.ch2,(V._3cd4))),A(V.ch4,V.ch4,V._3cd4))",
					cx12: "=C(V.ch2,V.ch,A(V.ch2,V.ch2,V.cd2),true)",
					cy12: "=C(V.ch2,V.ch2,A(V.ch2,V.ch2,V.cd2))",
					cx13: "=C(V.ch2,V.x7,A(V.ch2,V.ch2,V._3cd4),true)",
					cy13: "=C(V.ch2,V.t,A(V.ch2,V.ch2,V._3cd4))",
					cx14: "=C(V.ch2,V.x6,A(V.ch2,V.ch2,0),true)",
					cy14: "=C(V.ch2,V.y4,A(V.ch2,V.ch2,0))",
					cx15: "=C(V.ch2,V.ch2,A(V.ch2,V.ch2,V.cd4),true)",
					cy15: "=C(V.ch2,V.b,A(V.ch2,V.ch2,V.cd4))",
					cx16: "=C(V.ch2,V.x3,A(V.ch2,V.ch2,V._3cd4),true)",
					cy16: "=C(V.ch2,V.t,A(V.ch2,V.ch2,V._3cd4))",
					cx17: "=C(V.ch4,P(V.cx16,V.ch2,A(V.ch2,V.ch2,(V._3cd4 + V.cd2)),true),A(V.ch4,V.ch4,V.cd4),true)",
					cy17: "=C(V.ch4,P(V.cy16,V.ch2,A(V.ch2,V.ch2,(V._3cd4 + V.cd2))),A(V.ch4,V.ch4,V.cd4))",
					cx18: "=C(V.ch4,V.ch2,A(V.ch4,V.ch4,V._3cd4),true)",
					cy18: "=C(V.ch4,V.y3,A(V.ch4,V.ch4,V._3cd4))",
					cx19: "=C(V.ch2,V.ch2,A(V.ch2,V.ch2,V.cd4),true)",
					cy19: "=C(V.ch2,V.b,A(V.ch2,V.ch2,V.cd4))"
				},
				adjustInfo: [["adj", 12500]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: "=V.ch",
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: "=V.x6",
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj",
						minY: 0,
						maxY: 25000,
						position: {
							x: "l",
							y: "ch"
						},
						point: [0, "=V.ch"]
					}
				],
				path: [[["M", "=V.ch2", h], ["E", "=V.cx1", "=V.cy1", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,V.cd4)", "=A(V.ch2,V.ch2,(V.cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", "=V.ch2", "=V.y4"], ["E", "=V.cx2", "=V.cy2", "=V.ch4", "=V.ch4", 0, "=A(V.ch4,V.ch4,V.cd4)", "=A(V.ch4,V.ch4,(V.cd4 + -10800000))", "=IF(-10800000 > 0, FALSE, TRUE)"], ["L", "=V.ch", "=V.y3"], ["L", "=V.ch", "=V.ch2"], ["E", "=V.cx3", "=V.cy3", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,V.cd2)", "=A(V.ch2,V.ch2,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.x7", 0], ["E", "=V.cx4", "=V.cy4", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,V._3cd4)", "=A(V.ch2,V.ch2,(V._3cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["L", "=V.x6", "=V.ch"], ["L", "=V.x6", "=V.y4"], ["E", "=V.cx5", "=V.cy5", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,0)", "=A(V.ch2,V.ch2,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["Z"], ["M", "=V.x4", "=V.ch2"], ["E", "=V.cx6", "=V.cy6", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,0)", "=A(V.ch2,V.ch2,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx7", "=V.cy7", "=V.ch4", "=V.ch4", 0, "=A(V.ch4,V.ch4,V.cd4)", "=A(V.ch4,V.ch4,(V.cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", "=V.x4", "=V.ch2"], ["E", "=V.cx8", "=V.cy8", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,0)", "=A(V.ch2,V.ch2,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx9", "=V.cy9", "=V.ch4", "=V.ch4", 0, "=A(V.ch4,V.ch4,V.cd4)", "=A(V.ch4,V.ch4,(V.cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["Z"], ["M", "=V.ch", "=V.y4"], ["E", "=V.cx10", "=V.cy10", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,0)", "=A(V.ch2,V.ch2,(V._3cd4))", "=IF(V._3cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx11", "=V.cy11", "=V.ch4", "=V.ch4", 0, "=A(V.ch4,V.ch4,V._3cd4)", "=A(V.ch4,V.ch4,(V._3cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["Z"], {
							fillMode: "darkenLess",
							strokeMode: "false"
						}
					], [["M", "=V.ch", "=V.y3"], ["L", "=V.ch", "=V.ch2"], ["E", "=V.cx12", "=V.cy12", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,V.cd2)", "=A(V.ch2,V.ch2,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.x7", 0], ["E", "=V.cx13", "=V.cy13", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,V._3cd4)", "=A(V.ch2,V.ch2,(V._3cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["L", "=V.x6", "=V.ch"], ["L", "=V.x6", "=V.y4"], ["E", "=V.cx14", "=V.cy14", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,0)", "=A(V.ch2,V.ch2,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.ch2", h], ["E", "=V.cx15", "=V.cy15", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,V.cd4)", "=A(V.ch2,V.ch2,(V.cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["Z"], ["M", "=V.x3", 0], ["E", "=V.cx16", "=V.cy16", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,V._3cd4)", "=A(V.ch2,V.ch2,(V._3cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["E", "=V.cx17", "=V.cy17", "=V.ch4", "=V.ch4", 0, "=A(V.ch4,V.ch4,V.cd4)", "=A(V.ch4,V.ch4,(V.cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["L", "=V.x4", "=V.ch2"], ["M", "=V.x6", "=V.ch"], ["L", "=V.x3", "=V.ch"], ["M", "=V.ch2", "=V.y3"], ["E", "=V.cx18", "=V.cy18", "=V.ch4", "=V.ch4", 0, "=A(V.ch4,V.ch4,V._3cd4)", "=A(V.ch4,V.ch4,(V._3cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["L", "=V.ch", "=V.y4"], ["M", "=V.ch2", h], ["E", "=V.cx19", "=V.cy19", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,V.cd4)", "=A(V.ch2,V.ch2,(V.cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", "=V.ch", "=V.y3"], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: "=V.ch",
					top: "=V.ch",
					right: "=V.x6",
					bottom: "=V.y4"
				}
			},
			horizontalScroll: {
				variables: {
					adj: 12500,
					a: "=MIN(MAX(0, V.adj), 25000)",
					ss: s,
					ch: "=V.ss * V.a / 100000",
					ch2: "=V.ch / 2",
					ch4: "=V.ch / 4",
					y3: "=V.ch + V.ch2",
					y4: "=V.ch + V.ch",
					b: h,
					y6: "=height - V.ch",
					y7: "=height - V.ch2",
					y5: "=V.y6 - V.ch2",
					r: w,
					x3: "=width - V.ch",
					x4: "=width - V.ch2",
					hc: E,
					l: 0,
					vc: F,
					t: 0,
					cd4: C,
					cx1: "=C(V.ch2,V.r,A(V.ch2,V.ch2,0),true)",
					cy1: "=C(V.ch2,V.ch2,A(V.ch2,V.ch2,0))",
					cd2: B,
					cx2: "=C(V.ch4,V.x4,A(V.ch4,V.ch4,0),true)",
					cy2: "=C(V.ch4,V.ch2,A(V.ch4,V.ch4,0))",
					_3cd4: D,
					cx3: "=C(V.ch2,V.ch2,A(V.ch2,V.ch2,V._3cd4),true)",
					cy3: "=C(V.ch2,V.ch,A(V.ch2,V.ch2,V._3cd4))",
					cx4: "=C(V.ch2,V.l,A(V.ch2,V.ch2,V.cd2),true)",
					cy4: "=C(V.ch2,V.y7,A(V.ch2,V.ch2,V.cd2))",
					cx5: "=C(V.ch2,V.x4,A(V.ch2,V.ch2,V.cd4),true)",
					cy5: "=C(V.ch2,V.y6,A(V.ch2,V.ch2,V.cd4))",
					cx6: "=C(V.ch2,V.ch2,A(V.ch2,V.ch2,V.cd4),true)",
					cy6: "=C(V.ch2,V.y4,A(V.ch2,V.ch2,V.cd4))",
					cx7: "=C(V.ch4,P(V.cx6,V.ch2,A(V.ch2,V.ch2,(V.cd4 + -5400000)),true),A(V.ch4,V.ch4,0),true)",
					cy7: "=C(V.ch4,P(V.cy6,V.ch2,A(V.ch2,V.ch2,(V.cd4 + -5400000))),A(V.ch4,V.ch4,0))",
					cx8: "=C(V.ch2,V.ch2,A(V.ch2,V.ch2,V.cd4),true)",
					cy8: "=C(V.ch2,V.y4,A(V.ch2,V.ch2,V.cd4))",
					cx9: "=C(V.ch4,P(V.cx8,V.ch2,A(V.ch2,V.ch2,(V.cd4 + -5400000)),true),A(V.ch4,V.ch4,0),true)",
					cy9: "=C(V.ch4,P(V.cy8,V.ch2,A(V.ch2,V.ch2,(V.cd4 + -5400000))),A(V.ch4,V.ch4,0))",
					cx10: "=C(V.ch2,V.x4,A(V.ch2,V.ch2,V.cd4),true)",
					cy10: "=C(V.ch2,V.ch,A(V.ch2,V.ch2,V.cd4))",
					cx11: "=C(V.ch4,P(V.cx10,V.ch2,A(V.ch2,V.ch2,(V.cd4 + -16200000)),true),A(V.ch4,V.ch4,V.cd2),true)",
					cy11: "=C(V.ch4,P(V.cy10,V.ch2,A(V.ch2,V.ch2,(V.cd4 + -16200000))),A(V.ch4,V.ch4,V.cd2))",
					cx12: "=C(V.ch2,V.l,A(V.ch2,V.ch2,V.cd2),true)",
					cy12: "=C(V.ch2,V.y3,A(V.ch2,V.ch2,V.cd2))",
					cx13: "=C(V.ch2,V.x3,A(V.ch2,V.ch2,V.cd2),true)",
					cy13: "=C(V.ch2,V.ch2,A(V.ch2,V.ch2,V.cd2))",
					cx14: "=C(V.ch2,V.r,A(V.ch2,V.ch2,0),true)",
					cy14: "=C(V.ch2,V.y5,A(V.ch2,V.ch2,0))",
					cx15: "=C(V.ch2,V.ch,A(V.ch2,V.ch2,0),true)",
					cy15: "=C(V.ch2,V.y7,A(V.ch2,V.ch2,0))",
					cx16: "=C(V.ch2,V.x4,A(V.ch2,V.ch2,V.cd4),true)",
					cy16: "=C(V.ch2,V.ch,A(V.ch2,V.ch2,V.cd4))",
					cx17: "=C(V.ch4,V.x4,A(V.ch4,V.ch4,0),true)",
					cy17: "=C(V.ch4,V.ch2,A(V.ch4,V.ch4,0))",
					cx18: "=C(V.ch4,V.ch2,A(V.ch4,V.ch4,V.cd2),true)",
					cy18: "=C(V.ch4,V.y3,A(V.ch4,V.ch4,V.cd2))",
					cx19: "=C(V.ch2,P(V.cx18,V.ch4,A(V.ch4,V.ch4,(V.cd2 + V.cd2)),true),A(V.ch2,V.ch2,0),true)",
					cy19: "=C(V.ch2,P(V.cy18,V.ch4,A(V.ch4,V.ch4,(V.cd2 + V.cd2))),A(V.ch2,V.ch2,0))"
				},
				adjustInfo: [["adj", 12500]],
				connectionPoints: [{
						x: a,
						y: "=V.ch"
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: "=V.y6"
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj",
						minX: 0,
						maxX: 25000,
						position: {
							x: "ch",
							y: "t"
						},
						point: ["=V.ch", 0]
					}
				],
				path: [[["M", w, "=V.ch2"], ["E", "=V.cx1", "=V.cy1", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,0)", "=A(V.ch2,V.ch2,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.x4", "=V.ch2"], ["E", "=V.cx2", "=V.cy2", "=V.ch4", "=V.ch4", 0, "=A(V.ch4,V.ch4,0)", "=A(V.ch4,V.ch4,(V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["L", "=V.x3", "=V.ch"], ["L", "=V.ch2", "=V.ch"], ["E", "=V.cx3", "=V.cy3", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,V._3cd4)", "=A(V.ch2,V.ch2,(V._3cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", 0, "=V.y7"], ["E", "=V.cx4", "=V.cy4", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,V.cd2)", "=A(V.ch2,V.ch2,(V.cd2 + -10800000))", "=IF(-10800000 > 0, FALSE, TRUE)"], ["L", "=V.ch", "=V.y6"], ["L", "=V.x4", "=V.y6"], ["E", "=V.cx5", "=V.cy5", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,V.cd4)", "=A(V.ch2,V.ch2,(V.cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["Z"], ["M", "=V.ch2", "=V.y4"], ["E", "=V.cx6", "=V.cy6", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,V.cd4)", "=A(V.ch2,V.ch2,(V.cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["E", "=V.cx7", "=V.cy7", "=V.ch4", "=V.ch4", 0, "=A(V.ch4,V.ch4,0)", "=A(V.ch4,V.ch4,(-10800000))", "=IF(-10800000 > 0, FALSE, TRUE)"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", "=V.ch2", "=V.y4"], ["E", "=V.cx8", "=V.cy8", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,V.cd4)", "=A(V.ch2,V.ch2,(V.cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["E", "=V.cx9", "=V.cy9", "=V.ch4", "=V.ch4", 0, "=A(V.ch4,V.ch4,0)", "=A(V.ch4,V.ch4,(-10800000))", "=IF(-10800000 > 0, FALSE, TRUE)"], ["Z"], ["M", "=V.x4", "=V.ch"], ["E", "=V.cx10", "=V.cy10", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,V.cd4)", "=A(V.ch2,V.ch2,(V.cd4 + -16200000))", "=IF(-16200000 > 0, FALSE, TRUE)"], ["E", "=V.cx11", "=V.cy11", "=V.ch4", "=V.ch4", 0, "=A(V.ch4,V.ch4,V.cd2)", "=A(V.ch4,V.ch4,(V.cd2 + -10800000))", "=IF(-10800000 > 0, FALSE, TRUE)"], ["Z"], {
							fillMode: "darkenLess",
							strokeMode: "false"
						}
					], [["M", 0, "=V.y3"], ["E", "=V.cx12", "=V.cy12", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,V.cd2)", "=A(V.ch2,V.ch2,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.x3", "=V.ch"], ["L", "=V.x3", "=V.ch2"], ["E", "=V.cx13", "=V.cy13", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,V.cd2)", "=A(V.ch2,V.ch2,(V.cd2 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["L", w, "=V.y5"], ["E", "=V.cx14", "=V.cy14", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,0)", "=A(V.ch2,V.ch2,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.ch", "=V.y6"], ["L", "=V.ch", "=V.y7"], ["E", "=V.cx15", "=V.cy15", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,0)", "=A(V.ch2,V.ch2,(V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["Z"], ["M", "=V.x3", "=V.ch"], ["L", "=V.x4", "=V.ch"], ["E", "=V.cx16", "=V.cy16", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,V.cd4)", "=A(V.ch2,V.ch2,(V.cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["M", "=V.x4", "=V.ch"], ["L", "=V.x4", "=V.ch2"], ["E", "=V.cx17", "=V.cy17", "=V.ch4", "=V.ch4", 0, "=A(V.ch4,V.ch4,0)", "=A(V.ch4,V.ch4,(V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["M", "=V.ch2", "=V.y4"], ["L", "=V.ch2", "=V.y3"], ["E", "=V.cx18", "=V.cy18", "=V.ch4", "=V.ch4", 0, "=A(V.ch4,V.ch4,V.cd2)", "=A(V.ch4,V.ch4,(V.cd2 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["E", "=V.cx19", "=V.cy19", "=V.ch2", "=V.ch2", 0, "=A(V.ch2,V.ch2,0)", "=A(V.ch2,V.ch2,(V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["M", "=V.ch", "=V.y3"], ["L", "=V.ch", "=V.y6"], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: "=V.ch",
					top: "=V.ch",
					right: "=V.x4",
					bottom: "=V.y6"
				}
			},
			wave: {
				variables: {
					adj1: 12500,
					adj2: 0,
					a1: "=MIN(MAX(0, V.adj1), 20000)",
					a2: "=MIN(MAX(-10000, V.adj2), 10000)",
					y1: "=height * V.a1 / 100000",
					dy2: "=V.y1 * 10 / 3",
					y2: "=V.y1 - V.dy2",
					y3: "=V.y1 + V.dy2",
					b: h,
					y4: "=height - V.y1",
					y5: "=V.y4 - V.dy2",
					y6: "=V.y4 + V.dy2",
					dx1: "=width * V.a2 / 100000",
					of2: "=width * V.a2 / 50000",
					x1: "=ABS(V.dx1)",
					dx2: "=IF(V.of2 > 0, 0, V.of2)",
					l: 0,
					x2: "=0 - V.dx2",
					dx5: "=IF(V.of2 > 0, V.of2, 0)",
					r: w,
					x5: "=width - V.dx5",
					dx3: "=(V.dx2 + V.x5) / 3",
					x3: "=V.x2 + V.dx3",
					x4: "=(V.x3 + V.x5) / 2",
					x6: "=V.dx5",
					x10: "=width + V.dx2",
					x7: "=V.x6 + V.dx3",
					x8: "=(V.x7 + V.x10) / 2",
					x9: "=width - V.x1",
					hc: E,
					xAdj: "=V.hc + V.dx1",
					xAdj2: "=V.hc - V.dx1",
					il: "=MAX(V.x2, V.x6)",
					ir: "=MIN(V.x5, V.x10)",
					it: "=height * V.a1 / 50000",
					ib: "=height - V.it",
					vc: F
				},
				adjustInfo: [["adj1", 12500], ["adj2", 0]],
				connectionPoints: [{
						x: "=V.xAdj2",
						y: e
					}, {
						x: c,
						y: b
					}, {
						x: "=V.xAdj",
						y: "=V.y4"
					}, {
						x: "=V.x9",
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: 20000,
						position: {
							x: "l",
							y: "y1"
						},
						point: [0, e]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: -10000,
						maxX: 10000,
						position: {
							x: "xAdj",
							y: "b"
						},
						point: ["=V.xAdj", h]
					}
				],
				path: [[["M", d, e], ["B", "=V.x3", f, "=V.x4", "=V.y3", "=V.x5", e], ["L", "=V.x10", "=V.y4"], ["B", "=V.x8", "=V.y6", "=V.x7", "=V.y5", "=V.x6", "=V.y4"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			doubleWave: {
				variables: {
					adj1: 6250,
					adj2: 0,
					a1: "=MIN(MAX(0, V.adj1), 12500)",
					a2: "=MIN(MAX(-10000, V.adj2), 10000)",
					y1: "=height * V.a1 / 100000",
					dy2: "=V.y1 * 10 / 3",
					y2: "=V.y1 - V.dy2",
					y3: "=V.y1 + V.dy2",
					b: h,
					y4: "=height - V.y1",
					y5: "=V.y4 - V.dy2",
					y6: "=V.y4 + V.dy2",
					dx1: "=width * V.a2 / 100000",
					of2: "=width * V.a2 / 50000",
					x1: "=ABS(V.dx1)",
					dx2: "=IF(V.of2 > 0, 0, V.of2)",
					l: 0,
					x2: "=0 - V.dx2",
					dx8: "=IF(V.of2 > 0, V.of2, 0)",
					r: w,
					x8: "=width - V.dx8",
					dx3: "=(V.dx2 + V.x8) / 6",
					x3: "=V.x2 + V.dx3",
					dx4: "=(V.dx2 + V.x8) / 3",
					x4: "=V.x2 + V.dx4",
					x5: "=(V.x2 + V.x8) / 2",
					x6: "=V.x5 + V.dx3",
					x7: "=(V.x6 + V.x8) / 2",
					x9: "=V.dx8",
					x15: "=width + V.dx2",
					x10: "=V.x9 + V.dx3",
					x11: "=V.x9 + V.dx4",
					x12: "=(V.x9 + V.x15) / 2",
					x13: "=V.x12 + V.dx3",
					x14: "=(V.x13 + V.x15) / 2",
					x16: "=width - V.x1",
					hc: E,
					xAdj: "=V.hc + V.dx1",
					il: "=MAX(V.x2, V.x9)",
					ir: "=MIN(V.x8, V.x15)",
					it: "=height * V.a1 / 50000",
					ib: "=height - V.it",
					vc: F
				},
				adjustInfo: [["adj1", 6250], ["adj2", 0]],
				connectionPoints: [{
						x: "=V.x12",
						y: e
					}, {
						x: c,
						y: b
					}, {
						x: "=V.x5",
						y: "=V.y4"
					}, {
						x: "=V.x16",
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: 12500,
						position: {
							x: "l",
							y: "y1"
						},
						point: [0, e]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: -10000,
						maxX: 10000,
						position: {
							x: "xAdj",
							y: "b"
						},
						point: ["=V.xAdj", h]
					}
				],
				path: [[["M", d, e], ["B", "=V.x3", f, "=V.x4", "=V.y3", "=V.x5", e], ["B", "=V.x6", f, "=V.x7", "=V.y3", "=V.x8", e], ["L", "=V.x15", "=V.y4"], ["B", "=V.x14", "=V.y6", "=V.x13", "=V.y5", "=V.x12", "=V.y4"], ["B", "=V.x11", "=V.y6", "=V.x10", "=V.y5", "=V.x9", "=V.y4"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			rectangularCallout: {
				variables: {
					adj1: -20833,
					adj2: 62500,
					dxPos: "=width * V.adj1 / 100000",
					dyPos: "=height * V.adj2 / 100000",
					hc: E,
					xPos: "=V.hc + V.dxPos",
					vc: F,
					yPos: "=V.vc + V.dyPos",
					dx: "=V.xPos - V.hc",
					dy: "=V.yPos - V.vc",
					dq: "=V.dxPos * height / width",
					ady: "=ABS(V.dyPos)",
					adq: "=ABS(V.dq)",
					dz: "=V.ady - V.adq",
					xg1: "=IF(V.dxPos > 0, 7, 2)",
					xg2: "=IF(V.dxPos > 0, 10, 5)",
					x1: "=width * V.xg1 / 12",
					x2: "=width * V.xg2 / 12",
					yg1: "=IF(V.dyPos > 0, 7, 2)",
					yg2: "=IF(V.dyPos > 0, 10, 5)",
					y1: "=height * V.yg1 / 12",
					y2: "=height * V.yg2 / 12",
					l: 0,
					t1: "=IF(V.dxPos > 0, V.l, V.xPos)",
					xl: "=IF(V.dz > 0, V.l, V.t1)",
					t2: "=IF(V.dyPos > 0, V.x1, V.xPos)",
					xt: "=IF(V.dz > 0, V.t2, V.x1)",
					r: w,
					t3: "=IF(V.dxPos > 0, V.xPos, V.r)",
					xr: "=IF(V.dz > 0, V.r, V.t3)",
					t4: "=IF(V.dyPos > 0, V.xPos, V.x1)",
					xb: "=IF(V.dz > 0, V.t4, V.x1)",
					t5: "=IF(V.dxPos > 0, V.y1, V.yPos)",
					yl: "=IF(V.dz > 0, V.y1, V.t5)",
					t: 0,
					t6: "=IF(V.dyPos > 0, V.t, V.yPos)",
					yt: "=IF(V.dz > 0, V.t6, V.t)",
					t7: "=IF(V.dxPos > 0, V.yPos, V.y1)",
					yr: "=IF(V.dz > 0, V.y1, V.t7)",
					b: h,
					t8: "=IF(V.dyPos > 0, V.yPos, V.b)",
					yb: "=IF(V.dz > 0, V.t8, V.b)"
				},
				adjustInfo: [["adj1", -20833], ["adj2", 62500]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}, {
						x: "=V.xPos",
						y: "=V.yPos"
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj1",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj2",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "xPos",
							y: "yPos"
						},
						point: ["=V.xPos", "=V.yPos"]
					}
				],
				path: [[["M", 0, 0], ["L", c, 0], ["L", "=V.xt", "=V.yt"], ["L", d, 0], ["L", w, 0], ["L", w, e], ["L", "=V.xr", "=V.yr"], ["L", w, f], ["L", w, h], ["L", d, h], ["L", "=V.xb", "=V.yb"], ["L", c, h], ["L", 0, h], ["L", 0, f], ["L", "=V.xl", "=V.yl"], ["L", 0, e], ["Z"], {}
					]]
			},
			roundedRectangularCallout: {
				variables: {
					adj1: -20833,
					adj2: 62500,
					adj3: 16667,
					dxPos: "=width * V.adj1 / 100000",
					dyPos: "=height * V.adj2 / 100000",
					hc: E,
					xPos: "=V.hc + V.dxPos",
					vc: F,
					yPos: "=V.vc + V.dyPos",
					dq: "=V.dxPos * height / width",
					ady: "=ABS(V.dyPos)",
					adq: "=ABS(V.dq)",
					dz: "=V.ady - V.adq",
					xg1: "=IF(V.dxPos > 0, 7, 2)",
					xg2: "=IF(V.dxPos > 0, 10, 5)",
					x1: "=width * V.xg1 / 12",
					x2: "=width * V.xg2 / 12",
					yg1: "=IF(V.dyPos > 0, 7, 2)",
					yg2: "=IF(V.dyPos > 0, 10, 5)",
					y1: "=height * V.yg1 / 12",
					y2: "=height * V.yg2 / 12",
					l: 0,
					t1: "=IF(V.dxPos > 0, V.l, V.xPos)",
					xl: "=IF(V.dz > 0, V.l, V.t1)",
					t2: "=IF(V.dyPos > 0, V.x1, V.xPos)",
					xt: "=IF(V.dz > 0, V.t2, V.x1)",
					r: w,
					t3: "=IF(V.dxPos > 0, V.xPos, V.r)",
					xr: "=IF(V.dz > 0, V.r, V.t3)",
					t4: "=IF(V.dyPos > 0, V.xPos, V.x1)",
					xb: "=IF(V.dz > 0, V.t4, V.x1)",
					t5: "=IF(V.dxPos > 0, V.y1, V.yPos)",
					yl: "=IF(V.dz > 0, V.y1, V.t5)",
					t: 0,
					t6: "=IF(V.dyPos > 0, V.t, V.yPos)",
					yt: "=IF(V.dz > 0, V.t6, V.t)",
					t7: "=IF(V.dxPos > 0, V.yPos, V.y1)",
					yr: "=IF(V.dz > 0, V.y1, V.t7)",
					b: h,
					t8: "=IF(V.dyPos > 0, V.yPos, V.b)",
					yb: "=IF(V.dz > 0, V.t8, V.b)",
					ss: s,
					u1: "=V.ss * V.adj3 / 100000",
					u2: "=width - V.u1",
					v2: "=height - V.u1",
					il: "=V.u1 * 29289 / 100000",
					ir: "=width - V.il",
					ib: "=height - V.il",
					cd2: B,
					cd4: C,
					cx1: "=C(V.u1,V.l,A(V.u1,V.u1,V.cd2),true)",
					cy1: "=C(V.u1,V.u1,A(V.u1,V.u1,V.cd2))",
					_3cd4: D,
					cx2: "=C(V.u1,V.u2,A(V.u1,V.u1,V._3cd4),true)",
					cy2: "=C(V.u1,V.t,A(V.u1,V.u1,V._3cd4))",
					cx3: "=C(V.u1,V.r,A(V.u1,V.u1,0),true)",
					cy3: "=C(V.u1,V.v2,A(V.u1,V.u1,0))",
					cx4: "=C(V.u1,V.u1,A(V.u1,V.u1,V.cd4),true)",
					cy4: "=C(V.u1,V.b,A(V.u1,V.u1,V.cd4))"
				},
				adjustInfo: [["adj1", -20833], ["adj2", 62500], ["adj3", 16667]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}, {
						x: "=V.xPos",
						y: "=V.yPos"
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj1",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj2",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "xPos",
							y: "yPos"
						},
						point: ["=V.xPos", "=V.yPos"]
					}
				],
				path: [[["M", 0, "=V.u1"], ["E", "=V.cx1", "=V.cy1", "=V.u1", "=V.u1", 0, "=A(V.u1,V.u1,V.cd2)", "=A(V.u1,V.u1,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", c, 0], ["L", "=V.xt", "=V.yt"], ["L", d, 0], ["L", "=V.u2", 0], ["E", "=V.cx2", "=V.cy2", "=V.u1", "=V.u1", 0, "=A(V.u1,V.u1,V._3cd4)", "=A(V.u1,V.u1,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", w, e], ["L", "=V.xr", "=V.yr"], ["L", w, f], ["L", w, "=V.v2"], ["E", "=V.cx3", "=V.cy3", "=V.u1", "=V.u1", 0, "=A(V.u1,V.u1,0)", "=A(V.u1,V.u1,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", d, h], ["L", "=V.xb", "=V.yb"], ["L", c, h], ["L", "=V.u1", h], ["E", "=V.cx4", "=V.cy4", "=V.u1", "=V.u1", 0, "=A(V.u1,V.u1,V.cd4)", "=A(V.u1,V.u1,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", 0, f], ["L", "=V.xl", "=V.yl"], ["L", 0, e], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.il",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			ovalCallout: {
				variables: {
					adj1: -20833,
					adj2: 62500,
					dxPos: "=width * V.adj1 / 100000",
					dyPos: "=height * V.adj2 / 100000",
					hc: E,
					xPos: "=V.hc + V.dxPos",
					vc: F,
					yPos: "=V.vc + V.dyPos",
					sdx: "=V.dxPos * height",
					sdy: "=V.dyPos * width",
					d2r: A,
					pang: "=(ATAN2(V.sdx,V.sdy) * V.d2r)",
					stAng: "=V.pang + 660000",
					enAng: "=V.pang - 660000",
					wd2: E,
					dx1: "=V.wd2 * COS(V.stAng / V.d2r)",
					hd2: F,
					dy1: "=V.hd2 * SIN(V.stAng / V.d2r)",
					x1: "=V.hc + V.dx1",
					y1: "=V.vc + V.dy1",
					dx2: "=V.wd2 * COS(V.enAng / V.d2r)",
					dy2: "=V.hd2 * SIN(V.enAng / V.d2r)",
					x2: "=V.hc + V.dx2",
					y2: "=V.vc + V.dy2",
					stAng1: "=(ATAN2(V.dx1,V.dy1) * V.d2r)",
					enAng1: "=(ATAN2(V.dx2,V.dy2) * V.d2r)",
					swAng1: "=V.enAng1 - V.stAng1",
					swAng2: "=V.swAng1 + 21600000",
					swAng: "=IF(V.swAng1 > 0, V.swAng1, V.swAng2)",
					idx: "=V.wd2 * COS(2700000 / V.d2r)",
					idy: "=V.hd2 * SIN(2700000 / V.d2r)",
					il: "=V.hc - V.idx",
					ir: "=V.hc + V.idx",
					it: "=V.vc - V.idy",
					ib: "=V.vc + V.idy",
					t: 0,
					b: h,
					r: w,
					cx1: "=C(V.wd2,V.x1,A(V.wd2,V.hd2,V.stAng1),true)",
					cy1: "=C(V.hd2,V.y1,A(V.wd2,V.hd2,V.stAng1))"
				},
				adjustInfo: [["adj1", -20833], ["adj2", 62500]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: "=V.il",
						y: "=V.it"
					}, {
						x: "=V.il",
						y: "=V.ib"
					}, {
						x: a,
						y: h
					}, {
						x: "=V.ir",
						y: "=V.ib"
					}, {
						x: w,
						y: b
					}, {
						x: "=V.ir",
						y: "=V.it"
					}, {
						x: "=V.xPos",
						y: "=V.yPos"
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj1",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj2",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "xPos",
							y: "yPos"
						},
						point: ["=V.xPos", "=V.yPos"]
					}
				],
				path: [[["M", "=V.xPos", "=V.yPos"], ["L", c, e], ["E", "=V.cx1", "=V.cy1", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.stAng1)", "=A(V.wd2,V.hd2,(V.stAng1 + V.swAng))", "=IF(V.swAng > 0, FALSE, TRUE)"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			cloudCallout: {
				variables: {
					adj1: -20833,
					adj2: 62500,
					dxPos: "=width * V.adj1 / 100000",
					dyPos: "=height * V.adj2 / 100000",
					hc: E,
					xPos: "=V.hc + V.dxPos",
					vc: F,
					yPos: "=V.vc + V.dyPos",
					hd2: F,
					ht: "=V.hd2 * COS(ATAN2(V.dxPos,V.dyPos))",
					wd2: E,
					wt: "=V.wd2 * SIN(ATAN2(V.dxPos,V.dyPos))",
					g2: "=V.wd2 * COS(ATAN2(V.ht,V.wt))",
					g3: "=V.hd2 * SIN(ATAN2(V.ht,V.wt))",
					g4: "=V.hc + V.g2",
					g5: "=V.vc + V.g3",
					g6: "=V.g4 - V.xPos",
					g7: "=V.g5 - V.yPos",
					g8: "=SQRT(V.g6*V.g6 + V.g7*V.g7)",
					ss: s,
					g9: "=V.ss * 6600 / 21600",
					g10: "=V.g8 - V.g9",
					g11: "=V.g10 / 3",
					g12: "=V.ss * 1800 / 21600",
					g13: "=V.g11 + V.g12",
					g14: "=V.g13 * V.g6 / V.g8",
					g15: "=V.g13 * V.g7 / V.g8",
					g16: "=V.g14 + V.xPos",
					g17: "=V.g15 + V.yPos",
					g18: "=V.ss * 4800 / 21600",
					g19: "=V.g11 * 2",
					g20: "=V.g18 + V.g19",
					g21: "=V.g20 * V.g6 / V.g8",
					g22: "=V.g20 * V.g7 / V.g8",
					g23: "=V.g21 + V.xPos",
					g24: "=V.g22 + V.yPos",
					g25: "=V.ss * 1200 / 21600",
					g26: "=V.ss * 600 / 21600",
					x23: "=V.xPos + V.g26",
					x24: "=V.g16 + V.g25",
					x25: "=V.g23 + V.g12",
					il: "=width * 2977 / 21600",
					it: "=height * 3262 / 21600",
					ir: "=width * 17087 / 21600",
					ib: "=height * 17337 / 21600",
					g27: "=width * 67 / 21600",
					g28: "=height * 21577 / 21600",
					g29: "=width * 21582 / 21600",
					g30: "=height * 1235 / 21600",
					d2r: A,
					pang: "=(ATAN2(V.dxPos,V.dyPos) * V.d2r)",
					_scaleX1: "= width / 43200",
					_scaleY1: "= height / 43200",
					cx1: "=C(6753,3900,A(6753,9190,-11429249),true)",
					cy1: "=C(9190,14370,A(6753,9190,-11429249))",
					cx2: "=C(5333,P(V.cx1,6753,A(6753,9190,(-11429249 + 7426832)),true),A(5333,7267,-8646143),true)",
					cy2: "=C(7267,P(V.cy1,9190,A(6753,9190,(-11429249 + 7426832))),A(5333,7267,-8646143))",
					cx3: "=C(4365,P(V.cx2,5333,A(5333,7267,(-8646143 + 5396714)),true),A(4365,5945,-8748475),true)",
					cy3: "=C(5945,P(V.cy2,7267,A(5333,7267,(-8646143 + 5396714))),A(4365,5945,-8748475))",
					cx4: "=C(4857,P(V.cx3,4365,A(4365,5945,(-8748475 + 5983381)),true),A(4857,6595,-7859164),true)",
					cy4: "=C(6595,P(V.cy3,5945,A(4365,5945,(-8748475 + 5983381))),A(4857,6595,-7859164))",
					cx5: "=C(5333,P(V.cx4,4857,A(4857,6595,(-7859164 + 7034504)),true),A(5333,7273,-4722533),true)",
					cy5: "=C(7273,P(V.cy4,6595,A(4857,6595,(-7859164 + 7034504))),A(5333,7273,-4722533))",
					cx6: "=C(6775,P(V.cx5,5333,A(5333,7273,(-4722533 + 6541615)),true),A(6775,9220,-2776035),true)",
					cy6: "=C(9220,P(V.cy5,7273,A(5333,7273,(-4722533 + 6541615))),A(6775,9220,-2776035))",
					cx7: "=C(5785,P(V.cx6,6775,A(6775,9220,(-2776035 + 7816140)),true),A(5785,7867,37501),true)",
					cy7: "=C(7867,P(V.cy6,9220,A(6775,9220,(-2776035 + 7816140))),A(5785,7867,37501))",
					cx8: "=C(6752,P(V.cx7,5785,A(5785,7867,(37501 + 6842000)),true),A(6752,9215,1347096),true)",
					cy8: "=C(9215,P(V.cy7,7867,A(5785,7867,(37501 + 6842000))),A(6752,9215,1347096))",
					cx9: "=C(7720,P(V.cx8,6752,A(6752,9215,(1347096 + 6910353)),true),A(7720,10543,3974558),true)",
					cy9: "=C(10543,P(V.cy8,9215,A(6752,9215,(1347096 + 6910353))),A(7720,10543,3974558))",
					cx10: "=C(4360,P(V.cx9,7720,A(7720,10543,(3974558 + 4542661)),true),A(4360,5918,-16496525),true)",
					cy10: "=C(5918,P(V.cy9,10543,A(7720,10543,(3974558 + 4542661))),A(4360,5918,-16496525))",
					cx11: "=C(4345,P(V.cx10,4360,A(4360,5918,(-16496525 + 8804134)),true),A(4345,5945,-14809710),true)",
					cy11: "=C(5945,P(V.cy10,5918,A(4360,5918,(-16496525 + 8804134))),A(4345,5945,-14809710))",
					cx12: "=C(V.g26,V.x23,A(V.g26,V.g26,0),true)",
					cy12: "=C(V.g26,V.yPos,A(V.g26,V.g26,0))",
					cx13: "=C(V.g25,V.x24,A(V.g25,V.g25,0),true)",
					cy13: "=C(V.g25,V.g17,A(V.g25,V.g25,0))",
					cx14: "=C(V.g12,V.x25,A(V.g12,V.g12,0),true)",
					cy14: "=C(V.g12,V.g24,A(V.g12,V.g12,0))",
					_scaleX2: "= width / 43200",
					_scaleY2: "= height / 43200",
					cx15: "=C(4345,4693,A(4345,5945,5204520),true)",
					cy15: "=C(5945,26177,A(4345,5945,5204520))",
					cx16: "=C(4360,6928,A(4360,5918,4416628),true)",
					cy16: "=C(5918,34899,A(4360,5918,4416628))",
					cx17: "=C(6752,16478,A(6752,9215,8257449),true)",
					cy17: "=C(9215,39090,A(6752,9215,8257449))",
					cx18: "=C(6752,28827,A(6752,9215,387196),true)",
					cy18: "=C(9215,34751,A(6752,9215,387196))",
					cx19: "=C(5785,34129,A(5785,7867,-4217541),true)",
					cy19: "=C(7867,22954,A(5785,7867,-4217541))",
					cx20: "=C(5333,41798,A(5333,7273,1819082),true)",
					cy20: "=C(7273,15354,A(5333,7273,1819082))",
					cx21: "=C(4857,38324,A(4857,6595,-824660),true)",
					cy21: "=C(6595,5426,A(4857,6595,-824660))",
					cx22: "=C(4857,29078,A(4857,6595,-8950887),true)",
					cy22: "=C(6595,3952,A(4857,6595,-8950887))",
					cx23: "=C(4365,22141,A(4365,5945,-9809656),true)",
					cy23: "=C(5945,4720,A(4365,5945,-9809656))",
					cx24: "=C(6753,14000,A(6753,9190,-4002417),true)",
					cy24: "=C(9190,5192,A(6753,9190,-4002417))",
					cx25: "=C(6753,4127,A(6753,9190,9459261),true)",
					cy25: "=C(9190,15789,A(6753,9190,9459261))"
				},
				adjustInfo: [["adj1", -20833], ["adj2", 62500]],
				connectionPoints: [{
						x: "=V.g27",
						y: b
					}, {
						x: a,
						y: "=V.g28"
					}, {
						x: "=V.g29",
						y: b
					}, {
						x: a,
						y: "=V.g30"
					}, {
						x: "=V.xPos",
						y: "=V.yPos"
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj1",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj2",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "xPos",
							y: "yPos"
						},
						point: ["=V.xPos", "=V.yPos"]
					}
				],
				path: [[["M", "=3900 * V._scaleX1", "=14370 * V._scaleY1"], ["E", "=V.cx1 * V._scaleX1", "=V.cy1 * V._scaleY1", "=6753 * V._scaleX1", "=9190 * V._scaleY1", 0, "=A(6753,9190,-11429249)", "=A(6753,9190,(-11429249 + 7426832))", "=IF(7426832 > 0, FALSE, TRUE)"], ["E", "=V.cx2 * V._scaleX1", "=V.cy2 * V._scaleY1", "=5333 * V._scaleX1", "=7267 * V._scaleY1", 0, "=A(5333,7267,-8646143)", "=A(5333,7267,(-8646143 + 5396714))", "=IF(5396714 > 0, FALSE, TRUE)"], ["E", "=V.cx3 * V._scaleX1", "=V.cy3 * V._scaleY1", "=4365 * V._scaleX1", "=5945 * V._scaleY1", 0, "=A(4365,5945,-8748475)", "=A(4365,5945,(-8748475 + 5983381))", "=IF(5983381 > 0, FALSE, TRUE)"], ["E", "=V.cx4 * V._scaleX1", "=V.cy4 * V._scaleY1", "=4857 * V._scaleX1", "=6595 * V._scaleY1", 0, "=A(4857,6595,-7859164)", "=A(4857,6595,(-7859164 + 7034504))", "=IF(7034504 > 0, FALSE, TRUE)"], ["E", "=V.cx5 * V._scaleX1", "=V.cy5 * V._scaleY1", "=5333 * V._scaleX1", "=7273 * V._scaleY1", 0, "=A(5333,7273,-4722533)", "=A(5333,7273,(-4722533 + 6541615))", "=IF(6541615 > 0, FALSE, TRUE)"], ["E", "=V.cx6 * V._scaleX1", "=V.cy6 * V._scaleY1", "=6775 * V._scaleX1", "=9220 * V._scaleY1", 0, "=A(6775,9220,-2776035)", "=A(6775,9220,(-2776035 + 7816140))", "=IF(7816140 > 0, FALSE, TRUE)"], ["E", "=V.cx7 * V._scaleX1", "=V.cy7 * V._scaleY1", "=5785 * V._scaleX1", "=7867 * V._scaleY1", 0, "=A(5785,7867,37501)", "=A(5785,7867,(37501 + 6842000))", "=IF(6842000 > 0, FALSE, TRUE)"], ["E", "=V.cx8 * V._scaleX1", "=V.cy8 * V._scaleY1", "=6752 * V._scaleX1", "=9215 * V._scaleY1", 0, "=A(6752,9215,1347096)", "=A(6752,9215,(1347096 + 6910353))", "=IF(6910353 > 0, FALSE, TRUE)"], ["E", "=V.cx9 * V._scaleX1", "=V.cy9 * V._scaleY1", "=7720 * V._scaleX1", "=10543 * V._scaleY1", 0, "=A(7720,10543,3974558)", "=A(7720,10543,(3974558 + 4542661))", "=IF(4542661 > 0, FALSE, TRUE)"], ["E", "=V.cx10 * V._scaleX1", "=V.cy10 * V._scaleY1", "=4360 * V._scaleX1", "=5918 * V._scaleY1", 0, "=A(4360,5918,-16496525)", "=A(4360,5918,(-16496525 + 8804134))", "=IF(8804134 > 0, FALSE, TRUE)"], ["E", "=V.cx11 * V._scaleX1", "=V.cy11 * V._scaleY1", "=4345 * V._scaleX1", "=5945 * V._scaleY1", 0, "=A(4345,5945,-14809710)", "=A(4345,5945,(-14809710 + 9151131))", "=IF(9151131 > 0, FALSE, TRUE)"], ["Z"], {}
					], [["M", "=V.x23", "=V.yPos"], ["E", "=V.cx12", "=V.cy12", "=V.g26", "=V.g26", 0, "=A(V.g26,V.g26,0)", "=(A(V.g26,V.g26,0)+ 2*PI())", "=IF(21600000 > 0, FALSE, TRUE)"], ["Z"], {}
					], [["M", "=V.x24", "=V.g17"], ["E", "=V.cx13", "=V.cy13", "=V.g25", "=V.g25", 0, "=A(V.g25,V.g25,0)", "=(A(V.g25,V.g25,0)+ 2*PI())", "=IF(21600000 > 0, FALSE, TRUE)"], ["Z"], {}
					], [["M", "=V.x25", "=V.g24"], ["E", "=V.cx14", "=V.cy14", "=V.g12", "=V.g12", 0, "=A(V.g12,V.g12,0)", "=(A(V.g12,V.g12,0)+ 2*PI())", "=IF(21600000 > 0, FALSE, TRUE)"], ["Z"], {}
					], [["M", "=4693 * V._scaleX2", "=26177 * V._scaleY2"], ["E", "=V.cx15 * V._scaleX2", "=V.cy15 * V._scaleY2", "=4345 * V._scaleX2", "=5945 * V._scaleY2", 0, "=A(4345,5945,5204520)", "=A(4345,5945,(5204520 + 1585770))", "=IF(1585770 > 0, FALSE, TRUE)"], ["M", "=6928 * V._scaleX2", "=34899 * V._scaleY2"], ["E", "=V.cx16 * V._scaleX2", "=V.cy16 * V._scaleY2", "=4360 * V._scaleX2", "=5918 * V._scaleY2", 0, "=A(4360,5918,4416628)", "=A(4360,5918,(4416628 + 686848))", "=IF(686848 > 0, FALSE, TRUE)"], ["M", "=16478 * V._scaleX2", "=39090 * V._scaleY2"], ["E", "=V.cx17 * V._scaleX2", "=V.cy17 * V._scaleY2", "=6752 * V._scaleX2", "=9215 * V._scaleY2", 0, "=A(6752,9215,8257449)", "=A(6752,9215,(8257449 + 844866))", "=IF(844866 > 0, FALSE, TRUE)"], ["M", "=28827 * V._scaleX2", "=34751 * V._scaleY2"], ["E", "=V.cx18 * V._scaleX2", "=V.cy18 * V._scaleY2", "=6752 * V._scaleX2", "=9215 * V._scaleY2", 0, "=A(6752,9215,387196)", "=A(6752,9215,(387196 + 959901))", "=IF(959901 > 0, FALSE, TRUE)"], ["M", "=34129 * V._scaleX2", "=22954 * V._scaleY2"], ["E", "=V.cx19 * V._scaleX2", "=V.cy19 * V._scaleY2", "=5785 * V._scaleX2", "=7867 * V._scaleY2", 0, "=A(5785,7867,-4217541)", "=A(5785,7867,(-4217541 + 4255042))", "=IF(4255042 > 0, FALSE, TRUE)"], ["M", "=41798 * V._scaleX2", "=15354 * V._scaleY2"], ["E", "=V.cx20 * V._scaleX2", "=V.cy20 * V._scaleY2", "=5333 * V._scaleX2", "=7273 * V._scaleY2", 0, "=A(5333,7273,1819082)", "=A(5333,7273,(1819082 + 1665090))", "=IF(1665090 > 0, FALSE, TRUE)"], ["M", "=38324 * V._scaleX2", "=5426 * V._scaleY2"], ["E", "=V.cx21 * V._scaleX2", "=V.cy21 * V._scaleY2", "=4857 * V._scaleX2", "=6595 * V._scaleY2", 0, "=A(4857,6595,-824660)", "=A(4857,6595,(-824660 + 891534))", "=IF(891534 > 0, FALSE, TRUE)"], ["M", "=29078 * V._scaleX2", "=3952 * V._scaleY2"], ["E", "=V.cx22 * V._scaleX2", "=V.cy22 * V._scaleY2", "=4857 * V._scaleX2", "=6595 * V._scaleY2", 0, "=A(4857,6595,-8950887)", "=A(4857,6595,(-8950887 + 1091722))", "=IF(1091722 > 0, FALSE, TRUE)"], ["M", "=22141 * V._scaleX2", "=4720 * V._scaleY2"], ["E", "=V.cx23 * V._scaleX2", "=V.cy23 * V._scaleY2", "=4365 * V._scaleX2", "=5945 * V._scaleY2", 0, "=A(4365,5945,-9809656)", "=A(4365,5945,(-9809656 + 1061181))", "=IF(1061181 > 0, FALSE, TRUE)"], ["M", "=14000 * V._scaleX2", "=5192 * V._scaleY2"], ["E", "=V.cx24 * V._scaleX2", "=V.cy24 * V._scaleY2", "=6753 * V._scaleX2", "=9190 * V._scaleY2", 0, "=A(6753,9190,-4002417)", "=A(6753,9190,(-4002417 + 739161))", "=IF(739161 > 0, FALSE, TRUE)"], ["M", "=4127 * V._scaleX2", "=15789 * V._scaleY2"], ["E", "=V.cx25 * V._scaleX2", "=V.cy25 * V._scaleY2", "=6753 * V._scaleX2", "=9190 * V._scaleY2", 0, "=A(6753,9190,9459261)", "=A(6753,9190,(9459261 + 711490))", "=IF(711490 > 0, FALSE, TRUE)"], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			lineCallout1: {
				variables: {
					adj1: 18750,
					adj2: -8333,
					adj3: 112500,
					adj4: -38333,
					y1: "=height * V.adj1 / 100000",
					x1: "=width * V.adj2 / 100000",
					y2: "=height * V.adj3 / 100000",
					x2: "=width * V.adj4 / 100000",
					r: w,
					vc: F,
					hc: E,
					b: h,
					l: 0,
					t: 0
				},
				adjustInfo: [["adj1", 18750], ["adj2", -8333], ["adj3", 112500], ["adj4", -38333]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj2",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj1",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x1",
							y: "y1"
						},
						point: [c, e]
					}, {
						type: "ahXY",
						gdRefX: "adj4",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj3",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x2",
							y: "y2"
						},
						point: [d, f]
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {}
					], [["M", c, e], ["L", d, f], {
							fillMode: "none"
						}
					]]
			},
			lineCallout2: {
				variables: {
					adj1: 18750,
					adj2: -8333,
					adj3: 112500,
					adj4: -38333,
					y1: "=height * V.adj1 / 100000",
					x1: "=width * V.adj2 / 100000",
					y2: "=height * V.adj3 / 100000",
					x2: "=width * V.adj4 / 100000",
					r: w,
					vc: F,
					hc: E,
					b: h,
					l: 0,
					t: 0
				},
				adjustInfo: [["adj1", 18750], ["adj2", -8333], ["adj3", 112500], ["adj4", -38333]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj2",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj1",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x1",
							y: "y1"
						},
						point: [c, e]
					}, {
						type: "ahXY",
						gdRefX: "adj4",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj3",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x2",
							y: "y2"
						},
						point: [d, f]
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {}
					], [["M", c, e], ["L", d, f], {
							fillMode: "none"
						}
					]]
			},
			lineCallout3: {
				variables: {
					adj1: 18750,
					adj2: -8333,
					adj3: 18750,
					adj4: -16667,
					adj5: 112500,
					adj6: -46667,
					y1: "=height * V.adj1 / 100000",
					x1: "=width * V.adj2 / 100000",
					y2: "=height * V.adj3 / 100000",
					x2: "=width * V.adj4 / 100000",
					y3: "=height * V.adj5 / 100000",
					x3: "=width * V.adj6 / 100000",
					r: w,
					vc: F,
					hc: E,
					b: h,
					l: 0,
					t: 0
				},
				adjustInfo: [["adj1", 18750], ["adj2", -8333], ["adj3", 18750], ["adj4", -16667], ["adj5", 112500], ["adj6", -46667]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj2",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj1",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x1",
							y: "y1"
						},
						point: [c, e]
					}, {
						type: "ahXY",
						gdRefX: "adj4",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj3",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x2",
							y: "y2"
						},
						point: [d, f]
					}, {
						type: "ahXY",
						gdRefX: "adj6",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj5",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x3",
							y: "y3"
						},
						point: ["=V.x3", "=V.y3"]
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {}
					], [["M", c, e], ["L", d, f], ["L", "=V.x3", "=V.y3"], {
							fillMode: "none"
						}
					]]
			},
			lineCallout4: {
				variables: {
					adj1: 18750,
					adj2: -8333,
					adj3: 18750,
					adj4: -16667,
					adj5: 100000,
					adj6: -16667,
					adj7: 112963,
					adj8: -8333,
					y1: "=height * V.adj1 / 100000",
					x1: "=width * V.adj2 / 100000",
					y2: "=height * V.adj3 / 100000",
					x2: "=width * V.adj4 / 100000",
					y3: "=height * V.adj5 / 100000",
					x3: "=width * V.adj6 / 100000",
					y4: "=height * V.adj7 / 100000",
					x4: "=width * V.adj8 / 100000",
					r: w,
					vc: F,
					hc: E,
					b: h,
					l: 0,
					t: 0
				},
				adjustInfo: [["adj1", 18750], ["adj2", -8333], ["adj3", 18750], ["adj4", -16667], ["adj5", 100000], ["adj6", -16667], ["adj7", 112963], ["adj8", -8333]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj2",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj1",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x1",
							y: "y1"
						},
						point: [c, e]
					}, {
						type: "ahXY",
						gdRefX: "adj4",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj3",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x2",
							y: "y2"
						},
						point: [d, f]
					}, {
						type: "ahXY",
						gdRefX: "adj6",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj5",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x3",
							y: "y3"
						},
						point: ["=V.x3", "=V.y3"]
					}, {
						type: "ahXY",
						gdRefX: "adj8",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj7",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x4",
							y: "y4"
						},
						point: ["=V.x4", "=V.y4"]
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {}
					], [["M", c, e], ["L", d, f], ["L", "=V.x3", "=V.y3"], ["L", "=V.x4", "=V.y4"], {
							fillMode: "none"
						}
					]]
			},
			lineCallout1AccentBar: {
				variables: {
					adj1: 18750,
					adj2: -8333,
					adj3: 112500,
					adj4: -38333,
					y1: "=height * V.adj1 / 100000",
					x1: "=width * V.adj2 / 100000",
					y2: "=height * V.adj3 / 100000",
					x2: "=width * V.adj4 / 100000",
					r: w,
					vc: F,
					hc: E,
					b: h,
					l: 0,
					t: 0
				},
				adjustInfo: [["adj1", 18750], ["adj2", -8333], ["adj3", 112500], ["adj4", -38333]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj2",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj1",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x1",
							y: "y1"
						},
						point: [c, e]
					}, {
						type: "ahXY",
						gdRefX: "adj4",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj3",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x2",
							y: "y2"
						},
						point: [d, f]
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {
							strokeMode: "false"
						}
					], [["M", c, e], ["L", d, f], {
							fillMode: "none"
						}
					]]
			},
			lineCallout2AccentBar: {
				variables: {
					adj1: 18750,
					adj2: -8333,
					adj3: 112500,
					adj4: -38333,
					y1: "=height * V.adj1 / 100000",
					x1: "=width * V.adj2 / 100000",
					y2: "=height * V.adj3 / 100000",
					x2: "=width * V.adj4 / 100000",
					r: w,
					vc: F,
					hc: E,
					b: h,
					l: 0,
					t: 0
				},
				adjustInfo: [["adj1", 18750], ["adj2", -8333], ["adj3", 112500], ["adj4", -38333]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj2",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj1",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x1",
							y: "y1"
						},
						point: [c, e]
					}, {
						type: "ahXY",
						gdRefX: "adj4",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj3",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x2",
							y: "y2"
						},
						point: [d, f]
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {
							strokeMode: "false"
						}
					], [["M", c, 0], ["Z"], ["L", c, h], {
							fillMode: "none"
						}
					], [["M", c, e], ["L", d, f], {
							fillMode: "none"
						}
					]]
			},
			lineCallout3AccentBar: {
				variables: {
					adj1: 18750,
					adj2: -8333,
					adj3: 18750,
					adj4: -16667,
					adj5: 112500,
					adj6: -46667,
					y1: "=height * V.adj1 / 100000",
					x1: "=width * V.adj2 / 100000",
					y2: "=height * V.adj3 / 100000",
					x2: "=width * V.adj4 / 100000",
					y3: "=height * V.adj5 / 100000",
					x3: "=width * V.adj6 / 100000",
					r: w,
					vc: F,
					hc: E,
					b: h,
					l: 0,
					t: 0
				},
				adjustInfo: [["adj1", 18750], ["adj2", -8333], ["adj3", 18750], ["adj4", -16667], ["adj5", 112500], ["adj6", -46667]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj2",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj1",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x1",
							y: "y1"
						},
						point: [c, e]
					}, {
						type: "ahXY",
						gdRefX: "adj4",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj3",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x2",
							y: "y2"
						},
						point: [d, f]
					}, {
						type: "ahXY",
						gdRefX: "adj6",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj5",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x3",
							y: "y3"
						},
						point: ["=V.x3", "=V.y3"]
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {
							strokeMode: "false"
						}
					], [["M", c, 0], ["Z"], ["L", c, h], {
							fillMode: "none"
						}
					], [["M", c, e], ["L", d, f], ["L", "=V.x3", "=V.y3"], {
							fillMode: "none"
						}
					]]
			},
			lineCallout4AccentBar: {
				variables: {
					adj1: 18750,
					adj2: -8333,
					adj3: 18750,
					adj4: -16667,
					adj5: 100000,
					adj6: -16667,
					adj7: 112963,
					adj8: -8333,
					y1: "=height * V.adj1 / 100000",
					x1: "=width * V.adj2 / 100000",
					y2: "=height * V.adj3 / 100000",
					x2: "=width * V.adj4 / 100000",
					y3: "=height * V.adj5 / 100000",
					x3: "=width * V.adj6 / 100000",
					y4: "=height * V.adj7 / 100000",
					x4: "=width * V.adj8 / 100000",
					r: w,
					vc: F,
					hc: E,
					b: h,
					l: 0,
					t: 0
				},
				adjustInfo: [["adj1", 18750], ["adj2", -8333], ["adj3", 18750], ["adj4", -16667], ["adj5", 100000], ["adj6", -16667], ["adj7", 112963], ["adj8", -8333]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj2",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj1",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x1",
							y: "y1"
						},
						point: [c, e]
					}, {
						type: "ahXY",
						gdRefX: "adj4",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj3",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x2",
							y: "y2"
						},
						point: [d, f]
					}, {
						type: "ahXY",
						gdRefX: "adj6",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj5",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x3",
							y: "y3"
						},
						point: ["=V.x3", "=V.y3"]
					}, {
						type: "ahXY",
						gdRefX: "adj8",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj7",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x4",
							y: "y4"
						},
						point: ["=V.x4", "=V.y4"]
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {
							strokeMode: "false"
						}
					], [["M", c, 0], ["Z"], ["L", c, h], {
							fillMode: "none"
						}
					], [["M", c, e], ["L", d, f], ["L", "=V.x3", "=V.y3"], ["L", "=V.x4", "=V.y4"], {
							fillMode: "none"
						}
					]]
			},
			lineCallout1NoBorder: {
				variables: {
					adj1: 18750,
					adj2: -8333,
					adj3: 112500,
					adj4: -38333,
					y1: "=height * V.adj1 / 100000",
					x1: "=width * V.adj2 / 100000",
					y2: "=height * V.adj3 / 100000",
					x2: "=width * V.adj4 / 100000",
					r: w,
					vc: F,
					hc: E,
					b: h,
					l: 0,
					t: 0
				},
				adjustInfo: [["adj1", 18750], ["adj2", -8333], ["adj3", 112500], ["adj4", -38333]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj2",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj1",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x1",
							y: "y1"
						},
						point: [c, e]
					}, {
						type: "ahXY",
						gdRefX: "adj4",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj3",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x2",
							y: "y2"
						},
						point: [d, f]
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {
							strokeMode: "false"
						}
					], [["M", c, e], ["L", d, f], {
							fillMode: "none"
						}
					]]
			},
			lineCallout2NoBorder: {
				variables: {
					adj1: 18750,
					adj2: -8333,
					adj3: 112500,
					adj4: -38333,
					y1: "=height * V.adj1 / 100000",
					x1: "=width * V.adj2 / 100000",
					y2: "=height * V.adj3 / 100000",
					x2: "=width * V.adj4 / 100000",
					r: w,
					vc: F,
					hc: E,
					b: h,
					l: 0,
					t: 0
				},
				adjustInfo: [["adj1", 18750], ["adj2", -8333], ["adj3", 112500], ["adj4", -38333]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj2",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj1",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x1",
							y: "y1"
						},
						point: [c, e]
					}, {
						type: "ahXY",
						gdRefX: "adj4",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj3",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x2",
							y: "y2"
						},
						point: [d, f]
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {
							strokeMode: "false"
						}
					], [["M", c, e], ["L", d, f], {
							fillMode: "none"
						}
					]]
			},
			lineCallout3NoBorder: {
				variables: {
					adj1: 18750,
					adj2: -8333,
					adj3: 18750,
					adj4: -16667,
					adj5: 112500,
					adj6: -46667,
					y1: "=height * V.adj1 / 100000",
					x1: "=width * V.adj2 / 100000",
					y2: "=height * V.adj3 / 100000",
					x2: "=width * V.adj4 / 100000",
					y3: "=height * V.adj5 / 100000",
					x3: "=width * V.adj6 / 100000",
					r: w,
					vc: F,
					hc: E,
					b: h,
					l: 0,
					t: 0
				},
				adjustInfo: [["adj1", 18750], ["adj2", -8333], ["adj3", 18750], ["adj4", -16667], ["adj5", 112500], ["adj6", -46667]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj2",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj1",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x1",
							y: "y1"
						},
						point: [c, e]
					}, {
						type: "ahXY",
						gdRefX: "adj4",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj3",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x2",
							y: "y2"
						},
						point: [d, f]
					}, {
						type: "ahXY",
						gdRefX: "adj6",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj5",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x3",
							y: "y3"
						},
						point: ["=V.x3", "=V.y3"]
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {
							strokeMode: "false"
						}
					], [["M", c, e], ["L", d, f], ["L", "=V.x3", "=V.y3"], {
							fillMode: "none"
						}
					]]
			},
			lineCallout4NoBorder: {
				variables: {
					adj1: 18750,
					adj2: -8333,
					adj3: 18750,
					adj4: -16667,
					adj5: 100000,
					adj6: -16667,
					adj7: 112963,
					adj8: -8333,
					y1: "=height * V.adj1 / 100000",
					x1: "=width * V.adj2 / 100000",
					y2: "=height * V.adj3 / 100000",
					x2: "=width * V.adj4 / 100000",
					y3: "=height * V.adj5 / 100000",
					x3: "=width * V.adj6 / 100000",
					y4: "=height * V.adj7 / 100000",
					x4: "=width * V.adj8 / 100000",
					r: w,
					vc: F,
					hc: E,
					b: h,
					l: 0,
					t: 0
				},
				adjustInfo: [["adj1", 18750], ["adj2", -8333], ["adj3", 18750], ["adj4", -16667], ["adj5", 100000], ["adj6", -16667], ["adj7", 112963], ["adj8", -8333]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj2",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj1",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x1",
							y: "y1"
						},
						point: [c, e]
					}, {
						type: "ahXY",
						gdRefX: "adj4",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj3",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x2",
							y: "y2"
						},
						point: [d, f]
					}, {
						type: "ahXY",
						gdRefX: "adj6",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj5",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x3",
							y: "y3"
						},
						point: ["=V.x3", "=V.y3"]
					}, {
						type: "ahXY",
						gdRefX: "adj8",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj7",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x4",
							y: "y4"
						},
						point: ["=V.x4", "=V.y4"]
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {
							strokeMode: "false"
						}
					], [["M", c, e], ["L", d, f], ["L", "=V.x3", "=V.y3"], ["L", "=V.x4", "=V.y4"], {
							fillMode: "none"
						}
					]]
			},
			lineCallout1BorderandAccentBar: {
				variables: {
					adj1: 18750,
					adj2: -8333,
					adj3: 112500,
					adj4: -38333,
					y1: "=height * V.adj1 / 100000",
					x1: "=width * V.adj2 / 100000",
					y2: "=height * V.adj3 / 100000",
					x2: "=width * V.adj4 / 100000",
					r: w,
					vc: F,
					hc: E,
					b: h,
					l: 0,
					t: 0
				},
				adjustInfo: [["adj1", 18750], ["adj2", -8333], ["adj3", 112500], ["adj4", -38333]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj2",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj1",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x1",
							y: "y1"
						},
						point: [c, e]
					}, {
						type: "ahXY",
						gdRefX: "adj4",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj3",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x2",
							y: "y2"
						},
						point: [d, f]
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {}
					], [["M", c, e], ["L", d, f], {
							fillMode: "none"
						}
					]]
			},
			lineCallout2BorderandAccentBar: {
				variables: {
					adj1: 18750,
					adj2: -8333,
					adj3: 112500,
					adj4: -38333,
					y1: "=height * V.adj1 / 100000",
					x1: "=width * V.adj2 / 100000",
					y2: "=height * V.adj3 / 100000",
					x2: "=width * V.adj4 / 100000",
					r: w,
					vc: F,
					hc: E,
					b: h,
					l: 0,
					t: 0
				},
				adjustInfo: [["adj1", 18750], ["adj2", -8333], ["adj3", 112500], ["adj4", -38333]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj2",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj1",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x1",
							y: "y1"
						},
						point: [c, e]
					}, {
						type: "ahXY",
						gdRefX: "adj4",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj3",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x2",
							y: "y2"
						},
						point: [d, f]
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {}
					], [["M", c, 0], ["Z"], ["L", c, h], {
							fillMode: "none"
						}
					], [["M", c, e], ["L", d, f], {
							fillMode: "none"
						}
					]]
			},
			lineCallout3BorderandAccentBar: {
				variables: {
					adj1: 18750,
					adj2: -8333,
					adj3: 18750,
					adj4: -16667,
					adj5: 112500,
					adj6: -46667,
					y1: "=height * V.adj1 / 100000",
					x1: "=width * V.adj2 / 100000",
					y2: "=height * V.adj3 / 100000",
					x2: "=width * V.adj4 / 100000",
					y3: "=height * V.adj5 / 100000",
					x3: "=width * V.adj6 / 100000",
					r: w,
					vc: F,
					hc: E,
					b: h,
					l: 0,
					t: 0
				},
				adjustInfo: [["adj1", 18750], ["adj2", -8333], ["adj3", 18750], ["adj4", -16667], ["adj5", 112500], ["adj6", -46667]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj2",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj1",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x1",
							y: "y1"
						},
						point: [c, e]
					}, {
						type: "ahXY",
						gdRefX: "adj4",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj3",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x2",
							y: "y2"
						},
						point: [d, f]
					}, {
						type: "ahXY",
						gdRefX: "adj6",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj5",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x3",
							y: "y3"
						},
						point: ["=V.x3", "=V.y3"]
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {}
					], [["M", c, 0], ["Z"], ["L", c, h], {
							fillMode: "none"
						}
					], [["M", c, e], ["L", d, f], ["L", "=V.x3", "=V.y3"], {
							fillMode: "none"
						}
					]]
			},
			lineCallout4BorderandAccentBar: {
				variables: {
					adj1: 18750,
					adj2: -8333,
					adj3: 18750,
					adj4: -16667,
					adj5: 100000,
					adj6: -16667,
					adj7: 112963,
					adj8: -8333,
					y1: "=height * V.adj1 / 100000",
					x1: "=width * V.adj2 / 100000",
					y2: "=height * V.adj3 / 100000",
					x2: "=width * V.adj4 / 100000",
					y3: "=height * V.adj5 / 100000",
					x3: "=width * V.adj6 / 100000",
					y4: "=height * V.adj7 / 100000",
					x4: "=width * V.adj8 / 100000",
					r: w,
					vc: F,
					hc: E,
					b: h,
					l: 0,
					t: 0
				},
				adjustInfo: [["adj1", 18750], ["adj2", -8333], ["adj3", 18750], ["adj4", -16667], ["adj5", 100000], ["adj6", -16667], ["adj7", 112963], ["adj8", -8333]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj2",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj1",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x1",
							y: "y1"
						},
						point: [c, e]
					}, {
						type: "ahXY",
						gdRefX: "adj4",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj3",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x2",
							y: "y2"
						},
						point: [d, f]
					}, {
						type: "ahXY",
						gdRefX: "adj6",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj5",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x3",
							y: "y3"
						},
						point: ["=V.x3", "=V.y3"]
					}, {
						type: "ahXY",
						gdRefX: "adj8",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj7",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "x4",
							y: "y4"
						},
						point: ["=V.x4", "=V.y4"]
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {}
					], [["M", c, 0], ["Z"], ["L", c, h], {
							fillMode: "none"
						}
					], [["M", c, e], ["L", d, f], ["L", "=V.x3", "=V.y3"], ["L", "=V.x4", "=V.y4"], {
							fillMode: "none"
						}
					]]
			},
			actionButtonCustom: {
				variables: {
					r: w,
					vc: F,
					hc: E,
					b: h,
					l: 0,
					t: 0
				},
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {}
					]]
			},
			actionButtonHome: {
				variables: {
					ss: s,
					dx2: "=V.ss * 3 / 8",
					vc: F,
					g9: "=V.vc - V.dx2",
					g10: "=V.vc + V.dx2",
					hc: E,
					g11: "=V.hc - V.dx2",
					g12: "=V.hc + V.dx2",
					g13: "=V.ss * 3 / 4",
					g14: "=V.g13 / 16",
					g15: "=V.g13 / 8",
					g16: "=V.g13 * 3 / 16",
					g17: "=V.g13 * 5 / 16",
					g18: "=V.g13 * 7 / 16",
					g19: "=V.g13 * 9 / 16",
					g20: "=V.g13 * 11 / 16",
					g21: "=V.g13 * 3 / 4",
					g22: "=V.g13 * 13 / 16",
					g23: "=V.g13 * 7 / 8",
					g24: "=V.g9 + V.g14",
					g25: "=V.g9 + V.g16",
					g26: "=V.g9 + V.g17",
					g27: "=V.g9 + V.g21",
					g28: "=V.g11 + V.g15",
					g29: "=V.g11 + V.g18",
					g30: "=V.g11 + V.g19",
					g31: "=V.g11 + V.g20",
					g32: "=V.g11 + V.g22",
					g33: "=V.g11 + V.g23",
					r: w,
					b: h,
					l: 0,
					t: 0
				},
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], ["M", a, "=V.g9"], ["L", "=V.g11", b], ["L", "=V.g28", b], ["L", "=V.g28", "=V.g10"], ["L", "=V.g33", "=V.g10"], ["L", "=V.g33", b], ["L", "=V.g12", b], ["L", "=V.g32", "=V.g26"], ["L", "=V.g32", "=V.g24"], ["L", "=V.g31", "=V.g24"], ["L", "=V.g31", "=V.g25"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", "=V.g32", "=V.g26"], ["L", "=V.g32", "=V.g24"], ["L", "=V.g31", "=V.g24"], ["L", "=V.g31", "=V.g25"], ["Z"], ["M", "=V.g28", b], ["L", "=V.g28", "=V.g10"], ["L", "=V.g29", "=V.g10"], ["L", "=V.g29", "=V.g27"], ["L", "=V.g30", "=V.g27"], ["L", "=V.g30", "=V.g10"], ["L", "=V.g33", "=V.g10"], ["L", "=V.g33", b], ["Z"], {
							fillMode: "darkenLess",
							strokeMode: "false"
						}
					], [["M", a, "=V.g9"], ["L", "=V.g11", b], ["L", "=V.g12", b], ["Z"], ["M", "=V.g29", "=V.g27"], ["L", "=V.g30", "=V.g27"], ["L", "=V.g30", "=V.g10"], ["L", "=V.g29", "=V.g10"], ["Z"], {
							fillMode: "darken",
							strokeMode: "false"
						}
					], [["M", a, "=V.g9"], ["L", "=V.g31", "=V.g25"], ["L", "=V.g31", "=V.g24"], ["L", "=V.g32", "=V.g24"], ["L", "=V.g32", "=V.g26"], ["L", "=V.g12", b], ["L", "=V.g33", b], ["L", "=V.g33", "=V.g10"], ["L", "=V.g28", "=V.g10"], ["L", "=V.g28", b], ["L", "=V.g11", b], ["Z"], ["M", "=V.g31", "=V.g25"], ["L", "=V.g32", "=V.g26"], ["M", "=V.g33", b], ["L", "=V.g28", b], ["M", "=V.g29", "=V.g10"], ["L", "=V.g29", "=V.g27"], ["L", "=V.g30", "=V.g27"], ["L", "=V.g30", "=V.g10"], {
							fillMode: "none"
						}
					], [["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {
							fillMode: "none"
						}
					]]
			},
			actionButtonHelp: {
				variables: {
					ss: s,
					dx2: "=V.ss * 3 / 8",
					vc: F,
					g9: "=V.vc - V.dx2",
					hc: E,
					g11: "=V.hc - V.dx2",
					g13: "=V.ss * 3 / 4",
					g14: "=V.g13 / 7",
					g15: "=V.g13 * 3 / 14",
					g16: "=V.g13 * 2 / 7",
					g19: "=V.g13 * 3 / 7",
					g20: "=V.g13 * 4 / 7",
					g21: "=V.g13 * 17 / 28",
					g23: "=V.g13 * 21 / 28",
					g24: "=V.g13 * 11 / 14",
					g27: "=V.g9 + V.g16",
					g29: "=V.g9 + V.g21",
					g30: "=V.g9 + V.g23",
					g31: "=V.g9 + V.g24",
					g33: "=V.g11 + V.g15",
					g36: "=V.g11 + V.g19",
					g37: "=V.g11 + V.g20",
					g41: "=V.g13 / 14",
					g42: "=V.g13 * 3 / 28",
					r: w,
					b: h,
					l: 0,
					t: 0,
					cd2: B,
					cx1: "=C(V.g16,V.g33,A(V.g16,V.g16,V.cd2),true)",
					cy1: "=C(V.g16,V.g27,A(V.g16,V.g16,V.cd2))",
					cd4: C,
					cx2: "=C(V.g14,P(V.cx1,V.g16,A(V.g16,V.g16,(V.cd2 + V.cd2)),true),A(V.g14,V.g15,0),true)",
					cy2: "=C(V.g15,P(V.cy1,V.g16,A(V.g16,V.g16,(V.cd2 + V.cd2))),A(V.g14,V.g15,0))",
					_3cd4: D,
					cx3: "=C(V.g41,P(V.cx2,V.g14,A(V.g14,V.g15,(V.cd4)),true),A(V.g41,V.g42,V._3cd4),true)",
					cy3: "=C(V.g42,P(V.cy2,V.g15,A(V.g14,V.g15,(V.cd4))),A(V.g41,V.g42,V._3cd4))",
					cx4: "=C(V.g14,V.g36,A(V.g14,V.g15,V.cd2),true)",
					cy4: "=C(V.g15,V.g29,A(V.g14,V.g15,V.cd2))",
					cx5: "=C(V.g41,P(V.cx4,V.g14,A(V.g14,V.g15,(V.cd2 + V.cd4)),true),A(V.g41,V.g42,V.cd4),true)",
					cy5: "=C(V.g42,P(V.cy4,V.g15,A(V.g14,V.g15,(V.cd2 + V.cd4))),A(V.g41,V.g42,V.cd4))",
					cx6: "=C(V.g14,P(V.cx5,V.g41,A(V.g41,V.g42,(V.cd4 + -5400000)),true),A(V.g14,V.g14,0),true)",
					cy6: "=C(V.g14,P(V.cy5,V.g42,A(V.g41,V.g42,(V.cd4 + -5400000))),A(V.g14,V.g14,0))",
					cx7: "=C(V.g42,V.hc,A(V.g42,V.g42,V._3cd4),true)",
					cy7: "=C(V.g42,V.g31,A(V.g42,V.g42,V._3cd4))",
					cx8: "=C(V.g16,V.g33,A(V.g16,V.g16,V.cd2),true)",
					cy8: "=C(V.g16,V.g27,A(V.g16,V.g16,V.cd2))",
					cx9: "=C(V.g14,P(V.cx8,V.g16,A(V.g16,V.g16,(V.cd2 + V.cd2)),true),A(V.g14,V.g15,0),true)",
					cy9: "=C(V.g15,P(V.cy8,V.g16,A(V.g16,V.g16,(V.cd2 + V.cd2))),A(V.g14,V.g15,0))",
					cx10: "=C(V.g41,P(V.cx9,V.g14,A(V.g14,V.g15,(V.cd4)),true),A(V.g41,V.g42,V._3cd4),true)",
					cy10: "=C(V.g42,P(V.cy9,V.g15,A(V.g14,V.g15,(V.cd4))),A(V.g41,V.g42,V._3cd4))",
					cx11: "=C(V.g14,V.g36,A(V.g14,V.g15,V.cd2),true)",
					cy11: "=C(V.g15,V.g29,A(V.g14,V.g15,V.cd2))",
					cx12: "=C(V.g41,P(V.cx11,V.g14,A(V.g14,V.g15,(V.cd2 + V.cd4)),true),A(V.g41,V.g42,V.cd4),true)",
					cy12: "=C(V.g42,P(V.cy11,V.g15,A(V.g14,V.g15,(V.cd2 + V.cd4))),A(V.g41,V.g42,V.cd4))",
					cx13: "=C(V.g14,P(V.cx12,V.g41,A(V.g41,V.g42,(V.cd4 + -5400000)),true),A(V.g14,V.g14,0),true)",
					cy13: "=C(V.g14,P(V.cy12,V.g42,A(V.g41,V.g42,(V.cd4 + -5400000))),A(V.g14,V.g14,0))",
					cx14: "=C(V.g42,V.hc,A(V.g42,V.g42,V._3cd4),true)",
					cy14: "=C(V.g42,V.g31,A(V.g42,V.g42,V._3cd4))",
					cx15: "=C(V.g16,V.g33,A(V.g16,V.g16,V.cd2),true)",
					cy15: "=C(V.g16,V.g27,A(V.g16,V.g16,V.cd2))",
					cx16: "=C(V.g14,P(V.cx15,V.g16,A(V.g16,V.g16,(V.cd2 + V.cd2)),true),A(V.g14,V.g15,0),true)",
					cy16: "=C(V.g15,P(V.cy15,V.g16,A(V.g16,V.g16,(V.cd2 + V.cd2))),A(V.g14,V.g15,0))",
					cx17: "=C(V.g41,P(V.cx16,V.g14,A(V.g14,V.g15,(V.cd4)),true),A(V.g41,V.g42,V._3cd4),true)",
					cy17: "=C(V.g42,P(V.cy16,V.g15,A(V.g14,V.g15,(V.cd4))),A(V.g41,V.g42,V._3cd4))",
					cx18: "=C(V.g14,V.g36,A(V.g14,V.g15,V.cd2),true)",
					cy18: "=C(V.g15,V.g29,A(V.g14,V.g15,V.cd2))",
					cx19: "=C(V.g41,P(V.cx18,V.g14,A(V.g14,V.g15,(V.cd2 + V.cd4)),true),A(V.g41,V.g42,V.cd4),true)",
					cy19: "=C(V.g42,P(V.cy18,V.g15,A(V.g14,V.g15,(V.cd2 + V.cd4))),A(V.g41,V.g42,V.cd4))",
					cx20: "=C(V.g14,P(V.cx19,V.g41,A(V.g41,V.g42,(V.cd4 + -5400000)),true),A(V.g14,V.g14,0),true)",
					cy20: "=C(V.g14,P(V.cy19,V.g42,A(V.g41,V.g42,(V.cd4 + -5400000))),A(V.g14,V.g14,0))",
					cx21: "=C(V.g42,V.hc,A(V.g42,V.g42,V._3cd4),true)",
					cy21: "=C(V.g42,V.g31,A(V.g42,V.g42,V._3cd4))"
				},
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], ["M", "=V.g33", "=V.g27"], ["E", "=V.cx1", "=V.cy1", "=V.g16", "=V.g16", 0, "=A(V.g16,V.g16,V.cd2)", "=A(V.g16,V.g16,(V.cd2 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["E", "=V.cx2", "=V.cy2", "=V.g14", "=V.g15", 0, "=A(V.g14,V.g15,0)", "=A(V.g14,V.g15,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx3", "=V.cy3", "=V.g41", "=V.g42", 0, "=A(V.g41,V.g42,V._3cd4)", "=A(V.g41,V.g42,(V._3cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", "=V.g37", "=V.g30"], ["L", "=V.g36", "=V.g30"], ["L", "=V.g36", "=V.g29"], ["E", "=V.cx4", "=V.cy4", "=V.g14", "=V.g15", 0, "=A(V.g14,V.g15,V.cd2)", "=A(V.g14,V.g15,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx5", "=V.cy5", "=V.g41", "=V.g42", 0, "=A(V.g41,V.g42,V.cd4)", "=A(V.g41,V.g42,(V.cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["E", "=V.cx6", "=V.cy6", "=V.g14", "=V.g14", 0, "=A(V.g14,V.g14,0)", "=A(V.g14,V.g14,(-10800000))", "=IF(-10800000 > 0, FALSE, TRUE)"], ["Z"], ["M", a, "=V.g31"], ["E", "=V.cx7", "=V.cy7", "=V.g42", "=V.g42", 0, "=A(V.g42,V.g42,V._3cd4)", "=(A(V.g42,V.g42,V._3cd4)+ 2*PI())", "=IF(21600000 > 0, FALSE, TRUE)"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", "=V.g33", "=V.g27"], ["E", "=V.cx8", "=V.cy8", "=V.g16", "=V.g16", 0, "=A(V.g16,V.g16,V.cd2)", "=A(V.g16,V.g16,(V.cd2 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["E", "=V.cx9", "=V.cy9", "=V.g14", "=V.g15", 0, "=A(V.g14,V.g15,0)", "=A(V.g14,V.g15,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx10", "=V.cy10", "=V.g41", "=V.g42", 0, "=A(V.g41,V.g42,V._3cd4)", "=A(V.g41,V.g42,(V._3cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", "=V.g37", "=V.g30"], ["L", "=V.g36", "=V.g30"], ["L", "=V.g36", "=V.g29"], ["E", "=V.cx11", "=V.cy11", "=V.g14", "=V.g15", 0, "=A(V.g14,V.g15,V.cd2)", "=A(V.g14,V.g15,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx12", "=V.cy12", "=V.g41", "=V.g42", 0, "=A(V.g41,V.g42,V.cd4)", "=A(V.g41,V.g42,(V.cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["E", "=V.cx13", "=V.cy13", "=V.g14", "=V.g14", 0, "=A(V.g14,V.g14,0)", "=A(V.g14,V.g14,(-10800000))", "=IF(-10800000 > 0, FALSE, TRUE)"], ["Z"], ["M", a, "=V.g31"], ["E", "=V.cx14", "=V.cy14", "=V.g42", "=V.g42", 0, "=A(V.g42,V.g42,V._3cd4)", "=(A(V.g42,V.g42,V._3cd4)+ 2*PI())", "=IF(21600000 > 0, FALSE, TRUE)"], ["Z"], {
							fillMode: "darken",
							strokeMode: "false"
						}
					], [["M", "=V.g33", "=V.g27"], ["E", "=V.cx15", "=V.cy15", "=V.g16", "=V.g16", 0, "=A(V.g16,V.g16,V.cd2)", "=A(V.g16,V.g16,(V.cd2 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["E", "=V.cx16", "=V.cy16", "=V.g14", "=V.g15", 0, "=A(V.g14,V.g15,0)", "=A(V.g14,V.g15,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx17", "=V.cy17", "=V.g41", "=V.g42", 0, "=A(V.g41,V.g42,V._3cd4)", "=A(V.g41,V.g42,(V._3cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", "=V.g37", "=V.g30"], ["L", "=V.g36", "=V.g30"], ["L", "=V.g36", "=V.g29"], ["E", "=V.cx18", "=V.cy18", "=V.g14", "=V.g15", 0, "=A(V.g14,V.g15,V.cd2)", "=A(V.g14,V.g15,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx19", "=V.cy19", "=V.g41", "=V.g42", 0, "=A(V.g41,V.g42,V.cd4)", "=A(V.g41,V.g42,(V.cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["E", "=V.cx20", "=V.cy20", "=V.g14", "=V.g14", 0, "=A(V.g14,V.g14,0)", "=A(V.g14,V.g14,(-10800000))", "=IF(-10800000 > 0, FALSE, TRUE)"], ["Z"], ["M", a, "=V.g31"], ["E", "=V.cx21", "=V.cy21", "=V.g42", "=V.g42", 0, "=A(V.g42,V.g42,V._3cd4)", "=(A(V.g42,V.g42,V._3cd4)+ 2*PI())", "=IF(21600000 > 0, FALSE, TRUE)"], ["Z"], {
							fillMode: "none"
						}
					], [["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {
							fillMode: "none"
						}
					]]
			},
			actionButtonInformation: {
				variables: {
					ss: s,
					dx2: "=V.ss * 3 / 8",
					vc: F,
					g9: "=V.vc - V.dx2",
					hc: E,
					g11: "=V.hc - V.dx2",
					g13: "=V.ss * 3 / 4",
					g14: "=V.g13 / 32",
					g17: "=V.g13 * 5 / 16",
					g18: "=V.g13 * 3 / 8",
					g19: "=V.g13 * 13 / 32",
					g20: "=V.g13 * 19 / 32",
					g22: "=V.g13 * 11 / 16",
					g23: "=V.g13 * 13 / 16",
					g24: "=V.g13 * 7 / 8",
					g25: "=V.g9 + V.g14",
					g28: "=V.g9 + V.g17",
					g29: "=V.g9 + V.g18",
					g30: "=V.g9 + V.g23",
					g31: "=V.g9 + V.g24",
					g32: "=V.g11 + V.g17",
					g34: "=V.g11 + V.g19",
					g35: "=V.g11 + V.g20",
					g37: "=V.g11 + V.g22",
					g38: "=V.g13 * 3 / 32",
					r: w,
					b: h,
					l: 0,
					t: 0,
					_3cd4: D,
					cx1: "=C(V.dx2,V.hc,A(V.dx2,V.dx2,V._3cd4),true)",
					cy1: "=C(V.dx2,V.g9,A(V.dx2,V.dx2,V._3cd4))",
					cx2: "=C(V.dx2,V.hc,A(V.dx2,V.dx2,V._3cd4),true)",
					cy2: "=C(V.dx2,V.g9,A(V.dx2,V.dx2,V._3cd4))",
					cx3: "=C(V.g38,V.hc,A(V.g38,V.g38,V._3cd4),true)",
					cy3: "=C(V.g38,V.g25,A(V.g38,V.g38,V._3cd4))",
					cx4: "=C(V.g38,V.hc,A(V.g38,V.g38,V._3cd4),true)",
					cy4: "=C(V.g38,V.g25,A(V.g38,V.g38,V._3cd4))",
					cx5: "=C(V.dx2,V.hc,A(V.dx2,V.dx2,V._3cd4),true)",
					cy5: "=C(V.dx2,V.g9,A(V.dx2,V.dx2,V._3cd4))",
					cx6: "=C(V.g38,V.hc,A(V.g38,V.g38,V._3cd4),true)",
					cy6: "=C(V.g38,V.g25,A(V.g38,V.g38,V._3cd4))"
				},
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], ["M", a, "=V.g9"], ["E", "=V.cx1", "=V.cy1", "=V.dx2", "=V.dx2", 0, "=A(V.dx2,V.dx2,V._3cd4)", "=(A(V.dx2,V.dx2,V._3cd4)+ 2*PI())", "=IF(21600000 > 0, FALSE, TRUE)"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", a, "=V.g9"], ["E", "=V.cx2", "=V.cy2", "=V.dx2", "=V.dx2", 0, "=A(V.dx2,V.dx2,V._3cd4)", "=(A(V.dx2,V.dx2,V._3cd4)+ 2*PI())", "=IF(21600000 > 0, FALSE, TRUE)"], ["Z"], ["M", a, "=V.g25"], ["E", "=V.cx3", "=V.cy3", "=V.g38", "=V.g38", 0, "=A(V.g38,V.g38,V._3cd4)", "=(A(V.g38,V.g38,V._3cd4)+ 2*PI())", "=IF(21600000 > 0, FALSE, TRUE)"], ["M", "=V.g32", "=V.g28"], ["L", "=V.g32", "=V.g29"], ["L", "=V.g34", "=V.g29"], ["L", "=V.g34", "=V.g30"], ["L", "=V.g32", "=V.g30"], ["L", "=V.g32", "=V.g31"], ["L", "=V.g37", "=V.g31"], ["L", "=V.g37", "=V.g30"], ["L", "=V.g35", "=V.g30"], ["L", "=V.g35", "=V.g28"], ["Z"], {
							fillMode: "darken",
							strokeMode: "false"
						}
					], [["M", a, "=V.g25"], ["E", "=V.cx4", "=V.cy4", "=V.g38", "=V.g38", 0, "=A(V.g38,V.g38,V._3cd4)", "=(A(V.g38,V.g38,V._3cd4)+ 2*PI())", "=IF(21600000 > 0, FALSE, TRUE)"], ["M", "=V.g32", "=V.g28"], ["L", "=V.g35", "=V.g28"], ["L", "=V.g35", "=V.g30"], ["L", "=V.g37", "=V.g30"], ["L", "=V.g37", "=V.g31"], ["L", "=V.g32", "=V.g31"], ["L", "=V.g32", "=V.g30"], ["L", "=V.g34", "=V.g30"], ["L", "=V.g34", "=V.g29"], ["L", "=V.g32", "=V.g29"], ["Z"], {
							fillMode: "lighten",
							strokeMode: "false"
						}
					], [["M", a, "=V.g9"], ["E", "=V.cx5", "=V.cy5", "=V.dx2", "=V.dx2", 0, "=A(V.dx2,V.dx2,V._3cd4)", "=(A(V.dx2,V.dx2,V._3cd4)+ 2*PI())", "=IF(21600000 > 0, FALSE, TRUE)"], ["Z"], ["M", a, "=V.g25"], ["E", "=V.cx6", "=V.cy6", "=V.g38", "=V.g38", 0, "=A(V.g38,V.g38,V._3cd4)", "=(A(V.g38,V.g38,V._3cd4)+ 2*PI())", "=IF(21600000 > 0, FALSE, TRUE)"], ["M", "=V.g32", "=V.g28"], ["L", "=V.g35", "=V.g28"], ["L", "=V.g35", "=V.g30"], ["L", "=V.g37", "=V.g30"], ["L", "=V.g37", "=V.g31"], ["L", "=V.g32", "=V.g31"], ["L", "=V.g32", "=V.g30"], ["L", "=V.g34", "=V.g30"], ["L", "=V.g34", "=V.g29"], ["L", "=V.g32", "=V.g29"], ["Z"], {
							fillMode: "none"
						}
					], [["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {
							fillMode: "none"
						}
					]]
			},
			actionButtonBackorPrevious: {
				variables: {
					ss: s,
					dx2: "=V.ss * 3 / 8",
					vc: F,
					g9: "=V.vc - V.dx2",
					g10: "=V.vc + V.dx2",
					hc: E,
					g11: "=V.hc - V.dx2",
					g12: "=V.hc + V.dx2",
					r: w,
					b: h,
					l: 0,
					t: 0
				},
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], ["M", "=V.g11", b], ["L", "=V.g12", "=V.g9"], ["L", "=V.g12", "=V.g10"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", "=V.g11", b], ["L", "=V.g12", "=V.g9"], ["L", "=V.g12", "=V.g10"], ["Z"], {
							fillMode: "darken",
							strokeMode: "false"
						}
					], [["M", "=V.g11", b], ["L", "=V.g12", "=V.g9"], ["L", "=V.g12", "=V.g10"], ["Z"], {
							fillMode: "none"
						}
					], [["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {
							fillMode: "none"
						}
					]]
			},
			actionButtonForwardorNext: {
				variables: {
					ss: s,
					dx2: "=V.ss * 3 / 8",
					vc: F,
					g9: "=V.vc - V.dx2",
					g10: "=V.vc + V.dx2",
					hc: E,
					g11: "=V.hc - V.dx2",
					g12: "=V.hc + V.dx2",
					r: w,
					b: h,
					l: 0,
					t: 0
				},
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], ["M", "=V.g12", b], ["L", "=V.g11", "=V.g9"], ["L", "=V.g11", "=V.g10"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", "=V.g12", b], ["L", "=V.g11", "=V.g9"], ["L", "=V.g11", "=V.g10"], ["Z"], {
							fillMode: "darken",
							strokeMode: "false"
						}
					], [["M", "=V.g12", b], ["L", "=V.g11", "=V.g10"], ["L", "=V.g11", "=V.g9"], ["Z"], {
							fillMode: "none"
						}
					], [["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {
							fillMode: "none"
						}
					]]
			},
			actionButtonBeginning: {
				variables: {
					ss: s,
					dx2: "=V.ss * 3 / 8",
					vc: F,
					g9: "=V.vc - V.dx2",
					g10: "=V.vc + V.dx2",
					hc: E,
					g11: "=V.hc - V.dx2",
					g12: "=V.hc + V.dx2",
					g13: "=V.ss * 3 / 4",
					g14: "=V.g13 / 8",
					g15: "=V.g13 / 4",
					g16: "=V.g11 + V.g14",
					g17: "=V.g11 + V.g15",
					r: w,
					b: h,
					l: 0,
					t: 0
				},
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], ["M", "=V.g17", b], ["L", "=V.g12", "=V.g9"], ["L", "=V.g12", "=V.g10"], ["Z"], ["M", "=V.g16", "=V.g9"], ["L", "=V.g11", "=V.g9"], ["L", "=V.g11", "=V.g10"], ["L", "=V.g16", "=V.g10"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", "=V.g17", b], ["L", "=V.g12", "=V.g9"], ["L", "=V.g12", "=V.g10"], ["Z"], ["M", "=V.g16", "=V.g9"], ["L", "=V.g11", "=V.g9"], ["L", "=V.g11", "=V.g10"], ["L", "=V.g16", "=V.g10"], ["Z"], {
							fillMode: "darken",
							strokeMode: "false"
						}
					], [["M", "=V.g17", b], ["L", "=V.g12", "=V.g9"], ["L", "=V.g12", "=V.g10"], ["Z"], ["M", "=V.g16", "=V.g9"], ["L", "=V.g16", "=V.g10"], ["L", "=V.g11", "=V.g10"], ["L", "=V.g11", "=V.g9"], ["Z"], {
							fillMode: "none"
						}
					], [["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {
							fillMode: "none"
						}
					]]
			},
			actionButtonEnd: {
				variables: {
					ss: s,
					dx2: "=V.ss * 3 / 8",
					vc: F,
					g9: "=V.vc - V.dx2",
					g10: "=V.vc + V.dx2",
					hc: E,
					g11: "=V.hc - V.dx2",
					g12: "=V.hc + V.dx2",
					g13: "=V.ss * 3 / 4",
					g14: "=V.g13 * 3 / 4",
					g15: "=V.g13 * 7 / 8",
					g16: "=V.g11 + V.g14",
					g17: "=V.g11 + V.g15",
					r: w,
					b: h,
					l: 0,
					t: 0
				},
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], ["M", "=V.g16", b], ["L", "=V.g11", "=V.g9"], ["L", "=V.g11", "=V.g10"], ["Z"], ["M", "=V.g17", "=V.g9"], ["L", "=V.g12", "=V.g9"], ["L", "=V.g12", "=V.g10"], ["L", "=V.g17", "=V.g10"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", "=V.g16", b], ["L", "=V.g11", "=V.g9"], ["L", "=V.g11", "=V.g10"], ["Z"], ["M", "=V.g17", "=V.g9"], ["L", "=V.g12", "=V.g9"], ["L", "=V.g12", "=V.g10"], ["L", "=V.g17", "=V.g10"], ["Z"], {
							fillMode: "darken",
							strokeMode: "false"
						}
					], [["M", "=V.g16", b], ["L", "=V.g11", "=V.g10"], ["L", "=V.g11", "=V.g9"], ["Z"], ["M", "=V.g17", "=V.g9"], ["L", "=V.g12", "=V.g9"], ["L", "=V.g12", "=V.g10"], ["L", "=V.g17", "=V.g10"], ["Z"], {
							fillMode: "none"
						}
					], [["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {
							fillMode: "none"
						}
					]]
			},
			actionButtonReturn: {
				variables: {
					ss: s,
					dx2: "=V.ss * 3 / 8",
					vc: F,
					g9: "=V.vc - V.dx2",
					g10: "=V.vc + V.dx2",
					hc: E,
					g11: "=V.hc - V.dx2",
					g12: "=V.hc + V.dx2",
					g13: "=V.ss * 3 / 4",
					g14: "=V.g13 * 7 / 8",
					g15: "=V.g13 * 3 / 4",
					g16: "=V.g13 * 5 / 8",
					g17: "=V.g13 * 3 / 8",
					g18: "=V.g13 / 4",
					g19: "=V.g9 + V.g15",
					g20: "=V.g9 + V.g16",
					g21: "=V.g9 + V.g18",
					g22: "=V.g11 + V.g14",
					g23: "=V.g11 + V.g15",
					g24: "=V.g11 + V.g16",
					g25: "=V.g11 + V.g17",
					g26: "=V.g11 + V.g18",
					g27: "=V.g13 / 8",
					r: w,
					b: h,
					l: 0,
					t: 0,
					cd4: C,
					cx1: "=C(V.g27,V.g24,A(V.g27,V.g27,0),true)",
					cy1: "=C(V.g27,V.g20,A(V.g27,V.g27,0))",
					cx2: "=C(V.g27,V.g25,A(V.g27,V.g27,V.cd4),true)",
					cy2: "=C(V.g27,V.g19,A(V.g27,V.g27,V.cd4))",
					cd2: B,
					cx3: "=C(V.g17,V.g11,A(V.g17,V.g17,V.cd2),true)",
					cy3: "=C(V.g17,V.g20,A(V.g17,V.g17,V.cd2))",
					cx4: "=C(V.g17,V.hc,A(V.g17,V.g17,V.cd4),true)",
					cy4: "=C(V.g17,V.g10,A(V.g17,V.g17,V.cd4))",
					cx5: "=C(V.g27,V.g24,A(V.g27,V.g27,0),true)",
					cy5: "=C(V.g27,V.g20,A(V.g27,V.g27,0))",
					cx6: "=C(V.g27,V.g25,A(V.g27,V.g27,V.cd4),true)",
					cy6: "=C(V.g27,V.g19,A(V.g27,V.g27,V.cd4))",
					cx7: "=C(V.g17,V.g11,A(V.g17,V.g17,V.cd2),true)",
					cy7: "=C(V.g17,V.g20,A(V.g17,V.g17,V.cd2))",
					cx8: "=C(V.g17,V.hc,A(V.g17,V.g17,V.cd4),true)",
					cy8: "=C(V.g17,V.g10,A(V.g17,V.g17,V.cd4))",
					cx9: "=C(V.g17,V.g22,A(V.g17,V.g17,0),true)",
					cy9: "=C(V.g17,V.g20,A(V.g17,V.g17,0))",
					cx10: "=C(V.g17,V.g25,A(V.g17,V.g17,V.cd4),true)",
					cy10: "=C(V.g17,V.g10,A(V.g17,V.g17,V.cd4))",
					cx11: "=C(V.g27,V.g26,A(V.g27,V.g27,V.cd2),true)",
					cy11: "=C(V.g27,V.g20,A(V.g27,V.g27,V.cd2))",
					cx12: "=C(V.g27,V.hc,A(V.g27,V.g27,V.cd4),true)",
					cy12: "=C(V.g27,V.g19,A(V.g27,V.g27,V.cd4))"
				},
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], ["M", "=V.g12", "=V.g21"], ["L", "=V.g23", "=V.g9"], ["L", a, "=V.g21"], ["L", "=V.g24", "=V.g21"], ["L", "=V.g24", "=V.g20"], ["E", "=V.cx1", "=V.cy1", "=V.g27", "=V.g27", 0, "=A(V.g27,V.g27,0)", "=A(V.g27,V.g27,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.g25", "=V.g19"], ["E", "=V.cx2", "=V.cy2", "=V.g27", "=V.g27", 0, "=A(V.g27,V.g27,V.cd4)", "=A(V.g27,V.g27,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.g26", "=V.g21"], ["L", "=V.g11", "=V.g21"], ["L", "=V.g11", "=V.g20"], ["E", "=V.cx3", "=V.cy3", "=V.g17", "=V.g17", 0, "=A(V.g17,V.g17,V.cd2)", "=A(V.g17,V.g17,(V.cd2 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", a, "=V.g10"], ["E", "=V.cx4", "=V.cy4", "=V.g17", "=V.g17", 0, "=A(V.g17,V.g17,V.cd4)", "=A(V.g17,V.g17,(V.cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", "=V.g22", "=V.g21"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", "=V.g12", "=V.g21"], ["L", "=V.g23", "=V.g9"], ["L", a, "=V.g21"], ["L", "=V.g24", "=V.g21"], ["L", "=V.g24", "=V.g20"], ["E", "=V.cx5", "=V.cy5", "=V.g27", "=V.g27", 0, "=A(V.g27,V.g27,0)", "=A(V.g27,V.g27,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.g25", "=V.g19"], ["E", "=V.cx6", "=V.cy6", "=V.g27", "=V.g27", 0, "=A(V.g27,V.g27,V.cd4)", "=A(V.g27,V.g27,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.g26", "=V.g21"], ["L", "=V.g11", "=V.g21"], ["L", "=V.g11", "=V.g20"], ["E", "=V.cx7", "=V.cy7", "=V.g17", "=V.g17", 0, "=A(V.g17,V.g17,V.cd2)", "=A(V.g17,V.g17,(V.cd2 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", a, "=V.g10"], ["E", "=V.cx8", "=V.cy8", "=V.g17", "=V.g17", 0, "=A(V.g17,V.g17,V.cd4)", "=A(V.g17,V.g17,(V.cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", "=V.g22", "=V.g21"], ["Z"], {
							fillMode: "darken",
							strokeMode: "false"
						}
					], [["M", "=V.g12", "=V.g21"], ["L", "=V.g22", "=V.g21"], ["L", "=V.g22", "=V.g20"], ["E", "=V.cx9", "=V.cy9", "=V.g17", "=V.g17", 0, "=A(V.g17,V.g17,0)", "=A(V.g17,V.g17,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.g25", "=V.g10"], ["E", "=V.cx10", "=V.cy10", "=V.g17", "=V.g17", 0, "=A(V.g17,V.g17,V.cd4)", "=A(V.g17,V.g17,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.g11", "=V.g21"], ["L", "=V.g26", "=V.g21"], ["L", "=V.g26", "=V.g20"], ["E", "=V.cx11", "=V.cy11", "=V.g27", "=V.g27", 0, "=A(V.g27,V.g27,V.cd2)", "=A(V.g27,V.g27,(V.cd2 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", a, "=V.g19"], ["E", "=V.cx12", "=V.cy12", "=V.g27", "=V.g27", 0, "=A(V.g27,V.g27,V.cd4)", "=A(V.g27,V.g27,(V.cd4 + -5400000))", "=IF(-5400000 > 0, FALSE, TRUE)"], ["L", "=V.g24", "=V.g21"], ["L", a, "=V.g21"], ["L", "=V.g23", "=V.g9"], ["Z"], {
							fillMode: "none"
						}
					], [["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {
							fillMode: "none"
						}
					]]
			},
			actionButtonDocument: {
				variables: {
					ss: s,
					dx2: "=V.ss * 3 / 8",
					vc: F,
					g9: "=V.vc - V.dx2",
					g10: "=V.vc + V.dx2",
					dx1: "=V.ss * 9 / 32",
					hc: E,
					g11: "=V.hc - V.dx1",
					g12: "=V.hc + V.dx1",
					g13: "=V.ss * 3 / 16",
					g14: "=V.g12 - V.g13",
					g15: "=V.g9 + V.g13",
					r: w,
					b: h,
					l: 0,
					t: 0
				},
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], ["M", "=V.g11", "=V.g9"], ["L", "=V.g14", "=V.g9"], ["L", "=V.g12", "=V.g15"], ["L", "=V.g12", "=V.g10"], ["L", "=V.g11", "=V.g10"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", "=V.g11", "=V.g9"], ["L", "=V.g14", "=V.g9"], ["L", "=V.g14", "=V.g15"], ["L", "=V.g12", "=V.g15"], ["L", "=V.g12", "=V.g10"], ["L", "=V.g11", "=V.g10"], ["Z"], {
							fillMode: "darkenLess",
							strokeMode: "false"
						}
					], [["M", "=V.g14", "=V.g9"], ["L", "=V.g14", "=V.g15"], ["L", "=V.g12", "=V.g15"], ["Z"], {
							fillMode: "darken",
							strokeMode: "false"
						}
					], [["M", "=V.g11", "=V.g9"], ["L", "=V.g14", "=V.g9"], ["L", "=V.g12", "=V.g15"], ["L", "=V.g12", "=V.g10"], ["L", "=V.g11", "=V.g10"], ["Z"], ["M", "=V.g12", "=V.g15"], ["L", "=V.g14", "=V.g15"], ["L", "=V.g14", "=V.g9"], {
							fillMode: "none"
						}
					], [["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {
							fillMode: "none"
						}
					]]
			},
			actionButtonSound: {
				variables: {
					ss: s,
					dx2: "=V.ss * 3 / 8",
					vc: F,
					g9: "=V.vc - V.dx2",
					g10: "=V.vc + V.dx2",
					hc: E,
					g11: "=V.hc - V.dx2",
					g12: "=V.hc + V.dx2",
					g13: "=V.ss * 3 / 4",
					g14: "=V.g13 / 8",
					g15: "=V.g13 * 5 / 16",
					g16: "=V.g13 * 5 / 8",
					g17: "=V.g13 * 11 / 16",
					g18: "=V.g13 * 3 / 4",
					g19: "=V.g13 * 7 / 8",
					g20: "=V.g9 + V.g14",
					g21: "=V.g9 + V.g15",
					g22: "=V.g9 + V.g17",
					g23: "=V.g9 + V.g19",
					g24: "=V.g11 + V.g15",
					g25: "=V.g11 + V.g16",
					g26: "=V.g11 + V.g18",
					r: w,
					b: h,
					l: 0,
					t: 0
				},
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], ["M", "=V.g11", "=V.g21"], ["L", "=V.g11", "=V.g22"], ["L", "=V.g24", "=V.g22"], ["L", "=V.g25", "=V.g10"], ["L", "=V.g25", "=V.g9"], ["L", "=V.g24", "=V.g21"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", "=V.g11", "=V.g21"], ["L", "=V.g11", "=V.g22"], ["L", "=V.g24", "=V.g22"], ["L", "=V.g25", "=V.g10"], ["L", "=V.g25", "=V.g9"], ["L", "=V.g24", "=V.g21"], ["Z"], {
							fillMode: "darken",
							strokeMode: "false"
						}
					], [["M", "=V.g11", "=V.g21"], ["L", "=V.g24", "=V.g21"], ["L", "=V.g25", "=V.g9"], ["L", "=V.g25", "=V.g10"], ["L", "=V.g24", "=V.g22"], ["L", "=V.g11", "=V.g22"], ["Z"], ["M", "=V.g26", "=V.g21"], ["L", "=V.g12", "=V.g20"], ["M", "=V.g26", b], ["L", "=V.g12", b], ["M", "=V.g26", "=V.g22"], ["L", "=V.g12", "=V.g23"], {
							fillMode: "none"
						}
					], [["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {
							fillMode: "none"
						}
					]]
			},
			actionButtonMovie: {
				variables: {
					ss: s,
					dx2: "=V.ss * 3 / 8",
					vc: F,
					g9: "=V.vc - V.dx2",
					g10: "=V.vc + V.dx2",
					hc: E,
					g11: "=V.hc - V.dx2",
					g12: "=V.hc + V.dx2",
					g13: "=V.ss * 3 / 4",
					g14: "=V.g13 * 1455 / 21600",
					g15: "=V.g13 * 1905 / 21600",
					g16: "=V.g13 * 2325 / 21600",
					g17: "=V.g13 * 16155 / 21600",
					g18: "=V.g13 * 17010 / 21600",
					g19: "=V.g13 * 19335 / 21600",
					g20: "=V.g13 * 19725 / 21600",
					g21: "=V.g13 * 20595 / 21600",
					g22: "=V.g13 * 5280 / 21600",
					g23: "=V.g13 * 5730 / 21600",
					g24: "=V.g13 * 6630 / 21600",
					g25: "=V.g13 * 7492 / 21600",
					g26: "=V.g13 * 9067 / 21600",
					g27: "=V.g13 * 9555 / 21600",
					g28: "=V.g13 * 13342 / 21600",
					g29: "=V.g13 * 14580 / 21600",
					g30: "=V.g13 * 15592 / 21600",
					g31: "=V.g11 + V.g14",
					g32: "=V.g11 + V.g15",
					g33: "=V.g11 + V.g16",
					g34: "=V.g11 + V.g17",
					g35: "=V.g11 + V.g18",
					g36: "=V.g11 + V.g19",
					g37: "=V.g11 + V.g20",
					g38: "=V.g11 + V.g21",
					g39: "=V.g9 + V.g22",
					g40: "=V.g9 + V.g23",
					g41: "=V.g9 + V.g24",
					g42: "=V.g9 + V.g25",
					g43: "=V.g9 + V.g26",
					g44: "=V.g9 + V.g27",
					g45: "=V.g9 + V.g28",
					g46: "=V.g9 + V.g29",
					g47: "=V.g9 + V.g30",
					g48: "=V.g9 + V.g31",
					r: w,
					b: h,
					l: 0,
					t: 0
				},
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], ["M", "=V.g11", "=V.g39"], ["L", "=V.g11", "=V.g44"], ["L", "=V.g31", "=V.g44"], ["L", "=V.g32", "=V.g43"], ["L", "=V.g33", "=V.g43"], ["L", "=V.g33", "=V.g47"], ["L", "=V.g35", "=V.g47"], ["L", "=V.g35", "=V.g45"], ["L", "=V.g36", "=V.g45"], ["L", "=V.g38", "=V.g46"], ["L", "=V.g12", "=V.g46"], ["L", "=V.g12", "=V.g41"], ["L", "=V.g38", "=V.g41"], ["L", "=V.g37", "=V.g42"], ["L", "=V.g35", "=V.g42"], ["L", "=V.g35", "=V.g41"], ["L", "=V.g34", "=V.g40"], ["L", "=V.g32", "=V.g40"], ["L", "=V.g31", "=V.g39"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", "=V.g11", "=V.g39"], ["L", "=V.g11", "=V.g44"], ["L", "=V.g31", "=V.g44"], ["L", "=V.g32", "=V.g43"], ["L", "=V.g33", "=V.g43"], ["L", "=V.g33", "=V.g47"], ["L", "=V.g35", "=V.g47"], ["L", "=V.g35", "=V.g45"], ["L", "=V.g36", "=V.g45"], ["L", "=V.g38", "=V.g46"], ["L", "=V.g12", "=V.g46"], ["L", "=V.g12", "=V.g41"], ["L", "=V.g38", "=V.g41"], ["L", "=V.g37", "=V.g42"], ["L", "=V.g35", "=V.g42"], ["L", "=V.g35", "=V.g41"], ["L", "=V.g34", "=V.g40"], ["L", "=V.g32", "=V.g40"], ["L", "=V.g31", "=V.g39"], ["Z"], {
							fillMode: "darken",
							strokeMode: "false"
						}
					], [["M", "=V.g11", "=V.g39"], ["L", "=V.g31", "=V.g39"], ["L", "=V.g32", "=V.g40"], ["L", "=V.g34", "=V.g40"], ["L", "=V.g35", "=V.g41"], ["L", "=V.g35", "=V.g42"], ["L", "=V.g37", "=V.g42"], ["L", "=V.g38", "=V.g41"], ["L", "=V.g12", "=V.g41"], ["L", "=V.g12", "=V.g46"], ["L", "=V.g38", "=V.g46"], ["L", "=V.g36", "=V.g45"], ["L", "=V.g35", "=V.g45"], ["L", "=V.g35", "=V.g47"], ["L", "=V.g33", "=V.g47"], ["L", "=V.g33", "=V.g43"], ["L", "=V.g32", "=V.g43"], ["L", "=V.g31", "=V.g44"], ["L", "=V.g11", "=V.g44"], ["Z"], {
							fillMode: "none"
						}
					], [["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], {
							fillMode: "none"
						}
					]]
			},
			balloon: {
				variables: {
					adj1: -20833,
					adj2: 62500,
					adj3: 16667,
					dxPos: "=width * V.adj1 / 100000",
					dyPos: "=height * V.adj2 / 100000",
					hc: E,
					xPos: "=V.hc + V.dxPos",
					vc: F,
					yPos: "=V.vc + V.dyPos",
					dq: "=V.dxPos * height / width",
					ady: "=ABS(V.dyPos)",
					adq: "=ABS(V.dq)",
					dz: "=V.ady - V.adq",
					xg1: "=IF(V.dxPos > 0, 7, 2)",
					xg2: "=IF(V.dxPos > 0, 10, 5)",
					x1: "=width * V.xg1 / 12",
					x2: "=width * V.xg2 / 12",
					yg1: "=IF(V.dyPos > 0, 7, 2)",
					yg2: "=IF(V.dyPos > 0, 10, 5)",
					y1: "=height * V.yg1 / 12",
					y2: "=height * V.yg2 / 12",
					l: 0,
					t1: "=IF(V.dxPos > 0, V.l, V.xPos)",
					xl: "=IF(V.dz > 0, V.l, V.t1)",
					t2: "=IF(V.dyPos > 0, V.x1, V.xPos)",
					xt: "=IF(V.dz > 0, V.t2, V.x1)",
					r: w,
					t3: "=IF(V.dxPos > 0, V.xPos, V.r)",
					xr: "=IF(V.dz > 0, V.r, V.t3)",
					t4: "=IF(V.dyPos > 0, V.xPos, V.x1)",
					xb: "=IF(V.dz > 0, V.t4, V.x1)",
					t5: "=IF(V.dxPos > 0, V.y1, V.yPos)",
					yl: "=IF(V.dz > 0, V.y1, V.t5)",
					t: 0,
					t6: "=IF(V.dyPos > 0, V.t, V.yPos)",
					yt: "=IF(V.dz > 0, V.t6, V.t)",
					t7: "=IF(V.dxPos > 0, V.yPos, V.y1)",
					yr: "=IF(V.dz > 0, V.y1, V.t7)",
					b: h,
					t8: "=IF(V.dyPos > 0, V.yPos, V.b)",
					yb: "=IF(V.dz > 0, V.t8, V.b)",
					ss: s,
					u1: "=V.ss * V.adj3 / 100000",
					u2: "=width - V.u1",
					v2: "=height - V.u1",
					il: "=V.u1 * 29289 / 100000",
					ir: "=width - V.il",
					ib: "=height - V.il",
					cd2: B,
					cd4: C,
					cx1: "=C(V.u1,V.l,A(V.u1,V.u1,V.cd2),true)",
					cy1: "=C(V.u1,V.u1,A(V.u1,V.u1,V.cd2))",
					_3cd4: D,
					cx2: "=C(V.u1,V.u2,A(V.u1,V.u1,V._3cd4),true)",
					cy2: "=C(V.u1,V.t,A(V.u1,V.u1,V._3cd4))",
					cx3: "=C(V.u1,V.r,A(V.u1,V.u1,0),true)",
					cy3: "=C(V.u1,V.v2,A(V.u1,V.u1,0))",
					cx4: "=C(V.u1,V.u1,A(V.u1,V.u1,V.cd4),true)",
					cy4: "=C(V.u1,V.b,A(V.u1,V.u1,V.cd4))"
				},
				adjustInfo: [["adj1", -20833], ["adj2", 62500], ["adj3", 16667]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}, {
						x: "=V.xPos",
						y: "=V.yPos"
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj1",
						minX: -2147483647,
						maxX: 2147483647,
						gdRefY: "adj2",
						minY: -2147483647,
						maxY: 2147483647,
						position: {
							x: "xPos",
							y: "yPos"
						},
						point: ["=V.xPos", "=V.yPos"]
					}
				],
				path: [[["M", 0, "=V.u1"], ["E", "=V.cx1", "=V.cy1", "=V.u1", "=V.u1", 0, "=A(V.u1,V.u1,V.cd2)", "=A(V.u1,V.u1,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", c, 0], ["L", "=V.xt", "=V.yt"], ["L", d, 0], ["L", "=V.u2", 0], ["E", "=V.cx2", "=V.cy2", "=V.u1", "=V.u1", 0, "=A(V.u1,V.u1,V._3cd4)", "=A(V.u1,V.u1,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", w, e], ["L", "=V.xr", "=V.yr"], ["L", w, f], ["L", w, "=V.v2"], ["E", "=V.cx3", "=V.cy3", "=V.u1", "=V.u1", 0, "=A(V.u1,V.u1,0)", "=A(V.u1,V.u1,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", d, h], ["L", "=V.xb", "=V.yb"], ["L", c, h], ["L", "=V.u1", h], ["E", "=V.cx4", "=V.cy4", "=V.u1", "=V.u1", 0, "=A(V.u1,V.u1,V.cd4)", "=A(V.u1,V.u1,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", 0, f], ["L", "=V.xl", "=V.yl"], ["L", 0, e], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.il",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			flowchartOfflineStorage: {
				variables: {
					x4: "=width * 3 / 4",
					vc: F,
					hc: E,
					b: h,
					wd4: "=width/4",
					t: 0,
					_scaleX1: "= width / 2",
					_scaleY1: "= height / 2",
					_scaleX2: "= width / 5",
					_scaleY2: "= height / 5",
					_scaleX3: "= width / 2",
					_scaleY3: "= height / 2"
				},
				connectionPoints: [{
						x: "=V.x4",
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: "=V.wd4",
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", E, h], ["Z"], {
							strokeMode: "false"
						}
					], [["M", "=2 * V._scaleX2", "=4 * V._scaleY2"], ["L", "=3 * V._scaleX2", "=4 * V._scaleY2"], {
							fillMode: "none"
						}
					], [["M", 0, 0], ["L", w, 0], ["L", E, h], ["Z"], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: "=V.wd4",
					top: 0,
					right: "=V.x4",
					bottom: b
				}
			},
			leftRightRibbon: {
				variables: {
					adj1: 50000,
					adj2: 50000,
					adj3: 16667,
					a3: "=MIN(MAX(0, V.adj3), 33333)",
					maxAdj1: "=100000 - V.a3",
					a1: "=MIN(MAX(0, V.adj1), V.maxAdj1)",
					wd2: E,
					wd32: "=width/32",
					w1: "=V.wd2 - V.wd32",
					ss: s,
					maxAdj2: "=100000 * V.w1 / V.ss",
					a2: "=MIN(MAX(0, V.adj2), V.maxAdj2)",
					x1: "=V.ss * V.a2 / 100000",
					r: w,
					x4: "=width - V.x1",
					dy1: "=height * V.a1 / 200000",
					dy2: "=height * V.a3 / -200000",
					vc: F,
					ly1: "=V.vc + V.dy2 - V.dy1",
					ry4: "=V.vc + V.dy1 - V.dy2",
					ly2: "=V.ly1 + V.dy1",
					b: h,
					ry3: "=height - V.ly2",
					ly4: "=V.ly2 * 2",
					ry1: "=height - V.ly4",
					ly3: "=V.ly4 - V.ly1",
					ry2: "=height - V.ly3",
					hR: "=V.a3 * V.ss / 400000",
					hc: E,
					x2: "=V.hc - V.wd32",
					x3: "=V.hc + V.wd32",
					y1: "=V.ly1 + V.hR",
					y2: "=V.ry2 - V.hR",
					l: 0,
					t: 0,
					_3cd4: D,
					cd2: B,
					cx1: "=C(V.wd32,V.hc,A(V.wd32,V.hR,V._3cd4),true)",
					cy1: "=C(V.hR,V.ly1,A(V.wd32,V.hR,V._3cd4))",
					cx2: "=C(V.wd32,P(V.cx1,V.wd32,A(V.wd32,V.hR,(V._3cd4 + V.cd2)),true),A(V.wd32,V.hR,V._3cd4),true)",
					cy2: "=C(V.hR,P(V.cy1,V.hR,A(V.wd32,V.hR,(V._3cd4 + V.cd2))),A(V.wd32,V.hR,V._3cd4))",
					cd4: C,
					cx3: "=C(V.wd32,V.hc,A(V.wd32,V.hR,V.cd4),true)",
					cy3: "=C(V.hR,V.ry4,A(V.wd32,V.hR,V.cd4))",
					cx4: "=C(V.wd32,V.x3,A(V.wd32,V.hR,0),true)",
					cy4: "=C(V.hR,V.y1,A(V.wd32,V.hR,0))",
					cx5: "=C(V.wd32,P(V.cx4,V.wd32,A(V.wd32,V.hR,(V.cd4)),true),A(V.wd32,V.hR,V._3cd4),true)",
					cy5: "=C(V.hR,P(V.cy4,V.hR,A(V.wd32,V.hR,(V.cd4))),A(V.wd32,V.hR,V._3cd4))",
					cx6: "=C(V.wd32,V.hc,A(V.wd32,V.hR,V._3cd4),true)",
					cy6: "=C(V.hR,V.ly1,A(V.wd32,V.hR,V._3cd4))",
					cx7: "=C(V.wd32,P(V.cx6,V.wd32,A(V.wd32,V.hR,(V._3cd4 + V.cd2)),true),A(V.wd32,V.hR,V._3cd4),true)",
					cy7: "=C(V.hR,P(V.cy6,V.hR,A(V.wd32,V.hR,(V._3cd4 + V.cd2))),A(V.wd32,V.hR,V._3cd4))",
					cx8: "=C(V.wd32,V.hc,A(V.wd32,V.hR,V.cd4),true)",
					cy8: "=C(V.hR,V.ry4,A(V.wd32,V.hR,V.cd4))"
				},
				adjustInfo: [["adj1", 50000], ["adj2", 50000], ["adj3", 16667]],
				connectionPoints: [{
						x: w,
						y: "=V.ry3"
					}, {
						x: "=V.x4",
						y: h
					}, {
						x: c,
						y: "=V.ly4"
					}, {
						x: 0,
						y: "=V.ly2"
					}, {
						x: c,
						y: 0
					}, {
						x: "=V.x4",
						y: "=V.ry1"
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: "maxAdj1",
						position: {
							x: "x4",
							y: "ry2"
						},
						point: ["=V.x4", "=V.ry2"]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: "maxAdj2",
						position: {
							x: "x1",
							y: "t"
						},
						point: [c, 0]
					}, {
						type: "ahXY",
						gdRefY: "adj3",
						minY: 0,
						maxY: 33333,
						position: {
							x: "x3",
							y: "ry2"
						},
						point: ["=V.x3", "=V.ry2"]
					}
				],
				path: [[["M", 0, "=V.ly2"], ["L", c, 0], ["L", c, "=V.ly1"], ["L", a, "=V.ly1"], ["E", "=V.cx1", "=V.cy1", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V._3cd4)", "=A(V.wd32,V.hR,(V._3cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["E", "=V.cx2", "=V.cy2", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V._3cd4)", "=A(V.wd32,V.hR,(V._3cd4 + -10800000))", "=IF(-10800000 > 0, FALSE, TRUE)"], ["L", "=V.x4", "=V.ry2"], ["L", "=V.x4", "=V.ry1"], ["L", w, "=V.ry3"], ["L", "=V.x4", h], ["L", "=V.x4", "=V.ry4"], ["L", a, "=V.ry4"], ["E", "=V.cx3", "=V.cy3", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V.cd4)", "=A(V.wd32,V.hR,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", d, "=V.ly3"], ["L", c, "=V.ly3"], ["L", c, "=V.ly4"], ["Z"], {
							strokeMode: "false"
						}
					], [["M", "=V.x3", e], ["E", "=V.cx4", "=V.cy4", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,0)", "=A(V.wd32,V.hR,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx5", "=V.cy5", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V._3cd4)", "=A(V.wd32,V.hR,(V._3cd4 + -10800000))", "=IF(-10800000 > 0, FALSE, TRUE)"], ["L", "=V.x3", "=V.ry2"], ["Z"], {
							fillMode: "darkenLess",
							strokeMode: "false"
						}
					], [["M", 0, "=V.ly2"], ["L", c, 0], ["L", c, "=V.ly1"], ["L", a, "=V.ly1"], ["E", "=V.cx6", "=V.cy6", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V._3cd4)", "=A(V.wd32,V.hR,(V._3cd4 + V.cd2))", "=IF(V.cd2 > 0, FALSE, TRUE)"], ["E", "=V.cx7", "=V.cy7", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V._3cd4)", "=A(V.wd32,V.hR,(V._3cd4 + -10800000))", "=IF(-10800000 > 0, FALSE, TRUE)"], ["L", "=V.x4", "=V.ry2"], ["L", "=V.x4", "=V.ry1"], ["L", w, "=V.ry3"], ["L", "=V.x4", h], ["L", "=V.x4", "=V.ry4"], ["L", a, "=V.ry4"], ["E", "=V.cx8", "=V.cy8", "=V.wd32", "=V.hR", 0, "=A(V.wd32,V.hR,V.cd4)", "=A(V.wd32,V.hR,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", d, "=V.ly3"], ["L", c, "=V.ly3"], ["L", c, "=V.ly4"], ["Z"], ["M", "=V.x3", e], ["L", "=V.x3", "=V.ry2"], ["M", d, f], ["L", d, "=V.ly3"], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: c,
					top: "=V.ly1",
					right: "=V.x4",
					bottom: "=V.ry4"
				}
			},
			diagonalStripe: {
				variables: {
					adj: 50000,
					a: "=MIN(MAX(0, V.adj), 100000)",
					x2: "=width * V.a / 100000",
					x1: "=V.x2 / 2",
					r: w,
					x3: "=(V.x2 + V.r) / 2",
					y2: "=height * V.a / 100000",
					y1: "=V.y2 / 2",
					b: h,
					y3: "=(V.y2 + V.b) / 2",
					hc: E,
					vc: F,
					l: 0,
					t: 0
				},
				adjustInfo: [["adj", 50000]],
				connectionPoints: [{
						x: a,
						y: b
					}, {
						x: 0,
						y: "=V.y3"
					}, {
						x: c,
						y: e
					}, {
						x: "=V.x3",
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj",
						minY: 0,
						maxY: 100000,
						position: {
							x: "l",
							y: "y2"
						},
						point: [0, f]
					}
				],
				path: [[["M", 0, f], ["L", d, 0], ["L", w, 0], ["L", 0, h], ["Z"], {}
					]],
				textRect: {
					left: 0,
					top: 0,
					right: "=V.x3",
					bottom: "=V.y3"
				}
			},
			pie: {
				variables: {
					adj1: 0,
					adj2: D,
					stAng: "=MIN(MAX(0, V.adj1), 21599999)",
					enAng: "=MIN(MAX(0, V.adj2), 21599999)",
					sw1: "=V.enAng - V.stAng",
					sw2: "=V.sw1 + 21600000",
					swAng: "=IF(V.sw1 > 0, V.sw1, V.sw2)",
					wd2: E,
					d2r: A,
					wt1: "=V.wd2 * SIN(V.stAng / V.d2r)",
					hd2: F,
					ht1: "=V.hd2 * COS(V.stAng / V.d2r)",
					dx1: "=V.wd2 * COS(ATAN2(V.ht1,V.wt1))",
					dy1: "=V.hd2 * SIN(ATAN2(V.ht1,V.wt1))",
					hc: E,
					x1: "=V.hc + V.dx1",
					vc: F,
					y1: "=V.vc + V.dy1",
					wt2: "=V.wd2 * SIN(V.enAng / V.d2r)",
					ht2: "=V.hd2 * COS(V.enAng / V.d2r)",
					dx2: "=V.wd2 * COS(ATAN2(V.ht2,V.wt2))",
					dy2: "=V.hd2 * SIN(ATAN2(V.ht2,V.wt2))",
					x2: "=V.hc + V.dx2",
					y2: "=V.vc + V.dy2",
					idx: "=V.wd2 * COS(2700000 / V.d2r)",
					idy: "=V.hd2 * SIN(2700000 / V.d2r)",
					il: "=V.hc - V.idx",
					ir: "=V.hc + V.idx",
					it: "=V.vc - V.idy",
					ib: "=V.vc + V.idy",
					r: w,
					b: h,
					l: 0,
					t: 0,
					cx1: "=C(V.wd2,V.x1,A(V.wd2,V.hd2,V.stAng),true)",
					cy1: "=C(V.hd2,V.y1,A(V.wd2,V.hd2,V.stAng))"
				},
				adjustInfo: [["adj1", 0], ["adj2", 16200000]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahPolar",
						gdRefAng: "adj1",
						minAng: 0,
						maxAng: 21599999,
						position: {
							x: "x1",
							y: "y1"
						},
						point: [c, e]
					}, {
						type: "ahPolar",
						gdRefAng: "adj2",
						minAng: 0,
						maxAng: 21599999,
						position: {
							x: "x2",
							y: "y2"
						},
						point: [d, f]
					}
				],
				path: [[["M", c, e], ["E", "=V.cx1", "=V.cy1", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.stAng)", "=A(V.wd2,V.hd2,(V.stAng + V.swAng))", "=IF(V.swAng > 0, FALSE, TRUE)"], ["L", a, b], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.ir",
					right: "=V.it",
					bottom: "=V.ib"
				}
			},
			nonIsoscelesTrapezoid: {
				variables: {
					adj1: 25000,
					adj2: 25000,
					ss: s,
					maxAdj: "=50000 * width / V.ss",
					a1: "=MIN(MAX(0, V.adj1), V.maxAdj)",
					a2: "=MIN(MAX(0, V.adj2), V.maxAdj)",
					x1: "=V.ss * V.a1 / 200000",
					x2: "=V.ss * V.a1 / 100000",
					dx3: "=V.ss * V.a2 / 100000",
					r: w,
					x3: "=width - V.dx3",
					x4: "=(width + V.x3) / 2",
					wd3: "=width/3",
					il: "=V.wd3 * V.a1 / V.maxAdj",
					adjm: "=MAX(V.a1, V.a2)",
					hd3: "=height/3",
					it: "=V.hd3 * V.adjm / V.maxAdj",
					irt: "=V.wd3 * V.a2 / V.maxAdj",
					ir: "=width - V.irt",
					vc: F,
					hc: E,
					b: h,
					t: 0,
					l: 0
				},
				adjustInfo: [["adj1", 25000], ["adj2", 25000]],
				connectionPoints: [{
						x: "=V.x4",
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: c,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj1",
						minX: 0,
						maxX: "maxAdj",
						position: {
							x: "x2",
							y: "t"
						},
						point: [d, 0]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: "maxAdj",
						position: {
							x: "x3",
							y: "t"
						},
						point: ["=V.x3", 0]
					}
				],
				path: [[["M", 0, h], ["L", d, 0], ["L", "=V.x3", 0], ["L", w, h], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: h
				}
			},
			decagon: {
				variables: {
					vf: 105146,
					hd2: F,
					shd2: "=V.hd2 * V.vf / 100000",
					wd2: E,
					d2r: A,
					dx1: "=V.wd2 * COS(2160000 / V.d2r)",
					dx2: "=V.wd2 * COS(4320000 / V.d2r)",
					hc: E,
					x1: "=V.hc - V.dx1",
					x2: "=V.hc - V.dx2",
					x3: "=V.hc + V.dx2",
					x4: "=V.hc + V.dx1",
					dy1: "=V.shd2 * SIN(4320000 / V.d2r)",
					dy2: "=V.shd2 * SIN(2160000 / V.d2r)",
					vc: F,
					y1: "=V.vc - V.dy1",
					y2: "=V.vc - V.dy2",
					y3: "=V.vc + V.dy2",
					y4: "=V.vc + V.dy1",
					r: w,
					l: 0
				},
				adjustInfo: [["vf", 105146]],
				connectionPoints: [{
						x: "=V.x4",
						y: f
					}, {
						x: w,
						y: b
					}, {
						x: "=V.x4",
						y: "=V.y3"
					}, {
						x: "=V.x3",
						y: "=V.y4"
					}, {
						x: d,
						y: "=V.y4"
					}, {
						x: c,
						y: "=V.y3"
					}, {
						x: 0,
						y: b
					}, {
						x: c,
						y: f
					}, {
						x: d,
						y: e
					}, {
						x: "=V.x3",
						y: e
					}
				],
				path: [[["M", 0, b], ["L", c, f], ["L", d, e], ["L", "=V.x3", e], ["L", "=V.x4", f], ["L", w, b], ["L", "=V.x4", "=V.y3"], ["L", "=V.x3", "=V.y4"], ["L", d, "=V.y4"], ["L", c, "=V.y3"], ["Z"], {}
					]],
				textRect: {
					left: c,
					top: f,
					right: "=V.x4",
					bottom: "=V.y3"
				}
			},
			heptagon: {
				variables: {
					hf: 102572,
					vf: 105210,
					wd2: E,
					swd2: "=V.wd2 * V.hf / 100000",
					hd2: F,
					shd2: "=V.hd2 * V.vf / 100000",
					vc: F,
					svc: "=V.vc * V.vf / 100000",
					dx1: "=V.swd2 * 97493 / 100000",
					dx2: "=V.swd2 * 78183 / 100000",
					dx3: "=V.swd2 * 43388 / 100000",
					dy1: "=V.shd2 * 62349 / 100000",
					dy2: "=V.shd2 * 22252 / 100000",
					dy3: "=V.shd2 * 90097 / 100000",
					hc: E,
					x1: "=V.hc - V.dx1",
					x2: "=V.hc - V.dx2",
					x3: "=V.hc - V.dx3",
					x4: "=V.hc + V.dx3",
					x5: "=V.hc + V.dx2",
					x6: "=V.hc + V.dx1",
					y1: "=V.svc - V.dy1",
					y2: "=V.svc + V.dy2",
					y3: "=V.svc + V.dy3",
					b: h,
					ib: "=height - V.y1",
					t: 0
				},
				adjustInfo: [["hf", 102572], ["vf", 105210]],
				connectionPoints: [{
						x: "=V.x5",
						y: e
					}, {
						x: "=V.x6",
						y: f
					}, {
						x: "=V.x4",
						y: "=V.y3"
					}, {
						x: "=V.x3",
						y: "=V.y3"
					}, {
						x: c,
						y: f
					}, {
						x: d,
						y: e
					}, {
						x: a,
						y: 0
					}
				],
				path: [[["M", c, f], ["L", d, e], ["L", a, 0], ["L", "=V.x5", e], ["L", "=V.x6", f], ["L", "=V.x4", "=V.y3"], ["L", "=V.x3", "=V.y3"], ["Z"], {}
					]],
				textRect: {
					left: d,
					top: e,
					right: "=V.x5",
					bottom: "=V.ib"
				}
			},
			dodecagon: {
				variables: {
					x1: "=width * 2894 / 21600",
					x2: "=width * 7906 / 21600",
					x3: "=width * 13694 / 21600",
					x4: "=width * 18706 / 21600",
					y1: "=height * 2894 / 21600",
					y2: "=height * 7906 / 21600",
					y3: "=height * 13694 / 21600",
					y4: "=height * 18706 / 21600",
					r: w,
					b: h,
					l: 0,
					t: 0
				},
				connectionPoints: [{
						x: "=V.x4",
						y: e
					}, {
						x: w,
						y: f
					}, {
						x: w,
						y: "=V.y3"
					}, {
						x: "=V.x4",
						y: "=V.y4"
					}, {
						x: "=V.x3",
						y: h
					}, {
						x: d,
						y: h
					}, {
						x: c,
						y: "=V.y4"
					}, {
						x: 0,
						y: "=V.y3"
					}, {
						x: 0,
						y: f
					}, {
						x: c,
						y: e
					}, {
						x: d,
						y: 0
					}, {
						x: "=V.x3",
						y: 0
					}
				],
				path: [[["M", 0, f], ["L", c, e], ["L", d, 0], ["L", "=V.x3", 0], ["L", "=V.x4", e], ["L", w, f], ["L", w, "=V.y3"], ["L", "=V.x4", "=V.y4"], ["L", "=V.x3", h], ["L", d, h], ["L", c, "=V.y4"], ["L", 0, "=V.y3"], ["Z"], {}
					]],
				textRect: {
					left: c,
					top: e,
					right: "=V.x4",
					bottom: "=V.y4"
				}
			},
			star6Point: {
				variables: {
					adj: 28868,
					hf: 115470,
					a: "=MIN(MAX(0, V.adj), 50000)",
					wd2: E,
					swd2: "=V.wd2 * V.hf / 100000",
					d2r: A,
					dx1: "=V.swd2 * COS(1800000 / V.d2r)",
					hc: E,
					x1: "=V.hc - V.dx1",
					x2: "=V.hc + V.dx1",
					vc: F,
					hd4: "=height/4",
					y2: "=V.vc + V.hd4",
					iwd2: "=V.swd2 * V.a / 50000",
					hd2: F,
					ihd2: "=V.hd2 * V.a / 50000",
					sdx2: "=V.iwd2 / 2",
					sx1: "=V.hc - V.iwd2",
					sx2: "=V.hc - V.sdx2",
					sx3: "=V.hc + V.sdx2",
					sx4: "=V.hc + V.iwd2",
					sdy1: "=V.ihd2 * SIN(3600000 / V.d2r)",
					sy1: "=V.vc - V.sdy1",
					sy2: "=V.vc + V.sdy1",
					yAdj: "=V.vc - V.ihd2",
					b: h,
					t: 0
				},
				adjustInfo: [["adj", 28868], ["hf", 115470]],
				connectionPoints: [{
						x: d,
						y: "=V.hd4"
					}, {
						x: d,
						y: f
					}, {
						x: a,
						y: h
					}, {
						x: c,
						y: f
					}, {
						x: c,
						y: "=V.hd4"
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj",
						minY: 0,
						maxY: 50000,
						position: {
							x: "hc",
							y: "yAdj"
						},
						point: [a, "=V.yAdj"]
					}
				],
				path: [[["M", c, "=V.hd4"], ["L", "=V.sx2", "=V.sy1"], ["L", a, 0], ["L", "=V.sx3", "=V.sy1"], ["L", d, "=V.hd4"], ["L", "=V.sx4", b], ["L", d, f], ["L", "=V.sx3", "=V.sy2"], ["L", a, h], ["L", "=V.sx2", "=V.sy2"], ["L", c, f], ["L", "=V.sx1", b], ["Z"], {}
					]],
				textRect: {
					left: "=V.sx1",
					top: "=V.sy1",
					right: "=V.sx4",
					bottom: "=V.sy2"
				}
			},
			star7Point: {
				variables: {
					adj: 34601,
					hf: 102572,
					vf: 105210,
					a: "=MIN(MAX(0, V.adj), 50000)",
					wd2: E,
					swd2: "=V.wd2 * V.hf / 100000",
					hd2: F,
					shd2: "=V.hd2 * V.vf / 100000",
					vc: F,
					svc: "=V.vc * V.vf / 100000",
					dx1: "=V.swd2 * 97493 / 100000",
					dx2: "=V.swd2 * 78183 / 100000",
					dx3: "=V.swd2 * 43388 / 100000",
					dy1: "=V.shd2 * 62349 / 100000",
					dy2: "=V.shd2 * 22252 / 100000",
					dy3: "=V.shd2 * 90097 / 100000",
					hc: E,
					x1: "=V.hc - V.dx1",
					x2: "=V.hc - V.dx2",
					x3: "=V.hc - V.dx3",
					x4: "=V.hc + V.dx3",
					x5: "=V.hc + V.dx2",
					x6: "=V.hc + V.dx1",
					y1: "=V.svc - V.dy1",
					y2: "=V.svc + V.dy2",
					y3: "=V.svc + V.dy3",
					iwd2: "=V.swd2 * V.a / 50000",
					ihd2: "=V.shd2 * V.a / 50000",
					sdx1: "=V.iwd2 * 97493 / 100000",
					sdx2: "=V.iwd2 * 78183 / 100000",
					sdx3: "=V.iwd2 * 43388 / 100000",
					sx1: "=V.hc - V.sdx1",
					sx2: "=V.hc - V.sdx2",
					sx3: "=V.hc - V.sdx3",
					sx4: "=V.hc + V.sdx3",
					sx5: "=V.hc + V.sdx2",
					sx6: "=V.hc + V.sdx1",
					sdy1: "=V.ihd2 * 90097 / 100000",
					sdy2: "=V.ihd2 * 22252 / 100000",
					sdy3: "=V.ihd2 * 62349 / 100000",
					sy1: "=V.svc - V.sdy1",
					sy2: "=V.svc - V.sdy2",
					sy3: "=V.svc + V.sdy3",
					sy4: "=V.svc + V.ihd2",
					yAdj: "=V.svc - V.ihd2",
					t: 0
				},
				adjustInfo: [["adj", 34601], ["hf", 102572], ["vf", 105210]],
				connectionPoints: [{
						x: "=V.x5",
						y: e
					}, {
						x: "=V.x6",
						y: f
					}, {
						x: "=V.x4",
						y: "=V.y3"
					}, {
						x: "=V.x3",
						y: "=V.y3"
					}, {
						x: c,
						y: f
					}, {
						x: d,
						y: e
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj",
						minY: 0,
						maxY: 50000,
						position: {
							x: "hc",
							y: "yAdj"
						},
						point: [a, "=V.yAdj"]
					}
				],
				path: [[["M", c, f], ["L", "=V.sx1", "=V.sy2"], ["L", d, e], ["L", "=V.sx3", "=V.sy1"], ["L", a, 0], ["L", "=V.sx4", "=V.sy1"], ["L", "=V.x5", e], ["L", "=V.sx6", "=V.sy2"], ["L", "=V.x6", f], ["L", "=V.sx5", "=V.sy3"], ["L", "=V.x4", "=V.y3"], ["L", a, "=V.sy4"], ["L", "=V.x3", "=V.y3"], ["L", "=V.sx2", "=V.sy3"], ["Z"], {}
					]],
				textRect: {
					left: "=V.sx2",
					top: "=V.sy1",
					right: "=V.sx5",
					bottom: "=V.sy3"
				}
			},
			star10Point: {
				variables: {
					adj: 42533,
					hf: 105146,
					a: "=MIN(MAX(0, V.adj), 50000)",
					wd2: E,
					swd2: "=V.wd2 * V.hf / 100000",
					dx1: "=V.swd2 * 95106 / 100000",
					dx2: "=V.swd2 * 58779 / 100000",
					hc: E,
					x1: "=V.hc - V.dx1",
					x2: "=V.hc - V.dx2",
					x3: "=V.hc + V.dx2",
					x4: "=V.hc + V.dx1",
					hd2: F,
					dy1: "=V.hd2 * 80902 / 100000",
					dy2: "=V.hd2 * 30902 / 100000",
					vc: F,
					y1: "=V.vc - V.dy1",
					y2: "=V.vc - V.dy2",
					y3: "=V.vc + V.dy2",
					y4: "=V.vc + V.dy1",
					iwd2: "=V.swd2 * V.a / 50000",
					ihd2: "=V.hd2 * V.a / 50000",
					sdx1: "=V.iwd2 * 80902 / 100000",
					sdx2: "=V.iwd2 * 30902 / 100000",
					sdy1: "=V.ihd2 * 95106 / 100000",
					sdy2: "=V.ihd2 * 58779 / 100000",
					sx1: "=V.hc - V.iwd2",
					sx2: "=V.hc - V.sdx1",
					sx3: "=V.hc - V.sdx2",
					sx4: "=V.hc + V.sdx2",
					sx5: "=V.hc + V.sdx1",
					sx6: "=V.hc + V.iwd2",
					sy1: "=V.vc - V.sdy1",
					sy2: "=V.vc - V.sdy2",
					sy3: "=V.vc + V.sdy2",
					sy4: "=V.vc + V.sdy1",
					yAdj: "=V.vc - V.ihd2",
					b: h,
					t: 0
				},
				adjustInfo: [["adj", 42533], ["hf", 105146]],
				connectionPoints: [{
						x: "=V.x4",
						y: f
					}, {
						x: "=V.x4",
						y: "=V.y3"
					}, {
						x: "=V.x3",
						y: "=V.y4"
					}, {
						x: a,
						y: h
					}, {
						x: d,
						y: "=V.y4"
					}, {
						x: c,
						y: "=V.y3"
					}, {
						x: c,
						y: f
					}, {
						x: d,
						y: e
					}, {
						x: a,
						y: 0
					}, {
						x: "=V.x3",
						y: e
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj",
						minY: 0,
						maxY: 50000,
						position: {
							x: "hc",
							y: "yAdj"
						},
						point: [a, "=V.yAdj"]
					}
				],
				path: [[["M", c, f], ["L", "=V.sx2", "=V.sy2"], ["L", d, e], ["L", "=V.sx3", "=V.sy1"], ["L", a, 0], ["L", "=V.sx4", "=V.sy1"], ["L", "=V.x3", e], ["L", "=V.sx5", "=V.sy2"], ["L", "=V.x4", f], ["L", "=V.sx6", b], ["L", "=V.x4", "=V.y3"], ["L", "=V.sx5", "=V.sy3"], ["L", "=V.x3", "=V.y4"], ["L", "=V.sx4", "=V.sy4"], ["L", a, h], ["L", "=V.sx3", "=V.sy4"], ["L", d, "=V.y4"], ["L", "=V.sx2", "=V.sy3"], ["L", c, "=V.y3"], ["L", "=V.sx1", b], ["Z"], {}
					]],
				textRect: {
					left: "=V.sx2",
					top: "=V.sy2",
					right: "=V.sx5",
					bottom: "=V.sy3"
				}
			},
			star12Point: {
				variables: {
					adj: 37500,
					a: "=MIN(MAX(0, V.adj), 50000)",
					wd2: E,
					d2r: A,
					dx1: "=V.wd2 * COS(1800000 / V.d2r)",
					hd2: F,
					dy1: "=V.hd2 * SIN(3600000 / V.d2r)",
					hc: E,
					x1: "=V.hc - V.dx1",
					x3: "=width * 3 / 4",
					x4: "=V.hc + V.dx1",
					vc: F,
					y1: "=V.vc - V.dy1",
					y3: "=height * 3 / 4",
					y4: "=V.vc + V.dy1",
					iwd2: "=V.wd2 * V.a / 50000",
					ihd2: "=V.hd2 * V.a / 50000",
					sdx1: "=V.iwd2 * COS(900000 / V.d2r)",
					sdx2: "=V.iwd2 * COS(2700000 / V.d2r)",
					sdx3: "=V.iwd2 * COS(4500000 / V.d2r)",
					sdy1: "=V.ihd2 * SIN(4500000 / V.d2r)",
					sdy2: "=V.ihd2 * SIN(2700000 / V.d2r)",
					sdy3: "=V.ihd2 * SIN(900000 / V.d2r)",
					sx1: "=V.hc - V.sdx1",
					sx2: "=V.hc - V.sdx2",
					sx3: "=V.hc - V.sdx3",
					sx4: "=V.hc + V.sdx3",
					sx5: "=V.hc + V.sdx2",
					sx6: "=V.hc + V.sdx1",
					sy1: "=V.vc - V.sdy1",
					sy2: "=V.vc - V.sdy2",
					sy3: "=V.vc - V.sdy3",
					sy4: "=V.vc + V.sdy3",
					sy5: "=V.vc + V.sdy2",
					sy6: "=V.vc + V.sdy1",
					yAdj: "=V.vc - V.ihd2",
					hd4: "=height/4",
					r: w,
					b: h,
					wd4: "=width/4",
					l: 0,
					t: 0
				},
				adjustInfo: [["adj", 37500]],
				connectionPoints: [{
						x: "=V.x4",
						y: "=V.hd4"
					}, {
						x: w,
						y: b
					}, {
						x: "=V.x4",
						y: "=V.y3"
					}, {
						x: "=V.x3",
						y: "=V.y4"
					}, {
						x: a,
						y: h
					}, {
						x: "=V.wd4",
						y: "=V.y4"
					}, {
						x: c,
						y: "=V.y3"
					}, {
						x: 0,
						y: b
					}, {
						x: c,
						y: "=V.hd4"
					}, {
						x: "=V.wd4",
						y: e
					}, {
						x: a,
						y: 0
					}, {
						x: "=V.x3",
						y: e
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj",
						minY: 0,
						maxY: 50000,
						position: {
							x: "hc",
							y: "yAdj"
						},
						point: [a, "=V.yAdj"]
					}
				],
				path: [[["M", 0, b], ["L", "=V.sx1", "=V.sy3"], ["L", c, "=V.hd4"], ["L", "=V.sx2", "=V.sy2"], ["L", "=V.wd4", e], ["L", "=V.sx3", "=V.sy1"], ["L", a, 0], ["L", "=V.sx4", "=V.sy1"], ["L", "=V.x3", e], ["L", "=V.sx5", "=V.sy2"], ["L", "=V.x4", "=V.hd4"], ["L", "=V.sx6", "=V.sy3"], ["L", w, b], ["L", "=V.sx6", "=V.sy4"], ["L", "=V.x4", "=V.y3"], ["L", "=V.sx5", "=V.sy5"], ["L", "=V.x3", "=V.y4"], ["L", "=V.sx4", "=V.sy6"], ["L", a, h], ["L", "=V.sx3", "=V.sy6"], ["L", "=V.wd4", "=V.y4"], ["L", "=V.sx2", "=V.sy5"], ["L", c, "=V.y3"], ["L", "=V.sx1", "=V.sy4"], ["Z"], {}
					]],
				textRect: {
					left: "=V.sx2",
					top: "=V.sy2",
					right: "=V.sx5",
					bottom: "=V.sy5"
				}
			},
			round1Rectangle: {
				variables: {
					adj: 16667,
					a: "=MIN(MAX(0, V.adj), 50000)",
					ss: s,
					dx1: "=V.ss * V.a / 100000",
					r: w,
					x1: "=width - V.dx1",
					idx: "=V.dx1 * 29289 / 100000",
					ir: "=width - V.idx",
					hc: E,
					t: 0,
					l: 0,
					vc: F,
					b: h,
					_3cd4: D,
					cd4: C,
					cx1: "=C(V.dx1,V.x1,A(V.dx1,V.dx1,V._3cd4),true)",
					cy1: "=C(V.dx1,V.t,A(V.dx1,V.dx1,V._3cd4))"
				},
				adjustInfo: [["adj", 16667]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj",
						minX: 0,
						maxX: 50000,
						position: {
							x: "x1",
							y: "t"
						},
						point: [c, 0]
					}
				],
				path: [[["M", 0, 0], ["L", c, 0], ["E", "=V.cx1", "=V.cy1", "=V.dx1", "=V.dx1", 0, "=A(V.dx1,V.dx1,V._3cd4)", "=A(V.dx1,V.dx1,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", w, h], ["L", 0, h], ["Z"], {}
					]],
				textRect: {
					left: 0,
					top: 0,
					right: "=V.ir",
					bottom: h
				}
			},
			round2SameRectangle: {
				variables: {
					adj1: 16667,
					adj2: 0,
					a1: "=MIN(MAX(0, V.adj1), 50000)",
					a2: "=MIN(MAX(0, V.adj2), 50000)",
					ss: s,
					tx1: "=V.ss * V.a1 / 100000",
					r: w,
					tx2: "=width - V.tx1",
					bx1: "=V.ss * V.a2 / 100000",
					bx2: "=width - V.bx1",
					b: h,
					by1: "=height - V.bx1",
					d: "=V.tx1 - V.bx1",
					tdx: "=V.tx1 * 29289 / 100000",
					bdx: "=V.bx1 * 29289 / 100000",
					il: "=IF(V.d > 0, V.tdx, V.bdx)",
					ir: "=width - V.il",
					ib: "=height - V.bdx",
					vc: F,
					hc: E,
					l: 0,
					t: 0,
					_3cd4: D,
					cd4: C,
					cx1: "=C(V.tx1,V.tx2,A(V.tx1,V.tx1,V._3cd4),true)",
					cy1: "=C(V.tx1,V.t,A(V.tx1,V.tx1,V._3cd4))",
					cx2: "=C(V.bx1,V.r,A(V.bx1,V.bx1,0),true)",
					cy2: "=C(V.bx1,V.by1,A(V.bx1,V.bx1,0))",
					cx3: "=C(V.bx1,V.bx1,A(V.bx1,V.bx1,V.cd4),true)",
					cy3: "=C(V.bx1,V.b,A(V.bx1,V.bx1,V.cd4))",
					cd2: B,
					cx4: "=C(V.tx1,V.l,A(V.tx1,V.tx1,V.cd2),true)",
					cy4: "=C(V.tx1,V.tx1,A(V.tx1,V.tx1,V.cd2))"
				},
				adjustInfo: [["adj1", 16667], ["adj2", 0]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj1",
						minX: 0,
						maxX: 50000,
						position: {
							x: "tx2",
							y: "t"
						},
						point: ["=V.tx2", 0]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: 50000,
						position: {
							x: "bx1",
							y: "b"
						},
						point: ["=V.bx1", h]
					}
				],
				path: [[["M", "=V.tx1", 0], ["L", "=V.tx2", 0], ["E", "=V.cx1", "=V.cy1", "=V.tx1", "=V.tx1", 0, "=A(V.tx1,V.tx1,V._3cd4)", "=A(V.tx1,V.tx1,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", w, "=V.by1"], ["E", "=V.cx2", "=V.cy2", "=V.bx1", "=V.bx1", 0, "=A(V.bx1,V.bx1,0)", "=A(V.bx1,V.bx1,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.bx1", h], ["E", "=V.cx3", "=V.cy3", "=V.bx1", "=V.bx1", 0, "=A(V.bx1,V.bx1,V.cd4)", "=A(V.bx1,V.bx1,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", 0, "=V.tx1"], ["E", "=V.cx4", "=V.cy4", "=V.tx1", "=V.tx1", 0, "=A(V.tx1,V.tx1,V.cd2)", "=A(V.tx1,V.tx1,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.tdx",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			round2DiagRectangle: {
				variables: {
					adj1: 16667,
					adj2: 0,
					a1: "=MIN(MAX(0, V.adj1), 50000)",
					a2: "=MIN(MAX(0, V.adj2), 50000)",
					ss: s,
					x1: "=V.ss * V.a1 / 100000",
					b: h,
					y1: "=height - V.x1",
					a: "=V.ss * V.a2 / 100000",
					r: w,
					x2: "=width - V.a",
					y2: "=height - V.a",
					dx1: "=V.x1 * 29289 / 100000",
					dx2: "=V.a * 29289 / 100000",
					d: "=V.dx1 - V.dx2",
					dx: "=IF(V.d > 0, V.dx1, V.dx2)",
					ir: "=width - V.dx",
					ib: "=height - V.dx",
					vc: F,
					hc: E,
					l: 0,
					t: 0,
					_3cd4: D,
					cd4: C,
					cx1: "=C(V.a,V.x2,A(V.a,V.a,V._3cd4),true)",
					cy1: "=C(V.a,V.t,A(V.a,V.a,V._3cd4))",
					cx2: "=C(V.x1,V.r,A(V.x1,V.x1,0),true)",
					cy2: "=C(V.x1,V.y1,A(V.x1,V.x1,0))",
					cx3: "=C(V.a,V.a,A(V.a,V.a,V.cd4),true)",
					cy3: "=C(V.a,V.b,A(V.a,V.a,V.cd4))",
					cd2: B,
					cx4: "=C(V.x1,V.l,A(V.x1,V.x1,V.cd2),true)",
					cy4: "=C(V.x1,V.x1,A(V.x1,V.x1,V.cd2))"
				},
				adjustInfo: [["adj1", 16667], ["adj2", 0]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj1",
						minX: 0,
						maxX: 50000,
						position: {
							x: "x1",
							y: "t"
						},
						point: [c, 0]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: 50000,
						position: {
							x: "x2",
							y: "t"
						},
						point: [d, 0]
					}
				],
				path: [[["M", c, 0], ["L", d, 0], ["E", "=V.cx1", "=V.cy1", "=V.a", "=V.a", 0, "=A(V.a,V.a,V._3cd4)", "=A(V.a,V.a,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", w, e], ["E", "=V.cx2", "=V.cy2", c, c, 0, "=A(V.x1,V.x1,0)", "=A(V.x1,V.x1,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", "=V.a", h], ["E", "=V.cx3", "=V.cy3", "=V.a", "=V.a", 0, "=A(V.a,V.a,V.cd4)", "=A(V.a,V.a,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", 0, c], ["E", "=V.cx4", "=V.cy4", c, c, 0, "=A(V.x1,V.x1,V.cd2)", "=A(V.x1,V.x1,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["Z"], {}
					]],
				textRect: {
					left: "=V.dx",
					top: "=V.dx",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			snipRoundRectangle: {
				variables: {
					adj1: 16667,
					adj2: 16667,
					a1: "=MIN(MAX(0, V.adj1), 50000)",
					a2: "=MIN(MAX(0, V.adj2), 50000)",
					ss: s,
					x1: "=V.ss * V.a1 / 100000",
					dx2: "=V.ss * V.a2 / 100000",
					r: w,
					x2: "=width - V.dx2",
					il: "=V.x1 * 29289 / 100000",
					ir: "=(V.x2 + V.r) / 2",
					vc: F,
					hc: E,
					b: h,
					l: 0,
					t: 0,
					cd2: B,
					cd4: C,
					cx1: "=C(V.x1,V.l,A(V.x1,V.x1,V.cd2),true)",
					cy1: "=C(V.x1,V.x1,A(V.x1,V.x1,V.cd2))"
				},
				adjustInfo: [["adj1", 16667], ["adj2", 16667]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj1",
						minX: 0,
						maxX: 50000,
						position: {
							x: "x1",
							y: "t"
						},
						point: [c, 0]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: 50000,
						position: {
							x: "x2",
							y: "t"
						},
						point: [d, 0]
					}
				],
				path: [[["M", c, 0], ["L", d, 0], ["L", w, "=V.dx2"], ["L", w, h], ["L", 0, h], ["L", 0, c], ["E", "=V.cx1", "=V.cy1", c, c, 0, "=A(V.x1,V.x1,V.cd2)", "=A(V.x1,V.x1,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.il",
					right: "=V.ir",
					bottom: h
				}
			},
			snip1Rectangle: {
				variables: {
					adj: 16667,
					a: "=MIN(MAX(0, V.adj), 50000)",
					ss: s,
					dx1: "=V.ss * V.a / 100000",
					r: w,
					x1: "=width - V.dx1",
					it: "=V.dx1 / 2",
					ir: "=(V.x1 + V.r) / 2",
					vc: F,
					hc: E,
					b: h,
					l: 0,
					t: 0
				},
				adjustInfo: [["adj", 16667]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj",
						minX: 0,
						maxX: 50000,
						position: {
							x: "x1",
							y: "t"
						},
						point: [c, 0]
					}
				],
				path: [[["M", 0, 0], ["L", c, 0], ["L", w, "=V.dx1"], ["L", w, h], ["L", 0, h], ["Z"], {}
					]],
				textRect: {
					left: 0,
					top: "=V.it",
					right: "=V.ir",
					bottom: h
				}
			},
			snip2SameRectangle: {
				variables: {
					adj1: 16667,
					adj2: 0,
					a1: "=MIN(MAX(0, V.adj1), 50000)",
					a2: "=MIN(MAX(0, V.adj2), 50000)",
					ss: s,
					tx1: "=V.ss * V.a1 / 100000",
					r: w,
					tx2: "=width - V.tx1",
					bx1: "=V.ss * V.a2 / 100000",
					bx2: "=width - V.bx1",
					b: h,
					by1: "=height - V.bx1",
					d: "=V.tx1 - V.bx1",
					dx: "=IF(V.d > 0, V.tx1, V.bx1)",
					il: "=V.dx / 2",
					ir: "=width - V.il",
					it: "=V.tx1 / 2",
					ib: "=(V.by1 + V.b) / 2",
					vc: F,
					hc: E,
					l: 0,
					t: 0
				},
				adjustInfo: [["adj1", 16667], ["adj2", 0]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj1",
						minX: 0,
						maxX: 50000,
						position: {
							x: "tx2",
							y: "t"
						},
						point: ["=V.tx2", 0]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: 50000,
						position: {
							x: "bx1",
							y: "b"
						},
						point: ["=V.bx1", h]
					}
				],
				path: [[["M", "=V.tx1", 0], ["L", "=V.tx2", 0], ["L", w, "=V.tx1"], ["L", w, "=V.by1"], ["L", "=V.bx2", h], ["L", "=V.bx1", h], ["L", 0, "=V.by1"], ["L", 0, "=V.tx1"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			snip2DiagRectangle: {
				variables: {
					adj1: 0,
					adj2: 16667,
					a1: "=MIN(MAX(0, V.adj1), 50000)",
					a2: "=MIN(MAX(0, V.adj2), 50000)",
					ss: s,
					lx1: "=V.ss * V.a1 / 100000",
					r: w,
					lx2: "=width - V.lx1",
					b: h,
					ly1: "=height - V.lx1",
					rx1: "=V.ss * V.a2 / 100000",
					rx2: "=width - V.rx1",
					ry1: "=height - V.rx1",
					d: "=V.lx1 - V.rx1",
					dx: "=IF(V.d > 0, V.lx1, V.rx1)",
					il: "=V.dx / 2",
					ir: "=width - V.il",
					ib: "=height - V.il",
					vc: F,
					hc: E,
					l: 0,
					t: 0
				},
				adjustInfo: [["adj1", 0], ["adj2", 16667]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj1",
						minX: 0,
						maxX: 50000,
						position: {
							x: "lx1",
							y: "t"
						},
						point: ["=V.lx1", 0]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: 50000,
						position: {
							x: "rx2",
							y: "t"
						},
						point: ["=V.rx2", 0]
					}
				],
				path: [[["M", "=V.lx1", 0], ["L", "=V.rx2", 0], ["L", w, "=V.rx1"], ["L", w, "=V.ly1"], ["L", "=V.lx2", h], ["L", "=V.rx1", h], ["L", 0, "=V.ry1"], ["L", 0, "=V.lx1"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.il",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			frame: {
				variables: {
					adj1: 12500,
					a1: "=MIN(MAX(0, V.adj1), 50000)",
					ss: s,
					x1: "=V.ss * V.a1 / 100000",
					r: w,
					x4: "=width - V.x1",
					b: h,
					y4: "=height - V.x1",
					hc: E,
					t: 0,
					l: 0,
					vc: F
				},
				adjustInfo: [["adj1", 12500]],
				connectionPoints: [{
						x: a,
						y: 0
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: h
					}, {
						x: w,
						y: b
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj1",
						minX: 0,
						maxX: 50000,
						position: {
							x: "x1",
							y: "t"
						},
						point: [c, 0]
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", w, h], ["L", 0, h], ["Z"], ["M", c, c], ["L", c, "=V.y4"], ["L", "=V.x4", "=V.y4"], ["L", "=V.x4", c], ["Z"], {}
					]],
				textRect: {
					left: c,
					top: c,
					right: "=V.x4",
					bottom: "=V.y4"
				}
			},
			halfFrame: {
				variables: {
					adj1: 33333,
					adj2: 33333,
					ss: s,
					maxAdj2: "=100000 * width / V.ss",
					a2: "=MIN(MAX(0, V.adj2), V.maxAdj2)",
					x1: "=V.ss * V.a2 / 100000",
					g1: "=height * V.x1 / width",
					g2: "=height - V.g1",
					maxAdj1: "=100000 * V.g2 / V.ss",
					a1: "=MIN(MAX(0, V.adj1), V.maxAdj1)",
					y1: "=V.ss * V.a1 / 100000",
					dx2: "=V.y1 * width / height",
					r: w,
					x2: "=width - V.dx2",
					dy2: "=V.x1 * height / width",
					b: h,
					y2: "=height - V.dy2",
					cx1: "=V.x1 / 2",
					cy1: "=(V.y2 + V.b) / 2",
					cx2: "=(V.x2 + V.r) / 2",
					cy2: "=V.y1 / 2",
					l: 0,
					vc: F,
					hc: E,
					t: 0
				},
				adjustInfo: [["adj1", 33333], ["adj2", 33333]],
				connectionPoints: [{
						x: "=V.cx2",
						y: "=V.cy2"
					}, {
						x: "=V.cx1",
						y: "=V.cy1"
					}, {
						x: 0,
						y: b
					}, {
						x: a,
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: "maxAdj1",
						position: {
							x: "l",
							y: "y1"
						},
						point: [0, e]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: "maxAdj2",
						position: {
							x: "x1",
							y: "t"
						},
						point: [c, 0]
					}
				],
				path: [[["M", 0, 0], ["L", w, 0], ["L", d, e], ["L", c, e], ["L", c, f], ["L", 0, h], ["Z"], {}
					]]
			},
			tear: {
				variables: {
					adj: 100000,
					a: "=MIN(MAX(0, V.adj), 200000)",
					r2: "=SQRT(2)",
					wd2: E,
					tw: "=V.wd2 * V.r2",
					hd2: F,
					th: "=V.hd2 * V.r2",
					sw: "=V.tw * V.a / 100000",
					sh: "=V.th * V.a / 100000",
					d2r: A,
					dx1: "=V.sw * COS(2700000 / V.d2r)",
					dy1: "=V.sh * SIN(2700000 / V.d2r)",
					hc: E,
					x1: "=V.hc + V.dx1",
					vc: F,
					y1: "=V.vc - V.dy1",
					x2: "=(V.hc + V.x1) / 2",
					y2: "=(V.vc + V.y1) / 2",
					idx: "=V.wd2 * COS(2700000 / V.d2r)",
					idy: "=V.hd2 * SIN(2700000 / V.d2r)",
					il: "=V.hc - V.idx",
					ir: "=V.hc + V.idx",
					it: "=V.vc - V.idy",
					ib: "=V.vc + V.idy",
					r: w,
					b: h,
					l: 0,
					t: 0,
					cd2: B,
					cd4: C,
					cx1: "=C(V.wd2,V.l,A(V.wd2,V.hd2,V.cd2),true)",
					cy1: "=C(V.hd2,V.vc,A(V.wd2,V.hd2,V.cd2))",
					cx2: "=C(V.wd2,V.r,A(V.wd2,V.hd2,0),true)",
					cy2: "=C(V.hd2,V.vc,A(V.wd2,V.hd2,0))",
					cx3: "=C(V.wd2,P(V.cx2,V.wd2,A(V.wd2,V.hd2,(V.cd4)),true),A(V.wd2,V.hd2,V.cd4),true)",
					cy3: "=C(V.hd2,P(V.cy2,V.hd2,A(V.wd2,V.hd2,(V.cd4))),A(V.wd2,V.hd2,V.cd4))"
				},
				adjustInfo: [["adj", 100000]],
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: "=V.ir",
						y: "=V.ib"
					}, {
						x: a,
						y: h
					}, {
						x: "=V.il",
						y: "=V.ib"
					}, {
						x: 0,
						y: b
					}, {
						x: "=V.il",
						y: "=V.it"
					}, {
						x: a,
						y: 0
					}, {
						x: c,
						y: e
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefX: "adj",
						minX: 0,
						maxX: 200000,
						position: {
							x: "x1",
							y: "t"
						},
						point: [c, 0]
					}
				],
				path: [[["M", 0, b], ["E", "=V.cx1", "=V.cy1", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.cd2)", "=A(V.wd2,V.hd2,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["Q", d, 0, c, e], ["Q", w, f, w, b], ["E", "=V.cx2", "=V.cy2", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,0)", "=A(V.wd2,V.hd2,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["E", "=V.cx3", "=V.cy3", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.cd4)", "=A(V.wd2,V.hd2,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			chord: {
				variables: {
					adj1: 2700000,
					adj2: D,
					stAng: "=MIN(MAX(0, V.adj1), 21599999)",
					enAng: "=MIN(MAX(0, V.adj2), 21599999)",
					sw1: "=V.enAng - V.stAng",
					sw2: "=V.sw1 + 21600000",
					swAng: "=IF(V.sw1 > 0, V.sw1, V.sw2)",
					wd2: E,
					d2r: A,
					wt1: "=V.wd2 * SIN(V.stAng / V.d2r)",
					hd2: F,
					ht1: "=V.hd2 * COS(V.stAng / V.d2r)",
					dx1: "=V.wd2 * COS(ATAN2(V.ht1,V.wt1))",
					dy1: "=V.hd2 * SIN(ATAN2(V.ht1,V.wt1))",
					wt2: "=V.wd2 * SIN(V.enAng / V.d2r)",
					ht2: "=V.hd2 * COS(V.enAng / V.d2r)",
					dx2: "=V.wd2 * COS(ATAN2(V.ht2,V.wt2))",
					dy2: "=V.hd2 * SIN(ATAN2(V.ht2,V.wt2))",
					hc: E,
					x1: "=V.hc + V.dx1",
					vc: F,
					y1: "=V.vc + V.dy1",
					x2: "=V.hc + V.dx2",
					y2: "=V.vc + V.dy2",
					x3: "=(V.x1 + V.x2) / 2",
					y3: "=(V.y1 + V.y2) / 2",
					midAng0: "=V.swAng / 2",
					cd2: B,
					midAng: "=V.stAng + V.midAng0 - V.cd2",
					idx: "=V.wd2 * COS(2700000 / V.d2r)",
					idy: "=V.hd2 * SIN(2700000 / V.d2r)",
					il: "=V.hc - V.idx",
					ir: "=V.hc + V.idx",
					it: "=V.vc - V.idy",
					ib: "=V.vc + V.idy",
					cx1: "=C(V.wd2,V.x1,A(V.wd2,V.hd2,V.stAng),true)",
					cy1: "=C(V.hd2,V.y1,A(V.wd2,V.hd2,V.stAng))"
				},
				adjustInfo: [["adj1", 2700000], ["adj2", 16200000]],
				connectionPoints: [{
						x: c,
						y: e
					}, {
						x: d,
						y: f
					}, {
						x: "=V.x3",
						y: "=V.y3"
					}
				],
				controlsInfo: [{
						type: "ahPolar",
						gdRefAng: "adj1",
						minAng: 0,
						maxAng: 21599999,
						position: {
							x: "x1",
							y: "y1"
						},
						point: [c, e]
					}, {
						type: "ahPolar",
						gdRefAng: "adj2",
						minAng: 0,
						maxAng: 21599999,
						position: {
							x: "x2",
							y: "y2"
						},
						point: [d, f]
					}
				],
				path: [[["M", c, e], ["E", "=V.cx1", "=V.cy1", "=V.wd2", "=V.hd2", 0, "=A(V.wd2,V.hd2,V.stAng)", "=A(V.wd2,V.hd2,(V.stAng + V.swAng))", "=IF(V.swAng > 0, FALSE, TRUE)"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			corner: {
				variables: {
					adj1: 50000,
					adj2: 50000,
					ss: s,
					maxAdj1: "=100000 * height / V.ss",
					maxAdj2: "=100000 * width / V.ss",
					a1: "=MIN(MAX(0, V.adj1), V.maxAdj1)",
					a2: "=MIN(MAX(0, V.adj2), V.maxAdj2)",
					x1: "=V.ss * V.a2 / 100000",
					dy1: "=V.ss * V.a1 / 100000",
					b: h,
					y1: "=height - V.dy1",
					cx1: "=V.x1 / 2",
					cy1: "=(V.y1 + V.b) / 2",
					d: "=width - height",
					t: 0,
					it: "=IF(V.d > 0, V.y1, V.t)",
					r: w,
					ir: "=IF(V.d > 0, V.r, V.x1)",
					hc: E,
					l: 0,
					vc: F
				},
				adjustInfo: [["adj1", 50000], ["adj2", 50000]],
				connectionPoints: [{
						x: w,
						y: "=V.cy1"
					}, {
						x: a,
						y: h
					}, {
						x: 0,
						y: b
					}, {
						x: "=V.cx1",
						y: 0
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: "maxAdj1",
						position: {
							x: "l",
							y: "y1"
						},
						point: [0, e]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: "maxAdj2",
						position: {
							x: "x1",
							y: "t"
						},
						point: [c, 0]
					}
				],
				path: [[["M", 0, 0], ["L", c, 0], ["L", c, e], ["L", w, e], ["L", w, h], ["L", 0, h], ["Z"], {}
					]],
				textRect: {
					left: 0,
					top: "=V.it",
					right: "=V.ir",
					bottom: h
				}
			},
			mathPlus: {
				variables: {
					adj1: 23520,
					a1: "=MIN(MAX(0, V.adj1), 73490)",
					dx1: "=width * 73490 / 200000",
					dy1: "=height * 73490 / 200000",
					ss: s,
					dx2: "=V.ss * V.a1 / 200000",
					hc: E,
					x1: "=V.hc - V.dx1",
					x2: "=V.hc - V.dx2",
					x3: "=V.hc + V.dx2",
					x4: "=V.hc + V.dx1",
					vc: F,
					y1: "=V.vc - V.dy1",
					y2: "=V.vc - V.dx2",
					y3: "=V.vc + V.dx2",
					y4: "=V.vc + V.dy1",
					l: 0
				},
				adjustInfo: [["adj1", 23520]],
				connectionPoints: [{
						x: "=V.x4",
						y: b
					}, {
						x: a,
						y: "=V.y4"
					}, {
						x: c,
						y: b
					}, {
						x: a,
						y: e
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: 73490,
						position: {
							x: "l",
							y: "y2"
						},
						point: [0, f]
					}
				],
				path: [[["M", c, f], ["L", d, f], ["L", d, e], ["L", "=V.x3", e], ["L", "=V.x3", f], ["L", "=V.x4", f], ["L", "=V.x4", "=V.y3"], ["L", "=V.x3", "=V.y3"], ["L", "=V.x3", "=V.y4"], ["L", d, "=V.y4"], ["L", d, "=V.y3"], ["L", c, "=V.y3"], ["Z"], {}
					]],
				textRect: {
					left: c,
					top: f,
					right: "=V.x4",
					bottom: "=V.y3"
				}
			},
			mathMinus: {
				variables: {
					adj1: 23520,
					a1: "=MIN(MAX(0, V.adj1), 100000)",
					dy1: "=height * V.a1 / 200000",
					dx1: "=width * 73490 / 200000",
					vc: F,
					y1: "=V.vc - V.dy1",
					y2: "=V.vc + V.dy1",
					hc: E,
					x1: "=V.hc - V.dx1",
					x2: "=V.hc + V.dx1",
					l: 0
				},
				adjustInfo: [["adj1", 23520]],
				connectionPoints: [{
						x: d,
						y: b
					}, {
						x: a,
						y: f
					}, {
						x: c,
						y: b
					}, {
						x: a,
						y: e
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: 100000,
						position: {
							x: "l",
							y: "y1"
						},
						point: [0, e]
					}
				],
				path: [[["M", c, e], ["L", d, e], ["L", d, f], ["L", c, f], ["Z"], {}
					]],
				textRect: {
					left: c,
					top: e,
					right: d,
					bottom: f
				}
			},
			mathMultiply: {
				variables: {
					adj1: 23520,
					a1: "=MIN(MAX(0, V.adj1), 51965)",
					ss: s,
					th: "=V.ss * V.a1 / 100000",
					d2r: A,
					a: "=(ATAN2(width,height) * V.d2r)",
					sa: "=SIN(V.a / V.d2r)",
					ca: "=COS(V.a / V.d2r)",
					ta: "=TAN(V.a / V.d2r)",
					dl: "=SQRT(width*width + height*height)",
					rw: "=V.dl * 51965 / 100000",
					lM: "=V.dl - V.rw",
					xM: "=V.ca * V.lM / 2",
					yM: "=V.sa * V.lM / 2",
					dxAM: "=V.sa * V.th / 2",
					dyAM: "=V.ca * V.th / 2",
					xA: "=V.xM - V.dxAM",
					yA: "=V.yM + V.dyAM",
					xB: "=V.xM + V.dxAM",
					yB: "=V.yM - V.dyAM",
					hc: E,
					xBC: "=V.hc - V.xB",
					yBC: "=V.xBC * V.ta",
					yC: "=V.yBC + V.yB",
					r: w,
					xD: "=width - V.xB",
					xE: "=width - V.xA",
					vc: F,
					yFE: "=V.vc - V.yA",
					xFE: "=V.yFE / V.ta",
					xF: "=V.xE - V.xFE",
					xL: "=V.xA + V.xFE",
					b: h,
					yG: "=height - V.yA",
					yH: "=height - V.yB",
					yI: "=height - V.yC",
					xC2: "=width - V.xM",
					yC3: "=height - V.yM",
					l: 0
				},
				adjustInfo: [["adj1", 23520]],
				connectionPoints: [{
						x: "=V.xM",
						y: "=V.yM"
					}, {
						x: "=V.xC2",
						y: "=V.yM"
					}, {
						x: "=V.xC2",
						y: "=V.yC3"
					}, {
						x: "=V.xM",
						y: "=V.yC3"
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: 51965,
						position: {
							x: "l",
							y: "th"
						},
						point: [0, "=V.th"]
					}
				],
				path: [[["M", "=V.xA", "=V.yA"], ["L", "=V.xB", "=V.yB"], ["L", a, "=V.yC"], ["L", "=V.xD", "=V.yB"], ["L", "=V.xE", "=V.yA"], ["L", "=V.xF", b], ["L", "=V.xE", "=V.yG"], ["L", "=V.xD", "=V.yH"], ["L", a, "=V.yI"], ["L", "=V.xB", "=V.yH"], ["L", "=V.xA", "=V.yG"], ["L", "=V.xL", b], ["Z"], {}
					]],
				textRect: {
					left: "=V.xA",
					top: "=V.yB",
					right: "=V.xE",
					bottom: "=V.yH"
				}
			},
			mathDivide: {
				variables: {
					adj1: 23520,
					adj2: 5880,
					adj3: 11760,
					a1: "=MIN(MAX(1000, V.adj1), 36745)",
					ma1: "=0 - V.a1",
					ma3h: "=(73490 + V.ma1) / 4",
					ma3w: "=36745 * width / height",
					maxAdj3: "=MIN(V.ma3h, V.ma3w)",
					a3: "=MIN(MAX(1000, V.adj3), V.maxAdj3)",
					m4a3: "=-4 * V.a3",
					maxAdj2: "=73490 + V.m4a3 - V.a1",
					a2: "=MIN(MAX(0, V.adj2), V.maxAdj2)",
					dy1: "=height * V.a1 / 200000",
					yg: "=height * V.a2 / 100000",
					rad: "=height * V.a3 / 100000",
					dx1: "=width * 73490 / 200000",
					vc: F,
					y3: "=V.vc - V.dy1",
					y4: "=V.vc + V.dy1",
					a: "=V.yg + V.rad",
					y2: "=V.y3 - V.a",
					y1: "=V.y2 - V.rad",
					b: h,
					y5: "=height - V.y1",
					hc: E,
					x1: "=V.hc - V.dx1",
					x3: "=V.hc + V.dx1",
					x2: "=V.hc - V.rad",
					l: 0,
					r: w,
					t: 0,
					_3cd4: D,
					cx1: "=C(V.rad,V.hc,A(V.rad,V.rad,V._3cd4),true)",
					cy1: "=C(V.rad,V.y1,A(V.rad,V.rad,V._3cd4))",
					cd4: C,
					cx2: "=C(V.rad,V.hc,A(V.rad,V.rad,V.cd4),true)",
					cy2: "=C(V.rad,V.y5,A(V.rad,V.rad,V.cd4))"
				},
				adjustInfo: [["adj1", 23520], ["adj2", 5880], ["adj3", 11760]],
				connectionPoints: [{
						x: "=V.x3",
						y: b
					}, {
						x: a,
						y: "=V.y5"
					}, {
						x: c,
						y: b
					}, {
						x: a,
						y: e
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 1000,
						maxY: 36745,
						position: {
							x: "l",
							y: "y3"
						},
						point: [0, "=V.y3"]
					}, {
						type: "ahXY",
						gdRefY: "adj2",
						minY: 0,
						maxY: "maxAdj2",
						position: {
							x: "r",
							y: "y2"
						},
						point: [w, f]
					}, {
						type: "ahXY",
						gdRefX: "adj3",
						minX: 1000,
						maxX: "maxAdj3",
						position: {
							x: "x2",
							y: "t"
						},
						point: [d, 0]
					}
				],
				path: [[["M", a, e], ["E", "=V.cx1", "=V.cy1", "=V.rad", "=V.rad", 0, "=A(V.rad,V.rad,V._3cd4)", "=(A(V.rad,V.rad,V._3cd4)+ 2*PI())", "=IF(21600000 > 0, FALSE, TRUE)"], ["Z"], ["M", a, "=V.y5"], ["E", "=V.cx2", "=V.cy2", "=V.rad", "=V.rad", 0, "=A(V.rad,V.rad,V.cd4)", "=(A(V.rad,V.rad,V.cd4)+ 2*PI())", "=IF(21600000 > 0, FALSE, TRUE)"], ["Z"], ["M", c, "=V.y3"], ["L", "=V.x3", "=V.y3"], ["L", "=V.x3", "=V.y4"], ["L", c, "=V.y4"], ["Z"], {}
					]],
				textRect: {
					left: c,
					top: "=V.y3",
					right: "=V.x3",
					bottom: "=V.y4"
				}
			},
			mathEqual: {
				variables: {
					adj1: 23520,
					adj2: 11760,
					a1: "=MIN(MAX(0, V.adj1), 36745)",
					"2a1": "=V.a1 * 2",
					mAdj2: "=100000 - V.2a1",
					a2: "=MIN(MAX(0, V.adj2), V.mAdj2)",
					dy1: "=height * V.a1 / 100000",
					dy2: "=height * V.a2 / 200000",
					dx1: "=width * 73490 / 200000",
					vc: F,
					y2: "=V.vc - V.dy2",
					y3: "=V.vc + V.dy2",
					y1: "=V.y2 - V.dy1",
					y4: "=V.y3 + V.dy1",
					hc: E,
					x1: "=V.hc - V.dx1",
					x2: "=V.hc + V.dx1",
					yC1: "=(V.y1 + V.y2) / 2",
					yC2: "=(V.y3 + V.y4) / 2",
					l: 0,
					r: w
				},
				adjustInfo: [["adj1", 23520], ["adj2", 11760]],
				connectionPoints: [{
						x: d,
						y: "=V.yC1"
					}, {
						x: d,
						y: "=V.yC2"
					}, {
						x: a,
						y: "=V.y4"
					}, {
						x: c,
						y: "=V.yC1"
					}, {
						x: c,
						y: "=V.yC2"
					}, {
						x: a,
						y: e
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: 36745,
						position: {
							x: "l",
							y: "y1"
						},
						point: [0, e]
					}, {
						type: "ahXY",
						gdRefY: "adj2",
						minY: 0,
						maxY: "mAdj2",
						position: {
							x: "r",
							y: "y2"
						},
						point: [w, f]
					}
				],
				path: [[["M", c, e], ["L", d, e], ["L", d, f], ["L", c, f], ["Z"], ["M", c, "=V.y3"], ["L", d, "=V.y3"], ["L", d, "=V.y4"], ["L", c, "=V.y4"], ["Z"], {}
					]],
				textRect: {
					left: c,
					top: e,
					right: d,
					bottom: "=V.y4"
				}
			},
			mathNotEqual: {
				variables: {
					adj1: 23520,
					adj2: 6600000,
					adj3: 11760,
					a1: "=MIN(MAX(0, V.adj1), 50000)",
					crAng: "=MIN(MAX(4200000, V.adj2), 6600000)",
					"2a1": "=V.a1 * 2",
					maxAdj3: "=100000 - V.2a1",
					a3: "=MIN(MAX(0, V.adj3), V.maxAdj3)",
					dy1: "=height * V.a1 / 100000",
					dy2: "=height * V.a3 / 200000",
					dx1: "=width * 73490 / 200000",
					hc: E,
					x1: "=V.hc - V.dx1",
					x8: "=V.hc + V.dx1",
					vc: F,
					y2: "=V.vc - V.dy2",
					y3: "=V.vc + V.dy2",
					y1: "=V.y2 - V.dy1",
					y4: "=V.y3 + V.dy1",
					cd4: C,
					cadj2: "=V.crAng - V.cd4",
					hd2: F,
					d2r: A,
					xadj2: "=V.hd2 * TAN(V.cadj2 / V.d2r)",
					len: "=SQRT(V.xadj2*V.xadj2 + V.hd2*V.hd2)",
					bhw: "=V.len * V.dy1 / V.hd2",
					bhw2: "=V.bhw / 2",
					x7: "=V.hc + V.xadj2 - V.bhw2",
					dx67: "=V.xadj2 * V.y1 / V.hd2",
					x6: "=V.x7 - V.dx67",
					dx57: "=V.xadj2 * V.y2 / V.hd2",
					x5: "=V.x7 - V.dx57",
					dx47: "=V.xadj2 * V.y3 / V.hd2",
					x4: "=V.x7 - V.dx47",
					dx37: "=V.xadj2 * V.y4 / V.hd2",
					x3: "=V.x7 - V.dx37",
					dx27: "=V.xadj2 * 2",
					x2: "=V.x7 - V.dx27",
					rx7: "=V.x7 + V.bhw",
					rx6: "=V.x6 + V.bhw",
					rx5: "=V.x5 + V.bhw",
					rx4: "=V.x4 + V.bhw",
					rx3: "=V.x3 + V.bhw",
					rx2: "=V.x2 + V.bhw",
					dx7: "=V.dy1 * V.hd2 / V.len",
					rxt: "=V.x7 + V.dx7",
					lxt: "=V.rx7 - V.dx7",
					rx: "=IF(V.cadj2 > 0, V.rxt, V.rx7)",
					lx: "=IF(V.cadj2 > 0, V.x7, V.lxt)",
					dy3: "=V.dy1 * V.xadj2 / V.len",
					dy4: "=0 - V.dy3",
					t: 0,
					ry: "=IF(V.cadj2 > 0, V.dy3, V.t)",
					ly: "=IF(V.cadj2 > 0, V.t, V.dy4)",
					dlx: "=width - V.rx",
					drx: "=width - V.lx",
					dly: "=height - V.ry",
					dry: "=height - V.ly",
					xC1: "=(V.rx + V.lx) / 2",
					xC2: "=(V.drx + V.dlx) / 2",
					yC1: "=(V.ry + V.ly) / 2",
					yC2: "=(V.y1 + V.y2) / 2",
					yC3: "=(V.y3 + V.y4) / 2",
					yC4: "=(V.dry + V.dly) / 2",
					l: 0,
					r: w
				},
				adjustInfo: [["adj1", 23520], ["adj2", 6600000], ["adj3", 11760]],
				connectionPoints: [{
						x: "=V.x8",
						y: "=V.yC2"
					}, {
						x: "=V.x8",
						y: "=V.yC3"
					}, {
						x: "=V.xC2",
						y: "=V.yC4"
					}, {
						x: c,
						y: "=V.yC2"
					}, {
						x: c,
						y: "=V.yC3"
					}, {
						x: "=V.xC1",
						y: "=V.yC1"
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: 50000,
						position: {
							x: "l",
							y: "y1"
						},
						point: [0, e]
					}, {
						type: "ahPolar",
						gdRefAng: "adj2",
						minAng: 4200000,
						maxAng: 6600000,
						position: {
							x: "lx",
							y: "t"
						},
						point: ["=V.lx", 0]
					}, {
						type: "ahXY",
						gdRefY: "adj3",
						minY: 0,
						maxY: "maxAdj3",
						position: {
							x: "r",
							y: "y2"
						},
						point: [w, f]
					}
				],
				path: [[["M", c, e], ["L", "=V.x6", e], ["L", "=V.lx", "=V.ly"], ["L", "=V.rx", "=V.ry"], ["L", "=V.rx6", e], ["L", "=V.x8", e], ["L", "=V.x8", f], ["L", "=V.rx5", f], ["L", "=V.rx4", "=V.y3"], ["L", "=V.x8", "=V.y3"], ["L", "=V.x8", "=V.y4"], ["L", "=V.rx3", "=V.y4"], ["L", "=V.drx", "=V.dry"], ["L", "=V.dlx", "=V.dly"], ["L", "=V.x3", "=V.y4"], ["L", c, "=V.y4"], ["L", c, "=V.y3"], ["L", "=V.x4", "=V.y3"], ["L", "=V.x5", f], ["L", c, f], ["Z"], {}
					]],
				textRect: {
					left: c,
					top: e,
					right: "=V.x8",
					bottom: "=V.y4"
				}
			},
			cornerTabs: {
				variables: {
					md: "=SQRT(width*width + height*height)",
					dx: "=V.md / 20",
					b: h,
					y1: "=height - V.dx",
					r: w,
					x1: "=width - V.dx",
					l: 0,
					t: 0
				},
				connectionPoints: [{
						x: 0,
						y: 0
					}, {
						x: 0,
						y: "=V.dx"
					}, {
						x: 0,
						y: e
					}, {
						x: 0,
						y: h
					}, {
						x: "=V.dx",
						y: 0
					}, {
						x: c,
						y: 0
					}, {
						x: "=V.dx",
						y: h
					}, {
						x: c,
						y: h
					}, {
						x: w,
						y: 0
					}, {
						x: w,
						y: "=V.dx"
					}, {
						x: w,
						y: e
					}, {
						x: w,
						y: h
					}
				],
				path: [[["M", 0, 0], ["L", "=V.dx", 0], ["L", 0, "=V.dx"], ["Z"], {}
					], [["M", 0, e], ["L", "=V.dx", h], ["L", 0, h], ["Z"], {}
					], [["M", c, 0], ["L", w, 0], ["L", w, "=V.dx"], ["Z"], {}
					], [["M", w, e], ["L", w, h], ["L", c, h], ["Z"], {}
					]],
				textRect: {
					left: "=V.dx",
					top: "=V.dx",
					right: c,
					bottom: e
				}
			},
			squareTabs: {
				variables: {
					md: "=SQRT(width*width + height*height)",
					dx: "=V.md / 20",
					b: h,
					y1: "=height - V.dx",
					r: w,
					x1: "=width - V.dx",
					l: 0,
					t: 0
				},
				connectionPoints: [{
						x: 0,
						y: 0
					}, {
						x: 0,
						y: "=V.dx"
					}, {
						x: 0,
						y: e
					}, {
						x: 0,
						y: h
					}, {
						x: "=V.dx",
						y: "=V.dx"
					}, {
						x: "=V.dx",
						y: c
					}, {
						x: "=V.dx",
						y: 0
					}, {
						x: c,
						y: 0
					}, {
						x: "=V.dx",
						y: h
					}, {
						x: c,
						y: h
					}, {
						x: w,
						y: 0
					}, {
						x: w,
						y: "=V.dx"
					}, {
						x: w,
						y: e
					}, {
						x: w,
						y: h
					}, {
						x: c,
						y: "=V.dx"
					}, {
						x: c,
						y: e
					}
				],
				path: [[["M", 0, 0], ["L", "=V.dx", 0], ["L", "=V.dx", "=V.dx"], ["L", 0, "=V.dx"], ["Z"], {}
					], [["M", 0, e], ["L", "=V.dx", e], ["L", "=V.dx", h], ["L", 0, h], ["Z"], {}
					], [["M", c, 0], ["L", w, 0], ["L", w, "=V.dx"], ["L", c, "=V.dx"], ["Z"], {}
					], [["M", c, e], ["L", w, e], ["L", w, h], ["L", c, h], ["Z"], {}
					]],
				textRect: {
					left: "=V.dx",
					top: "=V.dx",
					right: c,
					bottom: e
				}
			},
			plaqueTabs: {
				variables: {
					md: "=SQRT(width*width + height*height)",
					dx: "=V.md / 20",
					b: h,
					y1: "=height - V.dx",
					r: w,
					x1: "=width - V.dx",
					l: 0,
					t: 0,
					cd4: C,
					cx1: "=C(V.dx,V.dx,A(V.dx,V.dx,0),true)",
					cy1: "=C(V.dx,V.t,A(V.dx,V.dx,0))",
					_3cd4: D,
					cx2: "=C(V.dx,V.l,A(V.dx,V.dx,V._3cd4),true)",
					cy2: "=C(V.dx,V.y1,A(V.dx,V.dx,V._3cd4))",
					cx3: "=C(V.dx,V.r,A(V.dx,V.dx,V.cd4),true)",
					cy3: "=C(V.dx,V.dx,A(V.dx,V.dx,V.cd4))",
					cd2: B,
					cx4: "=C(V.dx,V.x1,A(V.dx,V.dx,V.cd2),true)",
					cy4: "=C(V.dx,V.b,A(V.dx,V.dx,V.cd2))"
				},
				connectionPoints: [{
						x: 0,
						y: 0
					}, {
						x: 0,
						y: "=V.dx"
					}, {
						x: 0,
						y: e
					}, {
						x: 0,
						y: h
					}, {
						x: "=V.dx",
						y: 0
					}, {
						x: c,
						y: 0
					}, {
						x: "=V.dx",
						y: h
					}, {
						x: c,
						y: h
					}, {
						x: w,
						y: 0
					}, {
						x: w,
						y: "=V.dx"
					}, {
						x: w,
						y: e
					}, {
						x: w,
						y: h
					}
				],
				path: [[["M", 0, 0], ["L", "=V.dx", 0], ["E", "=V.cx1", "=V.cy1", "=V.dx", "=V.dx", 0, "=A(V.dx,V.dx,0)", "=A(V.dx,V.dx,(V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["Z"], {}
					], [["M", 0, e], ["E", "=V.cx2", "=V.cy2", "=V.dx", "=V.dx", 0, "=A(V.dx,V.dx,V._3cd4)", "=A(V.dx,V.dx,(V._3cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", 0, h], ["Z"], {}
					], [["M", w, 0], ["L", w, "=V.dx"], ["E", "=V.cx3", "=V.cy3", "=V.dx", "=V.dx", 0, "=A(V.dx,V.dx,V.cd4)", "=A(V.dx,V.dx,(V.cd4 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["Z"], {}
					], [["M", c, h], ["E", "=V.cx4", "=V.cy4", "=V.dx", "=V.dx", 0, "=A(V.dx,V.dx,V.cd2)", "=A(V.dx,V.dx,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", w, h], ["Z"], {}
					]],
				textRect: {
					left: "=V.dx",
					top: "=V.dx",
					right: c,
					bottom: e
				}
			},
			gear6: {
				variables: {
					adj1: 15000,
					adj2: 3526,
					a1: "=MIN(MAX(0, V.adj1), 20000)",
					a2: "=MIN(MAX(0, V.adj2), 5358)",
					ss: s,
					th: "=V.ss * V.a1 / 100000",
					lFD: "=V.ss * V.a2 / 100000",
					th2: "=V.th / 2",
					l2: "=V.lFD / 2",
					l3: "=V.th2 + V.l2",
					hd2: F,
					rh: "=V.hd2 - V.th",
					wd2: E,
					rw: "=V.wd2 - V.th",
					dr: "=V.rw - V.rh",
					maxr: "=IF(V.dr > 0, V.rh, V.rw)",
					d2r: A,
					ha: "=(ATAN2(V.maxr,V.l3) * V.d2r)",
					aA1: "=19800000 - V.ha",
					aD1: "=19800000 + V.ha",
					ta11: "=V.rw * COS(V.aA1 / V.d2r)",
					ta12: "=V.rh * SIN(V.aA1 / V.d2r)",
					bA1: "=(ATAN2(V.ta11,V.ta12) * V.d2r)",
					cta1: "=V.rh * COS(V.bA1 / V.d2r)",
					sta1: "=V.rw * SIN(V.bA1 / V.d2r)",
					ma1: "=SQRT(V.cta1*V.cta1 + V.sta1*V.sta1)",
					na1: "=V.rw * V.rh / V.ma1",
					dxa1: "=V.na1 * COS(V.bA1 / V.d2r)",
					dya1: "=V.na1 * SIN(V.bA1 / V.d2r)",
					hc: E,
					xA1: "=V.hc + V.dxa1",
					vc: F,
					yA1: "=V.vc + V.dya1",
					td11: "=V.rw * COS(V.aD1 / V.d2r)",
					td12: "=V.rh * SIN(V.aD1 / V.d2r)",
					bD1: "=(ATAN2(V.td11,V.td12) * V.d2r)",
					ctd1: "=V.rh * COS(V.bD1 / V.d2r)",
					std1: "=V.rw * SIN(V.bD1 / V.d2r)",
					md1: "=SQRT(V.ctd1*V.ctd1 + V.std1*V.std1)",
					nd1: "=V.rw * V.rh / V.md1",
					dxd1: "=V.nd1 * COS(V.bD1 / V.d2r)",
					dyd1: "=V.nd1 * SIN(V.bD1 / V.d2r)",
					xD1: "=V.hc + V.dxd1",
					yD1: "=V.vc + V.dyd1",
					xAD1: "=V.xA1 - V.xD1",
					yAD1: "=V.yA1 - V.yD1",
					lAD1: "=SQRT(V.xAD1*V.xAD1 + V.yAD1*V.yAD1)",
					_a1: "=(ATAN2(V.yAD1,V.xAD1) * V.d2r)",
					dxF1: "=V.lFD * SIN(V._a1 / V.d2r)",
					dyF1: "=V.lFD * COS(V._a1 / V.d2r)",
					xF1: "=V.xD1 + V.dxF1",
					yF1: "=V.yD1 + V.dyF1",
					xE1: "=V.xA1 - V.dxF1",
					yE1: "=V.yA1 - V.dyF1",
					yC1t: "=V.th * SIN(V._a1 / V.d2r)",
					xC1t: "=V.th * COS(V._a1 / V.d2r)",
					yC1: "=V.yF1 + V.yC1t",
					xC1: "=V.xF1 - V.xC1t",
					yB1: "=V.yE1 + V.yC1t",
					xB1: "=V.xE1 - V.xC1t",
					_3cd4: D,
					aD6: "=V._3cd4 + V.ha",
					td61: "=V.rw * COS(V.aD6 / V.d2r)",
					td62: "=V.rh * SIN(V.aD6 / V.d2r)",
					bD6: "=(ATAN2(V.td61,V.td62) * V.d2r)",
					ctd6: "=V.rh * COS(V.bD6 / V.d2r)",
					std6: "=V.rw * SIN(V.bD6 / V.d2r)",
					md6: "=SQRT(V.ctd6*V.ctd6 + V.std6*V.std6)",
					nd6: "=V.rw * V.rh / V.md6",
					dxd6: "=V.nd6 * COS(V.bD6 / V.d2r)",
					dyd6: "=V.nd6 * SIN(V.bD6 / V.d2r)",
					xD6: "=V.hc + V.dxd6",
					yD6: "=V.vc + V.dyd6",
					xA6: "=V.hc - V.dxd6",
					xF6: "=V.xD6 - V.lFD",
					xE6: "=V.xA6 + V.lFD",
					yC6: "=V.yD6 - V.th",
					swAng1: "=V.bA1 - V.bD6",
					aA2: "=1800000 - V.ha",
					aD2: "=1800000 + V.ha",
					ta21: "=V.rw * COS(V.aA2 / V.d2r)",
					ta22: "=V.rh * SIN(V.aA2 / V.d2r)",
					bA2: "=(ATAN2(V.ta21,V.ta22) * V.d2r)",
					yA2: "=height - V.yD1",
					td21: "=V.rw * COS(V.aD2 / V.d2r)",
					td22: "=V.rh * SIN(V.aD2 / V.d2r)",
					bD2: "=(ATAN2(V.td21,V.td22) * V.d2r)",
					yD2: "=height - V.yA1",
					yC2: "=height - V.yB1",
					yB2: "=height - V.yC1",
					xB2: "=V.xC1",
					swAng2: "=V.bA2 - V.bD1",
					cd4: C,
					aD3: "=V.cd4 + V.ha",
					td31: "=V.rw * COS(V.aD3 / V.d2r)",
					td32: "=V.rh * SIN(V.aD3 / V.d2r)",
					bD3: "=(ATAN2(V.td31,V.td32) * V.d2r)",
					yD3: "=height - V.yD6",
					yB3: "=height - V.yC6",
					aD4: "=9000000 + V.ha",
					td41: "=V.rw * COS(V.aD4 / V.d2r)",
					td42: "=V.rh * SIN(V.aD4 / V.d2r)",
					bD4: "=(ATAN2(V.td41,V.td42) * V.d2r)",
					xD4: "=width - V.xD1",
					xC4: "=width - V.xC1",
					xB4: "=width - V.xB1",
					aD5: "=12600000 + V.ha",
					td51: "=V.rw * COS(V.aD5 / V.d2r)",
					td52: "=V.rh * SIN(V.aD5 / V.d2r)",
					bD5: "=(ATAN2(V.td51,V.td52) * V.d2r)",
					xD5: "=width - V.xA1",
					xC5: "=width - V.xB1",
					xB5: "=width - V.xC1",
					xCxn1: "=(V.xB1 + V.xC1) / 2",
					yCxn1: "=(V.yB1 + V.yC1) / 2",
					b: h,
					yCxn2: "=height - V.yCxn1",
					r: w,
					xCxn4: "=(width) / V.xCxn1",
					cx1: "=C(V.rw,V.xD1,A(V.rw,V.rh,V.bD1),true)",
					cy1: "=C(V.rh,V.yD1,A(V.rw,V.rh,V.bD1))",
					cx2: "=C(V.rw,V.xA1,A(V.rw,V.rh,V.bD2),true)",
					cy2: "=C(V.rh,V.yD2,A(V.rw,V.rh,V.bD2))",
					cx3: "=C(V.rw,V.xA6,A(V.rw,V.rh,V.bD3),true)",
					cy3: "=C(V.rh,V.yD3,A(V.rw,V.rh,V.bD3))",
					cx4: "=C(V.rw,V.xD4,A(V.rw,V.rh,V.bD4),true)",
					cy4: "=C(V.rh,V.yA2,A(V.rw,V.rh,V.bD4))",
					cx5: "=C(V.rw,V.xD5,A(V.rw,V.rh,V.bD5),true)",
					cy5: "=C(V.rh,V.yA1,A(V.rw,V.rh,V.bD5))",
					cx6: "=C(V.rw,V.xD6,A(V.rw,V.rh,V.bD6),true)",
					cy6: "=C(V.rh,V.yD6,A(V.rw,V.rh,V.bD6))"
				},
				adjustInfo: [["adj1", 15000], ["adj2", 3526]],
				connectionPoints: [{
						x: "=V.xCxn1",
						y: "=V.yCxn1"
					}, {
						x: "=V.xCxn1",
						y: "=V.yCxn2"
					}, {
						x: a,
						y: "=V.yB3"
					}, {
						x: "=V.xCxn4",
						y: "=V.yCxn2"
					}, {
						x: "=V.xCxn4",
						y: "=V.yCxn1"
					}, {
						x: a,
						y: "=V.yC6"
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: 20000,
						position: {
							x: "xD6",
							y: "yD6"
						},
						point: ["=V.xD6", "=V.yD6"]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: 5358,
						position: {
							x: "xA6",
							y: "yD6"
						},
						point: ["=V.xA6", "=V.yD6"]
					}
				],
				path: [[["M", "=V.xA1", "=V.yA1"], ["L", "=V.xB1", "=V.yB1"], ["L", "=V.xC1", "=V.yC1"], ["L", "=V.xD1", "=V.yD1"], ["E", "=V.cx1", "=V.cy1", "=V.rw", "=V.rh", 0, "=A(V.rw,V.rh,V.bD1)", "=A(V.rw,V.rh,(V.bD1 + V.swAng2))", "=IF(V.swAng2 > 0, FALSE, TRUE)"], ["L", "=V.xC1", "=V.yB2"], ["L", "=V.xB1", "=V.yC2"], ["L", "=V.xA1", "=V.yD2"], ["E", "=V.cx2", "=V.cy2", "=V.rw", "=V.rh", 0, "=A(V.rw,V.rh,V.bD2)", "=A(V.rw,V.rh,(V.bD2 + V.swAng1))", "=IF(V.swAng1 > 0, FALSE, TRUE)"], ["L", "=V.xF6", "=V.yB3"], ["L", "=V.xE6", "=V.yB3"], ["L", "=V.xA6", "=V.yD3"], ["E", "=V.cx3", "=V.cy3", "=V.rw", "=V.rh", 0, "=A(V.rw,V.rh,V.bD3)", "=A(V.rw,V.rh,(V.bD3 + V.swAng1))", "=IF(V.swAng1 > 0, FALSE, TRUE)"], ["L", "=V.xB4", "=V.yC2"], ["L", "=V.xC4", "=V.yB2"], ["L", "=V.xD4", "=V.yA2"], ["E", "=V.cx4", "=V.cy4", "=V.rw", "=V.rh", 0, "=A(V.rw,V.rh,V.bD4)", "=A(V.rw,V.rh,(V.bD4 + V.swAng2))", "=IF(V.swAng2 > 0, FALSE, TRUE)"], ["L", "=V.xB5", "=V.yC1"], ["L", "=V.xC5", "=V.yB1"], ["L", "=V.xD5", "=V.yA1"], ["E", "=V.cx5", "=V.cy5", "=V.rw", "=V.rh", 0, "=A(V.rw,V.rh,V.bD5)", "=A(V.rw,V.rh,(V.bD5 + V.swAng1))", "=IF(V.swAng1 > 0, FALSE, TRUE)"], ["L", "=V.xE6", "=V.yC6"], ["L", "=V.xF6", "=V.yC6"], ["L", "=V.xD6", "=V.yD6"], ["E", "=V.cx6", "=V.cy6", "=V.rw", "=V.rh", 0, "=A(V.rw,V.rh,V.bD6)", "=A(V.rw,V.rh,(V.bD6 + V.swAng1))", "=IF(V.swAng1 > 0, FALSE, TRUE)"], ["Z"], {}
					]],
				textRect: {
					left: "=V.xD5",
					top: "=V.yA1",
					right: "=V.xA1",
					bottom: "=V.yD2"
				}
			},
			gear9: {
				variables: {
					adj1: 10000,
					adj2: 1763,
					a1: "=MIN(MAX(0, V.adj1), 20000)",
					a2: "=MIN(MAX(0, V.adj2), 2679)",
					ss: s,
					th: "=V.ss * V.a1 / 100000",
					lFD: "=V.ss * V.a2 / 100000",
					th2: "=V.th / 2",
					l2: "=V.lFD / 2",
					l3: "=V.th2 + V.l2",
					hd2: F,
					rh: "=V.hd2 - V.th",
					wd2: E,
					rw: "=V.wd2 - V.th",
					dr: "=V.rw - V.rh",
					maxr: "=IF(V.dr > 0, V.rh, V.rw)",
					d2r: A,
					ha: "=(ATAN2(V.maxr,V.l3) * V.d2r)",
					aA1: "=18600000 - V.ha",
					aD1: "=18600000 + V.ha",
					ta11: "=V.rw * COS(V.aA1 / V.d2r)",
					ta12: "=V.rh * SIN(V.aA1 / V.d2r)",
					bA1: "=(ATAN2(V.ta11,V.ta12) * V.d2r)",
					cta1: "=V.rh * COS(V.bA1 / V.d2r)",
					sta1: "=V.rw * SIN(V.bA1 / V.d2r)",
					ma1: "=SQRT(V.cta1*V.cta1 + V.sta1*V.sta1)",
					na1: "=V.rw * V.rh / V.ma1",
					dxa1: "=V.na1 * COS(V.bA1 / V.d2r)",
					dya1: "=V.na1 * SIN(V.bA1 / V.d2r)",
					hc: E,
					xA1: "=V.hc + V.dxa1",
					vc: F,
					yA1: "=V.vc + V.dya1",
					td11: "=V.rw * COS(V.aD1 / V.d2r)",
					td12: "=V.rh * SIN(V.aD1 / V.d2r)",
					bD1: "=(ATAN2(V.td11,V.td12) * V.d2r)",
					ctd1: "=V.rh * COS(V.bD1 / V.d2r)",
					std1: "=V.rw * SIN(V.bD1 / V.d2r)",
					md1: "=SQRT(V.ctd1*V.ctd1 + V.std1*V.std1)",
					nd1: "=V.rw * V.rh / V.md1",
					dxd1: "=V.nd1 * COS(V.bD1 / V.d2r)",
					dyd1: "=V.nd1 * SIN(V.bD1 / V.d2r)",
					xD1: "=V.hc + V.dxd1",
					yD1: "=V.vc + V.dyd1",
					xAD1: "=V.xA1 - V.xD1",
					yAD1: "=V.yA1 - V.yD1",
					lAD1: "=SQRT(V.xAD1*V.xAD1 + V.yAD1*V.yAD1)",
					_a1: "=(ATAN2(V.yAD1,V.xAD1) * V.d2r)",
					dxF1: "=V.lFD * SIN(V._a1 / V.d2r)",
					dyF1: "=V.lFD * COS(V._a1 / V.d2r)",
					xF1: "=V.xD1 + V.dxF1",
					yF1: "=V.yD1 + V.dyF1",
					xE1: "=V.xA1 - V.dxF1",
					yE1: "=V.yA1 - V.dyF1",
					yC1t: "=V.th * SIN(V._a1 / V.d2r)",
					xC1t: "=V.th * COS(V._a1 / V.d2r)",
					yC1: "=V.yF1 + V.yC1t",
					xC1: "=V.xF1 - V.xC1t",
					yB1: "=V.yE1 + V.yC1t",
					xB1: "=V.xE1 - V.xC1t",
					aA2: "=21000000 - V.ha",
					aD2: "=21000000 + V.ha",
					ta21: "=V.rw * COS(V.aA2 / V.d2r)",
					ta22: "=V.rh * SIN(V.aA2 / V.d2r)",
					bA2: "=(ATAN2(V.ta21,V.ta22) * V.d2r)",
					cta2: "=V.rh * COS(V.bA2 / V.d2r)",
					sta2: "=V.rw * SIN(V.bA2 / V.d2r)",
					ma2: "=SQRT(V.cta2*V.cta2 + V.sta2*V.sta2)",
					na2: "=V.rw * V.rh / V.ma2",
					dxa2: "=V.na2 * COS(V.bA2 / V.d2r)",
					dya2: "=V.na2 * SIN(V.bA2 / V.d2r)",
					xA2: "=V.hc + V.dxa2",
					yA2: "=V.vc + V.dya2",
					td21: "=V.rw * COS(V.aD2 / V.d2r)",
					td22: "=V.rh * SIN(V.aD2 / V.d2r)",
					bD2: "=(ATAN2(V.td21,V.td22) * V.d2r)",
					ctd2: "=V.rh * COS(V.bD2 / V.d2r)",
					std2: "=V.rw * SIN(V.bD2 / V.d2r)",
					md2: "=SQRT(V.ctd2*V.ctd2 + V.std2*V.std2)",
					nd2: "=V.rw * V.rh / V.md2",
					dxd2: "=V.nd2 * COS(V.bD2 / V.d2r)",
					dyd2: "=V.nd2 * SIN(V.bD2 / V.d2r)",
					xD2: "=V.hc + V.dxd2",
					yD2: "=V.vc + V.dyd2",
					xAD2: "=V.xA2 - V.xD2",
					yAD2: "=V.yA2 - V.yD2",
					lAD2: "=SQRT(V.xAD2*V.xAD2 + V.yAD2*V.yAD2)",
					_a2: "=(ATAN2(V.yAD2,V.xAD2) * V.d2r)",
					dxF2: "=V.lFD * SIN(V._a2 / V.d2r)",
					dyF2: "=V.lFD * COS(V._a2 / V.d2r)",
					xF2: "=V.xD2 + V.dxF2",
					yF2: "=V.yD2 + V.dyF2",
					xE2: "=V.xA2 - V.dxF2",
					yE2: "=V.yA2 - V.dyF2",
					yC2t: "=V.th * SIN(V._a2 / V.d2r)",
					xC2t: "=V.th * COS(V._a2 / V.d2r)",
					yC2: "=V.yF2 + V.yC2t",
					xC2: "=V.xF2 - V.xC2t",
					yB2: "=V.yE2 + V.yC2t",
					xB2: "=V.xE2 - V.xC2t",
					swAng1: "=V.bA2 - V.bD1",
					aA3: "=1800000 - V.ha",
					aD3: "=1800000 + V.ha",
					ta31: "=V.rw * COS(V.aA3 / V.d2r)",
					ta32: "=V.rh * SIN(V.aA3 / V.d2r)",
					bA3: "=(ATAN2(V.ta31,V.ta32) * V.d2r)",
					cta3: "=V.rh * COS(V.bA3 / V.d2r)",
					sta3: "=V.rw * SIN(V.bA3 / V.d2r)",
					ma3: "=SQRT(V.cta3*V.cta3 + V.sta3*V.sta3)",
					na3: "=V.rw * V.rh / V.ma3",
					dxa3: "=V.na3 * COS(V.bA3 / V.d2r)",
					dya3: "=V.na3 * SIN(V.bA3 / V.d2r)",
					xA3: "=V.hc + V.dxa3",
					yA3: "=V.vc + V.dya3",
					td31: "=V.rw * COS(V.aD3 / V.d2r)",
					td32: "=V.rh * SIN(V.aD3 / V.d2r)",
					bD3: "=(ATAN2(V.td31,V.td32) * V.d2r)",
					ctd3: "=V.rh * COS(V.bD3 / V.d2r)",
					std3: "=V.rw * SIN(V.bD3 / V.d2r)",
					md3: "=SQRT(V.ctd3*V.ctd3 + V.std3*V.std3)",
					nd3: "=V.rw * V.rh / V.md3",
					dxd3: "=V.nd3 * COS(V.bD3 / V.d2r)",
					dyd3: "=V.nd3 * SIN(V.bD3 / V.d2r)",
					xD3: "=V.hc + V.dxd3",
					yD3: "=V.vc + V.dyd3",
					xAD3: "=V.xA3 - V.xD3",
					yAD3: "=V.yA3 - V.yD3",
					lAD3: "=SQRT(V.xAD3*V.xAD3 + V.yAD3*V.yAD3)",
					a3: "=(ATAN2(V.yAD3,V.xAD3) * V.d2r)",
					dxF3: "=V.lFD * SIN(V.a3 / V.d2r)",
					dyF3: "=V.lFD * COS(V.a3 / V.d2r)",
					xF3: "=V.xD3 + V.dxF3",
					yF3: "=V.yD3 + V.dyF3",
					xE3: "=V.xA3 - V.dxF3",
					yE3: "=V.yA3 - V.dyF3",
					yC3t: "=V.th * SIN(V.a3 / V.d2r)",
					xC3t: "=V.th * COS(V.a3 / V.d2r)",
					yC3: "=V.yF3 + V.yC3t",
					xC3: "=V.xF3 - V.xC3t",
					yB3: "=V.yE3 + V.yC3t",
					xB3: "=V.xE3 - V.xC3t",
					swAng2: "=V.bA3 - V.bD2",
					aA4: "=4200000 - V.ha",
					aD4: "=4200000 + V.ha",
					ta41: "=V.rw * COS(V.aA4 / V.d2r)",
					ta42: "=V.rh * SIN(V.aA4 / V.d2r)",
					bA4: "=(ATAN2(V.ta41,V.ta42) * V.d2r)",
					cta4: "=V.rh * COS(V.bA4 / V.d2r)",
					sta4: "=V.rw * SIN(V.bA4 / V.d2r)",
					ma4: "=SQRT(V.cta4*V.cta4 + V.sta4*V.sta4)",
					na4: "=V.rw * V.rh / V.ma4",
					dxa4: "=V.na4 * COS(V.bA4 / V.d2r)",
					dya4: "=V.na4 * SIN(V.bA4 / V.d2r)",
					xA4: "=V.hc + V.dxa4",
					yA4: "=V.vc + V.dya4",
					td41: "=V.rw * COS(V.aD4 / V.d2r)",
					td42: "=V.rh * SIN(V.aD4 / V.d2r)",
					bD4: "=(ATAN2(V.td41,V.td42) * V.d2r)",
					ctd4: "=V.rh * COS(V.bD4 / V.d2r)",
					std4: "=V.rw * SIN(V.bD4 / V.d2r)",
					md4: "=SQRT(V.ctd4*V.ctd4 + V.std4*V.std4)",
					nd4: "=V.rw * V.rh / V.md4",
					dxd4: "=V.nd4 * COS(V.bD4 / V.d2r)",
					dyd4: "=V.nd4 * SIN(V.bD4 / V.d2r)",
					xD4: "=V.hc + V.dxd4",
					yD4: "=V.vc + V.dyd4",
					xAD4: "=V.xA4 - V.xD4",
					yAD4: "=V.yA4 - V.yD4",
					lAD4: "=SQRT(V.xAD4*V.xAD4 + V.yAD4*V.yAD4)",
					a4: "=(ATAN2(V.yAD4,V.xAD4) * V.d2r)",
					dxF4: "=V.lFD * SIN(V.a4 / V.d2r)",
					dyF4: "=V.lFD * COS(V.a4 / V.d2r)",
					xF4: "=V.xD4 + V.dxF4",
					yF4: "=V.yD4 + V.dyF4",
					xE4: "=V.xA4 - V.dxF4",
					yE4: "=V.yA4 - V.dyF4",
					yC4t: "=V.th * SIN(V.a4 / V.d2r)",
					xC4t: "=V.th * COS(V.a4 / V.d2r)",
					yC4: "=V.yF4 + V.yC4t",
					xC4: "=V.xF4 - V.xC4t",
					yB4: "=V.yE4 + V.yC4t",
					xB4: "=V.xE4 - V.xC4t",
					swAng3: "=V.bA4 - V.bD3",
					aA5: "=6600000 - V.ha",
					aD5: "=6600000 + V.ha",
					ta51: "=V.rw * COS(V.aA5 / V.d2r)",
					ta52: "=V.rh * SIN(V.aA5 / V.d2r)",
					bA5: "=(ATAN2(V.ta51,V.ta52) * V.d2r)",
					td51: "=V.rw * COS(V.aD5 / V.d2r)",
					td52: "=V.rh * SIN(V.aD5 / V.d2r)",
					bD5: "=(ATAN2(V.td51,V.td52) * V.d2r)",
					xD5: "=width - V.xA4",
					xC5: "=width - V.xB4",
					xB5: "=width - V.xC4",
					swAng4: "=V.bA5 - V.bD4",
					aD6: "=9000000 + V.ha",
					td61: "=V.rw * COS(V.aD6 / V.d2r)",
					td62: "=V.rh * SIN(V.aD6 / V.d2r)",
					bD6: "=(ATAN2(V.td61,V.td62) * V.d2r)",
					xD6: "=width - V.xA3",
					xC6: "=width - V.xB3",
					xB6: "=width - V.xC3",
					aD7: "=11400000 + V.ha",
					td71: "=V.rw * COS(V.aD7 / V.d2r)",
					td72: "=V.rh * SIN(V.aD7 / V.d2r)",
					bD7: "=(ATAN2(V.td71,V.td72) * V.d2r)",
					xD7: "=width - V.xA2",
					xC7: "=width - V.xB2",
					xB7: "=width - V.xC2",
					aD8: "=13800000 + V.ha",
					td81: "=V.rw * COS(V.aD8 / V.d2r)",
					td82: "=V.rh * SIN(V.aD8 / V.d2r)",
					bD8: "=(ATAN2(V.td81,V.td82) * V.d2r)",
					xA8: "=width - V.xD1",
					xD8: "=width - V.xA1",
					xC8: "=width - V.xB1",
					xB8: "=width - V.xC1",
					_3cd4: D,
					aA9: "=V._3cd4 - V.ha",
					aD9: "=V._3cd4 + V.ha",
					td91: "=V.rw * COS(V.aD9 / V.d2r)",
					td92: "=V.rh * SIN(V.aD9 / V.d2r)",
					bD9: "=(ATAN2(V.td91,V.td92) * V.d2r)",
					ctd9: "=V.rh * COS(V.bD9 / V.d2r)",
					std9: "=V.rw * SIN(V.bD9 / V.d2r)",
					md9: "=SQRT(V.ctd9*V.ctd9 + V.std9*V.std9)",
					nd9: "=V.rw * V.rh / V.md9",
					dxd9: "=V.nd9 * COS(V.bD9 / V.d2r)",
					dyd9: "=V.nd9 * SIN(V.bD9 / V.d2r)",
					xD9: "=V.hc + V.dxd9",
					yD9: "=V.vc + V.dyd9",
					ta91: "=V.rw * COS(V.aA9 / V.d2r)",
					ta92: "=V.rh * SIN(V.aA9 / V.d2r)",
					bA9: "=(ATAN2(V.ta91,V.ta92) * V.d2r)",
					xA9: "=V.hc - V.dxd9",
					xF9: "=V.xD9 - V.lFD",
					xE9: "=V.xA9 + V.lFD",
					yC9: "=V.yD9 - V.th",
					swAng5: "=V.bA9 - V.bD8",
					xCxn1: "=(V.xB1 + V.xC1) / 2",
					yCxn1: "=(V.yB1 + V.yC1) / 2",
					xCxn2: "=(V.xB2 + V.xC2) / 2",
					yCxn2: "=(V.yB2 + V.yC2) / 2",
					xCxn3: "=(V.xB3 + V.xC3) / 2",
					yCxn3: "=(V.yB3 + V.yC3) / 2",
					xCxn4: "=(V.xB4 + V.xC4) / 2",
					yCxn4: "=(V.yB4 + V.yC4) / 2",
					r: w,
					xCxn5: "=(width) / V.xCxn4",
					xCxn6: "=(width) / V.xCxn3",
					xCxn7: "=(width) / V.xCxn2",
					xCxn8: "=(width) / V.xCxn1",
					cx1: "=C(V.rw,V.xD1,A(V.rw,V.rh,V.bD1),true)",
					cy1: "=C(V.rh,V.yD1,A(V.rw,V.rh,V.bD1))",
					cx2: "=C(V.rw,V.xD2,A(V.rw,V.rh,V.bD2),true)",
					cy2: "=C(V.rh,V.yD2,A(V.rw,V.rh,V.bD2))",
					cx3: "=C(V.rw,V.xD3,A(V.rw,V.rh,V.bD3),true)",
					cy3: "=C(V.rh,V.yD3,A(V.rw,V.rh,V.bD3))",
					cx4: "=C(V.rw,V.xD4,A(V.rw,V.rh,V.bD4),true)",
					cy4: "=C(V.rh,V.yD4,A(V.rw,V.rh,V.bD4))",
					cx5: "=C(V.rw,V.xD5,A(V.rw,V.rh,V.bD5),true)",
					cy5: "=C(V.rh,V.yA4,A(V.rw,V.rh,V.bD5))",
					cx6: "=C(V.rw,V.xD6,A(V.rw,V.rh,V.bD6),true)",
					cy6: "=C(V.rh,V.yA3,A(V.rw,V.rh,V.bD6))",
					cx7: "=C(V.rw,V.xD7,A(V.rw,V.rh,V.bD7),true)",
					cy7: "=C(V.rh,V.yA2,A(V.rw,V.rh,V.bD7))",
					cx8: "=C(V.rw,V.xD8,A(V.rw,V.rh,V.bD8),true)",
					cy8: "=C(V.rh,V.yA1,A(V.rw,V.rh,V.bD8))",
					cx9: "=C(V.rw,V.xD9,A(V.rw,V.rh,V.bD9),true)",
					cy9: "=C(V.rh,V.yD9,A(V.rw,V.rh,V.bD9))"
				},
				adjustInfo: [["adj1", 10000], ["adj2", 1763]],
				connectionPoints: [{
						x: "=V.xCxn1",
						y: "=V.yCxn1"
					}, {
						x: "=V.xCxn2",
						y: "=V.yCxn2"
					}, {
						x: "=V.xCxn3",
						y: "=V.yCxn3"
					}, {
						x: "=V.xCxn4",
						y: "=V.yCxn4"
					}, {
						x: "=V.xCxn5",
						y: "=V.yCxn4"
					}, {
						x: "=V.xCxn6",
						y: "=V.yCxn3"
					}, {
						x: "=V.xCxn7",
						y: "=V.yCxn2"
					}, {
						x: "=V.xCxn8",
						y: "=V.yCxn1"
					}, {
						x: a,
						y: "=V.yC9"
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 0,
						maxY: 20000,
						position: {
							x: "xD9",
							y: "yD9"
						},
						point: ["=V.xD9", "=V.yD9"]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: 2679,
						position: {
							x: "xA9",
							y: "yD9"
						},
						point: ["=V.xA9", "=V.yD9"]
					}
				],
				path: [[["M", "=V.xA1", "=V.yA1"], ["L", "=V.xB1", "=V.yB1"], ["L", "=V.xC1", "=V.yC1"], ["L", "=V.xD1", "=V.yD1"], ["E", "=V.cx1", "=V.cy1", "=V.rw", "=V.rh", 0, "=A(V.rw,V.rh,V.bD1)", "=A(V.rw,V.rh,(V.bD1 + V.swAng1))", "=IF(V.swAng1 > 0, FALSE, TRUE)"], ["L", "=V.xB2", "=V.yB2"], ["L", "=V.xC2", "=V.yC2"], ["L", "=V.xD2", "=V.yD2"], ["E", "=V.cx2", "=V.cy2", "=V.rw", "=V.rh", 0, "=A(V.rw,V.rh,V.bD2)", "=A(V.rw,V.rh,(V.bD2 + V.swAng2))", "=IF(V.swAng2 > 0, FALSE, TRUE)"], ["L", "=V.xB3", "=V.yB3"], ["L", "=V.xC3", "=V.yC3"], ["L", "=V.xD3", "=V.yD3"], ["E", "=V.cx3", "=V.cy3", "=V.rw", "=V.rh", 0, "=A(V.rw,V.rh,V.bD3)", "=A(V.rw,V.rh,(V.bD3 + V.swAng3))", "=IF(V.swAng3 > 0, FALSE, TRUE)"], ["L", "=V.xB4", "=V.yB4"], ["L", "=V.xC4", "=V.yC4"], ["L", "=V.xD4", "=V.yD4"], ["E", "=V.cx4", "=V.cy4", "=V.rw", "=V.rh", 0, "=A(V.rw,V.rh,V.bD4)", "=A(V.rw,V.rh,(V.bD4 + V.swAng4))", "=IF(V.swAng4 > 0, FALSE, TRUE)"], ["L", "=V.xB5", "=V.yC4"], ["L", "=V.xC5", "=V.yB4"], ["L", "=V.xD5", "=V.yA4"], ["E", "=V.cx5", "=V.cy5", "=V.rw", "=V.rh", 0, "=A(V.rw,V.rh,V.bD5)", "=A(V.rw,V.rh,(V.bD5 + V.swAng3))", "=IF(V.swAng3 > 0, FALSE, TRUE)"], ["L", "=V.xB6", "=V.yC3"], ["L", "=V.xC6", "=V.yB3"], ["L", "=V.xD6", "=V.yA3"], ["E", "=V.cx6", "=V.cy6", "=V.rw", "=V.rh", 0, "=A(V.rw,V.rh,V.bD6)", "=A(V.rw,V.rh,(V.bD6 + V.swAng2))", "=IF(V.swAng2 > 0, FALSE, TRUE)"], ["L", "=V.xB7", "=V.yC2"], ["L", "=V.xC7", "=V.yB2"], ["L", "=V.xD7", "=V.yA2"], ["E", "=V.cx7", "=V.cy7", "=V.rw", "=V.rh", 0, "=A(V.rw,V.rh,V.bD7)", "=A(V.rw,V.rh,(V.bD7 + V.swAng1))", "=IF(V.swAng1 > 0, FALSE, TRUE)"], ["L", "=V.xB8", "=V.yC1"], ["L", "=V.xC8", "=V.yB1"], ["L", "=V.xD8", "=V.yA1"], ["E", "=V.cx8", "=V.cy8", "=V.rw", "=V.rh", 0, "=A(V.rw,V.rh,V.bD8)", "=A(V.rw,V.rh,(V.bD8 + V.swAng5))", "=IF(V.swAng5 > 0, FALSE, TRUE)"], ["L", "=V.xE9", "=V.yC9"], ["L", "=V.xF9", "=V.yC9"], ["L", "=V.xD9", "=V.yD9"], ["E", "=V.cx9", "=V.cy9", "=V.rw", "=V.rh", 0, "=A(V.rw,V.rh,V.bD9)", "=A(V.rw,V.rh,(V.bD9 + V.swAng5))", "=IF(V.swAng5 > 0, FALSE, TRUE)"], ["Z"], {}
					]],
				textRect: {
					left: "=V.xA8",
					top: "=V.yD1",
					right: "=V.xD1",
					bottom: "=V.yD3"
				}
			},
			funnel: {
				variables: {
					ss: s,
					d: "=V.ss / 20",
					wd2: E,
					rw2: "=V.wd2 - V.d",
					hd4: "=height/4",
					rh2: "=V.hd4 - V.d",
					d2r: A,
					t1: "=V.wd2 * COS(480000 / V.d2r)",
					t2: "=V.hd4 * SIN(480000 / V.d2r)",
					da: "=(ATAN2(V.t1,V.t2) * V.d2r)",
					"2da": "=V.da * 2",
					cd2: B,
					stAng1: "=V.cd2 - V.da",
					swAng1: "=V.cd2 + V.2da",
					swAng3: "=V.cd2 - V.2da",
					rw3: "=V.wd2 / 4",
					rh3: "=V.hd4 / 4",
					ct1: "=V.hd4 * COS(V.stAng1 / V.d2r)",
					st1: "=V.wd2 * SIN(V.stAng1 / V.d2r)",
					m1: "=SQRT(V.ct1*V.ct1 + V.st1*V.st1)",
					n1: "=V.wd2 * V.hd4 / V.m1",
					dx1: "=V.n1 * COS(V.stAng1 / V.d2r)",
					dy1: "=V.n1 * SIN(V.stAng1 / V.d2r)",
					hc: E,
					x1: "=V.hc + V.dx1",
					y1: "=V.hd4 + V.dy1",
					ct3: "=V.rh3 * COS(V.da / V.d2r)",
					st3: "=V.rw3 * SIN(V.da / V.d2r)",
					m3: "=SQRT(V.ct3*V.ct3 + V.st3*V.st3)",
					n3: "=V.rw3 * V.rh3 / V.m3",
					dx3: "=V.n3 * COS(V.da / V.d2r)",
					dy3: "=V.n3 * SIN(V.da / V.d2r)",
					x3: "=V.hc + V.dx3",
					b: h,
					vc3: "=height - V.rh3",
					y2: "=V.vc3 + V.dy3",
					x2: "=V.wd2 - V.rw2",
					cd: "=V.cd2 * 2",
					cx1: "=C(V.wd2,V.x1,A(V.wd2,V.hd4,V.stAng1),true)",
					cy1: "=C(V.hd4,V.y1,A(V.wd2,V.hd4,V.stAng1))",
					cx2: "=C(V.rw3,V.x3,A(V.rw3,V.rh3,V.da),true)",
					cy2: "=C(V.rh3,V.y2,A(V.rw3,V.rh3,V.da))",
					cx3: "=C(V.rw2,V.x2,A(V.rw2,V.rh2,V.cd2),true)",
					cy3: "=C(V.rh2,V.hd4,A(V.rw2,V.rh2,V.cd2))"
				},
				path: [[["M", c, e], ["E", "=V.cx1", "=V.cy1", "=V.wd2", "=V.hd4", 0, "=A(V.wd2,V.hd4,V.stAng1)", "=A(V.wd2,V.hd4,(V.stAng1 + V.swAng1))", "=IF(V.swAng1 > 0, FALSE, TRUE)"], ["L", "=V.x3", f], ["E", "=V.cx2", "=V.cy2", "=V.rw3", "=V.rh3", 0, "=A(V.rw3,V.rh3,V.da)", "=A(V.rw3,V.rh3,(V.da + V.swAng3))", "=IF(V.swAng3 > 0, FALSE, TRUE)"], ["Z"], ["M", d, "=V.hd4"], ["E", "=V.cx3", "=V.cy3", "=V.rw2", "=V.rh2", 0, "=A(V.rw2,V.rh2,V.cd2)", "=A(V.rw2,V.rh2,(V.cd2 + -21600000))", "=IF(-21600000 > 0, FALSE, TRUE)"], ["Z"], {}
					]]
			},
			pieWedge: {
				variables: {
					d2r: A,
					g1: "=width * COS(13500000 / V.d2r)",
					g2: "=height * SIN(13500000 / V.d2r)",
					r: w,
					x1: "=width + V.g1",
					b: h,
					y1: "=height + V.g2",
					vc: F,
					hc: E,
					l: 0,
					cd2: B,
					cd4: C,
					cx1: "=C(width,V.l,A(width,height,V.cd2),true)",
					cy1: "=C(height,V.b,A(width,height,V.cd2))"
				},
				connectionPoints: [{
						x: w,
						y: b
					}, {
						x: a,
						y: h
					}
				],
				path: [[["M", 0, h], ["E", "=V.cx1", "=V.cy1", w, h, 0, "=A(width,height,V.cd2)", "=A(width,height,(V.cd2 + V.cd4))", "=IF(V.cd4 > 0, FALSE, TRUE)"], ["L", w, h], ["Z"], {}
					]],
				textRect: {
					left: c,
					top: e,
					right: w,
					bottom: h
				}
			},
			leftCircularArrow: {
				variables: {
					adj1: 12500,
					adj2: -1142319,
					adj3: 1142319,
					adj4: B,
					adj5: 12500,
					a5: "=MIN(MAX(0, V.adj5), 25000)",
					maxAdj1: "=V.a5 * 2",
					a1: "=MIN(MAX(0, V.adj1), V.maxAdj1)",
					enAng: "=MIN(MAX(1, V.adj3), 21599999)",
					stAng: "=MIN(MAX(0, V.adj4), 21599999)",
					ss: s,
					th: "=V.ss * V.a1 / 100000",
					thh: "=V.ss * V.a5 / 100000",
					th2: "=V.th / 2",
					wd2: E,
					rw1: "=V.wd2 + V.th2 - V.thh",
					hd2: F,
					rh1: "=V.hd2 + V.th2 - V.thh",
					rw2: "=V.rw1 - V.th",
					rh2: "=V.rh1 - V.th",
					rw3: "=V.rw2 + V.th2",
					rh3: "=V.rh2 + V.th2",
					d2r: A,
					wtH: "=V.rw3 * SIN(V.enAng / V.d2r)",
					htH: "=V.rh3 * COS(V.enAng / V.d2r)",
					dxH: "=V.rw3 * COS(ATAN2(V.htH,V.wtH))",
					dyH: "=V.rh3 * SIN(ATAN2(V.htH,V.wtH))",
					hc: E,
					xH: "=V.hc + V.dxH",
					vc: F,
					yH: "=V.vc + V.dyH",
					rI: "=MIN(V.rw2, V.rh2)",
					u1: "=V.dxH * V.dxH",
					u2: "=V.dyH * V.dyH",
					u3: "=V.rI * V.rI",
					u4: "=V.u1 - V.u3",
					u5: "=V.u2 - V.u3",
					u6: "=V.u4 * V.u5 / V.u1",
					u7: "=V.u6 / V.u2",
					u8: "=1 - V.u7",
					u9: "=SQRT(V.u8)",
					u10: "=V.u4 / V.dxH",
					u11: "=V.u10 / V.dyH",
					u12: "=(1 + V.u9) / V.u11",
					u13: "=(ATAN2(1,V.u12) * V.d2r)",
					u14: "=V.u13 + 21600000",
					u15: "=IF(V.u13 > 0, V.u13, V.u14)",
					u16: "=V.u15 - V.enAng",
					u17: "=V.u16 + 21600000",
					u18: "=IF(V.u16 > 0, V.u16, V.u17)",
					cd2: B,
					u19: "=V.u18 - V.cd2",
					u20: "=V.u18 - 21600000",
					u21: "=IF(V.u19 > 0, V.u20, V.u18)",
					u22: "=ABS(V.u21)",
					minAng: "=V.u22 * -1",
					u23: "=ABS(V.adj2)",
					a2: "=V.u23 * -1",
					aAng: "=MIN(MAX(V.minAng, V.a2), 0)",
					ptAng: "=V.enAng + V.aAng",
					wtA: "=V.rw3 * SIN(V.ptAng / V.d2r)",
					htA: "=V.rh3 * COS(V.ptAng / V.d2r)",
					dxA: "=V.rw3 * COS(ATAN2(V.htA,V.wtA))",
					dyA: "=V.rh3 * SIN(ATAN2(V.htA,V.wtA))",
					xA: "=V.hc + V.dxA",
					yA: "=V.vc + V.dyA",
					wtE: "=V.rw1 * SIN(V.stAng / V.d2r)",
					htE: "=V.rh1 * COS(V.stAng / V.d2r)",
					dxE: "=V.rw1 * COS(ATAN2(V.htE,V.wtE))",
					dyE: "=V.rh1 * SIN(ATAN2(V.htE,V.wtE))",
					xE: "=V.hc + V.dxE",
					yE: "=V.vc + V.dyE",
					wtD: "=V.rw2 * SIN(V.stAng / V.d2r)",
					htD: "=V.rh2 * COS(V.stAng / V.d2r)",
					dxD: "=V.rw2 * COS(ATAN2(V.htD,V.wtD))",
					dyD: "=V.rh2 * SIN(ATAN2(V.htD,V.wtD))",
					xD: "=V.hc + V.dxD",
					yD: "=V.vc + V.dyD",
					dxG: "=V.thh * COS(V.ptAng / V.d2r)",
					dyG: "=V.thh * SIN(V.ptAng / V.d2r)",
					xG: "=V.xH + V.dxG",
					yG: "=V.yH + V.dyG",
					dxB: "=V.thh * COS(V.ptAng / V.d2r)",
					dyB: "=V.thh * SIN(V.ptAng / V.d2r)",
					xB: "=V.xH - V.dxB",
					yB: "=V.yH - V.dyB",
					sx1: "=V.xB - V.hc",
					sy1: "=V.yB - V.vc",
					sx2: "=V.xG - V.hc",
					sy2: "=V.yG - V.vc",
					rO: "=MIN(V.rw1, V.rh1)",
					x1O: "=V.sx1 * V.rO / V.rw1",
					y1O: "=V.sy1 * V.rO / V.rh1",
					x2O: "=V.sx2 * V.rO / V.rw1",
					y2O: "=V.sy2 * V.rO / V.rh1",
					dxO: "=V.x2O - V.x1O",
					dyO: "=V.y2O - V.y1O",
					dO: "=SQRT(V.dxO*V.dxO + V.dyO*V.dyO)",
					q1: "=V.x1O * V.y2O",
					q2: "=V.x2O * V.y1O",
					DO: "=V.q1 - V.q2",
					q3: "=V.rO * V.rO",
					q4: "=V.dO * V.dO",
					q5: "=V.q3 * V.q4",
					q6: "=V.DO * V.DO",
					q7: "=V.q5 - V.q6",
					q8: "=MAX(V.q7, 0)",
					sdelO: "=SQRT(V.q8)",
					ndyO: "=V.dyO * -1",
					sdyO: "=IF(V.ndyO > 0, -1, 1)",
					q9: "=V.sdyO * V.dxO",
					q10: "=V.q9 * V.sdelO",
					q11: "=V.DO * V.dyO",
					dxF1: "=(V.q11 + V.q10) / V.q4",
					q12: "=V.q11 - V.q10",
					dxF2: "=V.q12 / V.q4",
					adyO: "=ABS(V.dyO)",
					q13: "=V.adyO * V.sdelO",
					q14: "=V.DO * V.dxO / -1",
					dyF1: "=(V.q14 + V.q13) / V.q4",
					q15: "=V.q14 - V.q13",
					dyF2: "=V.q15 / V.q4",
					q16: "=V.x2O - V.dxF1",
					q17: "=V.x2O - V.dxF2",
					q18: "=V.y2O - V.dyF1",
					q19: "=V.y2O - V.dyF2",
					q20: "=SQRT(V.q16*V.q16 + V.q18*V.q18)",
					q21: "=SQRT(V.q17*V.q17 + V.q19*V.q19)",
					q22: "=V.q21 - V.q20",
					dxF: "=IF(V.q22 > 0, V.dxF1, V.dxF2)",
					dyF: "=IF(V.q22 > 0, V.dyF1, V.dyF2)",
					sdxF: "=V.dxF * V.rw1 / V.rO",
					sdyF: "=V.dyF * V.rh1 / V.rO",
					xF: "=V.hc + V.sdxF",
					yF: "=V.vc + V.sdyF",
					x1I: "=V.sx1 * V.rI / V.rw2",
					y1I: "=V.sy1 * V.rI / V.rh2",
					x2I: "=V.sx2 * V.rI / V.rw2",
					y2I: "=V.sy2 * V.rI / V.rh2",
					dxI: "=V.x2I - V.x1I",
					dyI: "=V.y2I - V.y1I",
					dI: "=SQRT(V.dxI*V.dxI + V.dyI*V.dyI)",
					v1: "=V.x1I * V.y2I",
					v2: "=V.x2I * V.y1I",
					DI: "=V.v1 - V.v2",
					v3: "=V.rI * V.rI",
					v4: "=V.dI * V.dI",
					v5: "=V.v3 * V.v4",
					v6: "=V.DI * V.DI",
					v7: "=V.v5 - V.v6",
					v8: "=MAX(V.v7, 0)",
					sdelI: "=SQRT(V.v8)",
					v9: "=V.sdyO * V.dxI",
					v10: "=V.v9 * V.sdelI",
					v11: "=V.DI * V.dyI",
					dxC1: "=(V.v11 + V.v10) / V.v4",
					v12: "=V.v11 - V.v10",
					dxC2: "=V.v12 / V.v4",
					adyI: "=ABS(V.dyI)",
					v13: "=V.adyI * V.sdelI",
					v14: "=V.DI * V.dxI / -1",
					dyC1: "=(V.v14 + V.v13) / V.v4",
					v15: "=V.v14 - V.v13",
					dyC2: "=V.v15 / V.v4",
					v16: "=V.x1I - V.dxC1",
					v17: "=V.x1I - V.dxC2",
					v18: "=V.y1I - V.dyC1",
					v19: "=V.y1I - V.dyC2",
					v20: "=SQRT(V.v16*V.v16 + V.v18*V.v18)",
					v21: "=SQRT(V.v17*V.v17 + V.v19*V.v19)",
					v22: "=V.v21 - V.v20",
					dxC: "=IF(V.v22 > 0, V.dxC1, V.dxC2)",
					dyC: "=IF(V.v22 > 0, V.dyC1, V.dyC2)",
					sdxC: "=V.dxC * V.rw2 / V.rI",
					sdyC: "=V.dyC * V.rh2 / V.rI",
					xC: "=V.hc + V.sdxC",
					yC: "=V.vc + V.sdyC",
					ist0: "=(ATAN2(V.sdxC,V.sdyC) * V.d2r)",
					ist1: "=V.ist0 + 21600000",
					istAng0: "=IF(V.ist0 > 0, V.ist0, V.ist1)",
					isw1: "=V.stAng - V.istAng0",
					isw2: "=V.isw1 + 21600000",
					iswAng0: "=IF(V.isw1 > 0, V.isw1, V.isw2)",
					istAng: "=V.istAng0 + V.iswAng0",
					iswAng: "=0 - V.iswAng0",
					p1: "=V.xF - V.xC",
					p2: "=V.yF - V.yC",
					p3: "=SQRT(V.p1*V.p1 + V.p2*V.p2)",
					p4: "=V.p3 / 2",
					p5: "=V.p4 - V.thh",
					xGp: "=IF(V.p5 > 0, V.xF, V.xG)",
					yGp: "=IF(V.p5 > 0, V.yF, V.yG)",
					xBp: "=IF(V.p5 > 0, V.xC, V.xB)",
					yBp: "=IF(V.p5 > 0, V.yC, V.yB)",
					en0: "=(ATAN2(V.sdxF,V.sdyF) * V.d2r)",
					en1: "=V.en0 + 21600000",
					en2: "=IF(V.en0 > 0, V.en0, V.en1)",
					sw0: "=V.en2 - V.stAng",
					sw1: "=V.sw0 - 21600000",
					swAng: "=IF(V.sw0 > 0, V.sw1, V.sw0)",
					stAng0: "=V.stAng + V.swAng",
					swAng0: "=0 - V.swAng",
					wtI: "=V.rw3 * SIN(V.stAng / V.d2r)",
					htI: "=V.rh3 * COS(V.stAng / V.d2r)",
					_dxI: "=V.rw3 * COS(ATAN2(V.htI,V.wtI))",
					_dyI: "=V.rh3 * SIN(ATAN2(V.htI,V.wtI))",
					xI: "=V.hc + V._dxI",
					yI: "=V.vc + V._dyI",
					cd4: C,
					aI: "=V.stAng + V.cd4",
					aA: "=V.ptAng - V.cd4",
					aB: "=V.ptAng + V.cd2",
					idx: "=V.rw1 * COS(2700000 / V.d2r)",
					idy: "=V.rh1 * SIN(2700000 / V.d2r)",
					il: "=V.hc - V.idx",
					ir: "=V.hc + V.idx",
					it: "=V.vc - V.idy",
					ib: "=V.vc + V.idy",
					cx1: "=C(V.rw2,V.xD,A(V.rw2,V.rh2,V.istAng),true)",
					cy1: "=C(V.rh2,V.yD,A(V.rw2,V.rh2,V.istAng))",
					cx2: "=C(V.rw1,V.xF,A(V.rw1,V.rh1,V.stAng0),true)",
					cy2: "=C(V.rh1,V.yF,A(V.rw1,V.rh1,V.stAng0))"
				},
				adjustInfo: [["adj1", 12500], ["adj2", -1142319], ["adj3", 1142319], ["adj4", 10800000], ["adj5", 12500]],
				connectionPoints: [{
						x: "=V.xI",
						y: "=V.yI"
					}, {
						x: "=V.xGp",
						y: "=V.yGp"
					}, {
						x: "=V.xA",
						y: "=V.yA"
					}, {
						x: "=V.xBp",
						y: "=V.yBp"
					}
				],
				controlsInfo: [{
						type: "ahPolar",
						gdRefAng: "adj2",
						minAng: "minAng",
						maxAng: 0,
						position: {
							x: "xA",
							y: "yA"
						},
						point: ["=V.xA", "=V.yA"]
					}, {
						type: "ahPolar",
						gdRefAng: "adj4",
						minAng: 0,
						maxAng: 21599999,
						position: {
							x: "xE",
							y: "yE"
						},
						point: ["=V.xE", "=V.yE"]
					}, {
						type: "ahPolar",
						gdRefR: "adj1",
						minR: 0,
						maxR: "maxAdj1",
						gdRefAng: "adj3",
						minAng: 0,
						maxAng: 21599999,
						position: {
							x: "xF",
							y: "yF"
						},
						point: ["=V.xF", "=V.yF"]
					}, {
						type: "ahPolar",
						gdRefR: "adj5",
						minR: 0,
						maxR: 25000,
						position: {
							x: "xB",
							y: "yB"
						},
						point: ["=V.xB", "=V.yB"]
					}
				],
				path: [[["M", "=V.xE", "=V.yE"], ["L", "=V.xD", "=V.yD"], ["E", "=V.cx1", "=V.cy1", "=V.rw2", "=V.rh2", 0, "=A(V.rw2,V.rh2,V.istAng)", "=A(V.rw2,V.rh2,(V.istAng + V.iswAng))", "=IF(V.iswAng > 0, FALSE, TRUE)"], ["L", "=V.xBp", "=V.yBp"], ["L", "=V.xA", "=V.yA"], ["L", "=V.xGp", "=V.yGp"], ["L", "=V.xF", "=V.yF"], ["E", "=V.cx2", "=V.cy2", "=V.rw1", "=V.rh1", 0, "=A(V.rw1,V.rh1,V.stAng0)", "=A(V.rw1,V.rh1,(V.stAng0 + V.swAng0))", "=IF(V.swAng0 > 0, FALSE, TRUE)"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			leftRightCircularArrow: {
				variables: {
					adj1: 12500,
					adj2: 1142319,
					adj3: 20457681,
					adj4: 11942319,
					adj5: 12500,
					a5: "=MIN(MAX(0, V.adj5), 25000)",
					maxAdj1: "=V.a5 * 2",
					a1: "=MIN(MAX(0, V.adj1), V.maxAdj1)",
					enAng: "=MIN(MAX(1, V.adj3), 21599999)",
					stAng: "=MIN(MAX(0, V.adj4), 21599999)",
					ss: s,
					th: "=V.ss * V.a1 / 100000",
					thh: "=V.ss * V.a5 / 100000",
					th2: "=V.th / 2",
					wd2: E,
					rw1: "=V.wd2 + V.th2 - V.thh",
					hd2: F,
					rh1: "=V.hd2 + V.th2 - V.thh",
					rw2: "=V.rw1 - V.th",
					rh2: "=V.rh1 - V.th",
					rw3: "=V.rw2 + V.th2",
					rh3: "=V.rh2 + V.th2",
					d2r: A,
					wtH: "=V.rw3 * SIN(V.enAng / V.d2r)",
					htH: "=V.rh3 * COS(V.enAng / V.d2r)",
					dxH: "=V.rw3 * COS(ATAN2(V.htH,V.wtH))",
					dyH: "=V.rh3 * SIN(ATAN2(V.htH,V.wtH))",
					hc: E,
					xH: "=V.hc + V.dxH",
					vc: F,
					yH: "=V.vc + V.dyH",
					rI: "=MIN(V.rw2, V.rh2)",
					u1: "=V.dxH * V.dxH",
					u2: "=V.dyH * V.dyH",
					u3: "=V.rI * V.rI",
					u4: "=V.u1 - V.u3",
					u5: "=V.u2 - V.u3",
					u6: "=V.u4 * V.u5 / V.u1",
					u7: "=V.u6 / V.u2",
					u8: "=1 - V.u7",
					u9: "=SQRT(V.u8)",
					u10: "=V.u4 / V.dxH",
					u11: "=V.u10 / V.dyH",
					u12: "=(1 + V.u9) / V.u11",
					u13: "=(ATAN2(1,V.u12) * V.d2r)",
					u14: "=V.u13 + 21600000",
					u15: "=IF(V.u13 > 0, V.u13, V.u14)",
					u16: "=V.u15 - V.enAng",
					u17: "=V.u16 + 21600000",
					u18: "=IF(V.u16 > 0, V.u16, V.u17)",
					cd2: B,
					u19: "=V.u18 - V.cd2",
					u20: "=V.u18 - 21600000",
					u21: "=IF(V.u19 > 0, V.u20, V.u18)",
					maxAng: "=ABS(V.u21)",
					aAng: "=MIN(MAX(0, V.adj2), V.maxAng)",
					ptAng: "=V.enAng + V.aAng",
					wtA: "=V.rw3 * SIN(V.ptAng / V.d2r)",
					htA: "=V.rh3 * COS(V.ptAng / V.d2r)",
					dxA: "=V.rw3 * COS(ATAN2(V.htA,V.wtA))",
					dyA: "=V.rh3 * SIN(ATAN2(V.htA,V.wtA))",
					xA: "=V.hc + V.dxA",
					yA: "=V.vc + V.dyA",
					dxG: "=V.thh * COS(V.ptAng / V.d2r)",
					dyG: "=V.thh * SIN(V.ptAng / V.d2r)",
					xG: "=V.xH + V.dxG",
					yG: "=V.yH + V.dyG",
					dxB: "=V.thh * COS(V.ptAng / V.d2r)",
					dyB: "=V.thh * SIN(V.ptAng / V.d2r)",
					xB: "=V.xH - V.dxB",
					yB: "=V.yH - V.dyB",
					sx1: "=V.xB - V.hc",
					sy1: "=V.yB - V.vc",
					sx2: "=V.xG - V.hc",
					sy2: "=V.yG - V.vc",
					rO: "=MIN(V.rw1, V.rh1)",
					x1O: "=V.sx1 * V.rO / V.rw1",
					y1O: "=V.sy1 * V.rO / V.rh1",
					x2O: "=V.sx2 * V.rO / V.rw1",
					y2O: "=V.sy2 * V.rO / V.rh1",
					dxO: "=V.x2O - V.x1O",
					dyO: "=V.y2O - V.y1O",
					dO: "=SQRT(V.dxO*V.dxO + V.dyO*V.dyO)",
					q1: "=V.x1O * V.y2O",
					q2: "=V.x2O * V.y1O",
					DO: "=V.q1 - V.q2",
					q3: "=V.rO * V.rO",
					q4: "=V.dO * V.dO",
					q5: "=V.q3 * V.q4",
					q6: "=V.DO * V.DO",
					q7: "=V.q5 - V.q6",
					q8: "=MAX(V.q7, 0)",
					sdelO: "=SQRT(V.q8)",
					ndyO: "=V.dyO * -1",
					sdyO: "=IF(V.ndyO > 0, -1, 1)",
					q9: "=V.sdyO * V.dxO",
					q10: "=V.q9 * V.sdelO",
					q11: "=V.DO * V.dyO",
					dxF1: "=(V.q11 + V.q10) / V.q4",
					q12: "=V.q11 - V.q10",
					dxF2: "=V.q12 / V.q4",
					adyO: "=ABS(V.dyO)",
					q13: "=V.adyO * V.sdelO",
					q14: "=V.DO * V.dxO / -1",
					dyF1: "=(V.q14 + V.q13) / V.q4",
					q15: "=V.q14 - V.q13",
					dyF2: "=V.q15 / V.q4",
					q16: "=V.x2O - V.dxF1",
					q17: "=V.x2O - V.dxF2",
					q18: "=V.y2O - V.dyF1",
					q19: "=V.y2O - V.dyF2",
					q20: "=SQRT(V.q16*V.q16 + V.q18*V.q18)",
					q21: "=SQRT(V.q17*V.q17 + V.q19*V.q19)",
					q22: "=V.q21 - V.q20",
					dxF: "=IF(V.q22 > 0, V.dxF1, V.dxF2)",
					dyF: "=IF(V.q22 > 0, V.dyF1, V.dyF2)",
					sdxF: "=V.dxF * V.rw1 / V.rO",
					sdyF: "=V.dyF * V.rh1 / V.rO",
					xF: "=V.hc + V.sdxF",
					yF: "=V.vc + V.sdyF",
					x1I: "=V.sx1 * V.rI / V.rw2",
					y1I: "=V.sy1 * V.rI / V.rh2",
					x2I: "=V.sx2 * V.rI / V.rw2",
					y2I: "=V.sy2 * V.rI / V.rh2",
					dxI: "=V.x2I - V.x1I",
					dyI: "=V.y2I - V.y1I",
					dI: "=SQRT(V.dxI*V.dxI + V.dyI*V.dyI)",
					v1: "=V.x1I * V.y2I",
					v2: "=V.x2I * V.y1I",
					DI: "=V.v1 - V.v2",
					v3: "=V.rI * V.rI",
					v4: "=V.dI * V.dI",
					v5: "=V.v3 * V.v4",
					v6: "=V.DI * V.DI",
					v7: "=V.v5 - V.v6",
					v8: "=MAX(V.v7, 0)",
					sdelI: "=SQRT(V.v8)",
					v9: "=V.sdyO * V.dxI",
					v10: "=V.v9 * V.sdelI",
					v11: "=V.DI * V.dyI",
					dxC1: "=(V.v11 + V.v10) / V.v4",
					v12: "=V.v11 - V.v10",
					dxC2: "=V.v12 / V.v4",
					adyI: "=ABS(V.dyI)",
					v13: "=V.adyI * V.sdelI",
					v14: "=V.DI * V.dxI / -1",
					dyC1: "=(V.v14 + V.v13) / V.v4",
					v15: "=V.v14 - V.v13",
					dyC2: "=V.v15 / V.v4",
					v16: "=V.x1I - V.dxC1",
					v17: "=V.x1I - V.dxC2",
					v18: "=V.y1I - V.dyC1",
					v19: "=V.y1I - V.dyC2",
					v20: "=SQRT(V.v16*V.v16 + V.v18*V.v18)",
					v21: "=SQRT(V.v17*V.v17 + V.v19*V.v19)",
					v22: "=V.v21 - V.v20",
					dxC: "=IF(V.v22 > 0, V.dxC1, V.dxC2)",
					dyC: "=IF(V.v22 > 0, V.dyC1, V.dyC2)",
					sdxC: "=V.dxC * V.rw2 / V.rI",
					sdyC: "=V.dyC * V.rh2 / V.rI",
					xC: "=V.hc + V.sdxC",
					yC: "=V.vc + V.sdyC",
					wtI: "=V.rw3 * SIN(V.stAng / V.d2r)",
					htI: "=V.rh3 * COS(V.stAng / V.d2r)",
					_dxI: "=V.rw3 * COS(ATAN2(V.htI,V.wtI))",
					_dyI: "=V.rh3 * SIN(ATAN2(V.htI,V.wtI))",
					xI: "=V.hc + V._dxI",
					yI: "=V.vc + V._dyI",
					lptAng: "=V.stAng - V.aAng",
					wtL: "=V.rw3 * SIN(V.lptAng / V.d2r)",
					htL: "=V.rh3 * COS(V.lptAng / V.d2r)",
					dxL: "=V.rw3 * COS(ATAN2(V.htL,V.wtL))",
					dyL: "=V.rh3 * SIN(ATAN2(V.htL,V.wtL))",
					xL: "=V.hc + V.dxL",
					yL: "=V.vc + V.dyL",
					dxK: "=V.thh * COS(V.lptAng / V.d2r)",
					dyK: "=V.thh * SIN(V.lptAng / V.d2r)",
					xK: "=V.xI + V.dxK",
					yK: "=V.yI + V.dyK",
					dxJ: "=V.thh * COS(V.lptAng / V.d2r)",
					dyJ: "=V.thh * SIN(V.lptAng / V.d2r)",
					xJ: "=V.xI - V.dxJ",
					yJ: "=V.yI - V.dyJ",
					p1: "=V.xF - V.xC",
					p2: "=V.yF - V.yC",
					p3: "=SQRT(V.p1*V.p1 + V.p2*V.p2)",
					p4: "=V.p3 / 2",
					p5: "=V.p4 - V.thh",
					xGp: "=IF(V.p5 > 0, V.xF, V.xG)",
					yGp: "=IF(V.p5 > 0, V.yF, V.yG)",
					xBp: "=IF(V.p5 > 0, V.xC, V.xB)",
					yBp: "=IF(V.p5 > 0, V.yC, V.yB)",
					en0: "=(ATAN2(V.sdxF,V.sdyF) * V.d2r)",
					en1: "=V.en0 + 21600000",
					en2: "=IF(V.en0 > 0, V.en0, V.en1)",
					od0: "=V.en2 - V.enAng",
					od1: "=V.od0 + 21600000",
					od2: "=IF(V.od0 > 0, V.od0, V.od1)",
					st0: "=V.stAng - V.od2",
					st1: "=V.st0 + 21600000",
					st2: "=IF(V.st0 > 0, V.st0, V.st1)",
					sw0: "=V.en2 - V.st2",
					sw1: "=V.sw0 + 21600000",
					swAng: "=IF(V.sw0 > 0, V.sw0, V.sw1)",
					ist0: "=(ATAN2(V.sdxC,V.sdyC) * V.d2r)",
					ist1: "=V.ist0 + 21600000",
					istAng: "=IF(V.ist0 > 0, V.ist0, V.ist1)",
					id0: "=V.istAng - V.enAng",
					id1: "=V.id0 - 21600000",
					id2: "=IF(V.id0 > 0, V.id1, V.id0)",
					ien0: "=V.stAng - V.id2",
					ien1: "=V.ien0 - 21600000",
					ien2: "=IF(V.ien1 > 0, V.ien1, V.ien0)",
					isw1: "=V.ien2 - V.istAng",
					isw2: "=V.isw1 - 21600000",
					iswAng: "=IF(V.isw1 > 0, V.isw2, V.isw1)",
					wtE: "=V.rw1 * SIN(V.st2 / V.d2r)",
					htE: "=V.rh1 * COS(V.st2 / V.d2r)",
					dxE: "=V.rw1 * COS(ATAN2(V.htE,V.wtE))",
					dyE: "=V.rh1 * SIN(ATAN2(V.htE,V.wtE))",
					xE: "=V.hc + V.dxE",
					yE: "=V.vc + V.dyE",
					wtD: "=V.rw2 * SIN(V.ien2 / V.d2r)",
					htD: "=V.rh2 * COS(V.ien2 / V.d2r)",
					dxD: "=V.rw2 * COS(ATAN2(V.htD,V.wtD))",
					dyD: "=V.rh2 * SIN(ATAN2(V.htD,V.wtD))",
					xD: "=V.hc + V.dxD",
					yD: "=V.vc + V.dyD",
					xKp: "=IF(V.p5 > 0, V.xE, V.xK)",
					yKp: "=IF(V.p5 > 0, V.yE, V.yK)",
					xJp: "=IF(V.p5 > 0, V.xD, V.xJ)",
					yJp: "=IF(V.p5 > 0, V.yD, V.yJ)",
					cd4: C,
					aL: "=V.lptAng - V.cd4",
					aA: "=V.ptAng + V.cd4",
					aB: "=V.ptAng + V.cd2",
					aJ: "=V.lptAng + V.cd2",
					idx: "=V.rw1 * COS(2700000 / V.d2r)",
					idy: "=V.rh1 * SIN(2700000 / V.d2r)",
					il: "=V.hc - V.idx",
					ir: "=V.hc + V.idx",
					it: "=V.vc - V.idy",
					ib: "=V.vc + V.idy",
					cx1: "=C(V.rw1,V.xE,A(V.rw1,V.rh1,V.st2),true)",
					cy1: "=C(V.rh1,V.yE,A(V.rw1,V.rh1,V.st2))",
					cx2: "=C(V.rw2,V.xC,A(V.rw2,V.rh2,V.istAng),true)",
					cy2: "=C(V.rh2,V.yC,A(V.rw2,V.rh2,V.istAng))"
				},
				adjustInfo: [["adj1", 12500], ["adj2", 1142319], ["adj3", 20457681], ["adj4", 11942319], ["adj5", 12500]],
				connectionPoints: [{
						x: "=V.xL",
						y: "=V.yL"
					}, {
						x: "=V.xKp",
						y: "=V.yKp"
					}, {
						x: "=V.xGp",
						y: "=V.yGp"
					}, {
						x: "=V.xA",
						y: "=V.yA"
					}, {
						x: "=V.xBp",
						y: "=V.yBp"
					}, {
						x: "=V.xJp",
						y: "=V.yJp"
					}
				],
				controlsInfo: [{
						type: "ahPolar",
						gdRefAng: "adj2",
						minAng: 0,
						maxAng: "maxAng",
						position: {
							x: "xA",
							y: "yA"
						},
						point: ["=V.xA", "=V.yA"]
					}, {
						type: "ahPolar",
						gdRefAng: "adj4",
						minAng: 0,
						maxAng: 21599999,
						position: {
							x: "xE",
							y: "yE"
						},
						point: ["=V.xE", "=V.yE"]
					}, {
						type: "ahPolar",
						gdRefR: "adj1",
						minR: 0,
						maxR: "maxAdj1",
						gdRefAng: "adj3",
						minAng: 0,
						maxAng: 21599999,
						position: {
							x: "xF",
							y: "yF"
						},
						point: ["=V.xF", "=V.yF"]
					}, {
						type: "ahPolar",
						gdRefR: "adj5",
						minR: 0,
						maxR: 25000,
						position: {
							x: "xB",
							y: "yB"
						},
						point: ["=V.xB", "=V.yB"]
					}
				],
				path: [[["M", "=V.xL", "=V.yL"], ["L", "=V.xKp", "=V.yKp"], ["L", "=V.xE", "=V.yE"], ["E", "=V.cx1", "=V.cy1", "=V.rw1", "=V.rh1", 0, "=A(V.rw1,V.rh1,V.st2)", "=A(V.rw1,V.rh1,(V.st2 + V.swAng))", "=IF(V.swAng > 0, FALSE, TRUE)"], ["L", "=V.xGp", "=V.yGp"], ["L", "=V.xA", "=V.yA"], ["L", "=V.xBp", "=V.yBp"], ["L", "=V.xC", "=V.yC"], ["E", "=V.cx2", "=V.cy2", "=V.rw2", "=V.rh2", 0, "=A(V.rw2,V.rh2,V.istAng)", "=A(V.rw2,V.rh2,(V.istAng + V.iswAng))", "=IF(V.iswAng > 0, FALSE, TRUE)"], ["L", "=V.xJp", "=V.yJp"], ["Z"], {}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			swooshArrow: {
				variables: {
					adj1: 25000,
					adj2: 16667,
					a1: "=MIN(MAX(1, V.adj1), 75000)",
					ss: s,
					maxAdj2: "=70000 * width / V.ss",
					a2: "=MIN(MAX(0, V.adj2), V.maxAdj2)",
					ad1: "=height * V.a1 / 100000",
					ad2: "=V.ss * V.a2 / 100000",
					r: w,
					xB: "=width - V.ad2",
					t: 0,
					ssd8: "=V.ss / 8",
					yB: "=V.ssd8",
					cd4: C,
					alfa: "=V.cd4 / 14",
					d2r: A,
					dx0: "=V.ssd8 * TAN(V.alfa / V.d2r)",
					xC: "=V.xB - V.dx0",
					dx1: "=V.ad1 * TAN(V.alfa / V.d2r)",
					yF: "=V.yB + V.ad1",
					xF: "=V.xB + V.dx1",
					xE: "=V.xF + V.dx0",
					yE: "=V.yF + V.ssd8",
					dy2: "=V.yE",
					dy22: "=V.dy2 / 2",
					dy3: "=height / 20",
					yD: "=V.dy22 - V.dy3",
					hd6: "=height/6",
					dy4: "=V.hd6",
					yP1: "=V.hd6 + V.dy4",
					wd6: "=width/6",
					xP1: "=V.wd6",
					dy5: "=V.hd6 / 2",
					yP2: "=V.yF + V.dy5",
					wd4: "=width/4",
					xP2: "=V.wd4",
					l: 0,
					b: h
				},
				adjustInfo: [["adj1", 25000], ["adj2", 16667]],
				connectionPoints: [{
						x: 0,
						y: h
					}, {
						x: "=V.xC",
						y: 0
					}, {
						x: w,
						y: "=V.yD"
					}, {
						x: "=V.xE",
						y: "=V.yE"
					}
				],
				controlsInfo: [{
						type: "ahXY",
						gdRefY: "adj1",
						minY: 1,
						maxY: 75000,
						position: {
							x: "xF",
							y: "yF"
						},
						point: ["=V.xF", "=V.yF"]
					}, {
						type: "ahXY",
						gdRefX: "adj2",
						minX: 0,
						maxX: "maxAdj2",
						position: {
							x: "xB",
							y: "yB"
						},
						point: ["=V.xB", "=V.yB"]
					}
				],
				path: [[["M", 0, h], ["Q", "=V.xP1", "=V.yP1", "=V.xB", "=V.yB"], ["L", "=V.xC", 0], ["L", w, "=V.yD"], ["L", "=V.xE", "=V.yE"], ["L", "=V.xF", "=V.yF"], ["Q", "=V.xP2", "=V.yP2", 0, h], ["Z"], {}
					]]
			},
			cloud: {
				variables: {
					il: "=width * 2977 / 21600",
					it: "=height * 3262 / 21600",
					ir: "=width * 17087 / 21600",
					ib: "=height * 17337 / 21600",
					g27: "=width * 67 / 21600",
					g28: "=height * 21577 / 21600",
					g29: "=width * 21582 / 21600",
					g30: "=height * 1235 / 21600",
					vc: F,
					hc: E,
					_scaleX1: "= width / 43200",
					_scaleY1: "= height / 43200",
					cx1: "=C(6753,3900,A(6753,9190,-11429249),true)",
					cy1: "=C(9190,14370,A(6753,9190,-11429249))",
					cx2: "=C(5333,P(V.cx1,6753,A(6753,9190,(-11429249 + 7426832)),true),A(5333,7267,-8646143),true)",
					cy2: "=C(7267,P(V.cy1,9190,A(6753,9190,(-11429249 + 7426832))),A(5333,7267,-8646143))",
					cx3: "=C(4365,P(V.cx2,5333,A(5333,7267,(-8646143 + 5396714)),true),A(4365,5945,-8748475),true)",
					cy3: "=C(5945,P(V.cy2,7267,A(5333,7267,(-8646143 + 5396714))),A(4365,5945,-8748475))",
					cx4: "=C(4857,P(V.cx3,4365,A(4365,5945,(-8748475 + 5983381)),true),A(4857,6595,-7859164),true)",
					cy4: "=C(6595,P(V.cy3,5945,A(4365,5945,(-8748475 + 5983381))),A(4857,6595,-7859164))",
					cx5: "=C(5333,P(V.cx4,4857,A(4857,6595,(-7859164 + 7034504)),true),A(5333,7273,-4722533),true)",
					cy5: "=C(7273,P(V.cy4,6595,A(4857,6595,(-7859164 + 7034504))),A(5333,7273,-4722533))",
					cx6: "=C(6775,P(V.cx5,5333,A(5333,7273,(-4722533 + 6541615)),true),A(6775,9220,-2776035),true)",
					cy6: "=C(9220,P(V.cy5,7273,A(5333,7273,(-4722533 + 6541615))),A(6775,9220,-2776035))",
					cx7: "=C(5785,P(V.cx6,6775,A(6775,9220,(-2776035 + 7816140)),true),A(5785,7867,37501),true)",
					cy7: "=C(7867,P(V.cy6,9220,A(6775,9220,(-2776035 + 7816140))),A(5785,7867,37501))",
					cx8: "=C(6752,P(V.cx7,5785,A(5785,7867,(37501 + 6842000)),true),A(6752,9215,1347096),true)",
					cy8: "=C(9215,P(V.cy7,7867,A(5785,7867,(37501 + 6842000))),A(6752,9215,1347096))",
					cx9: "=C(7720,P(V.cx8,6752,A(6752,9215,(1347096 + 6910353)),true),A(7720,10543,3974558),true)",
					cy9: "=C(10543,P(V.cy8,9215,A(6752,9215,(1347096 + 6910353))),A(7720,10543,3974558))",
					cx10: "=C(4360,P(V.cx9,7720,A(7720,10543,(3974558 + 4542661)),true),A(4360,5918,-16496525),true)",
					cy10: "=C(5918,P(V.cy9,10543,A(7720,10543,(3974558 + 4542661))),A(4360,5918,-16496525))",
					cx11: "=C(4345,P(V.cx10,4360,A(4360,5918,(-16496525 + 8804134)),true),A(4345,5945,-14809710),true)",
					cy11: "=C(5945,P(V.cy10,5918,A(4360,5918,(-16496525 + 8804134))),A(4345,5945,-14809710))",
					_scaleX2: "= width / 43200",
					_scaleY2: "= height / 43200",
					cx12: "=C(4345,4693,A(4345,5945,5204520),true)",
					cy12: "=C(5945,26177,A(4345,5945,5204520))",
					cx13: "=C(4360,6928,A(4360,5918,4416628),true)",
					cy13: "=C(5918,34899,A(4360,5918,4416628))",
					cx14: "=C(6752,16478,A(6752,9215,8257449),true)",
					cy14: "=C(9215,39090,A(6752,9215,8257449))",
					cx15: "=C(6752,28827,A(6752,9215,387196),true)",
					cy15: "=C(9215,34751,A(6752,9215,387196))",
					cx16: "=C(5785,34129,A(5785,7867,-4217541),true)",
					cy16: "=C(7867,22954,A(5785,7867,-4217541))",
					cx17: "=C(5333,41798,A(5333,7273,1819082),true)",
					cy17: "=C(7273,15354,A(5333,7273,1819082))",
					cx18: "=C(4857,38324,A(4857,6595,-824660),true)",
					cy18: "=C(6595,5426,A(4857,6595,-824660))",
					cx19: "=C(4857,29078,A(4857,6595,-8950887),true)",
					cy19: "=C(6595,3952,A(4857,6595,-8950887))",
					cx20: "=C(4365,22141,A(4365,5945,-9809656),true)",
					cy20: "=C(5945,4720,A(4365,5945,-9809656))",
					cx21: "=C(6753,14000,A(6753,9190,-4002417),true)",
					cy21: "=C(9190,5192,A(6753,9190,-4002417))",
					cx22: "=C(6753,4127,A(6753,9190,9459261),true)",
					cy22: "=C(9190,15789,A(6753,9190,9459261))"
				},
				connectionPoints: [{
						x: "=V.g29",
						y: b
					}, {
						x: a,
						y: "=V.g28"
					}, {
						x: "=V.g27",
						y: b
					}, {
						x: a,
						y: "=V.g30"
					}
				],
				path: [[["M", "=3900 * V._scaleX1", "=14370 * V._scaleY1"], ["E", "=V.cx1 * V._scaleX1", "=V.cy1 * V._scaleY1", "=6753 * V._scaleX1", "=9190 * V._scaleY1", 0, "=A(6753,9190,-11429249)", "=A(6753,9190,(-11429249 + 7426832))", "=IF(7426832 > 0, FALSE, TRUE)"], ["E", "=V.cx2 * V._scaleX1", "=V.cy2 * V._scaleY1", "=5333 * V._scaleX1", "=7267 * V._scaleY1", 0, "=A(5333,7267,-8646143)", "=A(5333,7267,(-8646143 + 5396714))", "=IF(5396714 > 0, FALSE, TRUE)"], ["E", "=V.cx3 * V._scaleX1", "=V.cy3 * V._scaleY1", "=4365 * V._scaleX1", "=5945 * V._scaleY1", 0, "=A(4365,5945,-8748475)", "=A(4365,5945,(-8748475 + 5983381))", "=IF(5983381 > 0, FALSE, TRUE)"], ["E", "=V.cx4 * V._scaleX1", "=V.cy4 * V._scaleY1", "=4857 * V._scaleX1", "=6595 * V._scaleY1", 0, "=A(4857,6595,-7859164)", "=A(4857,6595,(-7859164 + 7034504))", "=IF(7034504 > 0, FALSE, TRUE)"], ["E", "=V.cx5 * V._scaleX1", "=V.cy5 * V._scaleY1", "=5333 * V._scaleX1", "=7273 * V._scaleY1", 0, "=A(5333,7273,-4722533)", "=A(5333,7273,(-4722533 + 6541615))", "=IF(6541615 > 0, FALSE, TRUE)"], ["E", "=V.cx6 * V._scaleX1", "=V.cy6 * V._scaleY1", "=6775 * V._scaleX1", "=9220 * V._scaleY1", 0, "=A(6775,9220,-2776035)", "=A(6775,9220,(-2776035 + 7816140))", "=IF(7816140 > 0, FALSE, TRUE)"], ["E", "=V.cx7 * V._scaleX1", "=V.cy7 * V._scaleY1", "=5785 * V._scaleX1", "=7867 * V._scaleY1", 0, "=A(5785,7867,37501)", "=A(5785,7867,(37501 + 6842000))", "=IF(6842000 > 0, FALSE, TRUE)"], ["E", "=V.cx8 * V._scaleX1", "=V.cy8 * V._scaleY1", "=6752 * V._scaleX1", "=9215 * V._scaleY1", 0, "=A(6752,9215,1347096)", "=A(6752,9215,(1347096 + 6910353))", "=IF(6910353 > 0, FALSE, TRUE)"], ["E", "=V.cx9 * V._scaleX1", "=V.cy9 * V._scaleY1", "=7720 * V._scaleX1", "=10543 * V._scaleY1", 0, "=A(7720,10543,3974558)", "=A(7720,10543,(3974558 + 4542661))", "=IF(4542661 > 0, FALSE, TRUE)"], ["E", "=V.cx10 * V._scaleX1", "=V.cy10 * V._scaleY1", "=4360 * V._scaleX1", "=5918 * V._scaleY1", 0, "=A(4360,5918,-16496525)", "=A(4360,5918,(-16496525 + 8804134))", "=IF(8804134 > 0, FALSE, TRUE)"], ["E", "=V.cx11 * V._scaleX1", "=V.cy11 * V._scaleY1", "=4345 * V._scaleX1", "=5945 * V._scaleY1", 0, "=A(4345,5945,-14809710)", "=A(4345,5945,(-14809710 + 9151131))", "=IF(9151131 > 0, FALSE, TRUE)"], ["Z"], {}
					], [["M", "=4693 * V._scaleX2", "=26177 * V._scaleY2"], ["E", "=V.cx12 * V._scaleX2", "=V.cy12 * V._scaleY2", "=4345 * V._scaleX2", "=5945 * V._scaleY2", 0, "=A(4345,5945,5204520)", "=A(4345,5945,(5204520 + 1585770))", "=IF(1585770 > 0, FALSE, TRUE)"], ["M", "=6928 * V._scaleX2", "=34899 * V._scaleY2"], ["E", "=V.cx13 * V._scaleX2", "=V.cy13 * V._scaleY2", "=4360 * V._scaleX2", "=5918 * V._scaleY2", 0, "=A(4360,5918,4416628)", "=A(4360,5918,(4416628 + 686848))", "=IF(686848 > 0, FALSE, TRUE)"], ["M", "=16478 * V._scaleX2", "=39090 * V._scaleY2"], ["E", "=V.cx14 * V._scaleX2", "=V.cy14 * V._scaleY2", "=6752 * V._scaleX2", "=9215 * V._scaleY2", 0, "=A(6752,9215,8257449)", "=A(6752,9215,(8257449 + 844866))", "=IF(844866 > 0, FALSE, TRUE)"], ["M", "=28827 * V._scaleX2", "=34751 * V._scaleY2"], ["E", "=V.cx15 * V._scaleX2", "=V.cy15 * V._scaleY2", "=6752 * V._scaleX2", "=9215 * V._scaleY2", 0, "=A(6752,9215,387196)", "=A(6752,9215,(387196 + 959901))", "=IF(959901 > 0, FALSE, TRUE)"], ["M", "=34129 * V._scaleX2", "=22954 * V._scaleY2"], ["E", "=V.cx16 * V._scaleX2", "=V.cy16 * V._scaleY2", "=5785 * V._scaleX2", "=7867 * V._scaleY2", 0, "=A(5785,7867,-4217541)", "=A(5785,7867,(-4217541 + 4255042))", "=IF(4255042 > 0, FALSE, TRUE)"], ["M", "=41798 * V._scaleX2", "=15354 * V._scaleY2"], ["E", "=V.cx17 * V._scaleX2", "=V.cy17 * V._scaleY2", "=5333 * V._scaleX2", "=7273 * V._scaleY2", 0, "=A(5333,7273,1819082)", "=A(5333,7273,(1819082 + 1665090))", "=IF(1665090 > 0, FALSE, TRUE)"], ["M", "=38324 * V._scaleX2", "=5426 * V._scaleY2"], ["E", "=V.cx18 * V._scaleX2", "=V.cy18 * V._scaleY2", "=4857 * V._scaleX2", "=6595 * V._scaleY2", 0, "=A(4857,6595,-824660)", "=A(4857,6595,(-824660 + 891534))", "=IF(891534 > 0, FALSE, TRUE)"], ["M", "=29078 * V._scaleX2", "=3952 * V._scaleY2"], ["E", "=V.cx19 * V._scaleX2", "=V.cy19 * V._scaleY2", "=4857 * V._scaleX2", "=6595 * V._scaleY2", 0, "=A(4857,6595,-8950887)", "=A(4857,6595,(-8950887 + 1091722))", "=IF(1091722 > 0, FALSE, TRUE)"], ["M", "=22141 * V._scaleX2", "=4720 * V._scaleY2"], ["E", "=V.cx20 * V._scaleX2", "=V.cy20 * V._scaleY2", "=4365 * V._scaleX2", "=5945 * V._scaleY2", 0, "=A(4365,5945,-9809656)", "=A(4365,5945,(-9809656 + 1061181))", "=IF(1061181 > 0, FALSE, TRUE)"], ["M", "=14000 * V._scaleX2", "=5192 * V._scaleY2"], ["E", "=V.cx21 * V._scaleX2", "=V.cy21 * V._scaleY2", "=6753 * V._scaleX2", "=9190 * V._scaleY2", 0, "=A(6753,9190,-4002417)", "=A(6753,9190,(-4002417 + 739161))", "=IF(739161 > 0, FALSE, TRUE)"], ["M", "=4127 * V._scaleX2", "=15789 * V._scaleY2"], ["E", "=V.cx22 * V._scaleX2", "=V.cy22 * V._scaleY2", "=6753 * V._scaleX2", "=9190 * V._scaleY2", 0, "=A(6753,9190,9459261)", "=A(6753,9190,(9459261 + 711490))", "=IF(711490 > 0, FALSE, TRUE)"], {
							fillMode: "none"
						}
					]],
				textRect: {
					left: "=V.il",
					top: "=V.it",
					right: "=V.ir",
					bottom: "=V.ib"
				}
			},
			chartX: {
				variables: {
					_scaleX1: "= width / 10",
					_scaleY1: "= height / 10",
					_scaleX2: "= width / 10",
					_scaleY2: "= height / 10"
				},
				path: [[["M", 0, 0], ["L", w, h], ["M", 0, h], ["L", w, 0], {
							fillMode: "none"
						}
					], [["M", 0, 0], ["L", 0, h], ["L", w, h], ["L", w, 0], ["Z"], {
							strokeMode: "false"
						}
					]]
			},
			chartStar: {
				variables: {
					_scaleX1: "= width / 10",
					_scaleY1: "= height / 10",
					_scaleX2: "= width / 10",
					_scaleY2: "= height / 10"
				},
				path: [[["M", 0, 0], ["L", w, h], ["M", 0, h], ["L", w, 0], ["M", E, 0], ["L", E, h], {
							fillMode: "none"
						}
					], [["M", 0, 0], ["L", 0, h], ["L", w, h], ["L", w, 0], ["Z"], {
							strokeMode: "false"
						}
					]]
			},
			chartPlus: {
				variables: {
					_scaleX1: "= width / 10",
					_scaleY1: "= height / 10",
					_scaleX2: "= width / 10",
					_scaleY2: "= height / 10"
				},
				path: [[["M", E, 0], ["L", E, h], ["M", 0, F], ["L", w, F], {
							fillMode: "none"
						}
					], [["M", 0, 0], ["L", 0, h], ["L", w, h], ["L", w, 0], ["Z"], {
							strokeMode: "false"
						}
					]]
			},
			lineInverse: {
				variables: {
					l: 0,
					b: h,
					r: w,
					t: 0
				},
				connectionPoints: [{
						x: 0,
						y: h
					}, {
						x: w,
						y: 0
					}
				],
				path: [[["M", 0, h], ["L", w, 0], {fillMode: "none"}
					]]
			}
		};
	
		Shapes._presetShapeModels = presetShapeModels;
	}());


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var Shapes = __webpack_require__(1);
	    var Common = __webpack_require__(8);
	    var sR = function () {
	        return Common._getResource(Shapes.SR)();
	    };
	    var Types = Common._Types, isNullOrUndefined = Types._isNullOrUndefined;
	    var Sheets = __webpack_require__(16), $ = Sheets.GC$, Events = Sheets.Events;
	    var colorFormatToString = Shapes.ChartUtility.colorFormatToString;
	    var ShapeUtility = Shapes.ShapeUtility;
	    var syncShapeAdjustValues = ShapeUtility.syncShapeAdjustValues;
	    var syncShapeOptions = ShapeUtility.syncShapeOptions;
	    var getShapeAdjustValues = ShapeUtility.getShapeAdjustValues;
	    var syncShapeLineFormat = ShapeUtility.syncShapeLineFormat;
	    var getLineFormatInfo = ShapeUtility.getLineFormatInfo;
	    var getRGBAColor = ShapeUtility.getRGBAColor;
	    var getColorInfo = ShapeUtility.getColorInfo;
	    var presetShapeModels = Shapes._presetShapeModels;
	    var Math_min = Math.min,
	        Math_max = Math.max,
	        Math_abs = Math.abs;
	
	    var fillModeMap = ['none', 'normal', 'lighten', 'lightenLess', 'darkenLess', 'darken'];
	
	    
	    function applyPathOptions(model) {
	        var pathFillOptions = model.pathFillOptions, paths = model.path, count = paths.length;
	        if (pathFillOptions) {
	            for (var i = 0; i < count; i++) {
	                var value = +pathFillOptions[i];
	                if (!isNaN(value)) {
	                    var path = paths[i];
	                    if (value === 0 ) {
	                        path.strokeMode = 'false';
	                    } else {
	                        path.fillMode = fillModeMap[value - 1];
	                    }
	                }
	            }
	        }
	    }
	    function fixNumber(n, digits) {
	        digits = digits || 3;
	        return +(n.toFixed(digits));
	    }
	    function flipAndRotatePoint(x, y, isFilpV, isFilpH, left, top, width, height, origin, radians) {
	        var point = flipPoint(x, y, isFilpV, isFilpH, left, top, width, height);
	        var rs = rotatePoint(point, origin, radians);
	        return {
	            x: fixNumber(rs.x),
	            y: fixNumber(rs.y)
	        };
	    }
	    function rotatePoint(point, origin, radians) {
	        point.x -= origin.x;
	        point.y -= origin.y;
	        var v = rotateVector(point, radians);
	
	        return {x: v.x + origin.x, y: v.y + origin.y};
	    }
	
	    
	    function flipPoint(x, y, isFilpV, isFilpH, left, top, width, height) {
	        var _x, _y;
	        if (isFilpV) {
	            _y = height - y + top;
	        } else {
	            _y = y + top;
	        }
	        if(isFilpH) {
	            _x = width - x + left;
	        } else {
	            _x = x + left;
	        }
	        return {
	            x : _x,
	            y : _y
	        };
	    }
	
	    function rotateVector(vector, radians) {
	        var sin = Math.sin(radians),
	            cos = Math.cos(radians),
	            rx = vector.x * cos - vector.y * sin,
	            ry = vector.x * sin + vector.y * cos;
	        return {
	            x: rx,
	            y: ry
	        };
	    }
	
	
	
	    function syncShapeData(shapeData, properties, zoomFactor) {
	        shapeData._left = properties.left / zoomFactor;
	        shapeData._top = properties.top / zoomFactor;
	        shapeData._width = properties.width / zoomFactor;
	        shapeData._height = properties.height / zoomFactor;
	        shapeData._rotation = properties.rot;
	        shapeData._isFlipH = properties.flipH;
	        shapeData._isFlipV = properties.flipV;
	        shapeData.AdjustValues = getAdjustForShapeData(properties.adjs);
	        shapeData._updateStartPosition();
	        shapeData._updateEndPosition();
	    }
	
	    var minSizeValue = 4 / 3;  
	    
	    function getConnectorProperties(points) {
	        var p1 = points[0], count = points.length, p2 = points[count - 1];
	        var x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, p3 = points[1], x3 = p3.x, y3 = p3.y;
	        var w = x2 - x1, h = y2 - y1;
	        var rot = 0, radians;
	        var center = { x: (x1 + x2) / 2, y: (y1 + y2) / 2 };
	
	       
	        if (fixNumber(x1, 5) === fixNumber(x3, 5)) {
	            rot = 90;
	            radians = Math.PI / 2;
	        } else if (fixNumber(y1, 5) !== fixNumber(y3, 5)) {
	           
	            radians = Math.atan2(y3 - y1, x3 - x1);
	            rot = radians * 180 / Math.PI;
	            if (radians < 0) {
	                radians += 2 * Math.PI;
	                rot += 360;
	            }
	        }
	
	        if (rot) {
	           
	            radians = -radians;
	            points = points.map(function(pt) {
	                return rotatePoint(pt, center, radians);
	            });
	           
	            p1 = points[0];
	            x1 = p1.x;
	            y1 = p1.y;
	           
	            p2 = points[count - 1];
	            x2 = p2.x;
	            y2 = p2.y;
	            w = x2 - x1;
	            h = y2 - y1;
	        }
	
	       
	        var flipH = w < 0, flipV = h < 0;
	        var scaleX = flipH ? -1 : 1, scaleY = flipV ? -1 : 1;
	
	       
	        var width = Math_abs(w), height = Math_abs(h);
	
	       
	        if (width < minSizeValue) {
	            width = minSizeValue;   
	        }
	        if (height < minSizeValue) {
	            height = minSizeValue;
	        }
	
	        var adjs = [];
	
	       
	        for (var i = 0; i < count - 3; i++) {
	            var point = points[i + 1];
	            if (i % 2) {
	                adjs.push((point.y - y1) / height * scaleY);
	            } else {
	                adjs.push((point.x - x1) / width * scaleX);
	            }
	        }
	    
	        var left = center.x - width / 2, top = center.y - height / 2;
	    
	        return {
	            rot: rot,
	            left: left,
	            top: top,
	            width: width,
	            height: height,
	            flipH: flipH,
	            flipV: flipV,
	            adjs: adjs
	        };
	    }
	
	    function adjustTransparentColor(value) {
	        if (value) {
	            var color = value.color;
	            if (color === '' || color === null || color === 'transparent') {
	               
	                value.color = '';
	                value.transparency = 1;
	            }
	        }
	    }
	
	    var AutoShapeType = Shapes.AutoShapeType;
	    var AutoShapeTypeDict = {};
	    for (var p in AutoShapeType) {
	        if (AutoShapeType.hasOwnProperty(p)) {
	            AutoShapeTypeDict[AutoShapeType[p]] = p;
	        }
	    }
	
	    function sortShapePath(pathA, pathB) {
	        var fma = pathA.fillMode === "none", fmb = pathB.fillMode === "none";
	        if (fma ^ fmb) {
	            return fma ? 1 : -1;
	        }
	        return 0;
	    }
	
	   
	    function convertFormulaToFunction(str) {
	        return str.replace(/MIN\(/g, 'Math.min(')
	            .replace(/MAX\(/g, 'Math.max(')
	            .replace(/SIN\(/g, 'Math.sin(')
	            .replace(/COS\(/g, 'Math.cos(')
	            .replace(/ABS\(/g, 'Math.abs(')
	            .replace(/ATAN2\(([^,]+)\,([^,\)]+)\)/g, 'Math.atan2($2, $1)') 
	            .replace(/SQRT\(/g, 'Math.sqrt(')
	            .replace(/TAN\(/g, 'Math.tan(')
	            .replace(/IF\(([^,]+), ([^,]+), ([^,]+)\)/g, '($1 ? $2 : $3)');
	    }
	
	    var regVarName = /V\.(_?[A-Za-z0-9]+)/g;
	    var prefixLength = 'V.'.length;
	
	    function getAdjustStatements(src, name, lines, args, varAdjName, isResult) {
	        var f = src[name];
	
	        if (/^\d/.test(name)) {
	            name = '_' + name; 
	        }
	
	        if (!isNaN(+f)) {
	            lines.push(name + ' = ' + f);
	        } else {
	            var s = convertFormulaToFunction(f);
	            var names = s.match(regVarName);
	            if (names && names.length) {
	                s = s.replace(/V\.(\d)/g, '_$1')   
	                    .replace(/V\./g, '');
	                names.forEach(function (n) {
	                    var varName = n.substr(prefixLength);
	                   
	                    if (varName.indexOf('adj') === 0) {
	                        if (args.indexOf(varName) === -1) {
	                            if (varName === varAdjName) {
	                               
	                                args.unshift(varName);
	                            } else {
	                                args.push(varName);
	                            }
	                        }
	                        return;
	                    }
	
	                    if (!lines[varName]) {
	                        lines[varName] = true;
	                        getAdjustStatements(src, varName, lines, args, varAdjName);
	                    }
	                });
	            }
	            lines.push((isResult ? '' : name + ' = ') + s.substr(1));
	        }
	    }
	
	    function getAdjustFormula(name, adjName, src, target, varAdjName) {
	        if (!target.fnDefs) {
	            target.fnDefs = {};
	            target.fnArgs = {};
	        } else if (target.fnDefs[adjName]) {
	            return;
	        }
	        var args = [], lines = [];
	        varAdjName = varAdjName || adjName;
	        getAdjustStatements(src, name, lines, args, varAdjName, true);
	
	        var result, count = args.length;
	        if (count > 0) {   
	            var sResult = lines.pop();
	            var vars = lines.length ? ['var\t', lines.join(',\r\n\t'), ';\r\n'].join('') : '';
	            var body = vars + 'return ' + sResult + ';';
	
	            if (count === 1) {
	                result = new Function('width', 'height', args[0], body); 
	            } else if (count === 2) {
	                result = new Function('width', 'height', args[0], args[1], body); 
	            } else if (count === 3) {
	                result = new Function('width', 'height', args[0], args[1], args[2], body); 
	            } else if (count === 4) {
	                result = new Function('width', 'height', args[0], args[1], args[2], args[3], body); 
	            } else if (count === 5) {
	                result = new Function('width', 'height', args[0], args[1], args[2], args[3], args[4], body); 
	            } else {
	               
	               
	                return;
	            }
	        }
	        target.fnDefs[adjName] = result;
	        target.fnArgs[adjName] = args;
	    }
	
	    function getAdjustInfo(name, adjName, src, target) {
	        getAdjustFormula(name, adjName, src, target);
	    }
	
	    function getPolarAdjustInfo(xName, yName, adjName, src, target) {
	        getAdjustFormula(xName, adjName + '_x', src, target, adjName);
	        getAdjustFormula(yName, adjName + '_y', src, target, adjName);
	    }
	
	    
	    function modifyShapeControls(shapeModel, autoShapeType) {
	        if (autoShapeType === 167 ) {
	           
	            shapeModel.controls[1].adjustInfo = {
	                toHalfCircle: true
	            };
	        } else if (autoShapeType === 175 ) {
	           
	            shapeModel.controls[0].adjustInfo = {
	                toNegative: true
	            };
	        }
	    }
	
	    
	    function setShapeControlPoints(target, model) {
	        var variables = model.variables, node = model.controlsInfo;
	        if (node) {
	            if (model.controls) {
	                return;
	            }
	
	            var controls = model.controls = [];
	            var angleAdjustments = model.angleAdjustments = {};
	            node.forEach(function (item) {
	                var result = {xBehavior: 1, yBehavior: 1};
	                var pos = item.position, xName = pos.x, yName = pos.y;
	                var names = item.point;
	                result.x = names[0];
	                result.y = names[1];
	                if (item.type === 'ahXY') {
	                    var adjX = item.gdRefX, adjY = item.gdRefY;
	                    if (adjX) {
	                        getAdjustInfo(xName, adjX, variables, target);
	                        result.xBehavior = 0;
	                        result.xRef = adjX;
	                        result.min = item.minX;
	                        result.max = item.maxX;
	                    }
	
	                    if (adjY) {
	                        getAdjustInfo(yName, adjY, variables, target);
	                        result.yBehavior = 0;
	                        result.yRef = adjY;
	                        result.min = item.minY;
	                        result.max = item.maxY;
	                    }
	                } else {   
	                    var adjAngle = item.gdRefAng, adjRadius = item.gdRefR;
	                    result.xBehavior = 0;
	                    result.yBehavior = 0;
	                    result.aRef = adjAngle;
	                    result.rRef = adjRadius;
	                    if (adjAngle) {
	                        result.minAngle = item.minAng;
	                        result.maxAngle = item.maxAng;
	                       
	                        angleAdjustments[adjAngle] = item.maxAng === 0  ? 2  : 1 ;
	                    }
	                    if (adjRadius) {
	                        result.minRadius = item.minR;
	                        result.maxRadius = item.maxR;
	                        getPolarAdjustInfo(xName, yName, adjRadius, variables, target);
	                    }
	                }
	                controls.push(result);
	            });
	        }
	    }
	
	    var presetShapeInfos = Shapes._presetShapeInfos = {}; 
	    function getPresetShapeInfo(autoShapeType) {
	        var excelShapeName = AutoShapeTypeDict[autoShapeType];
	        var shapeInfo = presetShapeInfos[autoShapeType];
	        if (!shapeInfo) {
	            var definition = presetShapeModels[excelShapeName];
	            shapeInfo = presetShapeInfos[autoShapeType] = {
	                name: excelShapeName,
	                definition: definition
	            };
	            if (definition) {
	                var paths = definition.path;
	                paths.forEach(function (path) {
	                   
	                   
	                   
	                    var props = path.pop();
	                    if (props) {
	                        path.fillMode = props.fillMode;
	                        path.strokeMode = props.strokeMode;
	                    }
	                });
	
	                setShapeControlPoints(shapeInfo, definition);
	                modifyShapeControls(definition, autoShapeType);
	            }
	        }
	
	        return shapeInfo;
	    }
	
	    
	    var adjustmentUnit = 100000;
	    
	    var angleUnit = 60000;
	    function getShapeAdjustments(shapeUI) {
	        var adjustInfo = shapeUI._adjustInfo,
	            count = adjustInfo && adjustInfo.length;
	        if (count) {
	            var angleAdjustments = shapeUI._angleAdjustments;
	            return adjustInfo.map(function (item) {
	                var name = item[0], v = shapeUI.getVariable(name);
	                var t = angleAdjustments[name];
	                if (t) {
	                   
	                    v /= angleUnit;
	                    if (v > 180) {
	                        v = v - 360;
	                    }
	                    return v;
	                }
	               
	                return v / adjustmentUnit;
	            });
	        }
	        return [];
	    }
	    function getAdjustForShapeData(adjustList) {
	        return adjustList.map(function (adjust, index) {
	            return ["adj" + (index + 1), Math.round(adjust * adjustmentUnit)];
	        });
	    }
	
	    function updateShapeAdjustments(shapeUI, arrayValue) {
	        var adjustInfo = shapeUI._adjustInfo,
	            count = adjustInfo.length;
	        if (count) {
	            var angleAdjustments = shapeUI._angleAdjustments;
	            for (var i = 0; i < count; i++) {
	                var v = +arrayValue[i];
	                var name = adjustInfo[i][0],
	                    t = angleAdjustments[name];
	                if (!isNaN(v)) {
	                    if (t) {
	                       
	                        v = v % 360;
	                       
	                        if (v < 0 && t === 1 ) {
	                            v += 360;  
	                        }
	                        v *= angleUnit;
	                    } else {
	                       
	                        v *= adjustmentUnit;
	                    }
	                    shapeUI.setVariable(name, v);
	                }
	            }
	        }
	    }
	
	   
	
	    function updateOnAdd(startFn, endFn, index, count) {
	        var self = this;
	        var s = startFn.call(self), e = endFn.call(self);
	        if (index <= s) {
	            if (self.dynamicMove()) {
	                startFn.call(self, s + count);
	                endFn.call(self, e + count);
	            }
	        } else if (index < e && self.dynamicSize()) {
	            endFn.call(self, e + count);
	        }
	    }
	
	    function updateOnRemove(startFn, startOffsetFn, endFn, endOffsetFn, index, count, bottomRemoveRow) {
	        var self = this;
	        var dynamicMove = self.dynamicMove(), dynamicSize = self.dynamicSize();
	        var s = startFn.call(self), e = endFn.call(self);
	        if (index <= s) {
	            if (bottomRemoveRow < s) {
	                if (dynamicMove) {
	                    startFn.call(self, s - count);
	                    endFn.call(self, e - count);
	                }
	            } else if (bottomRemoveRow < e) {
	                var removeCount = bottomRemoveRow - s + 1;
	                var newCount = (e - s + 1) - removeCount;
	                if (dynamicMove) {
	                    startFn.call(self, index);
	                    startOffsetFn.call(self, 0);
	                }
	                if (dynamicSize) {
	                    endFn.call(self, index + newCount - 1);
	                }
	            }
	        } else if (index <= e) {
	            if (bottomRemoveRow < e) {
	                if (dynamicSize) {
	                    endFn.call(self, e - count);
	                }
	            } else if (dynamicSize) {
	                endFn.call(self, index);
	                endOffsetFn.call(self, 0);
	            }
	        }
	    }
	
	    var splitFont = Sheets._StyleHelper._splitFont;
	
	    function parseCssFont(font) {
	        var obj = splitFont(font);
	        var name = obj.fontFamily;
	        var size = parseFloat(obj.fontSize);   
	        var s = obj.fontStyle;
	        var italic = s !== 'normal';
	        s = obj.fontWeight;
	       
	        var bold = s.indexOf('bold') === 0 || (+s >= 700);
	
	        return {
	            name: name,
	            size: size,
	            bold: bold,
	            italic: italic
	        };
	    }
	
	    function noArguments(args) {
	        return args.length === 0;
	    }
	
	    function isFormula(value) {
	        return value && value[0] === '=';
	    }
	
	    function updateCustomShapeModel(shape, path, value) {
	        if (shape._isCustomShape) {
	           
	            Shapes.updateOptionItemByPath(shape._model, path, value);
	        }
	    }
	
	    function getFormula(shape, path) {
	        var shapeUI = shape._shapeUI;
	        if (shapeUI) {
	            var service = shapeUI.getService();
	            if (service) {
	                return service.getFormula(shapeUI.id, path);
	            }
	        }
	        return "";
	    }
	
	    function setFormula(shape, name, value) {
	        var shapeUI = shape._shapeUI;
	        updateCustomShapeModel(shape, name, value);
	        if (shapeUI) {
	            var service = shapeUI.getService();
	            service && service.setFormula(shapeUI.id, name, value, shape._forceRecalc);
	            return shapeUI[name];
	        }
	        return value;
	    }
	
	    function removeFormula(shape, path, value) {
	        var shapeUI = shape._shapeUI;
	        if (shapeUI) {
	            var service = shapeUI.getService();
	            service && service.removeFormula(shapeUI.id, path);
	        }
	        updateCustomShapeModel(shape, path, value);
	    }
	
	    function updateOptionsItem(shape, path, value, needValue) {
	        var shapeUI = shape._shapeUI;
	        updateCustomShapeModel(shape, path, value);
	        if (shapeUI) {
	            var service = shapeUI.getService();
	            if (service) {
	                service.setValueOrFormula(shapeUI.id, path, value, shape._forceRecalc);
	                if (needValue) {
	                    return service.getValue(shapeUI.id, path);  
	                }
	            }
	        }
	        return value;
	    }
	
	    var ShapeBase = (function () {
	       
	        
	        function ShapeBase() {
	            var self = this;
	            self._isSelected = false;
	            self._isLocked = true;
	            self._canPrint = true;
	            self._dynamicMove = true;
	            self._dynamicSize = true;
	           
	            self._allowResize = true;
	            self._allowMove = true;
	            self._shapeData = new Shapes.ShapeBaseData();
	            self._shapeType = 5 ;
	        }
	
	        var shapeBasePrototype = ShapeBase.prototype;
	       
	        
	        shapeBasePrototype.isSelected = function (value) {
	            var self = this;
	            if (noArguments(arguments)) {
	                return self._isSelected;
	            }
	
	            if(self._isSelected !== value) {
	                self._backup("isSelected");
	                self._isSelected = value;
	                if (self._shapeUI) {
	                    self._shapeUI.isSelected = value;
	                }
	                self._fireEvents("isSelected");
	                self._fireSelectedEvents();
	               
	                self.refresh();
	            }
	
	        };
	       
	        
	        shapeBasePrototype.isLocked = function (value) {
	            var self = this;
	            if (noArguments(arguments)) {
	                return self._isLocked;
	            }
	            self._backup("isLocked");
	            self._isLocked = value;
	            self._fireEvents("isLocked");
	        };
	       
	        
	        shapeBasePrototype.isVisible = function (value) {
	            var self = this;
	            if (noArguments(arguments)) {
	                return self._shapeData.Visible;
	            }
	            if(self._shapeData.Visible !== value) {
	                self._backup("isVisible");
	                self._shapeData.Visible = value;
	                if (!value) {
	                   
	                    self.isSelected(false);
	                }
	               
	                self._fireEvents("isVisible");
	                self.refresh();
	            }
	
	        };
	       
	        
	        shapeBasePrototype.canPrint = function (value) {
	            var self = this;
	            if (noArguments(arguments)) {
	                return self._canPrint;
	            }
	            if (self._canPrint !== value) {
	                self._backup("canPrint");
	                self._canPrint = value;
	                self._fireEvents("canPrint");
	            }
	
	        };
	       
	        
	        shapeBasePrototype.dynamicMove = function (value) {
	            var self = this;
	            if (noArguments(arguments)) {
	                return self._dynamicMove;
	            }
	
	           
	            self._backup("dynamicMove");
	            self._dynamicMove = value;
	            self._fireEvents("dynamicMove");
	            if (!value) {
	                self._backup("dynamicSize");
	                self._dynamicSize = false;
	                self._fireEvents("dynamicSize");
	            }
	           
	        };
	       
	        
	        shapeBasePrototype.dynamicSize = function (value) {
	            var self = this;
	            if (noArguments(arguments)) {
	                return self._dynamicSize;
	            }
	
	            if (self._dynamicMove) {
	                self._backup("dynamicSize");
	                self._dynamicSize = value;
	                self._fireEvents("dynamicSize");
	            }
	        };
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	        
	        shapeBasePrototype.allowResize = function (value) {
	            var self = this;
	            if (noArguments(arguments)) {
	                return self._allowResize;
	            }
	            self._backup("allowResize");
	            self._allowResize = value;
	            self._fireEvents("allowResize");
	        };
	       
	        
	        shapeBasePrototype.allowMove = function (value) {
	            var self = this;
	            if (noArguments(arguments)) {
	                return self._allowMove;
	            }
	            self._backup("allowMove");
	            self._allowMove = value;
	            self._fireEvents("allowMove");
	        };
	       
	        
	        shapeBasePrototype.name = function (value) {
	            var self = this, shapeData = self._shapeData, name = shapeData.Name;
	            if (noArguments(arguments)) {
	                return name;
	            }
	            if (isNullOrUndefined(value) || value === '') {
	                throw new Error(sR().Exp_EmptyName);
	            }
	            if (name !== value) {
	               
	                var sheet = self._sheet;
	                if (sheet && sheet.shapes.get(value)) {
	                    throw new Error(sR().Exp_DuplicatedName);
	                }
	                self._backup("name");
	                shapeData.Name = value;
	                if (self._shapeCollection) {
	                    self._shapeCollection._shapeRename(name, value);
	                }
	                self._fireEvents("name");
	            }
	        };
	        
	        shapeBasePrototype._setLocation = function (x, y, forceUpdatePosition, diffX, diffY, needBackup) {
	            var self = this, shapeData = self._shapeData;
	            if (shapeData._left !== x || diffX) {
	                needBackup && self._backup("x");
	                shapeData._left = x;
	                forceUpdatePosition = true;
	                self._fireEvents("x");
	            }
	
	            if (shapeData._top !== y || diffY) {
	                needBackup && self._backup("y");
	                shapeData._top = y;
	                forceUpdatePosition = true;
	                self._fireEvents("y");
	            }
	
	            if (forceUpdatePosition) {
	                shapeData._updateStartPosition();
	                shapeData._updateEndPosition();
	                self._refreshWithUI(true );
	            }            
	        };
	        
	        shapeBasePrototype._setSize = function (width, height, forceUpdatePosition, diffWidth, diffHeight, needBackup) {
	            var self = this, shapeData = self._shapeData;
	
	            if (shapeData._width !== width || diffWidth) {
	                needBackup && self._backup("width");
	                shapeData._width = width;
	                forceUpdatePosition = true;
	                self._fireEvents("width");
	            }
	
	            if (shapeData._height !== height || diffHeight) {
	                needBackup && self._backup("height");
	                shapeData._height = height;
	                forceUpdatePosition = true;
	                self._fireEvents("height");
	            }
	
	            if (forceUpdatePosition) {
	                shapeData._updateEndPosition();
	                self._refreshWithUI(true );
	            }
	        };
	       
	        
	        shapeBasePrototype.x = function (value, forceUpdatePosition) {
	            var self = this, shapeData = self._shapeData, left = shapeData._left;
	            if (noArguments(arguments)) {
	                return left;
	            }
	
	            if (isFormula(value)) {
	                self._left = value;
	                value = setFormula(self, "left", value);
	            } else {
	                if (self._left) {
	                    delete self._left;
	                }
	                removeFormula(self, "left", value);
	            }
	
	            self._setLocation(value, shapeData._top, forceUpdatePosition, left !== value, false , true );
	        };
	        shapeBasePrototype._refreshWithUI = function (pointsFromShapeData) {
	            this._refreshShapeUI(pointsFromShapeData);
	            this.refresh();
	        };
	       
	        
	        shapeBasePrototype.y = function (value, forceUpdatePosition) {
	            var self = this, shapeData = self._shapeData, top = shapeData._top;
	            if (noArguments(arguments)) {
	                return top;
	            }
	            
	            if (isFormula(value)) {
	                self._top = value;
	                value = setFormula(self, "top", value);
	            } else {
	                if (self._top) {
	                    delete self._top;
	                }
	                removeFormula(self, "top", value);
	            }
	
	            self._setLocation(shapeData._left, value, forceUpdatePosition, false , top !== value, true );
	        };
	       
	        
	        shapeBasePrototype.width = function (value, forceUpdatePosition) {
	            var self = this, shapeData = self._shapeData, width = shapeData._width;
	            if (noArguments(arguments)) {
	                return width;
	            }
	            
	            if (isFormula(value)) {
	                self._width = value;
	                value = setFormula(self, "width", value);
	            } else {
	                if (self._width) {
	                    delete self._width;
	                }
	                removeFormula(self, "width", value);
	            }
	
	            self._setSize(value, shapeData._height, forceUpdatePosition, width !== value, false , true );
	        };
	       
	        
	        shapeBasePrototype.height = function (value, forceUpdatePosition) {
	            var self = this, shapeData = self._shapeData, height = shapeData._height;
	            if (noArguments(arguments)) {
	                return height;
	            }
	            
	            if (isFormula(value)) {
	                self._height = value;
	                value = setFormula(self, "height", value);
	            } else {
	                if (self._height) {
	                    delete self._height;
	                }
	                removeFormula(self, "height", value);
	            }
	
	            self._setSize(shapeData._width, value, forceUpdatePosition, false , height !== value, true );
	        };
	       
	        
	        shapeBasePrototype.startRow = function (value) {
	            var self = this;
	            if (noArguments(arguments)) {
	                return self._shapeData._topAnchorRow;
	            }
	            if(self._shapeData._topAnchorRow !== value) {
	                self._backup("startRow");
	                self._shapeData._topAnchorRow = value;
	                self._fireEvents("y");
	                self._shapeData._updateLocation();
	                self._refreshWithUI(true );
	            }
	        };
	       
	        
	        shapeBasePrototype.startRowOffset = function (value) {
	            var self = this;
	            if (noArguments(arguments)) {
	                return self._shapeData._topAnchorRowOffset;
	            }
	            if(self._shapeData._topAnchorRowOffset !== value) {
	                self._backup("startRowOffset");
	                self._shapeData._topAnchorRowOffset = value;
	                self._fireEvents("y");
	                self._shapeData._updateLocation();
	                self._refreshWithUI(true );
	            }
	        };
	       
	        
	        shapeBasePrototype.startColumn = function (value) {
	            var self = this;
	            if (noArguments(arguments)) {
	                return self._shapeData._leftAnchorCol;
	            }
	            if(self._shapeData._leftAnchorCol !== value) {
	                self._backup("startColumn");
	                self._shapeData._leftAnchorCol = value;
	                self._fireEvents("x");
	                self._shapeData._updateLocation();
	                self._refreshWithUI(true );
	            }
	        };
	       
	        
	        shapeBasePrototype.startColumnOffset = function (value) {
	            var self = this;
	            if (noArguments(arguments)) {
	                return self._shapeData._leftAnchorColOffset;
	            }
	            if(self._shapeData._leftAnchorColOffset !== value) {
	                self._backup("startColumnOffset");
	                self._shapeData._leftAnchorColOffset = value;
	                self._fireEvents("x");
	                self._shapeData._updateLocation();
	                self._refreshWithUI(true );
	            }
	        };
	       
	        
	        shapeBasePrototype.endRow = function (value) {
	            var self = this;
	            if (noArguments(arguments)) {
	                return self._shapeData._bottomAnchorRow;
	            }
	            if(self._shapeData._bottomAnchorRow !== value) {
	                self._backup("endRow");
	                self._shapeData._bottomAnchorRow = value;
	                self._fireEvents("height");
	                self._shapeData._updateSize();
	                self._refreshWithUI(true );
	            }
	        };
	       
	        
	        shapeBasePrototype.endRowOffset = function (value) {
	            var self = this;
	            if (noArguments(arguments)) {
	                return self._shapeData._bottomAnchorRowOffset;
	            }
	            if(self._shapeData._bottomAnchorRowOffset !== value) {
	                self._backup("endRowOffset");
	                self._shapeData._bottomAnchorRowOffset = value;
	                self._fireEvents("height");
	                self._shapeData._updateSize();
	                self._refreshWithUI(true );
	            }
	        };
	       
	        
	        shapeBasePrototype.endColumn = function (value) {
	            var self = this;
	            if (noArguments(arguments)) {
	                return self._shapeData._rightAnchorCol;
	            }
	            if(self._shapeData._rightAnchorCol !== value) {
	                self._backup("endColumn");
	                self._shapeData._rightAnchorCol = value;
	                self._fireEvents("width");
	                self._shapeData._updateSize();
	                self._refreshWithUI(true );
	            }
	        };
	       
	        
	        shapeBasePrototype.endColumnOffset = function (value) {
	            var self = this;
	            if (noArguments(arguments)) {
	                return self._shapeData._rightAnchorColOffset;
	            }
	            if(self._shapeData._rightAnchorColOffset !== value) {
	                self._backup("endColumnOffset");
	                self._shapeData._rightAnchorColOffset = value;
	                self._fireEvents("width");
	                self._shapeData._updateSize();
	                self._refreshWithUI(true );
	            }
	        };
	        shapeBasePrototype._setAngle = function(value, needBackup) {
	            var self = this, shapeData = self._shapeData;
	
	           
	            if (!self._angle) {
	                needBackup && self._backup("rotate");
	                var oldValue = shapeData.Rotation;
	                if (oldValue !== value) {
	                    self._shapeData.Rotation = value;
	                    self._shapeUI.setAngle(value);
	                    self._fireEvents("rotate");
	
	                    self.refresh();
	                }
	            }
	        };
	        shapeBasePrototype.rotate = function (value) {
	            var self = this;
	            if (noArguments(arguments)) {
	                return self._shapeData.Rotation;
	            }
	
	            if (isFormula(value)) {
	                self._angle = value;
	                value = setFormula(self, "angle", value);
	            } else {
	                if (self._angle) {
	                    delete self._angle;
	                }
	                removeFormula(self, "angle", value);
	            }
	
	            self._setAngle(value, true);
	        };
	        shapeBasePrototype.resize = function (x, y, width, height) {
	            var self = this;
	           
	            var zoomFactor = self._sheet.zoom(), shapeUI = self._shapeUI;
	            shapeUI.move(x * zoomFactor, y * zoomFactor);
	            shapeUI.resize(width * zoomFactor, height * zoomFactor);
	           
	            if (self._left || self._top || self._width || self._height) {
	                x = shapeUI.left / zoomFactor;
	                y = shapeUI.top / zoomFactor;
	                width = shapeUI.width / zoomFactor;
	                height = shapeUI.height / zoomFactor;
	            }
	           
	           
	           
	            var forceUpdatePosition = true;
	            self._setLocation(x, y, forceUpdatePosition, false , false , true );
	            self._setSize(width, height, forceUpdatePosition, false , false , true );
	
	            self.afterResize();
	        };
	        shapeBasePrototype.afterResize = function () {
	         
	        };
	        shapeBasePrototype.preProcessShapeDataToJson = function (jsonData) {  
	           
	        };
	        shapeBasePrototype.shapeDataToJson = function (jsonData) {
	           
	            var self = this, shapeData = self._shapeData;
	            if (self._shapeType === 5 ) {
	               
	               
	               
	                shapeData._hAlign = self._hAlign;
	                shapeData._vAlign = self._vAlign;
	            }
	
	            jsonData.shapeData = self._shapeData.ToOOModel();
	        };
	        shapeBasePrototype.postProcessShapeDataToJson = function (jsonData) {
	           
	            jsonData.name = this.name();
	            jsonData.shapeType = this._shapeType;
	        };
	        shapeBasePrototype.toJSON = function (ignoreFormula, isFromJson) {
	            var self = this;
	            var result = {};
	           
	            result.isLocked = self._isLocked;
	            result.canPrint = self._canPrint;
	            result.dynamicMove = self._dynamicMove;
	            result.dynamicSize = self._dynamicSize;
	           
	            result.allowResize = self._allowResize;
	            result.allowMove = self._allowMove;
	            self.preProcessShapeDataToJson(result, ignoreFormula);
	            if (isFromJson) {
	                self._shapeData._updateStartPosition(isFromJson);
	                self._shapeData._updateEndPosition(isFromJson);
	            }
	            self.shapeDataToJson(result);
	            self.postProcessShapeDataToJson(result);
	            return result;
	        };
	        shapeBasePrototype.preProcessShapeDataFromJson = function (jsonData) {
	           
	        };
	        shapeBasePrototype.adjustShapeDataFromJson = function (jsonData) {
	           
	        };
	        shapeBasePrototype.shapeDataFromJson = function (jsonData) {
	           
	            var shapeData = this._shapeData;
	            shapeData.FromOOModel(jsonData.shapeData);
	            this.adjustShapeDataFromJson(jsonData);
	        };
	        shapeBasePrototype.postProcessShapeDataFromJson = function () {
	           
	        };
	        shapeBasePrototype.fromJSON = function (jsonData) {
	            var self = this;
	           
	           
	           
	            if (!isNullOrUndefined(jsonData.isLocked)) {
	                self._isLocked = jsonData.isLocked;
	            }
	            if (!isNullOrUndefined(jsonData.canPrint)) {
	                self._canPrint = jsonData.canPrint;
	            }
	            if (!isNullOrUndefined(jsonData.dynamicMove)) {
	                self._dynamicMove = jsonData.dynamicMove;
	            }
	            if (!isNullOrUndefined(jsonData.dynamicSize)) {
	                self._dynamicSize = jsonData.dynamicSize;
	            }
	           
	           
	           
	            if (!isNullOrUndefined(jsonData.allowResize)) {
	                self._allowResize = jsonData.allowResize;
	            }
	            if (!isNullOrUndefined(jsonData.allowMove)) {
	                self._allowMove = jsonData.allowMove;
	            }
	           
	            self._hAlign = jsonData.hAlign;
	            self._vAlign = jsonData.vAlign;
	            self.preProcessShapeDataFromJson(jsonData);
	            self.shapeDataFromJson(jsonData);
	            self.postProcessShapeDataFromJson();
	        };
	        shapeBasePrototype._createCloneShape = function (sheet) {
	           
	            return null;
	        };
	        shapeBasePrototype._clone = function () {
	            var self = this;
	            var json = JSON.stringify(self.toJSON());
	            var destShape = self._createCloneShape(self._sheet);
	            destShape.fromJSON(JSON.parse(json));
	            destShape._initShapeUI();
	            destShape._afterInit();
	            return destShape;
	        };
	        shapeBasePrototype._afterInit = function () {
	           
	        };
	        shapeBasePrototype._onRowsAdded = function (row, rowCount) {
	            var self = this;
	            if (!self._top && !self._height) { 
	                updateOnAdd.call(self, self.startRow, self.endRow, row, rowCount);
	
	                self._onPositionSizeChanged();
	                self._refreshShapeUI(true );
	            }
	        };
	        shapeBasePrototype._onRowsRemoved = function (row, rowCount) {
	            var self = this;
	            if (!self._top && !self._height) { 
	                updateOnRemove.call(self, self.startRow, self.startRowOffset, self.endRow, self.endRowOffset, row, rowCount, row + rowCount - 1);
	
	                self._onPositionSizeChanged();
	                self._refreshShapeUI(true );
	            }
	        };
	        shapeBasePrototype._onColumnsAdded = function (column, columnCount) {
	            var self = this;
	            if (!self._left && !self._width) { 
	                updateOnAdd.call(self, self.startColumn, self.endColumn, column, columnCount);
	
	                self._onPositionSizeChanged();
	                self._refreshShapeUI(true );
	            }
	        };
	        shapeBasePrototype._onColumnsRemoved = function (column, columnCount) {
	            var self = this;
	            if (!self._left && !self._width) { 
	                updateOnRemove.call(self, self.startColumn, self.startColumnOffset, self.endColumn, self.endColumnOffset, column, columnCount, column + columnCount - 1);
	
	                self._onPositionSizeChanged();
	                self._refreshShapeUI(true );
	            }
	        };
	        shapeBasePrototype._onPositionSizeChanged = function () {
	           
	        };
	        shapeBasePrototype._refreshShapeUI = function (pointsFromShapeData) {
	            var self = this;
	            if (self._suspendRefreshUI) {
	                return;
	            }
	            var zoomFactor = self._sheet.zoom();
	            var shapeUI = self._shapeUI;
	            if (shapeUI) {
	                if (shapeUI._shapeType === 1 ) {
	                   
	                   
	                   
	                    shapeUI.setPoints(self._getPoints(pointsFromShapeData), zoomFactor);
	                } else {
	                    shapeUI.move(self.x() * zoomFactor, self.y() * zoomFactor);
	                    shapeUI.resize(self.width() * zoomFactor, self.height() * zoomFactor);
	                }
	            }
	            self._onRefreshShapeUI();
	        };
	        shapeBasePrototype._onRefreshShapeUI = function () {
	           
	        };
	        shapeBasePrototype._updateZoomInfo = function () {
	            var self = this;
	            var shapeUI = self._shapeUI, sheet = self._sheet;
	            if (shapeUI && sheet) {
	                var zoom = sheet.zoom();
	                shapeUI._zoom = zoom;
	                shapeUI._needZoom = zoom !== 1;
	            }
	        };
	        shapeBasePrototype._fireSelectedEvents = function () {
	            var self = this, sheet = self._sheet;
	            if(sheet) {
	                var selectionArgs = {
	                    sheet: sheet,
	                    sheetName: sheet.name(),
	                    shape: self
	                };
	                sheet._trigger(Events.ShapeSelectionChanged, selectionArgs);
	            }
	        };
	        shapeBasePrototype._fireEvents = function (propertyName) {
	            var self = this;
	            if(self._isloading) {
	                return;
	            }
	            var sheet = self._sheet;
	            if (sheet) {
	                var args = {
	                    sheet: sheet,
	                    sheetName: sheet.name(),
	                    shape: self,
	                    propertyName: propertyName
	                };
	                sheet._trigger(Events.ShapeChanged, args);
	            }
	
	        };
	        shapeBasePrototype._backup = function (nameOrType, obj) {
	            var self = this, sheet = self._sheet;
	           
	            if (sheet && !self._notBackUp) {
	                var modelManager = sheet._modelManager;
	                if (modelManager._changes) {
	                    var backupObj, name = nameOrType;
	                    if (obj !== undefined) {
	                        backupObj = {type: nameOrType, value: obj};
	                    } else {
	                        backupObj = {name: name, value: self[name]()};
	                    }
	                    modelManager._backupShapes(self, backupObj);
	                }
	            }
	        };
	        shapeBasePrototype._restore = function (argValue) {
	            if (!argValue) {
	                return;
	            }
	            var self = this, name = argValue.name, value = argValue.value, type = argValue.type;
	            var propertyString = "x|y|width|height|";
	            if (self[name] && propertyString.indexOf(name + "|") > -1) {
	                self[name](value);
	                self._updatePosition();
	            } else if (self[name]) {
	                self[name](value);
	            }else {
	                self._restoreByType(type, value);
	            }
	        };
	        shapeBasePrototype._updatePosition = function () {
	          var shapeData = this._shapeData;
	          shapeData._updateStartPosition();
	          shapeData._updateEndPosition();
	        };
	        shapeBasePrototype._restoreByType = function () {
	
	        };
	        shapeBasePrototype.refresh = function () {
	            var sheet = this._sheet;
	            sheet && !this._suspendRefreshUI && sheet._paintShapes();
	        };
	
	        return ShapeBase;
	    })();
	    Shapes.ShapeBase = ShapeBase;
	
	    function getDefaultOptions(sheet) {
	        var defaultShapeData = sheet._defaultShapeData;
	        if (!defaultShapeData) {
	            defaultShapeData = sheet._defaultShapeData = new Shapes.ShapeData(sheet, '_default');
	        }
	        var font = defaultShapeData.ShapeStyle.Font;
	        var fontOption = ShapeUtility.getFontOptions(font);
	        return {
	            fill: {
	                type: 1,
	                color: colorFormatToString(defaultShapeData.Fill, false)
	            },
	            stroke: {
	                type: 1,
	                color: colorFormatToString(defaultShapeData.Line, false),
	                width: 1
	            },
	            textFormatOptions: {
	                text: defaultShapeData._drawingText.Text,
	                font: fontOption.font,
	                fill: fontOption.fill,
	                allowTextToOverflowShape: false,
	                textDirection: "horizontal",
	                wrapTextInShape: true
	            }
	        };
	    }
	
	    function getBaseShape(sheet, shapeLayer, autoShapeType) {
	        var BaseShapes = shapeLayer.model.BaseShapes;
	        if (!BaseShapes) {
	            BaseShapes = shapeLayer.model.BaseShapes = {};
	        }
	        var s = BaseShapes[autoShapeType];
	        if (!s) {
	            var presetShapeInfo = getPresetShapeInfo(autoShapeType);
	            var model = {
	                id: 'baseShape' + autoShapeType,
	                left: 0,
	                top: 0,
	                width: 200,
	                height: 160,
	                angle: 0,
	                options: getDefaultOptions(sheet)
	            };
	
	           
	            $.extend(true, model, presetShapeInfo.definition);
	
	            var paths = model.path;
	
	           
	            paths.sort(sortShapePath);
	
	            BaseShapes[autoShapeType] = s = shapeLayer.createShape(model);
	        }
	        return s;
	    }
	
	    
	    var strokeFormulaItemNames = ['_color', '_lineStyle', '_width', '_capType', '_joinType', '_transparency'];
	    function syncDataFromServiceCache(model, service, id, options, mergeAll, originalModel, ignoreFormula) {
	        var fn = (ignoreFormula ? service.getValue : service.getFormula).bind(service);
	        var formula = fn(id, 'left');
	        if (!isNullOrUndefined(formula)) {
	            model.left = formula;
	        }
	        formula = fn(id, 'top');
	        if (!isNullOrUndefined(formula)) {
	            model.top = formula;
	        }
	        formula = fn(id, 'width');
	        if (!isNullOrUndefined(formula)) {
	            model.width = formula;
	        }
	        formula = fn(id, 'height');
	        if (!isNullOrUndefined(formula)) {
	            model.height = formula;
	        }
	        formula = fn(id, 'angle');
	        if (!isNullOrUndefined(formula)) {
	            model.angle = formula;
	        }
	
	       
	        var tOptions = model.options = simpleCloneObject(service.getOptions(id, !ignoreFormula ));
	
	        var t;
	        if (originalModel && !ignoreFormula) {
	            model._line = simpleCloneObject(originalModel.options.stroke);
	        } else {
	            t = service.getValues(id, "options.stroke", !ignoreFormula );
	            var stroke = t.options.stroke;
	            if (stroke && stroke[strokeFormulaItemNames[0]]) { 
	                var lineSetting = {};
	                strokeFormulaItemNames.forEach(function(name) {
	                    lineSetting[name.substr(1)] = stroke[name];
	                });
	                if (mergeAll) {
	                    $.extend(model.options.stroke, lineSetting);
	                } else {
	                    model._line = lineSetting;
	                }
	            }
	        }
	
	       
	        if (!mergeAll) {
	            t = tOptions.fill.color;
	            if (isFormula(t)) {
	                model._fillColor = t;
	                tOptions.fill.color = options.fill.color;
	            }
	            t = tOptions.fill.transparency;
	            if (isFormula(t)) {
	                model._fillColorTransparency = t;
	                tOptions.fill.transparency = options.fill.transparency;
	            }
	            var textFormatOptions = tOptions.textFormatOptions, textFormatOptions2 = options.textFormatOptions;
	            t = textFormatOptions.text;
	            if (isFormula(t)) {
	                model._text = t;
	                textFormatOptions.text = textFormatOptions2.text;
	            }
	            t = textFormatOptions.fill.color;
	            if (isFormula(t)) {
	                model._textColor = t;
	                textFormatOptions.fill.color = textFormatOptions2.fill.color;
	            }
	            t = textFormatOptions.fill.transparency;
	            if (isFormula(t)) {
	                model._textTransparency = t;
	                textFormatOptions.fill.transparency = textFormatOptions2.fill.transparency;
	            }
	            t = textFormatOptions.font;
	            if (isFormula(t)) {
	                model._ffont = t;
	                textFormatOptions.font = textFormatOptions2.font;
	            }
	            t = textFormatOptions.horizontalAlignment;
	            if (isFormula(t)) {
	                model._fhAlign = t;
	                textFormatOptions.horizontalAlignment = textFormatOptions2.horizontalAlignment;
	            }
	            t = textFormatOptions.verticalAlignment;
	            if (isFormula(t)) {
	                model._fvAlign = t;
	                textFormatOptions.verticalAlignment = textFormatOptions2.verticalAlignment;
	            }
	            t = textFormatOptions.allowTextToOverflowShape;
	            if (isFormula(t)) {
	                model._overFlow = t;
	                textFormatOptions.allowTextToOverflowShape = textFormatOptions2.allowTextToOverflowShape;
	            }
	            t = textFormatOptions.wrapTextInShape;
	            if (isFormula(t)) {
	                model._wrap = t;
	                textFormatOptions.wrapTextInShape = textFormatOptions2.wrapTextInShape;
	            }
	        }
	    }
	
	    function syncCustomShapeModel(shape, ignoreFormula) {
	        var shapeUI = shape._shapeUI, model = ignoreFormula ? {} : simpleCloneObject(shape._model);
	        var controls = model.controls;
	        var service = shapeUI.getService(), id = shapeUI.id, formula;
	        if (service) {
	           
	            if (ignoreFormula) {
	               
	                model.path = service.getPath(id);
	                var t = service.getValues(id, 'textRect');
	                if (t && t.textRect) {
	                    model.textRect = t.textRect;
	                }
	            } else if (controls) {
	                controls.forEach(function (item, i) {
	                    formula = service.getFormula(id, 'controls.' + i + '.x');
	                    if (formula) {
	                        item.x = formula;
	                    }
	                    formula = service.getFormula(id, 'controls.' + i + '.y');
	                    if (formula) {
	                        item.y = formula;
	                    }
	                });
	            }
	           
	            syncDataFromServiceCache(model, service, id, shapeUI.options, true , null, ignoreFormula);
	        }
	        return model;
	    }
	
	   
	   
	    
	
	   
	    
	
	   
	
	   
	    
	
	   
	    
	
	   
	    
	
	   
	    
	
	   
	    
	
	   
	    
	
	   
	    
	
	   
	    
	
	    
	    function cloneCustomShapeModel(model, toShortenName) {
	        if (model) {
	            var s = JSON.stringify(model);
	            if (toShortenName) {
	                s = s.replace(/variables\./g, 'V.');
	            } else {
	                s = s.replace(/V\./g, 'variables.');
	            }
	            return JSON.parse(s);
	        }
	    }
	
	    function simpleCloneObject(obj) {
	        if (obj) {
	            var s = JSON.stringify(obj);
	            return JSON.parse(s);
	        }
	    }
	
	    var Shape = (function (_super) {
	        $.inherit(Shape, _super);
	
	       
	        
	        function Shape(worksheet, name, autoShapeTypeOrModel, left, top, width, height) {
	            var _this = _super.call(this) || this;
	            var autoShapeType = autoShapeTypeOrModel, model;
	            if (typeof autoShapeTypeOrModel === 'object') {
	                model = cloneCustomShapeModel(autoShapeTypeOrModel, true); 
	                autoShapeType = -1;
	                _this._isCustomShape = true;
	                applyPathOptions(model);
	                _this._model = model;
	            }
	            var shapeName = name && worksheet._ensureUniqueShapeName(name) || worksheet._ensureUniqueShapeName((AutoShapeTypeDict[autoShapeType] || "Shape") + " ", true );
	            _this._sheet = worksheet;
	            _this._shapeData = new Shapes.ShapeData(worksheet, shapeName, autoShapeType, left || 0, top || 0, width || 200, height || 160);
	            if (autoShapeType) {
	                _this._initShapeUI();
	            }
	        }
	
	        var prototype = Shape.prototype;
	       
	        
	        prototype.type = function (value) {
	            var _this = this, shapeData = _this._shapeData;
	            var shapeType = shapeData.AutoShapeType;
	            if (noArguments(arguments)) {
	                return shapeType;
	            }
	
	            if (value !== shapeType) {
	                _this._backup("type");
	                shapeData.AutoShapeType = value;
	                _this._fireEvents("type");
	                if (value) {
	                    _this._initShapeUI();
	                }
	                _this.refresh();
	            }
	        };
	       
	        
	        prototype._backgroundImp = function (value) {
	            var self = this;
	            var path = "options.fill.color";
	            if (noArguments(arguments) || typeof value === "boolean") {
	                if (!value && self._fillColor) {
	                    return getFormula(self, path);
	                }
	
	                return getColorInfo(self._shapeData.Fill).color;
	            }
	
	            var needValue;
	            if (isFormula(value)) {
	                self._fillColor = value;
	                needValue = true;
	            } else {
	                if (self._fillColor) {
	                    delete self._fillColor;
	                }
	                removeFormula(self, path, value);
	            }
	            value = updateOptionsItem(self, path, value, needValue);
	
	            var fill = self._shapeData.Fill, shapeUiFill = self._shapeUI.options.fill;
	            if(value === "" || value === null) {
	                fill.Color.ColorType = 0 ;
	            } else {
	                fill.Color.setColor(self._sheet, value);
	            }
	            shapeUiFill.color = getRGBAColor(fill);
	           
	        };
	        prototype._backgroundTransparencyImp = function (value) {
	            var self = this;
	            var path = "options.fill.transparency";
	            if (noArguments(arguments) || typeof value === "boolean") {
	                if (!value && self._fillColorTransparency) {
	                    return getFormula(self, path);
	                }
	
	                var transparency = getColorInfo(self._shapeData.Fill).transparency;
	               
	                transparency = Math.round(transparency * 100) / 100;
	                return transparency;
	            }
	            var needValue;
	            if (isFormula(value)) {
	                self._fillColorTransparency = value;
	                needValue = true;
	            } else {
	                if (self._fillColorTransparency) {
	                    delete self._fillColorTransparency;
	                }
	                removeFormula(self, path, value);
	            }
	            value = parseFloat(updateOptionsItem(self, path, value, needValue));
	            value = Math_min(1, value);
	            value = Math_max(0, value);
	
	            var fill = self._shapeData.Fill, shapeUIFill = self._shapeUI.options.fill;
	            fill.Transparency = value;
	            shapeUIFill.transparency = value;
	        };
	        prototype._borderImp = function (value) {
	            var self = this, line = self._shapeData.Line;
	            if (noArguments(arguments) || typeof value === "boolean") {
	                var result = getLineFormatInfo(line);
	                if (!value && self._line) {
	                    return {
	                        color: getFormula(self, "options.stroke._color") || result.color,
	                        lineStyle: getFormula(self, "options.stroke._lineStyle") || result.lineStyle,
	                        width: getFormula(self, "options.stroke._width") || result.width,
	                        capType: getFormula(self, "options.stroke._capType") || result.capType,
	                        joinType: getFormula(self, "options.stroke._joinType") || result.joinType,
	                        transparency: getFormula(self, "options.stroke._transparency") || result.transparency
	                    };
	                }
	
	                return result;
	            }
	
	            if (typeof value !== 'object') {
	               
	                return;
	            }
	
	            var hasFormula;
	            value = simpleCloneObject(value);
	            self._line = value;
	            for (var name in value) {    
	                var v = value[name];
	                var path = "options.stroke._" + name, needValue = isFormula(v);
	                if (needValue && !hasFormula) {
	                    hasFormula = true;
	                }
	                value[name] = updateOptionsItem(self, path, v, needValue);
	            }
	            if (!hasFormula) {
	                delete self._line;
	            }
	
	            if (value.color === "" || value.color === null) {
	                line.Color.ColorType = 0 ;
	            } else {
	                line.Color.setColor(self._sheet, value.color);
	            }
	            line.DashStyle = value.lineStyle;
	            line.Weight = value.width;
	            line.CapStyle = value.capType;
	            line.JoinStyle = value.joinType;
	           
	            var transparency = value.transparency;
	            if (!isNaN(transparency)) {
	                transparency = Math_min(1, transparency);
	                transparency = Math_max(0, transparency);
	                line.Transparency = transparency;
	            }
	            syncShapeLineFormat(self._shapeUI.options, self._shapeData);
	        };
	       
	        
	        prototype.text = function (value) {
	            var self = this;
	            if (noArguments(arguments)) {
	                return self._shapeData._drawingText.Text;
	            }
	
	            var path = "options.textFormatOptions.text", needValue;
	            if (isFormula(value)) {
	                self._text = value;
	                needValue = true;
	            } else {
	                if (self._text) {
	                    delete self._text;
	                }
	                removeFormula(self, path, value);
	            }
	            value = updateOptionsItem(self, path, value, needValue);
	
	            self._backup("text");
	            self._shapeData._drawingText.Text = value;
	            self._shapeUI.options.textFormatOptions.text = value;
	            self._fireEvents("text");
	
	            self.refresh();
	        };
	        prototype._colorImp = function (value) {
	            var self = this;
	            var path = "options.textFormatOptions.fill.color";
	            if (noArguments(arguments) || typeof value === "boolean") {
	                if (!value && self._textColor) {
	                    return getFormula(self, path);
	                }
	
	                return getColorInfo(self._shapeData.ShapeStyle.Font).color;
	            }
	
	            var needValue;
	            if (isFormula(value)) {
	                self._textColor = value;
	                needValue = true;
	            } else {
	                if (self._textColor) {
	                    delete self._textColor;
	                }
	                removeFormula(self, path, value);
	            }
	            value = updateOptionsItem(self, path, value, needValue);
	
	            if (value === "" || value === null) {
	                self._shapeData.ShapeStyle.Font.Color.ColorType = 0 ;
	            } else {
	                self._shapeData.ShapeStyle.Font.Color.setColor(self._sheet, value);
	            }
	            self._shapeUI.options.textFormatOptions.fill.color = getRGBAColor(self._shapeData.ShapeStyle.Font);
	        };
	        prototype._textTransparencyImp = function (value) {
	            var self = this;
	            var path = "options.textFormatOptions.fill.transparency";
	            if (noArguments(arguments) || typeof value === "boolean") {
	                if (!value && self._textTransparency) {
	                    return getFormula(self, path);
	                }
	
	                var transparency = getColorInfo(self._shapeData.ShapeStyle.Font).transparency;
	               
	                transparency = Math.round(transparency * 100) / 100;
	                return transparency;
	            }
	            var needValue;
	            if (isFormula(value)) {
	                self._textTransparency = value;
	                needValue = true;
	            } else {
	                if (self._textTransparency) {
	                    delete self._textTransparency;
	                }
	                removeFormula(self, path, value);
	            }
	            value = parseFloat(updateOptionsItem(self, path, value, needValue));
	            value = Math_min(1, value);
	            value = Math_max(0, value);
	
	            self._shapeData.ShapeStyle.Font.Color.Transparency = value;
	            self._shapeUI.options.textFormatOptions.fill.transparency = value;
	        };
	        prototype._fontImp = function (value) {
	            var self = this;
	            var path = "options.textFormatOptions.font";
	            if (noArguments(arguments) || typeof value === "boolean") {
	                if (!value && self._ffont) {
	                    return getFormula(self, path);
	                }
	
	                var font = self._font;
	                if (!font) {
	                   
	                    font = self._font = ShapeUtility.getFontFromShapeData(self._shapeData);
	                }
	                return font;
	            }
	
	            var needValue;
	            if (isFormula(value)) {
	                self._ffont = value;
	                needValue = true;
	            } else {
	                if (self._ffont) {
	                    delete self._ffont;
	                }
	                removeFormula(self, path, value);
	            }
	            value = updateOptionsItem(self, path, value, needValue);
	            if (!value) {
	                return;
	            }
	            var fontObj = parseCssFont(value);
	            var name = fontObj.name;
	            if (!name) {
	               
	                return;
	            }
	
	            self._shapeData._drawingText.TextBody.updateFont(name, fontObj.size, fontObj.bold, fontObj.italic);
	            self._shapeUI.options.textFormatOptions.font = value;
	            self._font = value;
	        };
	        prototype._updateFormulaItems = function (formulaItems, noEvents) {
	            var _this = this;
	            if (formulaItems) {
	                if (noEvents) {
	                    _this._isloading = true;
	                }
	                _this._forceRecalc = true;
	                if (formulaItems.left) {
	                    _this.x(formulaItems.left);
	                }
	                if (formulaItems.top) {
	                    _this.y(formulaItems.top);
	                }
	                if (formulaItems.width) {
	                    _this.width(formulaItems.width);
	                }
	                if (formulaItems.height) {
	                    _this.height(formulaItems.height);
	                }
	                if (formulaItems.angle) {
	                    _this.rotate(formulaItems.angle);
	                }
	                if (formulaItems.line) {
	                    _this._borderImp(formulaItems.line);
	                }
	                if (formulaItems.fillColor) {
	                    _this._backgroundImp(formulaItems.fillColor);
	                }
	                if (formulaItems.fillColorTransparency) {
	                    _this._backgroundTransparencyImp(formulaItems.fillColorTransparency);
	                }
	                if (formulaItems.text) {
	                    _this.text(formulaItems.text);
	                }
	                if (formulaItems.textColor) {
	                    _this._colorImp(formulaItems.textColor);
	                }
	                if (formulaItems.textTransparency) {
	                    _this._textTransparencyImp(formulaItems.textTransparency);
	                }
	                if (formulaItems.font) {
	                    _this._fontImp(formulaItems.font);
	                }
	                if (formulaItems.vAlign) {
	                    _this._vAlignImp(formulaItems.vAlign);
	                }
	                if (formulaItems.hAlign) {
	                    _this._hAlignImp(formulaItems.hAlign);
	                }
	                delete _this._forceRecalc;
	                if (noEvents) {
	                    delete _this._isloading;
	                }
	            }
	        };
	        prototype._initShapeUI = function () {
	            var _this = this, worksheet = _this._sheet, zoomFactor = worksheet.zoom();
	            _this._isloading = true;
	            var shapeData = _this._shapeData;
	            var autoShapeType = shapeData.AutoShapeType;
	            var shapeLayer = worksheet.shapeLayers[0];
	            var parentShapeID;
	            var isCustomShape = _this._isCustomShape, model;
	            if (!isCustomShape) {
	                var baseShape = getBaseShape(worksheet, shapeLayer, autoShapeType);
	                parentShapeID = baseShape.id;
	
	                model = {
	                    left: shapeData._left * zoomFactor,
	                    top: shapeData._top * zoomFactor,
	                    width: shapeData._width * zoomFactor,
	                    height: shapeData._height * zoomFactor,
	                    angle: shapeData.Rotation,
	                    parentShapeID: parentShapeID,
	                    options: {
	                        textFormatOptions: {
	                            text: _this.text() || _this.name(),
	                        }
	                    }
	                };
	            } else {
	                model = simpleCloneObject(_this._model); 
	               
	               
	               
	                if (!isNaN(shapeData._left) && (isNullOrUndefined(model.left) || !isNaN(+model.left))) {
	                    model.left = shapeData._left * zoomFactor;
	                }
	                if (!isNaN(shapeData._top) && (isNullOrUndefined(model.top) || !isNaN(+model.top))) {
	                    model.top = shapeData._top * zoomFactor;
	                }
	                if (!isNaN(shapeData._width) && (isNullOrUndefined(model.width) || !isNaN(+model.width))) {
	                    model.width = shapeData._width * zoomFactor;
	                }
	                if (!isNaN(shapeData._height) && (isNullOrUndefined(model.height) || !isNaN(+model.height))) {
	                    model.height = shapeData._height * zoomFactor;
	                }
	               
	                if (!isNaN(shapeData.Rotation) && isNullOrUndefined(model.angle)) {
	                    model.angle = shapeData.Rotation;
	                }
	
	                var t = model.left;
	                if (isFormula(t)) {
	                    _this._left = t;
	                }
	                t = model.top;
	                if (isFormula(t)) {
	                    _this._top = t;
	                }
	                t = model.height;
	                if (isFormula(t)) {
	                    _this._height = t;
	                }
	                t = model.width;
	                if (isFormula(t)) {
	                    _this._width = t;
	                }
	                t = model.angle;
	                if (isFormula(t)) {
	                    _this._angle = t;
	                }
	            }
	
	            var oldShapeUI = _this._shapeUI, oldParent, oldRelativeX, oldRelativeY, oldRelativeWidth, oldRelativeHeight;
	            if (oldShapeUI) {  
	                oldParent = oldShapeUI.parent;
	                oldRelativeX = oldShapeUI.relativeX;
	                oldRelativeY = oldShapeUI.relativeY;
	                oldRelativeWidth = oldShapeUI.relativeWidth;
	                oldRelativeHeight = oldShapeUI.relativeHeight;
	                if (oldParent) {
	                    oldParent.removeShape(oldShapeUI, true );
	                } else {
	                    shapeLayer.removeShape(oldShapeUI);
	                }
	            }
	
	           
	            syncShapeOptions(model, shapeData, shapeLayer, isCustomShape);
	            var options = model.options;
	           
	            _this._font = options.textFormatOptions.font;
	
	           
	           
	            var align = _this._hAlign = shapeData._hAlign;
	            if (align) {
	                options.textFormatOptions.horizontalAlignment = align;
	            }
	            align = _this._vAlign = shapeData._vAlign;
	            if (align) {
	                options.textFormatOptions.verticalAlignment = align;
	            }
	
	            var shape = shapeLayer.createShape(model);
	            shape.getShapeCenter();
	
	            if (!isCustomShape) {
	                var shapeModel = shapeLayer.model, shapeId = shape.id;
	                shapeModel._ignoreChange = true;   
	               
	                var exs = shapeModel.getExpressions(parentShapeID, 'variables');
	                if (autoShapeType && exs.variables) {
	                    syncShapeAdjustValues(exs, shapeData);
	                    shapeModel.setExpressions(shapeId, 'variables', exs.variables);
	                }
	
	                exs = shapeModel.getExpressions(parentShapeID, 'controls');
	                exs.controls && shapeModel.setExpressions(shapeId, 'controls', exs.controls);
	
	                exs = shapeModel.getExpressions(parentShapeID, 'path');
	                exs.path && shapeModel.setExpressions(shapeId, 'path', exs.path);
	                shape.resetPathOffset();
	
	                exs = shapeModel.getExpressions(parentShapeID, 'connectionPoints');
	                exs.connectionPoints && shapeLayer.model.setExpressions(shapeId, 'connectionPoints', exs.connectionPoints);
	
	                exs = shapeModel.getExpressions(parentShapeID, 'textRect');
	                exs.textRect && shapeModel.setExpressions(shapeId, 'textRect', exs.textRect);
	
	                delete shapeModel._ignoreChange;
	           
	           
	           
	           
	            }
	
	            if (shapeData._isFlipH) {
	                _this.flipX = true;
	            }
	            if (shapeData._isFlipV) {
	                _this.flipY = true;
	            }
	
	            shape._shapeWrapper = _this;
	
	            if (!isCustomShape) {
	                var presetShapeInfo = getPresetShapeInfo(autoShapeType);
	                if (presetShapeInfo.fnDefs) {
	                    shape._fnDefs = presetShapeInfo.fnDefs;
	                    shape._fnArgs = presetShapeInfo.fnArgs;
	                }
	               
	                shape._adjustInfo = presetShapeInfo.definition.adjustInfo;
	                shape._angleAdjustments = presetShapeInfo.definition.angleAdjustments;   
	            }
	            _this._shapeUI = shape;
	            if (oldShapeUI) {  
	                if (oldParent) {
	                    shape.relativeX = oldRelativeX;
	                    shape.relativeY = oldRelativeY;
	                    shape.relativeWidth = oldRelativeWidth;
	                    shape.relativeHeight = oldRelativeHeight;
	                    oldParent.addShape(shape, true );
	                } else {
	                   
	                    shapeLayer.addShape(shape);
	                    shape.isSelected = _this.isSelected();
	                }
	            }
	            _this._updateZoomInfo();
	            var formulaItems = !isCustomShape ? _this._formulaItems : getFormulaSettingItems(shape, _this._model);
	            _this._updateFormulaItems(formulaItems);
	            delete _this._isloading;
	        };
	       
	       
	       
	       
	       
	       
	       
	       
	        prototype.preProcessShapeDataFromJson = function (jsonData) {
	            var self = this;
	            if (jsonData.custom) {
	                var model = cloneCustomShapeModel(jsonData.modelData, true);
	                self._isCustomShape = true;
	                self._model = model;
	                applyPathOptions(model);
	            } else if (jsonData.formulaItems) {
	                self._formulaItems = jsonData.formulaItems;
	            }
	        };
	        function getFormulaSettingItems (shapeUI, originalModel, ignoreFormula) {
	            var service = shapeUI.getService(), id = shapeUI.id, formula;
	            var model = {}, formulaItems = {}, count = 0;
	            syncDataFromServiceCache(model, service, id, shapeUI.options, false , originalModel, ignoreFormula);
	           
	           
	           
	           
	            formula = model.left || originalModel && originalModel.left;
	            if (!isNullOrUndefined(formula)) {
	                count++;
	                formulaItems.left = formula;
	            }
	            formula = model.top || originalModel && originalModel.top;
	            if (!isNullOrUndefined(formula)) {
	                count++;
	                formulaItems.top = formula;
	            }
	            formula = model.width || originalModel && originalModel.width;
	            if (!isNullOrUndefined(formula)) {
	                count++;
	                formulaItems.width = formula;
	            }
	            formula = model.height || originalModel && originalModel.height;
	            if (!isNullOrUndefined(formula)) {
	                count++;
	                formulaItems.height = formula;
	            }
	            formula = model.angle || originalModel && originalModel.angle;
	            if (!isNullOrUndefined(formula)) {
	                count++;
	                formulaItems.angle = formula;
	            }
	            if (model._line) {
	                count++;
	                formulaItems.line = model._line;
	            }
	            var originalOptions = originalModel && originalModel.options;
	            var tmpFill = originalOptions && originalOptions.fill;
	            var t = model._fillColor || tmpFill && tmpFill.color;
	            if (t) {
	                count++;
	                formulaItems.fillColor = t;
	            }
	            t = model._fillColorTransparency || tmpFill && tmpFill.transparency;
	            if (t) {
	                count++;
	                formulaItems.fillColorTransparency = t;
	            }
	            var textFormatOptions = originalOptions && originalOptions.textFormatOptions;
	            t = model._text || textFormatOptions && textFormatOptions.text;
	            if (t) {
	                count++;
	                formulaItems.text = t;
	            }
	            tmpFill = textFormatOptions && textFormatOptions.fill;
	            t = model._textColor || tmpFill && tmpFill.color;
	            if (t) {
	                count++;
	                formulaItems.textColor = t;
	            }
	            t = model._textTransparency || tmpFill && tmpFill.transparency;
	            if (t) {
	                count++;
	                formulaItems.textTransparency = t;
	            }
	            t = model._ffont || textFormatOptions && textFormatOptions.font;
	            if (t) {
	                count++;
	                formulaItems.font = t;
	            }
	            t = model._fvAlign || textFormatOptions && textFormatOptions.verticalAlignment;
	            if (t) {
	                count++;
	                formulaItems.vAlign = t;
	            }
	            t = model._fhAlign || textFormatOptions && textFormatOptions.horizontalAlignment;
	            if (t) {
	                count++;
	                formulaItems.hAlign = t;
	            }
	            t = model._overFlow || textFormatOptions && textFormatOptions.allowTextToOverflowShape;
	            if (!isNullOrUndefined(t)) {
	                count++;
	                formulaItems.overFlow = t;
	            }
	            t = model._wrap || textFormatOptions && textFormatOptions.wrapTextInShape;
	            if (!isNullOrUndefined(t)) {
	                count++;
	                formulaItems.wrap = t;
	            }
	            return count && formulaItems;
	        }
	        Shapes.getFormulaSettingItems = getFormulaSettingItems;
	        prototype.preProcessShapeDataToJson = function (jsonData, ignoreFormula) {
	            var self = this;
	           
	            if (self._hAlign) {
	                jsonData.hAlign = self._hAlign;
	            }
	            if (self._vAlign) {
	                jsonData.vAlign = self._vAlign;
	            }
	            self._shapeData.AdjustValues = getShapeAdjustValues(self);
	            if (self._isCustomShape) {
	                jsonData.custom = true;
	                var model = syncCustomShapeModel(self, ignoreFormula);
	                jsonData.modelData = cloneCustomShapeModel(model, false);
	                delete jsonData.modelData.id;
	            } else {
	               
	                var shapeUI = self._shapeUI;
	                var formulaItems = getFormulaSettingItems(shapeUI, null, ignoreFormula);
	
	                if (formulaItems) {
	                    jsonData.formulaItems = formulaItems;
	                }
	            }
	        };
	        prototype._vAlignImp = function (value) {
	            var self = this;
	            var path = "options.textFormatOptions.verticalAlignment";
	            if (noArguments(arguments) || typeof value === "boolean") {
	                if (!value && self._fvAlign) {
	                    return getFormula(self, path);
	                }
	
	                return self._shapeUI.options.textFormatOptions.verticalAlignment;
	            }
	
	            var needValue;
	            if (isFormula(value)) {
	                self._fvAlign = value;
	                needValue = true;
	            } else {
	                if (self._fvAlign) {
	                    delete self._fvAlign;
	                }
	                removeFormula(self, path, value);
	            }
	            value = updateOptionsItem(self, path, value, needValue);
	
	           
	            self._shapeUI.options.textFormatOptions.verticalAlignment = value;
	           
	            self._vAlign = value;  
	         };
	        prototype._hAlignImp = function (value) {
	            var self = this;
	            var path = "options.textFormatOptions.horizontalAlignment";
	            if (noArguments(arguments) || typeof value === "boolean") {
	                if (!value && self._fhAlign) {
	                    return getFormula(self, path);
	                }
	
	                return self._shapeUI.options.textFormatOptions.horizontalAlignment;
	            }
	
	            var needValue;
	            if (isFormula(value)) {
	                self._fhAlign = value;
	                needValue = true;
	            } else {
	                if (self._fhAlign) {
	                    delete self._fhAlign;
	                }
	                removeFormula(self, path, value);
	            }
	            value = updateOptionsItem(self, path, value, needValue);
	
	           
	            self._shapeUI.options.textFormatOptions.horizontalAlignment = value;
	           
	            self._hAlign = value;  
	        };
	       
	        
	        prototype.adjustments = function (arrayValue) {
	            var self = this, shapeUI = self._shapeUI;
	            if (noArguments(arguments)) {
	                return getShapeAdjustments(shapeUI);
	            }
	            self._backup("adjustments");
	            updateShapeAdjustments(shapeUI, arrayValue);
	            self._fireEvents("adjustments");
	            self.refresh();
	        };
	       
	        
	        prototype.style = function (value) {
	            var self = this;
	            if (noArguments(arguments)) {
	                var style = new ShapeStyle();
	                style.fill = {
	                    color: self._backgroundImp(),
	                    transparency: self._backgroundTransparencyImp()
	                };
	                style.line = self._borderImp();
	                style.textEffect = {
	                    color: self._colorImp(),
	                    transparency: self._textTransparencyImp(),
	                    font: self._fontImp()
	                };
	                style.textFrame = {
	                    vAlign: self._vAlignImp(),
	                    hAlign: self._hAlignImp()
	                };
	                return style;
	            }
	
	            self._backup("style");
	
	            var fill = value.fill;
	            if (fill) {
	                adjustTransparentColor(fill);
	                var fill_color = fill.color;
	                if (!isNullOrUndefined(fill_color)) {
	                    self._backgroundImp(fill_color);
	                }
	                var fill_transparency = fill.transparency;
	                if (!isNullOrUndefined(fill_transparency)) {
	                    self._backgroundTransparencyImp(fill_transparency);
	                }
	            }
	            var line = value.line;
	            if (line) {
	                adjustTransparentColor(line);
	                self._borderImp(line);
	            }
	            var textEffect = value.textEffect;
	            if (textEffect) {
	                var textEffect_color = textEffect.color;
	                if (!isNullOrUndefined(textEffect_color)) {
	                    self._colorImp(textEffect_color);
	                }
	                var textEffect_transparency = textEffect.transparency;
	                if (!isNullOrUndefined(textEffect_transparency)) {
	                    self._textTransparencyImp(textEffect_transparency);
	                }
	                var textEffect_font = textEffect.font;
	                if (!isNullOrUndefined(textEffect_font)) {
	                    self._fontImp(textEffect_font);
	                }
	            }
	            var textFrame = value.textFrame;
	            if (textFrame) {
	                var textFrame_vAlign = textFrame.vAlign;
	                if (!isNullOrUndefined(textFrame_vAlign)) {
	                    self._vAlignImp(textFrame_vAlign);
	                }
	                var textFrame_hAlign = textFrame.hAlign;
	                if (!isNullOrUndefined(textFrame_hAlign)) {
	                    self._hAlignImp(textFrame_hAlign);
	                }
	            }
	
	            self._fireEvents("style");
	            self.refresh();
	        };
	        prototype._createCloneShape = function (sheet) {
	            return new Shape(sheet);
	        };
	
	        return Shape;
	    })(ShapeBase);
	    Shapes.Shape = Shape;
	
	    var ConnectorShape = (function (_super) {
	        $.inherit(ConnectorShape, _super);
	
	       
	
	        
	        function ConnectorShape(worksheet, name, connectorType, beginX, beginY, endX, endY) {
	            var _this = _super.call(this) || this;
	            this._shapeType = 4 ;
	            var shapeName = name && worksheet._ensureUniqueShapeName(name) || worksheet._ensureUniqueShapeName("ConnectorShape ", true );
	            _this._sheet = worksheet;
	            _this._shapeData = new Shapes.ConnectorShapeData(worksheet, shapeName, connectorType, beginX, beginY, endX, endY);
	            if (connectorType !== undefined) {
	                _this._initShapeUI();
	            }
	        }
	
	        var connectorShapePrototype = ConnectorShape.prototype;
	        delete connectorShapePrototype.rotate;
	        delete connectorShapePrototype._setAngle;
	
	
	       
	        
	        connectorShapePrototype.type = function () {
	            if (noArguments(arguments)) {
	                return this._shapeData.ConnectorFormat.Type;
	            }
	        };
	        connectorShapePrototype._beginArrowheadImp = function (value) {
	            var _this = this;
	            var line = _this._shapeData.Line;
	            if (noArguments(arguments)) {
	                return {
	                    style: line.BeginArrowheadStyle,
	                    width: line.BeginArrowheadWidth,
	                    length: line.BeginArrowheadLength
	                };
	            }
	
	            if (!isNullOrUndefined(value)) {
	                var uiOpitions = _this._shapeUI.options.endPoints.beginArrow;
	                var style = value.style, width = value.width, length = value.length;
	                if (!isNullOrUndefined(style)) {
	                    line.BeginArrowheadStyle = style;
	                    uiOpitions.type = style;
	                }
	                if (!isNullOrUndefined(width)) {
	                    line.BeginArrowheadWidth = width;
	                    uiOpitions.widthType = width;
	                }
	                if (!isNullOrUndefined(length)) {
	                    line.BeginArrowheadLength = length;
	                    uiOpitions.lengthType = length;
	                }
	            }
	        };
	        connectorShapePrototype._endArrowheadImp = function (value) {
	            var _this = this;
	            var line = _this._shapeData.Line;
	            if (noArguments(arguments)) {
	                return {
	                    style: line.EndArrowheadStyle,
	                    width: line.EndArrowheadWidth,
	                    length: line.EndArrowheadLength
	                };
	            }
	
	            if (!isNullOrUndefined(value)) {
	                var uiOpitions = _this._shapeUI.options.endPoints.endArrow;
	                var style = value.style, width = value.width, length = value.length;
	                if (!isNullOrUndefined(style)) {
	                    line.EndArrowheadStyle = style;
	                    uiOpitions.type = style;
	                }
	                if (!isNullOrUndefined(width)) {
	                    line.EndArrowheadWidth = width;
	                    uiOpitions.widthType = width;
	                }
	                if (!isNullOrUndefined(length)) {
	                    line.EndArrowheadLength = length;
	                    uiOpitions.lengthType = length;
	                }
	            }
	        };
	
	        function syncConnectors(connectors, shape) {
	            shape.ignoreLayoutConnection = true;
	            if (connectors[0]) {
	                shape.startConnector(connectors[0], true );
	            }
	            if (connectors[1]) {
	                shape.endConnector(connectors[1], true );
	            }
	            delete shape.ignoreLayoutConnection;
	        }
	
	        Shapes.syncConnectors = syncConnectors;
	
	        connectorShapePrototype._initShapeUI = function (ignoreSyncConnectors) {
	            var _this = this, worksheet = _this._sheet, shapeData = _this._shapeData;
	            _this._isloading = true;
	            var type = shapeData.ConnectorFormat.Type;
	            var options = _this._getOptions();
	            var shapeUI, points = _this._getPoints();
	            var shapeLayer = worksheet.shapeLayers[0];
	            var lineName;
	            if (type === 0 ) {
	                lineName = "Line";
	            } else if (type === 1  || type === 2 ) {
	                lineName = "ZipLine";
	            }
	            var zoomFactor = worksheet.zoom();
	            points = points.map(function (t) {
	                return {
	                    x: t.x * zoomFactor,
	                    y: t.y * zoomFactor
	                };
	            });
	            if (lineName) {
	                var model = {
	                    points: points,
	                    options: options
	                };
	                syncShapeOptions(model, shapeData, shapeLayer);
	
	                shapeUI = shapeLayer.createLine(lineName, model);
	                shapeUI.getShapeCenter();
	                shapeUI._shapeWrapper = _this;
	
	            }
	            _this._shapeUI = shapeUI;
	           
	            if (!ignoreSyncConnectors) {
	                syncConnectors([_this.startConnector(), _this.endConnector()], _this);
	            }
	
	            _this._updateZoomInfo();
	            delete _this._isloading;
	        };
	        connectorShapePrototype._getOptions = function () {
	            var _this = this, beginArrowhead = _this._beginArrowheadImp(), endArrowhead = _this._endArrowheadImp();
	            return {
	                stroke: {
	                    type: 1,
	                    color: _this._borderImp(true).color,
	                    width: 1
	                },
	                endPoints: {
	                    beginArrow: {
	                        type: beginArrowhead.style,
	                        widthType: beginArrowhead.width,
	                        lengthType: beginArrowhead.length
	                    },
	                    endArrow: {
	                        type: endArrowhead.style,
	                        widthType: endArrowhead.width,
	                        lengthType: endArrowhead.length
	                    }
	                }
	            };
	        };
	        connectorShapePrototype._getPoints = function (getPointsFromShapeData) {
	            var _this = this, points = _this._points;
	            if (!points || getPointsFromShapeData) {
	                var shapeData = _this._shapeData;
	                var left = shapeData._left || 0, top = shapeData._top || 0, width = shapeData._width || 0,
	                    height = shapeData._height || 0;
	               
	               
	               
	               
	               
	                var isFilpV = shapeData._isFlipV, isFilpH = shapeData._isFlipH;
	
	                var type = shapeData.ConnectorFormat.Type;
	                var rotation = shapeData.Rotation;
	                if (type === 0 ) {
	                    points = _this._points = _this._getLinePoints(top, left, width, height, isFilpV, isFilpH, rotation);
	                } else if (type === 1  || type === 2 ) {
	                    points = _this._points = _this._getZipLinePoints(top, left, width, height, isFilpV, isFilpH, rotation, shapeData.AdjustValues);
	                }
	            }
	            return points;
	        };
	        connectorShapePrototype._getLinePoints = function (top, left, width, height, isFilpV, isFilpH, angle) {
	            var startX, startY, endX, endY;
	            if (isFilpV && isFilpH) {
	                startX = left + width;
	                startY = top + height;
	                endX = left;
	                endY = top;
	            } else if (isFilpV) {
	                startX = left;
	                startY = top + height;
	                endX = left + width;
	                endY = top;
	            } else if (isFilpH) {
	                startX = left + width;
	                startY = top;
	                endX = left;
	                endY = top + height;
	            } else {
	                startX = left;
	                startY = top;
	                endX = left + width;
	                endY = top + height;
	            }
	
	            var origin = {x: left + width / 2, y: top + height / 2}, radians = angle / 180 * Math.PI;
	            var point1 = rotatePoint({x: startX, y: startY}, origin, radians),
	                point2 = rotatePoint({x: endX, y: endY}, origin, radians);
	            return [
	                point1,
	                point2
	            ];
	        };
	        connectorShapePrototype._getZipLinePointsWithBent2 = function (top, left, width, height, isFilpV, isFilpH, radians, origin) {
	            var point1, point2, point3;
	            point1 = flipAndRotatePoint(0, 0, isFilpV, isFilpH, left, top, width, height, origin, radians);
	            point2 = flipAndRotatePoint(width, 0, isFilpV, isFilpH, left, top, width, height, origin, radians);
	            point3 = flipAndRotatePoint(width, height, isFilpV, isFilpH, left, top, width, height, origin, radians);
	            return [
	                point1,
	                point2,
	                point3
	            ];
	        };
	        connectorShapePrototype._getZipLinePointsWithBent3 = function (top, left, width, height, isFilpV, isFilpH, radians, origin, adjustValue) {
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	
	            if(!adjustValue) {
	                adjustValue = [0.5];
	            }
	            var point1, point2, point3, point4;
	            point1 = flipAndRotatePoint(0, 0, isFilpV, isFilpH, left, top, width, height, origin, radians);
	            point2 = flipAndRotatePoint(width * adjustValue[0], 0, isFilpV, isFilpH, left, top, width, height, origin, radians);
	            point3 = flipAndRotatePoint(width * adjustValue[0], height, isFilpV, isFilpH, left, top, width, height, origin, radians);
	            point4 = flipAndRotatePoint(width, height, isFilpV, isFilpH, left, top, width, height, origin, radians);
	            return [
	                point1,
	                point2,
	                point3,
	                point4
	            ];
	        };
	        connectorShapePrototype._getZipLinePointsWithBent4 = function (top, left, width, height, isFilpV, isFilpH, radians, origin, adjustList) {
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	
	            var point1, point2, point3, point4, point5;
	            point1 = flipAndRotatePoint(0, 0, isFilpV, isFilpH, left, top, width, height, origin, radians);
	            point2 = flipAndRotatePoint(width * adjustList[0], 0, isFilpV, isFilpH, left, top, width, height, origin, radians);
	            point3 = flipAndRotatePoint(width * adjustList[0], height * adjustList[1], isFilpV, isFilpH, left, top, width, height, origin, radians);
	            point4 = flipAndRotatePoint(width, height * adjustList[1], isFilpV, isFilpH, left, top, width, height, origin, radians);
	            point5 = flipAndRotatePoint(width, height, isFilpV, isFilpH, left, top, width, height, origin, radians);
	            return [
	                point1,
	                point2,
	                point3,
	                point4,
	                point5
	            ];
	        };
	        connectorShapePrototype._getZipLinePointsWithBent5 = function (top, left, width, height, isFilpV, isFilpH, radians, origin, adjustList) {
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	            var point1, point2, point3, point4, point5, point6;
	            point1 = flipAndRotatePoint(0, 0, isFilpV, isFilpH, left, top, width, height, origin, radians);
	            point2 = flipAndRotatePoint(width * adjustList[0], 0, isFilpV, isFilpH, left, top, width, height, origin, radians);
	            point3 = flipAndRotatePoint(width * adjustList[0], height * adjustList[1], isFilpV, isFilpH, left, top, width, height, origin, radians);
	            point4 = flipAndRotatePoint(width * adjustList[2], height * adjustList[1], isFilpV, isFilpH, left, top, width, height, origin, radians);
	            point5 = flipAndRotatePoint(width * adjustList[2], height, isFilpV, isFilpH, left, top, width, height, origin, radians);
	            point6 = flipAndRotatePoint(width, height, isFilpV, isFilpH, left, top, width, height, origin, radians);
	            return [
	                point1,
	                point2,
	                point3,
	                point4,
	                point5,
	                point6
	            ];
	        };
	        connectorShapePrototype._getZipLinePointsWithAdjust = function (top, left, width, height, isFilpV, isFilpH, radians, origin, adjustList) {
	            var fn;
	            switch (this._shapeData._pointNum) {
	                case 2:
	                    fn = this._getZipLinePointsWithBent2;
	                    break;
	                case 3: 
	                    fn = this._getZipLinePointsWithBent3;
	                    break;
	                case 4:
	                    fn = this._getZipLinePointsWithBent4;
	                    break;
	                case 5:
	                    fn = this._getZipLinePointsWithBent5;
	                    break;
	            }
	            return fn && fn(top, left, width, height, isFilpV, isFilpH, radians, origin, adjustList);
	        };
	        connectorShapePrototype._getZipLinePoints = function (top, left, width, height, isFilpV, isFilpH, angle, adjustValue) {
	            var origin = {x: left + width / 2, y: top + height / 2}, radians = angle / 180 * Math.PI;
	            var adjustList;
	            if(adjustValue && adjustValue.length > 0) {
	               
	                adjustList = adjustValue.map(function (adjust) {
	                    return adjust[1] / adjustmentUnit;
	                });
	            }
	            return this._getZipLinePointsWithAdjust(top, left, width, height, isFilpV, isFilpH, radians, origin, adjustList);
	        };
	        connectorShapePrototype._clonePoints = function (points) {
	            if (points === undefined) {
	                points = this._shapeUI.getPoints();
	            }
	            var newPoints = [];
	            for(var i = 0, len = points.length; i < len; i++) {
	                newPoints.push({x : points[i].x, y : points[i].y});
	            }
	            return newPoints;
	        };
	       
	       
	
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	        connectorShapePrototype._getAdjustValues = function () {
	            var adjustList = [];
	            var properties = getConnectorProperties(this._clonePoints());
	            var adjs = properties.adjs;
	            if (adjs && adjs.length) {
	                adjs.forEach(function(value, index) {
	                    adjustList.push(['adj' + (index + 1), value]);
	                });
	            }
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	       
	            return adjustList;
	
	        };
	
	        connectorShapePrototype.preProcessShapeDataToJson = function () {
	            var self = this;
	            self._shapeData._pointNum = self._points.length - 1;
	            var properties = getConnectorProperties(self._clonePoints());
	            var angle = self._shapeUI.angle;
	            if (!isNaN(angle)) {
	                properties.rot = properties.rot + angle;
	            }
	            var zoomFactor = self._sheet.zoom();
	            syncShapeData(self._shapeData, properties, zoomFactor);
	        };
	        connectorShapePrototype._setPoints = function (points) {
	            var self = this, shapeData = self._shapeData;
	            self._backup("points", {
	                points : self._clonePoints(self._points)
	            });
	
	            var zoomFactor = self._sheet.zoom();
	           
	           
	           
	           
	           
	           
	           
	           
	           
	           
	            self._points = points;
	            self._shapeUI.setPoints(self._points, zoomFactor);
	            shapeData._pointNum = self._points.length - 1;
	            var properties = getConnectorProperties(self._clonePoints());
	            syncShapeData(shapeData, properties, zoomFactor);
	        };
	       
	        
	        connectorShapePrototype.adjustments = function (arrayValue) {
	            var self = this;
	            if (noArguments(arguments)) {
	                var adjustValues = self._getAdjustValues();
	                if (adjustValues && adjustValues.length > 0) {
	                    return adjustValues.map(function (adjustValue) {
	                        return adjustValue[1];
	                    });
	                }
	                return [];
	            }
	            if (arrayValue && arrayValue.length > 0 && self._points.length > 2) {
	                var left = self.x(), top = self.y(), width = self.width(), height = self.height(), angle = self._shapeData.Rotation;
	                var origin = {x: left + width / 2, y: top + height / 2}, radians = angle / 180 * Math.PI;
	                var points = self._getZipLinePointsWithAdjust(self.y(), self.x(), self.width(), self.height(), self._shapeData._isFlipV, self._shapeData._isFlipH, radians, origin, arrayValue);
	                self._setPoints(points);
	                self.refresh();
	            }
	
	        };
	       
	        
	        connectorShapePrototype.style = function (value) {
	            var self = this;
	            if (noArguments(arguments)) {
	                var style = new ShapeStyle();
	                var style_line = style.line = self._borderImp();
	                var beginArrowhead = self._beginArrowheadImp();
	                style_line.beginArrowheadStyle = beginArrowhead.style;
	                style_line.beginArrowheadWidth = beginArrowhead.width;
	                style_line.beginArrowheadLength = beginArrowhead.length;
	                var endArrowhead = self._endArrowheadImp();
	                style_line.endArrowheadStyle = endArrowhead.style;
	                style_line.endArrowheadWidth = endArrowhead.width;
	                style_line.endArrowheadLength = endArrowhead.length;
	                delete style.fill;
	                delete style.textEffect;
	                delete style.textFrame;
	                return style;
	            }
	
	            self._backup("style");
	
	            var line = value.line;
	            if (line) {
	                var line_color = line.color;
	                if (!isNullOrUndefined(line_color)) {
	                    self._borderImp({
	                        color: line_color,
	                        lineStyle: line.lineStyle,
	                        width: line.width,
	                        capType: line.capType,
	                        joinType: line.joinType,
	                        transparency: line.transparency,
	                    });
	                }
	                var line_beginArrowheadStyle = line.beginArrowheadStyle;
	                if (!isNullOrUndefined(line_beginArrowheadStyle)) {
	                    self._beginArrowheadImp({
	                        style: line_beginArrowheadStyle,
	                        width: line.beginArrowheadWidth,
	                        length: line.beginArrowheadLength,
	                    });
	
	                }
	                var line_endArrowheadStyle = line.endArrowheadStyle;
	                if (!isNullOrUndefined(line_endArrowheadStyle)) {
	                    self._endArrowheadImp({
	                        style: line_endArrowheadStyle,
	                        width: line.endArrowheadWidth,
	                        length: line.endArrowheadLength,
	                    });
	                }
	            }
	            
	            self._fireEvents("style");
	            self.refresh();
	        };
	       
	        
	        connectorShapePrototype.startConnector = function (connector, ignoreMovePoint) {
	            
	            var _this = this;
	            var format = _this._shapeData.ConnectorFormat;
	            if (noArguments(arguments)) {
	                if (!format.BeginConnected) {
	                    return null;
	                }
	                return {
	                    name: format.BeginConnected,
	                    index: format.BeginConnectionSite,
	                    shape: format.BeginConnectedShape
	                };
	            }
	
	            var shapeUI = _this._shapeUI;
	            var startConnector = _this.startConnector();
	            var points;
	            _this._backup('startConnector', startConnector ? {
	                name: startConnector.name,
	                index: startConnector.index
	            } : null);
	
	            format.BeginConnected = connector ? connector.name : "";
	            format.BeginConnectionSite = connector ? connector.index : -1;
	
	            startConnector = null;
	            if (connector) {
	                var index = connector.index;
	                var name = connector.name;
	                var shape = _this._sheet.shapes.get(name);
	                if (shape) {
	                    startConnector = {
	                        id: shape._shapeUI.id,
	                        index: index
	                    };
	                    if (!ignoreMovePoint) {
	                        points = shape._shapeUI.getActualConnectorPoints();
	                        var point = points[index];
	                        if (point) {
	                            shapeUI.moveStartPoint(point.x, point.y);
	                        } else {
	                           
	                            startConnector = null;
	                        }
	                    }
	                }
	            }
	            shapeUI.updateStartConnector(startConnector);
	
	            _this._fireEvents("startConnector");
	
	           
	            if (!_this.ignoreLayoutConnection && points && points.length && _this._sheet && (_this._shapeUI instanceof Shapes.ZipLine)) {
	                _this._sheet._layoutConnectionLine(shapeUI, points);
	                var zoom = _this._sheet.zoom(), newPoints = shapeUI.getPoints().map(function (t) {
	                    return {
	                        x: t.x / zoom,
	                        y: t.y / zoom
	                    };
	                });
	                _this._setPoints(newPoints);
	            }
	            _this.refresh();
	
	        };
	
	       
	        
	        connectorShapePrototype.endConnector = function (connector, ignoreMovePoint) {
	            
	            var _this = this;
	            var format = _this._shapeData.ConnectorFormat;
	            if (noArguments(arguments)) {
	                if (!format.EndConnected) {
	                    return null;
	                }
	                return {
	                    name: format.EndConnected,
	                    index: format.EndConnectionSite,
	                    shape: format.EndConnectedShape
	                };
	            }
	
	            var shapeUI = _this._shapeUI;
	            var endConnector = _this.endConnector();
	            var points;
	            _this._backup('endConnector', endConnector ? {
	                name: endConnector.name,
	                index: endConnector.index
	            } : null);
	            format.EndConnected = connector ? connector.name : "";
	            format.EndConnectionSite = connector ? connector.index : -1;
	
	            endConnector = null;
	            if (connector) {
	                var index = connector.index;
	                var name = connector.name;
	                var shape = _this._sheet.shapes.get(name);
	                if (shape) {
	                    endConnector = {
	                        id: shape._shapeUI.id,
	                        index: index
	                    };
	                    if (!ignoreMovePoint) {
	                        points = shape._shapeUI.getActualConnectorPoints();
	                        var point = points[index];
	                        if (point) {
	                            shapeUI.moveEndPoint(point.x, point.y);
	
	                        } else {
	                           
	                            endConnector = null;
	                        }
	                    }
	                }
	            }
	            shapeUI.updateEndConnector(endConnector);
	            _this._fireEvents("endConnector");
	           
	            if(!_this.ignoreLayoutConnection && points && points.length && _this._sheet && (_this._shapeUI instanceof Shapes.ZipLine)) {
	                _this._sheet._layoutConnectionLine(shapeUI, points);
	                var zoom = _this._sheet.zoom(), newPoints = shapeUI.getPoints().map(function (t) {
	                    return {
	                        x: t.x / zoom,
	                        y: t.y / zoom
	                    };
	                });
	                _this._setPoints(newPoints);
	            }
	            _this.refresh();
	        };
	       
	       
	       
	       
	       
	       
	       
	       
	        connectorShapePrototype._borderImp = function (value) {
	            var self = this, line = self._shapeData.Line;
	            if (noArguments(arguments) || typeof value === "boolean") {
	                var result = getLineFormatInfo(line);
	                if (!value && self._line) {
	                    return {
	                        color: getFormula(self, "options.stroke._color") || result.color,
	                        lineStyle: getFormula(self, "options.stroke._lineStyle") || result.lineStyle,
	                        width: getFormula(self, "options.stroke._width") || result.width,
	                        capType: getFormula(self, "options.stroke._capType") || result.capType,
	                        joinType: getFormula(self, "options.stroke._joinType") || result.joinType,
	                        transparency: getFormula(self, "options.stroke._transparency") || result.transparency
	                    };
	                }
	
	                return result;
	            }
	
	            if (typeof value !== 'object') {
	               
	                return;
	            }
	
	            var hasFormula;
	            value = simpleCloneObject(value);
	            self._line = value;
	            for (var name in value) {    
	                var v = value[name];
	                var path = "options.stroke._" + name, needValue = isFormula(v);
	                if (needValue && !hasFormula) {
	                    hasFormula = true;
	                }
	                value[name] = updateOptionsItem(self, path, v, needValue);
	            }
	            if (!hasFormula) {
	                delete self._line;
	            }
	
	            var colorValue = value.color;
	            if (colorValue === "" || colorValue === null) {
	                line.Color.ColorType = 0 ;
	            } else {
	                line.Color.setColor(self._sheet, value.color);
	            }
	            line.DashStyle = value.lineStyle;
	            line.Weight = value.width;
	            line.CapStyle = value.capType;
	            line.JoinStyle = value.joinType;
	           
	            var transparency = value.transparency;
	            if (!isNaN(transparency)) {
	                transparency = Math_min(1, transparency);
	                transparency = Math_max(0, transparency);
	                line.Transparency = transparency;
	            }
	            syncShapeLineFormat(self._shapeUI.options, self._shapeData);
	        };
	
	        connectorShapePrototype._updateFormulaItems = function (formulaItems, noEvents) {
	            var _this = this;
	            if (formulaItems) {
	                if (noEvents) {
	                    _this._isloading = true;
	                }
	                _this._forceRecalc = true;
	                if (formulaItems.line) {
	                    _this._borderImp(formulaItems.line);
	                }
	                delete _this._forceRecalc;
	                if (noEvents) {
	                    delete _this._isloading;
	                }
	            }
	        };
	
	        connectorShapePrototype._onRefreshShapeUI = function () {
	           
	           
	           
	        };
	
	        connectorShapePrototype._restoreByType = function (type, value) {
	            var self = this;
	            switch (type) {
	                case 'startConnector':
	                case 'endConnector':
	                    self[type](value);
	                    break;
	                case 'points':
	                    self._setPoints(value.points);
	                    break;
	                default:
	                    break;
	            }
	        };
	
	        connectorShapePrototype._createCloneShape = function (sheet) {
	            return new ConnectorShape(sheet);
	        };
	
	        return ConnectorShape;
	    })(ShapeBase);
	    Shapes.ConnectorShape = ConnectorShape;
	
	    var getLineShapeBoundByPoints = Shapes.getLineShapeBoundByPoints;
	
	    function getShapeBound(shape) {
	        var shapeUI = shape._shapeUI, bounds;
	        if (shapeUI instanceof Shapes.ZipLine) {
	            bounds = getLineShapeBoundByPoints(shapeUI.getPoints());
	            bounds.width = bounds.right - bounds.left;
	            bounds.height = bounds.bottom - bounds.top;
	        } else {
	            bounds = { 
	                left: shape.x(), 
	                top: shape.y(), 
	                width: shape.width(), 
	                height: shape.height()
	            };
	            bounds.right = bounds.left + bounds.width;
	            bounds.bottom = bounds.top + bounds.height;
	        }
	        return bounds;
	    }
	
	   
	    var GroupShape = (function (_super) {
	        $.inherit(GroupShape, _super);
	        
	       
	        
	        function GroupShape(worksheet, name) {
	            var left = -1, top = -1, width = -1, height = -1;
	            var _this = _super.call(this) || this;
	            this._shapeType = 3 ;
	            var shapeName = name && worksheet._ensureUniqueShapeName(name) || worksheet._ensureUniqueShapeName("GroupShape ", true );
	            _this._sheet = worksheet;
	            _this._shapeData = new Shapes.GroupShapeData(worksheet, shapeName, left, top, width, height);
	            _this._shapes = [];
	           
	        }
	
	        var groupShapePrototype = GroupShape.prototype;
	
	       
	        
	
	       
	        
	        groupShapePrototype.add = function (shape) {
	            var self = this;
	
	            self._shapes.push(shape);
	            self._shapeData.GroupItems.Add(shape._shapeData, self._shapeData);
	            var shapeUI = shape._shapeUI;
	            if(self._shapeUI) {
	                self._shapeUI.addShape(shapeUI);
	            }
	            if (!self._ignoreUpdate) {
	               
	                var bounds = getShapeBound(shape);
	                var shapeLeft = bounds.left, shapeTop = bounds.top, shapeWidth = bounds.width, shapeHeight = bounds.height;
	                self._ignoreChildren = true;
	                if (self.x() === -1) {
	                    self.x(shapeLeft);
	                    self.y(shapeTop);
	                    self.width(shapeWidth);
	                    self.height(shapeHeight);
	                } else {
	                    var left = self.x(), top = self.y();
	                    self.x(Math_min(shapeLeft, left));
	                    self.y(Math_min(shapeTop, top));
	                
	                   
	                    self.width(Math_max(shapeLeft + shapeWidth, left + self.width()) - self.x());
	                    self.height(Math_max(shapeTop + shapeHeight, top + self.height()) - self.y());
	                }
	                delete self._ignoreChildren;
	                
	                self.updateRelativeLocationSize();
	            }
	            
	
	           
	           
	            self._backup("groupAddShape", {
	                groupShape : self,
	                shape : shape
	            });
	            self.refresh();
	        };
	       
	        
	        groupShapePrototype.all = function() {
	          return this._shapes.concat();
	        };
	
	        function getValue(obj) {
	            return obj[this.property];
	        }
	
	        function setRectSize(rect) {
	            rect.width = rect.right - rect.left;
	            rect.height = rect.bottom - rect.top;
	        }
	
	        function getMaxBounds(rects) {
	            var bounds = {
	                left: Math_min.apply(null, rects.map(getValue.bind({ property: 'left' }))),
	                top: Math_min.apply(null, rects.map(getValue.bind({ property: 'top' }))),
	                right: Math_max.apply(null, rects.map(getValue.bind({ property: 'right' }))),
	                bottom: Math_max.apply(null, rects.map(getValue.bind({ property: 'bottom' })))
	            };
	
	            setRectSize(bounds);
	
	            return bounds;
	        }
	
	
	       
	        
	        groupShapePrototype.remove = function (shape) {
	            var self = this;
	            var shapes = self._shapes;
	            var index = shapes.indexOf(shape);
	            if(index < 0) {
	                return;
	            }
	
	
	
	            shapes.splice(index, 1);
	            self._shapeData.GroupItems.Remove(shape._shapeData);
	            if(self._shapeUI) {
	                self._shapeUI.removeShape(shape._shapeUI);
	            }
	           
	            delete shape.relativeHeight;
	            delete shape.relativeWidth;
	            delete shape.relativeX;
	            delete shape.relativeY;
	           
	           
	
	            if (!self._ignoreUpdate) {
	                self._ignoreChildren = true;
	                var len = shapes.length;
	                if (len === 0) {
	                    self.x(-1);
	                    self.y(-1);
	                    self.width(-1);
	                    self.height(-1);
	                } else {
	                    self._reLocateGroup();
	                }
	                delete self._ignoreChildren;
	
	                self.updateRelativeLocationSize();
	            }
	            self._backup("groupRemoveShape", {
	                groupShape : self,
	                shape : shape
	            });
	            self.refresh();
	        };
	       
	        
	        groupShapePrototype.find = function (name) {
	            var shapes = this._shapes;
	            for (var i = 0, length = shapes.length; i < length; i++) {
	                var shape = shapes[i];
	                if (shape.name() === name) {
	                    return shapes[i];
	                }
	               
	                if (shape._shapeType === 3 ) {
	                    var t = shape.find(name);
	                    if (t) {
	                        return t;
	                    }
	                }
	            }
	            return null;
	        };
	        groupShapePrototype._initShapeUI = function (shapes) {
	            var _this = this, sheet = _this._sheet;
	            _this._isloading = true;
	            var shapeData = _this._shapeData;
	            var childrenData = shapeData.childrenData || [];
	            if (!shapes) {
	                var sp;
	                shapes = _this._shapes;
	                shapeData.GroupItems.Items.forEach(function (spData, index) {
	                    var name = spData._name;
	                    var shapeType = spData._shapeType;
	                    if (shapeType === 0 ) {
	                        sp = new Shapes.Shape(sheet, name);
	                    } else if (shapeType === 1 ) {
	                        sp = new Shapes.ConnectorShape(sheet, name);
	                    } else if (shapeType === 2 ) {
	                        sp = new Shapes.GroupShape(sheet, name);
	                    }
	                    if (sp) {
	                        spData._setName(sp.name());
	                        sp._shapeData = spData;
	
	                       
	                        var jsonData = childrenData[index];
	                        if (jsonData) {
	                            sp.preProcessShapeDataFromJson(jsonData);
	                        }
	
	                        sp._initShapeUI();
	
	                        shapes.push(sp);
	                    }
	                });
	            }
	
	            _this._shapes = shapes;
	            var shapeUIs = [];
	            shapes.forEach(function (s) {
	                shapeUIs.push(s._shapeUI);
	            });
	            var model = {};
	           
	            syncShapeOptions(model, shapeData, sheet.shapeLayers[0]);
	            var shapeUI = new Shapes.CompoundShape(shapeUIs, model);
	            shapeUI.angle = shapeData.Rotation;
	            shapeUI.getShapeCenter();
	            shapeUI._shapeWrapper = _this;
	            var x = shapeUI.left, y = shapeUI.top, width = shapeUI.width, height = shapeUI.height;
	            var forceUpdatePosition = true;
	            _this._setLocation(x, y, forceUpdatePosition);
	            _this._setSize(width, height, forceUpdatePosition);
	            _this.updateRelativeLocationSize();
	
	            _this._shapeUI = shapeUI;
	            delete _this._isloading;
	        };
	        groupShapePrototype._disposeShapeUI = function () {
	            var _this = this;
	            _this._shapeUI.shapes.forEach(function (sp) {
	                sp.parent = null;
	            });
	            _this._shapeUI = null;
	        };
	        groupShapePrototype._updateChildren = function() {
	            var self = this;
	            self.layoutChildren();
	            self._refreshShapeUI();
	            self.refresh();
	        };
	        groupShapePrototype.x = function () {
	            var self = this;
	            var result = _super.prototype.x.apply(self, arguments);
	
	            if (!noArguments(arguments) && !self._ignoreChildren) {
	                self._updateChildren();
	            }
	            return result;
	        };
	        groupShapePrototype._refreshWithUI = function () {
	
	        };
	        groupShapePrototype.y = function () {
	            var self = this;
	            var result = _super.prototype.y.apply(self, arguments);
	
	            if (!noArguments(arguments) && !self._ignoreChildren) {
	               
	                self._updateChildren();
	            }
	
	            return result;
	        };
	        groupShapePrototype.width = function () {
	            var self = this;
	            var result = _super.prototype.width.apply(self, arguments);
	
	            if (!noArguments(arguments) && !self._ignoreChildren) {
	               
	                self._updateChildren();
	            }
	
	            return result;
	        };
	        groupShapePrototype.height = function () {
	            var self = this;
	            var result = _super.prototype.height.apply(self, arguments);
	
	            if (!noArguments(arguments) && !self._ignoreChildren) {
	               
	                self._updateChildren();
	            }
	
	            return result;
	        };
	        groupShapePrototype.updateGroup = function () {
	            var self = this, shapes = self._shapes, len = shapes.length;
	            if (len < 0) {
	                return;
	            }
	            self._updateShape();
	        };
	        groupShapePrototype._reLocateGroup = function () {
	            var self = this, shapes = self._shapes;
	            
	            var bounds = getMaxBounds(shapes.map(function(sp) { 
	                return getShapeBound(sp); 
	            }));
	            self.x(bounds.left);
	            self.y(bounds.top);
	            self.width(bounds.width);
	            self.height(bounds.height);
	        };
	        groupShapePrototype._updateShape = function () {
	            var self = this;
	
	            self._ignoreChildren = true;
	            self._reLocateGroup();
	            delete self._ignoreChildren;
	            self.updateRelativeLocationSize();
	            self._shapeUI.update();
	        };
	        groupShapePrototype.afterResize = function () {
	            var self = this;
	            self.layoutChildren();
	        };
	        groupShapePrototype.updateRelativeLocationSize = function () {
	            var self = this, top = self.y(), left = self.x(), width = self.width(), height = self.height();
	            self._shapes.forEach(function (shape) {
	                shape.relativeX = (shape.x() - left) / width;
	                shape.relativeY = (shape.y() - top) / height;
	                shape.relativeWidth = shape.width() / width;
	                shape.relativeHeight = shape.height() / height;
	                if (shape._shapeType === 3 ) {
	                    shape.updateRelativeLocationSize();
	                }
	            });
	        };
	        groupShapePrototype.layoutChildren = function () {
	            var self = this, top = self.y(), left = self.x(), width = self.width(), height = self.height();
	            self._shapes.forEach(function (shape) {
	                var forceUpdatePosition = true;
	                shape._setLocation(left + shape.relativeX * width, top + shape.relativeY * height, forceUpdatePosition);
	                shape._setSize(shape.relativeWidth * width, shape.relativeHeight * height, forceUpdatePosition);
	                if (shape._shapeType === 3 ) {
	                    shape.layoutChildren();
	                }
	            });
	        };
	        groupShapePrototype._onPositionSizeChanged = function () {
	            this.layoutChildren();
	        };
	        groupShapePrototype._onRefreshShapeUI = function () {
	            var self = this;
	            var shapes = self._shapes;
	            for (var i = 0, length = shapes.length; i < length; i++) {
	                var childShape = shapes[i];
	                if (childShape._shapeType === 4 ) {
	                    var points = childShape._getPoints();
	                    childShape._setPoints(points);
	                }
	            }
	        };
	        groupShapePrototype._createCloneShape = function (sheet) {
	            return new GroupShape(sheet);
	        };
	        groupShapePrototype._restoreByType = function (type, value) {
	           
	            switch (type) {
	                case "groupAddShape" :
	                    value.groupShape.remove(value.shape);
	                    break;
	                case "groupRemoveShape" :
	                    value.groupShape.add(value.shape);
	                    break;
	            }
	        };
	        groupShapePrototype._afterInit = function () {
	            this.updateRelativeLocationSize();
	        };
	        groupShapePrototype.preProcessShapeDataToJson = function (jsonData) {
	            var childrenData = jsonData.childrenData = [];
	            this._shapes.forEach(function(shape) {
	                var t = {};
	               
	                shape.preProcessShapeDataToJson(t);
	                childrenData.push(t);
	            });
	        };
	        groupShapePrototype.adjustShapeDataFromJson = function (jsonData) {
	           
	            this._shapeData.childrenData = jsonData.childrenData;
	        };
	
	        return GroupShape;
	    })(ShapeBase);
	   
	    Shapes.GroupShape = GroupShape;
	
	    function getPropertyValue(value, defaultValue) {
	        return !isNullOrUndefined(value) ? value : defaultValue;
	    }
	   
	    
	    function ShapeStyle(style) {
	        var _this = this;
	       
	       
	        
	        var style_fill = style && style.fill;
	        _this.fill = {
	            color: getPropertyValue(style_fill && style_fill.color, "accent 1"),
	            transparency: getPropertyValue(style_fill && style_fill.transparency, 0)
	        };
	       
	        
	        var style_line = style && style.line;
	        _this.line = {
	            color: getPropertyValue(style_line && style_line.color, "accent 1"),
	            lineStyle: getPropertyValue(style_line && style_line.lineStyle, 0 ),
	            width: getPropertyValue(style_line && style_line.width, 1),
	            capType: getPropertyValue(style_line && style_line.capType, 2 ),
	            joinType: getPropertyValue(style_line && style_line.joinType, 0 ),
	            transparency: getPropertyValue(style_line && style_line.transparency, 0),
	            beginArrowheadStyle: getPropertyValue(style_line && style_line.beginArrowheadStyle, 0 ),
	            beginArrowheadWidth: getPropertyValue(style_line && style_line.beginArrowheadWidth, 1 ),
	            beginArrowheadLength: getPropertyValue(style_line && style_line.beginArrowheadLength, 1 ),
	            endArrowheadStyle: getPropertyValue(style_line && style_line.endArrowheadStyle, 0 ),
	            endArrowheadWidth: getPropertyValue(style_line && style_line.endArrowheadWidth, 1 ),
	            endArrowheadLength: getPropertyValue(style_line && style_line.endArrowheadLength, 1 )
	        };
	       
	        
	        var style_textEffect = style && style.textEffect;
	        _this.textEffect = {
	            color: getPropertyValue(style_textEffect && style_textEffect.color, "background 1"),
	            transparency: getPropertyValue(style_textEffect && style_textEffect.transparency, 0),
	            font: getPropertyValue(style_textEffect && style_textEffect.font, "11pt Calibri")
	        };
	       
	        
	        var style_textFrame = style && style.textFrame;
	        _this.textFrame = {
	            vAlign: getPropertyValue(style_textFrame && style_textFrame.vAlign, 0 ),
	            hAlign: getPropertyValue(style_textFrame && style_textFrame.hAlign, 0 )
	        };
	    }
	   
	    Shapes.ShapeStyle = ShapeStyle;
	
	   
	    
	   
	    
	   
	    
	   
	    
	}());


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var Core = __webpack_require__(16), Events = Core.Events, _DPIHelper = Core._DPIHelper, cancelDefault = Core._util._cancelDefault;
	    var Shapes = __webpack_require__(1), Rect = __webpack_require__(4).Common.Rect;
	    var keyword_null = null, Math_max = Math.max;
	    var ShapeUtility = Shapes.ShapeUtility;
	    var getFormulaSettingItems = Shapes.getFormulaSettingItems;
	    var Common = Shapes.Common;
	    var rotatePoint = Common.rotatePoint, toRadius = Common.toRadius;
	
	    function isCoverRange(row, column, endRow, endColumn, shape) {
	        var fStartRow = shape.startRow();
	        var fStartColumn = shape.startColumn();
	        var fEndRow = shape.endRow();
	        var fEndColumn = shape.endColumn();
	        return row <= fStartRow && column <= fStartColumn && endRow >= fEndRow && endColumn >= fEndColumn;
	    }
	
	    function getShapeLayerByViewportIndex(layers, rowViewportIndex, colViewportIndex) {
	        return layers[rowViewportIndex * 3 + colViewportIndex];
	    }
	   
	   
	   
	   
	
	    
	    function getShapeLocationForUnGroup(groupCenter, groupRadius, shape) {
	        var x = shape.x(), y = shape.y();
	
	        var center = shape._shapeUI.getShapeCenter();
	
	        var angle = shape.rotate && shape.rotate();
	        if (isNaN(angle)) {
	            angle = 0;
	        }
	
	        var points = rotatePoint({x : x, y: y}, center, toRadius(angle) - groupRadius);
	       
	        points = rotatePoint(points, groupCenter, groupRadius);
	
	        center = rotatePoint(center, groupCenter, groupRadius);
	       
	        points = rotatePoint(points, center, toRadius(-angle));
	        return {
	            x: points.x,
	            y: points.y
	        };
	    }
	     function getLineShapePointsForUngroup(groupCenter, groupRadius, line) {
	         var points = line.getPoints();
	         var oldCenter = line.getShapeCenter();
	        
	         var center = rotatePoint({x: oldCenter.x, y: oldCenter.y}, groupCenter, groupRadius);
	         var deltaX = oldCenter.x - center.x, deltaY = oldCenter.y - center.y;
	         points = points.map(function (point) {
	             return rotatePoint({x:point.x - deltaX, y: point.y - deltaY}, center, Common.toRadius(line.angle));
	         });
	         line.setAngle(0);
	         return points;
	     }
	
	   
	    
	    function ShapeCollection(sheet) {
	        var self = this;
	        self._sheet = sheet;
	        self._shapes = {};
	        self._shapesList = [];
	    }
	    var shapeCollectionPrototype = ShapeCollection.prototype;
	   
	    
	    shapeCollectionPrototype.add = function (name, autoShapeTypeOrModel, left, top, width, height) {
	        var self = this, sheet = this._sheet;
	        var shape = new Shapes.Shape(sheet, name, autoShapeTypeOrModel, left, top, width, height);
	        shape._isloading = true;
	        self._add(shape);
	        delete shape._isloading;
	        return shape;
	    };
	    shapeCollectionPrototype._fireShapeEvent = function(eventName, eventArgs) {
	        var self = this, sheet = self._sheet;
	        if(sheet) {
	            sheet._trigger(eventName, eventArgs);
	        }
	    };
	
	   
	    
	    shapeCollectionPrototype.addConnector = function (name, connectorType, beginX, beginY, endX, endY) {
	        var self = this, sheet = this._sheet;
	        var shape = new Shapes.ConnectorShape(sheet, name, connectorType, beginX, beginY, endX, endY);
	        this._add(shape);
	        self._backup('addConnector', shape.name());
	        return shape;
	    };
	   
	    
	    shapeCollectionPrototype.group = function (shapes) {
	        var self = this;
	        var sheet = self._sheet;
	        var groupShape = new Shapes.GroupShape(sheet, '');
	        return self._group(shapes, groupShape);
	    };
	    shapeCollectionPrototype._group = function (shapes, groupShape) {
	        var self = this, count = shapes.length, i;
	        for (i = 0; i < count; i++) {
	            shapes[i].isSelected(false);
	            self._remove(shapes[i], true);
	        }
	        groupShape._notBackUp = true;
	        groupShape._ignoreUpdate = true;
	        for (i = 0; i < count; i++) {
	            groupShape.add(shapes[i]);
	        }
	        groupShape._initShapeUI(groupShape._shapes);
	        self._add(groupShape);
	        self._backup('group', groupShape.name());
	        delete groupShape._notBackUp;
	        delete groupShape._ignoreUpdate;
	        return groupShape;
	    };
	   
	    
	    shapeCollectionPrototype.ungroup = function (groupShape) {
	        var self = this, i;
	        var shapes = groupShape._shapes.slice(0);
	        var groupCenter = groupShape._shapeUI.getShapeCenter(), groupRadius = toRadius(groupShape.rotate());
	        var origin = [];
	       
	        if(groupRadius !== 0 ) {
	            shapes.forEach(function (sp) {
	                if(sp._shapeType === 4 ) {
	                    origin.push(getLineShapePointsForUngroup(groupCenter, groupRadius, sp._shapeUI));
	                } else {
	                    origin.push(getShapeLocationForUnGroup(groupCenter, groupRadius, sp));
	                }
	            });
	        }
	
	        groupShape._ignoreUpdate = true;
	        self._remove(groupShape, true);
	        var count = shapes.length;
	        groupShape._notBackUp = true;
	        for (i = count - 1; i >= 0; i--) {
	            groupShape.remove(shapes[i]);
	        }
	        delete groupShape._notBackUp;
	        delete groupShape._ignoreUpdate;
	        groupShape._disposeShapeUI();
	        var backupShapesName = [];
	        for (i = 0; i < count; i++) {
	            if (groupRadius !== 0) {
	               
	                if(shapes[i]._shapeType === 4 ) {
	                    shapes[i]._setPoints(origin[i]);
	                } else {
	                    shapes[i]._setLocation(origin[i].x, origin[i].y);
	                }
	
	            }
	            self._add(shapes[i]);
	            backupShapesName.push(shapes[i].name());
	        }
	        self._backup('ungroup', {backupShapesName:backupShapesName, groupShape:groupShape});
	    };
	   
	    shapeCollectionPrototype._add = function (shape, ignorePaint) {
	        var self = this, sheet = self._sheet, shapeName = shape.name();
	        shape._shapeCollection = self;
	        self._backup('add', shapeName);
	        self._shapes[shapeName] = shape;
	        self._shapesList.push(shapeName);
	        sheet.shapeLayers.forEach(function (shapeLayer) {
	            var shapeUI = shape._shapeUI;
	            if (shapeUI) {
	                var shapeModel = shapeLayer.model;
	                shapeModel._ignoreChange = true;   
	                shapeLayer.addShape(shapeUI);
	                delete shapeModel._ignoreChange;
	            }
	        });
	        if (!ignorePaint && !sheet.isPaintSuspended()) {
	            sheet._paintShapes();
	        }
	    };
	    function findShapeByID(shapes, id, idMaps) {
	        id = idMaps && idMaps[id] || id; 
	        if (shapes) {
	            for (var i = 0, count = shapes.length; i < count; i++) {
	                var shape = shapes[i];
	                if (shape._shapeData.Id === id) {
	                    return shape;
	                }
	                var t = findShapeByID(shape._shapes, id);  
	                if (t) {
	                    return t;
	                }
	            }
	        }
	    }
	    function findShapeByName(shapes, name) {
	        if (shapes) {
	            for (var i = 0, count = shapes.length; i < count; i++) {
	                var shape = shapes[i];
	                if (shape.name() === name) {
	                    return shape;
	                }
	                var t = findShapeByName(shape._shapes, name);
	                if (t) {
	                    return t;
	                }
	            }
	        }
	    }
	   
	    
	    shapeCollectionPrototype.get = function (name) {
	        return name && (this._shapes[name] || findShapeByName(this.all(), name));
	    };
	   
	    
	    shapeCollectionPrototype.remove = function (name, ignoreModel) {
	        var self = this, shape = self._shapes[name];
	        if (shape) {
	            self._backup('remove', shape);
	            self._remove(shape, ignoreModel);
	            delete shape._shapeCollection;
	            var sheet = self._sheet;
	            sheet._shapeNames[name] = false;
	            if (!sheet.isPaintSuspended()) {
	                sheet._paintShapes();
	            }
	        }
	    };
	    shapeCollectionPrototype._remove = function (shape, ignoreModel) {
	        var self = this, sheet = self._sheet, name = shape.name(), shapesList = self._shapesList;
	        var selectionArgs = {
	            sheet: sheet,
	            sheetName: sheet.name(),
	            shape: shape,
	            cancel: false
	        };
	        self._fireShapeEvent(Events.ShapeRemoving, selectionArgs);
	        if (selectionArgs.cancel === false) {
	            sheet.shapeLayers.forEach(function (shapeLayer) {
	                var shapeUI = shape._shapeUI;
	                if (shapeUI) {
	                    shapeLayer.removeShape(shapeUI, ignoreModel);
	                }
	            });
	            delete self._shapes[name];
	            var nameIndex = shapesList.indexOf(name);
	            if (nameIndex > -1) {
	                shapesList.splice(nameIndex, 1);
	            }
	            self._fireShapeEvent(Events.ShapeRemoved, {
	                sheet: sheet,
	                sheetName: sheet.name(),
	                shape: shape
	            });
	        }
	
	    };
	   
	    
	    shapeCollectionPrototype.clear = function () {
	        var self = this, shapes = self._shapes;
	        var names = self._shapesList;
	       
	        self._shapesList = [];
	        names.forEach(function(name) {
	            var shape = shapes[name];
	            shape && self.remove(name);
	        });
	    };
	   
	    
	    shapeCollectionPrototype.all = function () {
	        var self = this, shapes = self._shapes;
	        var result = [];
	        self._shapesList.forEach(function(name) {
	            var shape = shapes[name];
	            shape && result.push(shape);
	        });
	        return result;
	    };
	    shapeCollectionPrototype._getCount = function () {
	        return this._shapesList.length;
	    };
	    shapeCollectionPrototype._shapeRename = function (oldName, newName) {
	        var self = this, shapes = self._shapes, shapesList = self._shapesList;
	        shapes[newName] = shapes[oldName];
	        delete shapes[oldName];
	        var nameIndex = shapesList.indexOf(oldName);
	        if (nameIndex > -1) {
	            shapesList[nameIndex] = newName;
	        }
	    };
	    shapeCollectionPrototype._onRowsAdded = function (row, rowCount) {
	        this.all().forEach(function (item) {
	            item._onRowsAdded(row, rowCount);
	        });
	    };
	    shapeCollectionPrototype._removeShapesByName = function (names) {
	        var self = this;
	        names.forEach(function(name) {
	            self.remove(name);
	        });
	    };
	    shapeCollectionPrototype._onRowsRemoved = function (row, rowCount) {
	        var removedShapeNames = [];
	        var self = this;
	        var columnCount = self._sheet.getColumnCount();
	        self.all().forEach(function (item) {
	            if (!isCoverRange(row, -1, row + rowCount - 1, columnCount, item) || (!item.dynamicMove() && !item.dynamicSize())) {
	                item._onRowsRemoved(row, rowCount);
	            } else {
	                removedShapeNames.push(item.name());
	            }
	        });
	        self._removeShapesByName(removedShapeNames);
	    };
	    shapeCollectionPrototype._onColumnsAdded = function (column, columnCount) {
	        this.all().forEach(function (item) {
	            item._onColumnsAdded(column, columnCount);
	        });
	    };
	    shapeCollectionPrototype._onColumnsRemoved = function (column, columnCount) {
	        var removedShapeNames = [];
	        var self = this;
	        var rowCount = self._sheet.getRowCount();
	        self.all().forEach(function (item) {
	            if (!isCoverRange(-1, column, rowCount, column + columnCount - 1, item) || (!item.dynamicMove() && !item.dynamicSize())) {
	                item._onColumnsRemoved(column, columnCount);
	            } else {
	                removedShapeNames.push(item.name());
	            }
	        });
	        self._removeShapesByName(removedShapeNames);
	    };
	    shapeCollectionPrototype._onGroupChanged = function (start, end, isRow) {
	        this.all().forEach(function (shape) {
	            var floatingObjectStart = isRow ? shape.startRow() : shape.startColumn(),
	                floatingObjectEnd = isRow ? shape.endRow() : shape.endColumn();
	            if (!(end < floatingObjectStart || start > floatingObjectEnd)) {
	                shape._shapeData._updateLocation();
	                shape._shapeData._updateSize();
	                shape._refreshShapeUI(true );
	            }
	        });
	        this._sheet._paintShapes();
	    };
	   
	    
	    shapeCollectionPrototype._getRowLastShapeDirtyIndex = function () {
	        var self = this, sheet = self._sheet;
	        var lastDirtyIndex = -1, bound, items = [];
	        self.all().forEach(function (shape) {
	            if (shape.isVisible() && shape.canPrint()) {
	                if (shape.rotate && shape.rotate() === 0) {
	                    lastDirtyIndex = Math_max(lastDirtyIndex, shape.endRow());
	                } else {
	                    bound = Shapes.getActualBound(shape._shapeUI, false  );
	                    items.push(bound.bottom);
	                }
	            }
	        });
	        if (items.length > 0) {
	            var max = Math_max.apply(null, items);
	            var offset = Shapes.getRowAndRowOffset(sheet, max);
	            var rotateDirtyIndex = offset.row + (offset.rowOffset === 0 ? 0 : 1);
	            lastDirtyIndex = Math_max(lastDirtyIndex, rotateDirtyIndex);
	        }
	        return lastDirtyIndex;
	    };
	   
	    
	    shapeCollectionPrototype._getLastColumnShapeDirtyIndex = function () {
	        var self = this, sheet = self._sheet;
	        var lastDirtyIndex = -1, bound, items = [];
	        self.all().forEach(function (shape) {
	            if (shape.isVisible() && shape.canPrint()) {
	                if (shape.rotate && shape.rotate() === 0) {
	                    lastDirtyIndex = Math_max(lastDirtyIndex, shape.endColumn());
	                } else {
	                    bound = Shapes.getActualBound(shape._shapeUI, false  );
	                    items.push(bound.right);
	                }
	            }
	        });
	        if (items.length > 0) {
	            var max = Math_max.apply(null, items);
	            var offset = Shapes.getColAndColOffset(sheet, max);
	            var rotateDirtyIndex = offset.col + (offset.colOffset === 0 ? 0 : 1);
	            lastDirtyIndex = Math_max(lastDirtyIndex, rotateDirtyIndex);
	        }
	        return lastDirtyIndex;
	    };
	    
	    shapeCollectionPrototype._paintShapesForPrint = function (sheet, ctx, clipRect) {
	        var sheetLayout = sheet._getSheetLayout(), options = sheet.options;
	        var leftOffset = 0, topOffset = 0;
	       
	        if (options.rowHeaderVisible) {
	            leftOffset += sheetLayout._frozenX;
	        }
	        if (options.colHeaderVisible) {
	            topOffset += sheetLayout._frozenY;
	        }
	        ctx.save();
	        ctx.beginPath();
	        ctx.rect(clipRect.x + leftOffset, clipRect.y + topOffset, clipRect.width, clipRect.height);
	        ctx.clip();
	
	        for (var r = 0; r <= 2; r++) {
	            for (var c = 0; c <= 2; c++) {
	                var intersectRect = clipRect.getIntersectRect(sheetLayout._viewportRect(r, c));
	                if (intersectRect) {
	                    this._paintShapeLayerForPrint(sheet, ctx, r, c);
	                }
	            }
	        }
	
	        ctx.restore();
	    };
	    
	    shapeCollectionPrototype._paintShapeLayerForPrint = function (sheet, ctx, rowViewportIndex, columnViewportIndex) {
	        var layout = sheet._getSheetLayout();
	        var shapeLayer = getShapeLayerByViewportIndex(sheet.shapeLayers, rowViewportIndex, columnViewportIndex);
	
	        var rect = layout._viewportRect(rowViewportIndex, columnViewportIndex);
	        adjustViewportRect(rect, sheet, rowViewportIndex, columnViewportIndex);
	
	        var topRow = sheet.getViewportTopRow(rowViewportIndex),
	            leftCol = sheet.getViewportLeftColumn(columnViewportIndex);
	        var scrollTop = getScrollTop(sheet, topRow);
	        var scrollLeft = getScrollLeft(sheet, leftCol);
	
	        ctx.save();
	       
	        ctx.beginPath();
	        ctx.rect(rect.x, rect.y, rect.width, rect.height);
	        ctx.clip();
	
	       
	        shapeLayer.width = rect.width;
	        shapeLayer.height = rect.height;
	
	       
	       
	        shapeLayer.scrollTop = scrollTop - layout._frozenY;
	        shapeLayer.scrollLeft = scrollLeft - layout._frozenX;
	        shapeLayer._printOffsetX = rect.x;
	        shapeLayer._printOffsetY = rect.y;
	
	       
	       
	        if (rowViewportIndex === 1) {
	            shapeLayer.scrollTop -= layout._frozenHeight;
	        }
	        if (columnViewportIndex === 1) {
	            shapeLayer.scrollLeft -= layout._frozenWidth;
	        }
	
	        shapeLayer.paintForPrint(ctx);
	        ctx.restore();
	    };
	    
	    shapeCollectionPrototype._moveShapeForHideRowAndColumn = function (sheet, hiddenColWidth, hiddenRowHeight) {
	        var changes = [];
	        sheet.shapes.all().forEach(function (shape) {
	            var y = shape.y(), x = shape.x();
	            changes.push({type: "shapePosition", shape: shape, offset: {x: x, y: y}});
	            shape.x(x - hiddenColWidth);
	            shape.y(y - hiddenRowHeight);
	            shape.resize(shape.x(), shape.y(), shape.width(), shape.height());
	        });
	    };
	    shapeCollectionPrototype._undoAddShape = function (shapeName) {
	        if (!shapeName) {
	            return;
	        }
	        this.remove(shapeName);
	    };
	    shapeCollectionPrototype.hitTest = function (x, y) {
	        var self = this, sheet = self._sheet, ret = null;
	        var sheetLayout = sheet._getSheetLayout();
	        x -= sheetLayout._frozenX;
	        y -= sheetLayout._frozenY;
	        var shapes = sheet.shapes.all(), shape, t;
	
	        var rowViewportIndex = sheet._getRowViewportIndexFromY(x);
	        var colViewportIndex = sheet._getColumnViewportIndexFromX(y);
	        if (rowViewportIndex < 0 || rowViewportIndex > 2 || colViewportIndex < 0 || colViewportIndex > 2) {
	            return ret;
	        }
	        var shapeLayer = sheet.shapeLayers[rowViewportIndex * 3 + colViewportIndex];
	        if (!shapeLayer) {
	            return ret;
	        }
	        for (var i = 0, len = shapes.length; i < len; i++) {
	            shape = shapes[i];
	            if (shape && shape._shapeUI) {
	                t = shape._shapeUI.hitTest(x + shapeLayer.scrollLeft, y + shapeLayer.scrollTop);
	                if (t && t.shape) {
	                    t.shape = t.shape._shapeWrapper;
	                    ret = t;
	                    break;
	                }
	            }
	        }
	        return ret;
	    };
	    shapeCollectionPrototype._undoGroup = function (shapeName) {
	        if (!shapeName) {
	            return;
	        }
	        var self = this,
	            shape = self._shapes[shapeName];
	        self.ungroup(shape);
	    };
	    shapeCollectionPrototype._undoUngroup = function (backupOption) {
	        if (!backupOption) {
	            return;
	        }
	        var self = this, shapes = [],
	            backupShapesName = backupOption.backupShapesName,
	            groupShape = backupOption.groupShape,
	            shape;
	        backupShapesName.forEach(function (shapeName) {
	            shape = self._shapes[shapeName];
	            shapes.push(shape);
	        });
	        self._group(shapes, groupShape);
	    };
	    shapeCollectionPrototype._undoRemove = function (shape) {
	        if (!shape) {
	            return;
	        }
	        this._add(shape);
	    };
	    shapeCollectionPrototype._backup = function (nameOrType, obj) {
	        var self = this, sheet = self._sheet;
	        if (sheet) {
	            var modelManager = sheet._modelManager;
	            if (modelManager._changes) {
	                var backupObj = {type: nameOrType, value: obj};
	                modelManager._backupShapeCollection(backupObj);
	            }
	        }
	    };
	    shapeCollectionPrototype._restore = function (argValue) {
	        if (!argValue) {
	            return;
	        }
	        var self = this, type = argValue.type, value = argValue.value;
	        if (type === 'add') {
	            self._undoAddShape(value);
	        } else if (type === 'addConnector') {
	            self._undoAddShape(value);
	        } else if (type === 'group') {
	            self._undoGroup(value);
	        } else if (type === 'ungroup') {
	            self._undoUngroup(value);
	        } else if (type === 'remove') {
	            self._undoRemove(value);
	        }
	    };
	
	    Shapes.ShapeCollection = ShapeCollection;
	
	    var CORE_MODULE = __webpack_require__(16);
	    var extend = CORE_MODULE.GC$.extend;
	    var isNullOrUndefined = __webpack_require__(8)._Types._isNullOrUndefined;
	    var _SheetModelManager = CORE_MODULE._SheetModelManager;
	    extend(_SheetModelManager.prototype, {
	        _backupShapeFormulas: function (value) {
	            var self = this;
	            var changes = self._changes;
	            if (changes) {
	                var shapeFormulaChanges = changes._shapeFormulaChanges;
	                if (!shapeFormulaChanges) {
	                    shapeFormulaChanges = changes._shapeFormulaChanges = [];
	                }
	                shapeFormulaChanges.push(value);
	            }
	        },
	        _restoreShapeFormulas: function (changeItems) {
	            if (changeItems) {
	                var self = this, propertySource = self._sheet.shapeLayers[0].model.calcSource_;
	                for (var i = changeItems.length - 1; i >= 0; i--) {
	                    var item = changeItems[i];
	                    if (item) {
	                        propertySource.setExpression(item.id, item.name, item.expression);
	                    }
	                }
	            }
	        },
	        _backupShapes: function (shape, value) {
	            var self = this;
	            var changes = self._changes;
	            if (changes) {
	                var shapeChanges = changes._shapeChanges;
	                if (!shapeChanges) {
	                    shapeChanges = changes._shapeChanges = [];
	                }
	                shapeChanges.push({ shape: shape, value: value, changeType : 0 });
	            }
	        },
	        _backupShapeCollection: function (value) {
	            var self = this;
	            var changes = self._changes;
	            if (changes) {
	                var shapeCollectionChanges = changes._shapeChanges;
	                if (!shapeCollectionChanges) {
	                    shapeCollectionChanges = changes._shapeChanges = [];
	                }
	                shapeCollectionChanges.push({ value: value, changeType : 1  });
	            }
	        },
	        _restoreShapes: function (originalShapes) {
	            if (originalShapes) {
	                var shapeCollection = this._shapes;
	                for (var i = originalShapes.length - 1; i >= 0; i--) {
	                    var item = originalShapes[i];
	                    if (item.changeType === 0 ) {
	                        var shape = item.shape;
	                        shape._suspendRefreshUI = true;
	                        shape._restore(item.value);
	                        delete shape._suspendRefreshUI;
	                        shape._refreshShapeUI();
	                    } else if (item.changeType === 1 ) {
	                        shapeCollection._restore(item.value);
	                    }
	
	                }
	            }
	        }
	      
	    });
	
	    function updateFormulaItemsOfShape(shapeUI) {
	        var shapes = shapeUI.shapes;
	        if (shapes) {
	            shapes.forEach(updateFormulaItemsOfShape);
	        } else {
	            var shape = shapeUI._shapeWrapper;
	            if (shape) {
	                var formulaItems = getFormulaSettingItems(shapeUI, shape._model);
	                if (formulaItems) {
	                    shape._updateFormulaItems(formulaItems, true );
	                }
	            }
	        }
	    }
	
	    function updateFormulaItemsOfShapes(sheet) {
	        var model = sheet.shapeLayers[0].model;
	        model.shapes.forEach(updateFormulaItemsOfShape);
	    }
	
	    _SheetModelManager._registerFeature('shape', {
	       
	        init: function () {
	            this._shapes = new ShapeCollection(this._sheet);
	        },
	        undo: function (changes) {
	            var self = this;
	            var shapeChanges = changes._shapeChanges;
	            self._restoreShapes(shapeChanges);
	            
	
	            var formulaChanges = changes._shapeFormulaChanges;
	            if (formulaChanges) {
	                self._restoreShapeFormulas(formulaChanges);
	            }
	            updateFormulaItemsOfShapes(self._sheet);
	            self._sheet._paintShapes();
	        },
	        endTransaction: function () {
	            var shapeLayers = this._sheet.shapeLayers;
	            if (shapeLayers && shapeLayers.length) {
	                delete shapeLayers[0].model.calcSource_._onBackupFormula;
	            }
	        }
	    });
	
	    function getScrollTop(sheet, top, rowViewportIndex) {
	        var scrollTop = 0;
	        if (rowViewportIndex === 1) {
	            scrollTop = -sheet._touchScrollOffsetTop || 0;
	        }
	        for (var i = 0; i < top; i++) {
	            scrollTop += sheet._getZoomRowHeight(i, 3, true);
	        }
	        return scrollTop;
	    }
	
	    function getScrollLeft(sheet, left, colViewportIndex) {
	        var scrollLeft = 0;
	        if (colViewportIndex === 1) {
	            scrollLeft = -sheet._touchScrollOffsetLeft || 0;
	        }
	        for (var i = 0; i < left; i++) {
	            scrollLeft += sheet._getZoomColumnWidth(i, 3, true);
	        }
	        return scrollLeft;
	    }
	
	    function resizeElement(element, left, top, width, height) {
	        var style = element.style;
	        if (style.left !== left + "px"
	            || style.top !== top + "px"
	            || style.width !== width + "px"
	            || style.height !== height + "px") {
	            style.left = left + "px";
	            style.top = top + "px";
	            style.width = width + "px";
	            style.height = height + "px";
	
	            element.width = width;
	            element.height = height;
	
	            _DPIHelper._setSize(element, width, height);
	        }
	    }
	
	    function adjustViewportRect(viewportRect, sheet, rowViewportIndex, colViewportIndex) {
	        var colLayouts = sheet._getViewportColumnLayout(colViewportIndex),
	            rowLayouts = sheet._getViewportRowLayout(rowViewportIndex),
	            colLayoutsLength = colLayouts && colLayouts.length, rowLayoutsLength = rowLayouts && rowLayouts.length;
	        if (colLayoutsLength > 0 && rowLayoutsLength > 0) {
	            var lastColLayout = colLayouts[colLayoutsLength - 1], lastRowLayout = rowLayouts[rowLayoutsLength - 1];
	            var width = lastColLayout.x + lastColLayout.width - colLayouts[0].x,
	                height = lastRowLayout.y + lastRowLayout.height - rowLayouts[0].y;
	            viewportRect.width = Math.min(viewportRect.width, width);
	            viewportRect.height = Math.min(viewportRect.height, height);
	        }
	    }
	
	    function getActualViewportRect(sheet, rowViewportIndex, colViewportIndex) {
	        var colLayouts = sheet._getViewportColumnLayout(colViewportIndex),
	            rowLayouts = sheet._getViewportRowLayout(rowViewportIndex),
	            colLayoutsLength = colLayouts && colLayouts.length, rowLayoutsLength = rowLayouts && rowLayouts.length;
	        if (colLayoutsLength > 0 && rowLayoutsLength > 0) {
	            var lastColLayout = colLayouts[colLayoutsLength - 1], lastRowLayout = rowLayouts[rowLayoutsLength - 1];
	            var width = lastColLayout.x + lastColLayout.width - colLayouts[0].x,
	                height = lastRowLayout.y + lastRowLayout.height - rowLayouts[0].y;
	            return new Rect(colLayouts[0].x, rowLayouts[0].y, width, height);
	        }
	    }
	
	    function updateOnColumnRowChanged(sheet) {
	        sheet.shapes.all().forEach(function (item) {
	            if (item.dynamicMove()) {
	                item._shapeData._updateLocation();
	            } else {
	                item._shapeData._updateStartPosition();
	            }
	            if (item.dynamicSize()) {
	                item._shapeData._updateSize();
	            } else {
	                item._shapeData._updateEndPosition();
	            }
	            item._onPositionSizeChanged();
	            item._refreshShapeUI(true );
	        });
	        sheet._paintShapes();
	    }
	
	    function hasSelectedShape(sheet) {
	        var selected = false;
	        var shapes = sheet.shapes.all(), count = shapes.length;
	        for (var i = 0; i < count; i++) {
	            if (shapes[i] && shapes[i].isSelected()) {
	                selected = true;
	                break;
	            }
	        }
	        return selected;
	    }
	
	    var GC_SHAPE_NS = '.gcShape';
	    var adapter = {
	       
	        init: function () {
	            var sheet = this;
	            sheet._shapeNames = {};
	
	            var shapeLayers = [];
	            var shapeModel = Shapes.Canvas.createShapeModel();
	            for (var rowViewportIndex = 0; rowViewportIndex < 3; rowViewportIndex++) {
	                for (var colViewportIndex = 0; colViewportIndex < 3; colViewportIndex++) {
	                    var layer = shapeLayers[rowViewportIndex * 3 + colViewportIndex] = new Shapes.Canvas(shapeModel, null);
	                    layer._sheet = sheet;
	                }
	            }
	            sheet.shapeLayers = shapeLayers;
	
	            shapeModel.onPropertyChangedByFormula = function(id, path, value) {
	                sheet._onShapeItemChangedByFormlua(shapeModel, id, path, value);
	            };
	           
	            
	            sheet.shapes = sheet._modelManager._shapes;
	
	            sheet.bind(Events.RangeChanged, function () {
	                sheet.celldirty = true;
	                if (!sheet.suspendUpdate) {
	                    sheet.repaint();
	                }
	            });
	        },
	        attach: function (parent) {
	            var sheet = this, calcSerivce;
	            var Workbook = Core.Workbook;
	            if (parent instanceof Workbook) {
	                calcSerivce = parent._calcService;
	            } else {
	                calcSerivce = sheet.getCalcService();
	            }
	            sheet.shapeLayers.forEach(function (shapeLayer) {
	                shapeLayer.model.name = sheet.name() + 'shapes';
	                shapeLayer.model.setService(calcSerivce);
	            });
	        },
	       
	        dispose: function () {
	            var sheet = this;
	            sheet.shapeLayers.forEach(function (shapeLayer) {
	                var oldHost = shapeLayer.host;
	                _DPIHelper._disposeCanvasForSheet(sheet, oldHost);
	                shapeLayer.setHost(null);
	                shapeLayer.dispose();
	                if (oldHost) {
	                    var parentNode = oldHost.parentNode;
	                    if (parentNode) {
	                        parentNode.removeChild(oldHost);
	                    }
	                }
	            });
	
	            sheet._unbind(Events.ColumnChanged + GC_SHAPE_NS);
	            sheet._unbind(Events.RowChanged + GC_SHAPE_NS);
	            sheet._unbind(Events.ColumnWidthChanged + GC_SHAPE_NS);
	            sheet._unbind(Events.RowHeightChanged + GC_SHAPE_NS);
	            sheet._unbind(Events.TableFiltered + GC_SHAPE_NS);
	            sheet._unbind(Events.RangeFiltered + GC_SHAPE_NS);
	            sheet._unbind(Events.FloatingElementSelected + GC_SHAPE_NS);
	        },
	        setHost: function (host) {
	            var sheet = this;
	            sheet.shapeLayers.forEach(function (shapeLayer, index) {
	                var id = host.attr('id') + 'shapeHost' + index;
	                var shapeHost = host.parent().find('#' + id).get(0);
	                if (!shapeHost) {
	                    shapeHost = document.createElement('canvas');
	                    _DPIHelper._adjustDevicePixel(shapeHost, keyword_null, sheet);
	                    shapeHost.style.position = 'absolute';
	                    shapeHost.style.pointerEvents = 'none';
	                   
	                    shapeHost.style.width = 0;
	                    shapeHost.style.height = 0;
	                    shapeHost.width = 0;
	                    shapeHost.height = 0;
	                   
	                    shapeHost.style.zIndex = 900; 
	                    shapeHost.id = id;
	                    host.parent().append(shapeHost);
	                }
	                shapeLayer.setHost(shapeHost);
	                shapeLayer.onShapeSelected = function () {
	                    sheet._trigger(Core.Events.FloatingElementSelected, { type: 'shape' });
	                };
	            });
	           
	            sheet._bind(Events.ColumnChanged + GC_SHAPE_NS, function (event, data) {
	                var propertyName = data.propertyName;
	                if (propertyName === 'width' || propertyName === 'isVisible') {
	                    updateOnColumnRowChanged(sheet);
	                }
	            });
	            sheet._bind(Events.RowChanged + GC_SHAPE_NS, function (event, data) {
	                var propertyName = data.propertyName;
	                if (propertyName === 'height' || propertyName === 'isVisible') {
	                    updateOnColumnRowChanged(sheet);
	                }
	            });
	            sheet._bind(Events.ColumnWidthChanged + GC_SHAPE_NS, function () {
	                updateOnColumnRowChanged(sheet);
	            });
	            sheet._bind(Events.RowHeightChanged + GC_SHAPE_NS, function () {
	                updateOnColumnRowChanged(sheet);
	            });
	           
	            sheet._bind(Events.TableFiltered + GC_SHAPE_NS, function () {
	                updateOnColumnRowChanged(sheet);
	            });
	            sheet._bind(Events.RangeFiltered + GC_SHAPE_NS, function () {
	                updateOnColumnRowChanged(sheet);
	            });
	            sheet._bind(Events.FloatingElementSelected + GC_SHAPE_NS, function (event, data) {
	                if (data.type === 'shape') {
	                    return;
	                }
	                sheet._setSelectStateForAllShapes(false);
	            });
	        },
	        onLayoutChanged: function (e) {
	            var self = this;
	            var changeType = e.changeType;
	            var row = e.row;
	            var rowCount = e.rowCount;
	            var col = e.col;
	            var colCount = e.colCount;
	            var shapes = self.shapes;
	            var modelManager = self._modelManager, isInTransaction = modelManager._inTransaction;
	            var propertySource;
	            if (isInTransaction) {
	                propertySource = self.shapeLayers[0].model.calcSource_;
	                if (!propertySource._onBackupFormula) {
	                    propertySource._onBackupFormula = function (formulaInfo) {
	                        modelManager._backupShapeFormulas(formulaInfo);
	                    };
	                }
	            }
	            if (changeType === 'addRows') {
	                shapes._onRowsAdded(row, rowCount);
	            } else if (changeType === 'deleteRows') {
	                shapes._onRowsRemoved(row, rowCount);
	            } else if (changeType === 'addColumns') {
	                shapes._onColumnsAdded(col, colCount);
	            } else if (changeType === 'deleteColumns') {
	                shapes._onColumnsRemoved(col, colCount);
	            } else if (changeType === "invalidateLayout") {
	                var layout = self._getSheetLayout();
	                var offset = self._eventHandler._getCanvasPosition();
	                self.shapeLayers.forEach(function (shapeLayer, index) {
	                    var rowViewportIndex = parseInt(index / 3), colViewportIndex = index % 3;
	                    var panel = shapeLayer.host;
	                    if (panel) {
	                       
	                        var rect = layout._viewportRect(rowViewportIndex, colViewportIndex);
	                        adjustViewportRect(rect, self, rowViewportIndex, colViewportIndex);
	                        resizeElement(panel, rect.x + offset.left, rect.y + offset.top, rect.width, rect.height);
	                        shapeLayer.width = panel.width;
	                        shapeLayer.height = panel.height;
	                       
	                        var topRow = self.getViewportTopRow(rowViewportIndex),
	                            leftCol = self.getViewportLeftColumn(colViewportIndex);
	                        shapeLayer.scrollTop = getScrollTop(self, topRow, rowViewportIndex);
	                        shapeLayer.scrollLeft = getScrollLeft(self, leftCol, colViewportIndex);
	                    }
	                });
	            } else if (changeType === "zoomSheet") {
	               
	                shapes.all().forEach(function (shape) {
	                    shape._updateZoomInfo();
	                   
	                   
	                   
	                   
	                    shape._refreshShapeUI(true);
	                   
	                   
	                   
	                });
	            }
	        },
	        paint: function (e) {  
	            this._paintShapes();
	        },
	        toJson: function (data, serializationOption) {
	            var ignoreStyle = serializationOption && serializationOption.ignoreStyle;
	            if (ignoreStyle) {
	                return;
	            }
	            var ignoreFormula = serializationOption && serializationOption.ignoreFormula;
	            var sheet = this;
	            var shapes = sheet.shapes.all();
	            if (shapes.length > 0) {
	                data.shapes = shapes.map(function (shape) {
	                    return shape.toJSON(ignoreFormula, true );
	                   
	                   
	                   
	                   
	                   
	                   
	                   
	                   
	                   
	                   
	                   
	                   
	                   
	                   
	                   
	                   
	                   
	                });
	            }
	        },
	        fromJson: function (data, noSchema, deserializationOptions) {
	            var ignoreStyle = deserializationOptions && deserializationOptions.ignoreStyle;
	            if (ignoreStyle) {
	                return;
	            }
	            var shapes = data.shapes;
	            var sheet = this;
	            if (shapes) {
	
	                var delaySetConnectors = sheet._delaySetConnectors = [];
	                var shape;
	                shapes.forEach(function (shapeSetting) {
	                    var name = shapeSetting.name, shapeType = shapeSetting.shapeType;
	                    if (shapeType === 5 ) {
	                        shape = new Shapes.Shape(sheet, name);
	                        shape.fromJSON(shapeSetting);
	                        shape._initShapeUI();
	                    } else if (shapeType === 4 ) {
	                        shape = new Shapes.ConnectorShape(sheet, name);
	                        shape.fromJSON(shapeSetting);
	                        shape._initShapeUI();
	                    } else if (shapeType === 3 ) {
	                        shape = new Shapes.GroupShape(sheet, name);
	                        shape.fromJSON(shapeSetting);
	                        shape._initShapeUI();
	                        shape.updateRelativeLocationSize();
	                    }
	
	                    if (shape) {
	                        sheet.shapes._add(shape, true);
	                    }
	                });
	                if (delaySetConnectors.length > 0) {
	                    var syncConnectors = Shapes.syncConnectors;
	                    var idMaps = sheet.shapeLayers[0].model.idMaps;
	                    var sheetShapes = sheet.shapes.all();
	                    delaySetConnectors.forEach(function (item) {
	                        var target = item.target;  
	                        var referId = item.beginId, connectors = [undefined, undefined], shapeData;
	                        if (referId) {
	                            shape = findShapeByID(sheetShapes, referId, idMaps);
	                            if (shape) {
	                                shapeData = shape._shapeData;
	                                target._beginShapeName = shapeData.Name;
	                                connectors[0] = {
	                                    name: shapeData.Name,
	                                    index: item.beginConnectionSite,
	                                    shape: shape
	                                };
	                            }
	                        } else {
	                            referId = item.endId;
	                            shape = findShapeByID(sheetShapes, referId, idMaps);
	                            if (shape) {
	                                shapeData = shape._shapeData;
	                                target._endShapeName = shapeData.Name;
	                                connectors[1] = {
	                                    name: shapeData.Name,
	                                    index: item.endConnectionSite,
	                                    shape: shape
	                                };
	                            }
	                        }
	                        var targetShape = findShapeByID(sheetShapes, target._shapeData.Id, idMaps);
	                        syncConnectors(connectors, targetShape);
	                    });
	                }
	                delete sheet._delaySetConnectors;
	            }
	        },
	        preProcessMouseDown: function (argObj) {
	            var self = this;
	            var e = argObj.e;
	           
	            var offset = self._getCanvasOffset();
	            var rowViewportIndex = self._getRowViewportIndexFromY(e.pageY - offset.top);
	            var colViewportIndex = self._getColumnViewportIndexFromX(e.pageX - offset.left);
	            if (rowViewportIndex < 0 || rowViewportIndex > 2 || colViewportIndex < 0 || colViewportIndex > 2) {
	                return;
	            }
	            self._workingRowViewportIndex = rowViewportIndex;
	            self._workingColViewportIndex = colViewportIndex;
	
	            var shapeLayer = self.shapeLayers[rowViewportIndex * 3 + colViewportIndex];
	            if (!shapeLayer) {
	                return;
	            }
	            shapeLayer.doMouseDown(e);
	            self.working = argObj.r = !!shapeLayer.hitTestResult;
	            if (argObj.r) {
	                self._setFocus();
	
	            }
	            self._render._repaintSelection();
	        },
	
	        preProcessMouseMove: function (argObj) {
	            var self = this;
	            var e = argObj.e;
	           
	           
	           
	           
	            var offset = self._getCanvasOffset();
	            var rowViewportIndex = self._workingRowViewportIndex;
	            if (isNullOrUndefined(rowViewportIndex)) {
	                rowViewportIndex = self._getRowViewportIndexFromY(e.pageY - offset.top);
	            }
	            var colViewportIndex = self._workingColViewportIndex;
	            if (isNullOrUndefined(colViewportIndex)) {
	                colViewportIndex = self._getColumnViewportIndexFromX(e.pageX - offset.left);
	            }
	            if (rowViewportIndex < 0 || rowViewportIndex > 2 || colViewportIndex < 0 || colViewportIndex > 2) {
	                return;
	            }
	
	            var shapeLayer = self.shapeLayers[rowViewportIndex * 3 + colViewportIndex];
	            if (!shapeLayer) {
	                return;
	            }
	            if (shapeLayer.hitTestResult) {   
	                self.suspendUpdate = true;
	                shapeLayer.doMouseMove(e);
	                argObj.r = true;
	            } else if (self._eventHandler._isFloatingObjectWorking !== true && self._eventHandler._isCommentWorking !== true) {
	                var canvas = self._getCanvas();
	                var t = shapeLayer.hitTest(e);
	                if (t) {
	                    canvas.style.cursor = shapeLayer.getCursorFromHitTest(t);
	                    argObj.r = true;
	                }
	            }
	        },
	        preProcessMouseUp: function (argObj) {
	            var self = this;
	            self.suspendUpdate = false;
	            var e = argObj.e;
	           
	           
	           
	           
	            var rowViewportIndex = self._workingRowViewportIndex;
	            var colViewportIndex = self._workingColViewportIndex;
	            if (isNullOrUndefined(rowViewportIndex) || rowViewportIndex < 0 || rowViewportIndex > 2 ||
	                isNullOrUndefined(colViewportIndex) || colViewportIndex < 0 || colViewportIndex > 2) {
	                return;
	            }
	
	            var shapeLayer = self.shapeLayers[rowViewportIndex * 3 + colViewportIndex];
	            if (!shapeLayer) {
	                return;
	            }
	            shapeLayer.doMouseUp(e);
	
	            if (self.working) {
	                self.working = false;
	                argObj.r = true;
	            }
	
	            if (self.celldirty) {
	                self.celldirty = false;
	                self.repaint();
	            }
	
	            self._workingRowViewportIndex = null;
	            self._workingColViewportIndex = null;
	        },
	        preProcessMouseOut: function (argObj) {
	            var self = this;
	            self.suspendUpdate = false;
	            var e = argObj.e;
	           
	           
	           
	            var canvasOffset = self._getCanvasOffset();
	            var x = e.pageX - canvasOffset.left, y = e.pageY - canvasOffset.top;
	            var $canvas = Core.GC$(self._getCanvas());
	            if (x < $canvas.width() && y < $canvas.height()) {
	                return;
	            }
	           
	            var rowViewportIndex = self._workingRowViewportIndex;
	            var colViewportIndex = self._workingColViewportIndex;
	            if (isNullOrUndefined(rowViewportIndex) || rowViewportIndex < 0 || rowViewportIndex > 2 ||
	                isNullOrUndefined(colViewportIndex) || colViewportIndex < 0 || colViewportIndex > 2) {
	                return;
	            }
	
	            var shapeLayer = self.shapeLayers[rowViewportIndex * 3 + colViewportIndex];
	            if (!shapeLayer) {
	                return;
	            }
	            shapeLayer.doMouseOut(e);
	
	            if (self.working) {
	                self.working = false;
	                argObj.r = true;
	            }
	
	            if (self.celldirty) {
	                self.celldirty = false;
	                self.repaint();
	            }
	
	            self._workingRowViewportIndex = null;
	            self._workingColViewportIndex = null;
	        },
	        processKeyDown: function (argObj) {
	           
	            if (hasSelectedShape(this)) {
	                argObj.r = true;
	            }
	        },
	        needPaintSelection: function (args) {
	            args.nps = !hasSelectedShape(this);//need paint selection
	        },
	        onGroupChanged: function (args) {
	            this.shapes._onGroupChanged(args.start, args.end, args.isRow);
	        }
	    };
	    CORE_MODULE.Worksheet._registerFeature('shape', adapter);
	
	    var FloatingObjects = __webpack_require__(17),
	        FloatingObjectRender = FloatingObjects && FloatingObjects._FloatingObjectRender;
	    if (FloatingObjectRender) {
	        FloatingObjectRender._registerFeature('shape', {
	            preProcessMouseDown: function (argObj) {
	                var sheet = this._sheet;
	                adapter.preProcessMouseDown.call(sheet, argObj);
	            },
	            preProcessMouseMove: function (argObj) {
	                var sheet = this._sheet;
	                adapter.preProcessMouseMove.call(sheet, argObj);
	            },
	            preProcessMouseUp: function (argObj) {
	                var sheet = this._sheet;
	                adapter.preProcessMouseUp.call(sheet, argObj);
	            }
	        });
	    }
	
	    var Comments = __webpack_require__(25);
	    var CommentView = Comments && Comments._CommentView;
	    if (CommentView) {
	        CommentView._registerFeature('shape', {
	            preProcessMouseDownEdit: function (argObj) {
	                var sheet = this._comment._sheet;
	                adapter.preProcessMouseDown.call(sheet, argObj);
	            },
	            preProcessMouseDownDragResize: function (argObj) {
	                var sheet = this._comment._sheet;
	                adapter.preProcessMouseDown.call(sheet, argObj);
	            },
	            preProcessMouseMove: function (argObj) {
	                var sheet = this._comment._sheet;
	                adapter.preProcessMouseMove.call(sheet, argObj);
	            },
	            preProcessMouseUp: function (argObj) {
	                var sheet = this._comment._sheet;
	                adapter.preProcessMouseUp.call(sheet, argObj);
	            }
	        });
	    }
	
	    var ssAdapter = {
	        init: function () {
	            CORE_MODULE.Commands._initShapesDefaultCommands(this.commandManager());
	        }
	    };
	    CORE_MODULE.Workbook._registerFeature('shape', ssAdapter);
	
	    function getUniqueShapeName(names, name, spaceName, count) {
	        var n = 1, separator = spaceName ? " " : "_";
	        if (spaceName) {
	            var pos = name.lastIndexOf(" ");
	            n = count + 1;
	            name = name.substr(0, pos);
	        }
	        while (names[name + separator + n]) {
	            n++;
	        }
	        return name + separator + n;
	    }
	
	    function updateOptionItemByPath(obj, path, value) {
	        if (obj) {
	            var parts = path.split('.'), key = parts.pop();
	            var result = obj;
	            parts.forEach(function (name) {
	                if (!result[name]) {
	                    result[name] = {};
	                }
	                result = result[name];
	            });
	            result[key] = value;
	        }
	    }
	    Shapes.updateOptionItemByPath = updateOptionItemByPath;
	
	    var fnStartsWith;
	    function startsWith(str, search, pos) {
	        if (!fnStartsWith) {
	            fnStartsWith = String.prototype.startsWith || function (search, pos) {  
	                return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
	            };
	        }
	        return fnStartsWith.call(str, search, pos);
	    }
	
	    
	    var strokeOptionFormulaPathPrefix = 'options.stroke._';
	    var endPointsPathPrefix = 'options.endPoints.';
	    var endPointsTypes = ['beginArrow', 'endArrow'], endPointsProperties = ['type', 'widthType', 'lengthType'];
	    var endPointsNameMapping = ["BegingArrowhead", "EndArrowhead", "Style", "Width", "Length"];
	
	
	    var sheetEx = {
	        _layoutConnectionLine: function (shapeUI) {
	            var layer = this.shapeLayers;
	            if (layer && layer.length > 0) {
	                layer[0].layoutConnectionLine(shapeUI);
	            }
	        },
	        _onShapeItemChangedByFormlua: function (model, id, path, value) {
	            var shapeUI = model.getShapeById(id);
	            if (!shapeUI) { return; }
	           
	           
	           
	           
	            var shape = shapeUI._shapeWrapper, shapeData = shape && shape._shapeData, key;
	           
	            if (['left', 'top', 'width', 'height'].indexOf(path) !== -1) {
	                shapeUI.updateCenterData();
	               
	                if (path === 'left') {
	                    shape._setLocation(value, shapeData._top);
	                } else if (path === 'top') {
	                    shape._setLocation(shapeData._left, value);
	                } else if (path === 'width') {
	                    shape._setSize(value, shapeData._height);
	                } else if (path === 'height') {
	                    shape._setSize(shapeData._width, value);
	                }
	            } else if (path === 'angle') {
	                if (shapeData) {
	                    shapeData.Rotation = value;
	                }
	            } else if (startsWith(path, 'options.')) {
	                if (startsWith(path, 'options.fill') || startsWith(path, 'options.textFormatOptions')) {
	                    updateOptionItemByPath(shapeUI, path, value);
	                } else if (shapeData) {
	                    var line = shapeData.Line;
	                    var hasChanges = true;
	                    if (startsWith(path, strokeOptionFormulaPathPrefix)) {
	                        key = path.substr(strokeOptionFormulaPathPrefix.length);
	                        if (key === 'capType') {
	                            line.CapStyle = value;
	                        } else if (key === 'joinType') {
	                            line.JoinStyle = value;
	                        } else if (key === 'lineStyle') {
	                            line.DashStyle = value;
	                        } else if (key === 'width') {
	                            line.Weight = value;
	                        } else if (key === 'color') {
	                            line.Color.setColor(shape._sheet, value);
	                        } else if (key === 'transparency') {
	                            line.Color.Transparency = value;
	                        }
	                    } else if (startsWith(path, endPointsPathPrefix)) {
	                        var parts = path.substr(endPointsPathPrefix.length).split('.');
	                        var subType = endPointsTypes.indexOf(parts[0]), propertyType = endPointsProperties.indexOf(parts[1]);
	                        if (subType >= 0 && propertyType >= 0) {
	                            var name = endPointsNameMapping[subType] + endPointsNameMapping[propertyType + 2];
	                            line[name] = value;
	                        }
	                        updateOptionItemByPath(shapeUI, path, value);
	                    } else {
	                       
	                        hasChanges = false;
	                    }
	                    if (hasChanges) {
	                        ShapeUtility.syncShapeLineFormat(shapeUI.options, shapeData);
	                    }
	                }
	
	               
	               
	               
	               
	               
	               
	               
	               
	            }
	        },
	        _ensureUniqueShapeName: function (name, spaceName) {
	            var names = this._shapeNames;
	            if (names) {
	                if (spaceName && name[name.length - 1] === ' ') {
	                    name += "1";
	                }
	                if (names[name]) {
	                    name = getUniqueShapeName(names, name, spaceName, this.shapes._getCount());
	                }
	                names[name] = true;
	            }
	            return name;
	        },
	        _getShapeClipboardHelper: function () {
	            var self = this,
	                workbook = self.parent,
	                worksheetFOClipboardHelper = self._shapeClipboardHelper,
	                workbookFOClipboardHelper = workbook && workbook._shapeClipboardHelper;
	            if (!worksheetFOClipboardHelper) {
	                worksheetFOClipboardHelper = self._shapeClipboardHelper = workbookFOClipboardHelper || {
	                    fromSheet: keyword_null,
	                    isCutting: false
	                };
	            }
	
	            return worksheetFOClipboardHelper;
	        },
	        _clearShapeClipboardHelper: function () {
	            var self = this,
	                foClipboardHelper = self._getShapeClipboardHelper(),
	                fromSheet = foClipboardHelper && foClipboardHelper.fromSheet;
	            if (fromSheet) {
	                fromSheet._clipboardShapeData = keyword_null;
	            }
	            foClipboardHelper.fromSheet = keyword_null;
	            foClipboardHelper.isCutting = false;
	        },
	        _setSelectStateForAllShapes: function (selectState) {
	            var shapes = this.shapes.all();
	            if (Array.isArray(shapes)) {
	                shapes.forEach(function (p) {
	                    p.isSelected(selectState);
	                });
	            }
	        },
	        _paintShapes: function () {
	            var sheet = this;
	            if (!sheet.isPaintSuspended()) {
	                var layout = sheet._getSheetLayout();
	                sheet.shapeLayers.forEach(function (shapeLayer, index) {
	                    if (index === 0) {
	                        shapeLayer.shapes.forEach(function (sp) {
	                            sp._isTouchMode = sheet._isTouchMode;
	                        });
	                    }
	
	
	                    var rowViewportIndex = parseInt(index / 3), colViewportIndex = index % 3;
	                    var viewportRect = layout._viewportRect(rowViewportIndex, colViewportIndex);
	                    var actualViewportRect = getActualViewportRect(sheet, rowViewportIndex, colViewportIndex);
	                    var clipRect;
	                    if (actualViewportRect) {
	                        clipRect = viewportRect.getIntersectRect(actualViewportRect);
	                        if (clipRect) {
	                            clipRect.x = clipRect.x - viewportRect.x;
	                            clipRect.y = clipRect.y - viewportRect.y;
	                        }
	                    }
	                    shapeLayer.paint(null, clipRect);
	                });
	            }
	        },
	        isPasteShapes: function () {
	            var self = this,
	                fromSheet = self._getShapeClipboardHelper().fromSheet;
	            var clipboardData = self._copyShapeCollection;
	            if (!clipboardData && fromSheet) {
	                clipboardData = fromSheet._copyShapeCollection;
	            }
	            return !!clipboardData;
	        }
	    };
	    extend(CORE_MODULE.Worksheet.prototype, sheetEx);
	
	    var sheetSourcePrototype = CORE_MODULE.CalcEngine.SheetSource.prototype;
	    var originalGetCustomName = sheetSourcePrototype.getCustomName;
	    sheetSourcePrototype.getCustomName = function (name) {
	       
	        var ni = originalGetCustomName.call(this, name);
	        if (!ni) {
	            var sheet = this._sheet;
	            if (sheet) {
	                return sheet.shapeLayers[0].model.calcSource_.getCustomName(name);
	            }
	        }
	        return ni;
	    };
	
	    Shapes.Canvas._registerFeature('sheet', {
	        preProcessMouseOut: function (argObj) {
	            var shapeLayer = this;
	            shapeLayer.suspendUpdate = false;
	            var e = argObj.e;
	            var sheet = shapeLayer._sheet;
	            var canvasOffset = sheet._getCanvasOffset();
	            var x = e.pageX - canvasOffset.left, y = e.pageY - canvasOffset.top;
	            var $canvas = Core.GC$(sheet._getCanvas());
	            if ((x > 0 && x < $canvas.width()) && (y > 0 && y < $canvas.height())) {
	                argObj.r = true;
	            }
	        },
	    });
	
	    var browser = Core._util._browser;
	    if (browser.msie && parseFloat(browser.version) <= 10) {
	        Shapes.Canvas._registerFeature('sheet', {
	            preProcessMouseDown: function (argObj) {
	                var shapeLayer = this;
	                var sheet = shapeLayer._sheet;
	               
	                var canvasOffset = sheet._getCanvasOffset(), e = argObj.e;
	                var comments = sheet.comments, commentHitInfo = comments && comments.hitTest(e.pageX - canvasOffset.left, e.pageY - canvasOffset.top);
	                if (commentHitInfo) {
	                    var hitTestComment = commentHitInfo.comment;
	                    var hitTestCommentView = comments._getCommentView(hitTestComment);
	                    if (commentHitInfo.area === "comment_editor") {
	                        hitTestCommentView._doMouseDownToEdit(e);
	                    } else if (commentHitInfo.area === "comment_indicator") {
	                        hitTestCommentView._doMouseDownToDragOrResize(e);
	                    }
	                } else {
	                   
	                    var floatingObjectModel = sheet._floatingObjectModel,
	                        floatObjectInfo = floatingObjectModel && floatingObjectModel.hitTest(e.pageX - canvasOffset.left, e.pageY - canvasOffset.top);
	                    if (floatObjectInfo) {
	                        var floatingObject = floatObjectInfo.floatingObject, tableItemSlicer = floatingObject.typeName === "Slicer" && floatingObject._tableItemSlicers[0];
	                        if (tableItemSlicer && tableItemSlicer._hitInReservedArea(e)) {
	                            tableItemSlicer._doMouseDown(e);
	                        } else {
	                            floatObjectInfo._render._doMouseDown(e);
	                        }
	                    } else {
	                       
	                        var returnValue = sheet._mouseDownDelegate(e);
	                        if (returnValue === false) {
	                            cancelDefault(e);
	                        }
	                    }
	                }
	                argObj.r = true;
	            },
	            preProcessMouseMove: function (argObj) {
	                var shapeLayer = this;
	                var sheet = shapeLayer._sheet;
	               
	                var canvasOffset = sheet._getCanvasOffset(), e = argObj.e;
	                var comments = sheet.comments, commentHitInfo = comments && comments.hitTest(e.pageX - canvasOffset.left, e.pageY - canvasOffset.top);
	                if (commentHitInfo) {
	                    var hitTestComment = commentHitInfo.comment;
	                    var hitTestCommentView = comments._getCommentView(hitTestComment);
	                    hitTestCommentView._doMouseMove(e);
	
	                    if (commentHitInfo.area === "comment_editor") {
	                        shapeLayer.host.style.cursor = "text";
	                    } else if (commentHitInfo.area === "comment_indicator") {
	                        var resizeDirct = hitTestCommentView._getResizeDirection(e);
	                        var resizeHitRects = hitTestCommentView._resizeHitRects;
	                        shapeLayer.host.style.cursor = resizeDirct >= 0 && resizeDirct < resizeHitRects.length ? resizeHitRects[resizeDirct].cursor : "move";
	                    }
	                } else {
	                   
	                    var floatingObjectModel = sheet._floatingObjectModel,
	                        floatObjectInfo = floatingObjectModel && floatingObjectModel.hitTest(e.pageX - canvasOffset.left, e.pageY - canvasOffset.top);
	                    if (floatObjectInfo) {
	                        var floatingObject = floatObjectInfo.floatingObject, tableItemSlicer = floatingObject.typeName === "Slicer" && floatingObject._tableItemSlicers[0];
	                        if (tableItemSlicer && tableItemSlicer._hitInReservedArea(e)) {
	                            tableItemSlicer._doMouseMove(e);
	                            shapeLayer.host.style.cursor = "default";
	                        } else {
	                            floatObjectInfo._render._doMouseMove(e);
	                            shapeLayer.host.style.cursor = floatObjectInfo._render._getResizeCursor(e) || "move";
	                        }
	                    } else {
	                       
	                        var returnValue = sheet._mouseMoveDelegate(e);
	                        if (returnValue === false) {
	                            cancelDefault(e);
	                        }
	                        shapeLayer.host.style.cursor = sheet._getCanvas().style.cursor;
	                    }
	                }
	                argObj.r = true;
	            },
	            preProcessMouseUp: function (argObj) {
	                var shapeLayer = this;
	                var sheet = shapeLayer._sheet;
	               
	                var canvasOffset = sheet._getCanvasOffset(), e = argObj.e;
	                var comments = sheet.comments, commentHitInfo = comments && comments.hitTest(e.pageX - canvasOffset.left, e.pageY - canvasOffset.top);
	                if (commentHitInfo) {
	                    var hitTestComment = commentHitInfo.comment;
	                    var hitTestCommentView = comments._getCommentView(hitTestComment);
	                    hitTestCommentView._doMouseUp(e);
	                } else {
	                   
	                    var floatingObjectModel = sheet._floatingObjectModel,
	                        floatObjectInfo = floatingObjectModel && floatingObjectModel.hitTest(e.pageX - canvasOffset.left, e.pageY - canvasOffset.top);
	                    if (floatObjectInfo) {
	                        var floatingObject = floatObjectInfo.floatingObject, tableItemSlicer = floatingObject.typeName === "Slicer" && floatingObject._tableItemSlicers[0];
	                        if (tableItemSlicer && tableItemSlicer._hitInReservedArea(e)) {
	                            tableItemSlicer._doMouseUp(e);
	                        } else {
	                            floatObjectInfo._render._doMouseUp(e);
	                        }
	                    } else {
	                       
	                        var returnValue = sheet._mouseUpDelegate(e);
	                        if (returnValue === false) {
	                            cancelDefault(e);
	                        }
	                    }
	                }
	                argObj.r = true;
	            },
	            preProcessMouseWheel: function (argObj) {
	                var shapeLayer = this;
	                var sheet = shapeLayer._sheet;
	                var returnValue = sheet._mouseWheelDelegate(argObj.e);
	                if (returnValue === false) {
	                    cancelDefault(argObj.e);
	                }
	                argObj.r = true;
	            },
	            preProcessMouseOut: function (argObj) {
	                var shapeLayer = this;
	                var sheet = shapeLayer._sheet;
	                var returnValue = sheet._mouseOutDelegate(argObj.e);
	                if (returnValue === false) {
	                    cancelDefault(argObj.e);
	                }
	                argObj.r = true;
	            },
	            preProcessDbClick: function (argObj) {
	                var shapeLayer = this;
	                var sheet = shapeLayer._sheet;
	                var returnValue = sheet._dblClickDelegate(argObj.e);
	                if (returnValue === false) {
	                    cancelDefault(argObj.e);
	                }
	                argObj.r = true;
	            }
	        });
	    }
	}());

/***/ }),
/* 25 */
/***/ (function(module, exports) {

	module.exports = GC.Spread.Sheets.Comments;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var Shapes = __webpack_require__(1);
	    var Sheets = __webpack_require__(16),
	        $ = Sheets.GC$,
	        inherit = $.inherit,
	        extend = $.extend,
	        Commands = Sheets.Commands,
	        ActionBase = Commands.ActionBase,
	        _inArray = Shapes.Common._inArray,
	        executeCommand = Commands._executeCommand;
	
	    var MOVE_SHAPES = 'moveShapes',
	        MOVE_SHAPES_UP = 'moveShapesUp',
	        MOVE_SHAPES_DOWN = 'moveShapesDown',
	        MOVE_SHAPES_LEFT = 'moveShapesLeft',
	        MOVE_SHAPES_RIGHT = 'moveShapesRight',
	
	        NAVIGATION_NEXT_SHAPE = 'navigationNextShape',
	        NAVIGATION_PREVIOUS_SHAPE = 'navigationPreviousShape',
	        IS_SELECTED = 'isSelected',
	
	        SELECT_ALL_SHAPES = 'selectAllShapes',
	        UN_SELECTE_ALL_SHAPES = 'unSelectAllShapes',
	
	        COPY_SHAPES = 'copyShapes',
	        PASTE_SHAPES = 'pasteShapes',
	        CUT_SHAPES = 'cutShapes',
	        DRAG_COPY_SHAPES = 'dragCopyShapes',
	        DELETE_SHAPES = 'deleteShapes',
	
	        RESIZE_SHAPES = 'resizeShapes',
	        ROTATE_SHAPES = 'rotateShapes';
	
	    var UPDATE_SHAPES = 'updateShapes',
	        UPDATE_SHAPES_POINTS = 'updateConnectShapePoints';
	
	    var getShapeNameList = Shapes.getShapeNameList,
	        getLineShapeInGroup = Shapes.getLineShapeInGroup;
	
	
	    var keyword_null = null;
	
	    function hasSelectedShape(sheet) {
	        var selected = false;
	        var shapes = sheet.shapes.all(), count = shapes.length;
	        for (var i = 0; i < count; i++) {
	            if (shapes[i] && shapes[i].isSelected()) {
	                selected = true;
	                break;
	            }
	        }
	        return selected;
	    }
	
	    function adjustLineShapePoints(points, deltaX, deltaY) {
	        var len = points.length, newPoints = [];
	        for (var i = 0; i < len; i++) {
	            newPoints.push({
	                x: points[i].x + deltaX,
	                y: points[i].y + deltaY
	            });
	        }
	        return newPoints;
	    }
	
	
	
	    function getLinesForDeleteShape(shape, sheet) {
	        var lineShapes = [];
	        if (sheet) {
	            var layer = sheet.shapeLayers[0];
	            lineShapes = layer.getConnectionLines(shape._shapeUI);
	        }
	        return lineShapes;
	    }
	
	    function deleteShapeByName(name, sheet) {
	        var s = sheet.shapes.get(name);
	        if (s._shapeType === 4 ) {
	            s.startConnector(null);
	            s.endConnector(null);
	        }
	        var lines = getLinesForDeleteShape(s, sheet);
	        if (lines && lines.length) {
	            var shapeUIID = s._shapeUI.id, lineWrap;
	           
	            lines.forEach(function (line) {
	                lineWrap = line._shapeWrapper;
	                if (lineWrap) {
	                    if (line.startConnector && line.startConnector.id === shapeUIID) {
	                        lineWrap.startConnector(null);
	                    }
	                    if (line.endConnector && line.endConnector.id === shapeUIID) {
	                        lineWrap.endConnector(null);
	                    }
	                }
	
	            });
	        }
	        sheet.shapes.remove(name, true );
	    }
	
	    function getMaxSheetSize(sheet) {
	        var maxRow = sheet.getRowCount() - 1,
	            maxCol = sheet.getColumnCount() - 1,
	            maxRowHeight = 0,
	            maxColumnWidth = 0,
	            index;
	        for (index = 0; index <= maxRow; index++) {
	            maxRowHeight += sheet.getRowHeight(index, 3 );
	        }
	        for (index = 0; index <= maxCol; index++) {
	            maxColumnWidth += sheet.getColumnWidth(index, 3 );
	        }
	        return {
	            maxColumnWidth: maxColumnWidth,
	            maxRowHeight: maxRowHeight
	        };
	    }
	    var getLineShapeBoundByPoints = Shapes.getLineShapeBoundByPoints;
	
	    function adjustShapePosition(maxSheetSize, x, y, width, height, shape) {
	        var bound;
	       
	        if(shape.rotate && shape.rotate() !== 0 ) {
	            bound = Shapes.getActualBound(shape._shapeUI);
	            x = bound.left;
	            y = bound.top;
	        }
	        if (shape._shapeType === 4 ) {
	            bound = getLineShapeBoundByPoints(shape._shapeUI.getPoints());
	            x = bound.left;
	            y = bound.top;
	        }
	        var oldX = x, oldY = y;
	        var maxColumnWidth = maxSheetSize.maxColumnWidth, maxRowHeight = maxSheetSize.maxRowHeight;
	        if (x + width > maxColumnWidth) {
	            x -= x + width - maxColumnWidth;
	        }
	        if (y + height > maxRowHeight) {
	            y -= y + height - maxRowHeight;
	        }
	        if (y < 0) {
	            y = 0;
	        }
	        if (x < 0) {
	            x = 0;
	        }
	        return {
	            deltaX : x - oldX,
	            deltaY : y - oldY
	        };
	    }
	
	    function toJSONShape(shape) {
	        return JSON.stringify(shape.toJSON());
	    }
	
	    function getClipboardShapeCopy(sheet, option, isCutting) {
	        var clipboardHelper = sheet._getShapeClipboardHelper();
	        var fromSheet = clipboardHelper.fromSheet;
	        clipboardHelper.fromSheet = sheet;
	        clipboardHelper.isCutting = isCutting;
	        var selectedShapes = option.names, bound = option.bound, boundLeft = bound.left, boundTop = bound.top;
	        var shapesAll = [];
	        if (selectedShapes.length) {
	            var json, offsetList = [], tempBound;
	            var jsonList = selectedShapes.map(function (s) {
	                var shape = sheet.shapes.get(s);
	                shapesAll.push(shape);
	                if (shape._shapeType === 4 ) {
	                    tempBound = getLineShapeBoundByPoints(shape._getPoints());
	                } else {
	                    tempBound = {
	                        left: shape.x(),
	                        top: shape.y()
	                    };
	                }
	
	                offsetList.push({
	                    left: tempBound.left - boundLeft,
	                    top: tempBound.top - boundTop
	                });
	                json = toJSONShape(shape);
	                return json;
	            });
	            var nameList = getShapeNameList(shapesAll);
	
	           
	            if (fromSheet) {
	                fromSheet._copyShapeCollection = keyword_null;
	            }
	            sheet._copyShapeCollection = {
	                shapeJsonList: jsonList,
	                bound: option.bound,
	                offsetList: offsetList,
	                names: option.names,
	                allNameList: nameList
	            };
	           
	            if (isCutting) {
	                option.shapeJsonList = jsonList.concat([]);
	            }
	            return true;
	        }
	       
	        sheet._copyShapeCollection = keyword_null;
	
	        return false;
	    }
	    function autoFromJSON(sheet, jsonString) {
	        var json = JSON.parse(jsonString);
	        var shape, shapeData = json.shapeData;
	        if (shapeData) {
	            if (shapeData.sp) {
	                shape = new Shapes.Shape(sheet);
	            } else if (shapeData.cxnSp) {
	                shape = new Shapes.ConnectorShape(sheet);
	            } else if (shapeData.grpSp) {
	                shape = new Shapes.GroupShape(sheet);
	            }
	            if (shape) {
	                sheet._delaySetConnectors = [];
	                shape.fromJSON(json);
	                delete sheet._delaySetConnectors;
	            }
	        }
	        return shape;
	    }
	
	    function createShapeForPaste(sheet, json, row, col, offset) {
	        var shape = autoFromJSON(sheet, json);
	        if (shape) {
	            if (shape._shapeType === 4 ) {
	                shape._initShapeUI(true );
	            } else {
	                shape._initShapeUI();
	            }
	            if (shape._shapeType === 3  ) {
	                shape.updateRelativeLocationSize && shape.updateRelativeLocationSize();
	            }
	            var width = shape.width(),
	                height = shape.height();
	
	            shape.isSelected(true);
	            sheet.shapes._add(shape);
	            shape._isloading = true;
	            shape.startRow(row);
	            shape.startRowOffset(0);
	            shape.startColumn(col);
	            shape.startColumnOffset(0);
	            var x = shape.x() + offset.left,
	                y = shape.y() + offset.top;
	            var maxSheetSize = getMaxSheetSize(sheet);
	            var sizeInfo = adjustShapePosition(maxSheetSize, x, y, width, height, shape);
	            if (shape._shapeType === 4 ) {
	                shape._setPoints(adjustLineShapePoints(shape._getPoints(), offset.left, offset.top));
	            } else {
	                shape.resize(x + sizeInfo.deltaX, y + sizeInfo.deltaY, width, height);
	            }
	
	            delete shape._isloading;
	        }
	        return shape;
	    }
	
	    function setSelectStateForAllShapes(sheet, selectState) {
	        var shapes = sheet.shapes.all();
	        if (Array.isArray(shapes)) {
	            shapes.forEach(function (p) {
	                p.isSelected(selectState);
	            });
	        }
	    }
	
	    var MovingResizingShapeUndoAction = (function (_super) {
	        inherit(MovingResizingShapeUndoAction, _super);
	        function MovingResizingShapeUndoAction(sheet, command) {
	            var self = this;
	            _super.call(self);
	            self._sheet = sheet;
	            self._command = command;
	        }
	
	        var prototype = {
	            constructor: MovingResizingShapeUndoAction,
	            canExecute: function () {
	               
	                    return true;
	               
	               
	            },
	            execute: function () {
	                var self = this,
	                    ret = false,
	                    command = self._command,
	                    changes = command.changes,
	                    sheet = self._sheet;
	                if (self.canExecute() && Array.isArray(changes)) {
	                    sheet._modelManager.startTransaction();
	                    var maxSheetSize = getMaxSheetSize(sheet);
	                    for (var i = 0, len = changes.length; i < len; i++) {
	                        var currentChange = changes[i];
	                        var item = sheet.shapes.get(currentChange.name), deltaX, deltaY;
	                        var x = item.x() + currentChange.offsetX, y = item.y() + currentChange.offsetY, width = item.width() + currentChange.offsetWidth, height = item.height() + currentChange.offsetHeight;
	                        var sizeInfo = adjustShapePosition(maxSheetSize, x, y, width, height, item);
	                       
	                        deltaX = sizeInfo.deltaX;
	                        deltaY = sizeInfo.deltaY;
	
	                        if (currentChange.points) {
	                            item._setPoints(adjustLineShapePoints(currentChange.points, deltaX, deltaY));
	                        } else {
	                            item.resize(x + deltaX, y + deltaY, width, height);
	                        }
	                       
	                        if (currentChange.lineChanges && currentChange.lineChanges.length) {
	                            currentChange.lineChanges.forEach(function (lineChange) {
	                                var points = lineChange.points;
	                                var line = sheet.shapes.get(lineChange.name);
	                                points = adjustLineShapePoints(points, deltaX, deltaY);
	                                line._setPoints(points);
	                               
	                               
	                               
	                               
	                               
	                               
	                               
	                               
	                            });
	                        }
	
	
	
	                        if ((currentChange.startConnector || currentChange.endConnector) && item._shapeType === 4 ) {
	                            if (currentChange.startConnector) {
	                                item.startConnector(currentChange.startConnector, true);
	                            }
	                            if (currentChange.endConnector) {
	                                item.endConnector(currentChange.endConnector, true);
	                            }
	                        }
	
	                        var childrenChanges = currentChange.childrenChanges;
	                        if (childrenChanges) {
	                            childrenChanges.forEach(function (childChange) {
	                                var childShape = item.find(childChange.name);
	                                if (childShape) {
	                                    childChange.oldPoints = childShape._getPoints();
	                                    childShape._setPoints(childChange.points);
	                                }
	                            });
	                        }
	                    }
	                    sheet._paintShapes();
	
	                   
	
	                    var changesKey = Commands._getChangesKey(sheet.name());
	                    command[changesKey] = sheet._modelManager.endTransaction();
	
	                    ret = (changes.length > 0);
	                }
	
	                return ret;
	            },
	            canUndo: function () {
	                return true;
	            },
	            undo: function () {
	                var self = this, sheet = self._sheet;
	                if (self.canUndo()) {
	
	                    var changesKey = Commands._getChangesKey(sheet.name());
	                    sheet._modelManager.undo(self._command[changesKey]);
	                    sheet._paintShapes();
	                    return true;
	                }
	                return false;
	            }
	        };
	
	        extend(MovingResizingShapeUndoAction.prototype, prototype);
	
	        return MovingResizingShapeUndoAction;
	    })(ActionBase);
	    Shapes.MovingResizingShapeUndoAction = MovingResizingShapeUndoAction;
	
	    var RotateShapeUndoAction = (function (_super) {
	        inherit(RotateShapeUndoAction, _super);
	        function RotateShapeUndoAction(sheet, command) {
	            var self = this;
	            _super.call(self);
	            self._sheet = sheet;
	            self._command = command;
	        }
	
	        var prototype = {
	            constructor: RotateShapeUndoAction,
	            canExecute: function () {
	                    return true;
	            },
	            execute: function () {
	                var self = this,
	                    ret = false,
	                    command = self._command,
	                    changes = command.changes,
	                    sheet = self._sheet;
	                if (self.canExecute() && Array.isArray(changes)) {
	                    sheet._modelManager.startTransaction();
	
	                    for (var i = 0, len = changes.length; i < len; i++) {
	                        var currentChange = changes[i];
	                        var item = sheet.shapes.get(currentChange.name);
	                        var rotate = currentChange.rotate;
	                        if (typeof rotate !== "undefined" && item.rotate) {
	                            currentChange.oldRotate = item.rotate();
	                           
	                            item._setAngle(rotate, true);  
	                        }
	
	                        var points = currentChange.points;
	                        if (points) {
	                            currentChange.oldPoints = item._getPoints();
	                            item._setPoints(points);
	                        }
	                    }
	                    sheet._paintShapes();
	
	                    command._changes = sheet._modelManager.endTransaction();
	
	                    ret = (changes.length > 0);
	                }
	
	                return ret;
	            },
	            canUndo: function () {
	                return true;
	            },
	            undo: function () {
	                var self = this,
	                    command = self._command,
	                   
	                    sheet = self._sheet;
	                if (self.canUndo()) {
	                    sheet._modelManager.undo(command._changes);
	                    sheet._paintShapes();
	                    return true;
	                }
	                return false;
	            }
	        };
	
	        extend(RotateShapeUndoAction.prototype, prototype);
	
	        return RotateShapeUndoAction;
	    })(ActionBase);
	    Shapes.RotateShapeUndoAction = RotateShapeUndoAction;
	
	    function applyShapeChanges(shape, changes, isUndo) {
	        if (shape && changes) {
	            var shapeUI = shape._shapeUI;
	            var src = isUndo ? changes.oldValues : changes.values;
	            for (var i = 0, len = src.length; i < len; i++) {
	                var item = src[i], name = item[0], value = item[1];
	                shapeUI.setVariable(name, value);
	            }
	        }
	    }
	
	    var UpdateShapesUndoAction = (function (_super) {
	        inherit(UpdateShapesUndoAction, _super);
	
	        function UpdateShapesUndoAction(sheet, command) {
	            var self = this;
	            _super.call(self);
	            self._sheet = sheet;
	            self._command = command;
	        }
	
	        var prototype = {
	            constructor: UpdateShapesUndoAction,
	            applyChanges: function (sheet, names, values, isUndo) {
	                for (var i = 0, len = names.length; i < len; i++) {
	                    var shapeName = names[i];
	                    var shape = sheet.shapes.get(shapeName);
	                    var data = values && values[shapeName];
	                    if (data) {
	                        applyShapeChanges(shape, data, isUndo);
	                    }
	                }
	            },
	            execute: function () {
	                var self = this,
	                    ret = false,
	                    command = self._command,
	                    names = command.shapes,
	                    values = command.values,
	                    sheet = self._sheet;
	                if (self.canExecute() && Array.isArray(names)) {
	                   
	
	                   
	
	                    self.applyChanges(sheet, names, values, false);
	                    sheet._paintShapes();
	
	                   
	
	                   
	                   
	
	                    ret = (names.length > 0);
	                }
	
	                return ret;
	            },
	            canUndo: function () {
	               
	               
	               
	               
	                return true;
	               
	               
	            },
	            undo: function () {
	                var self = this,
	                    command = self._command,
	                    names = command.shapes,
	                    values = command.values,
	                    sheet = self._sheet;
	                if (self.canUndo()) {
	                   
	
	                   
	                   
	
	                    self.applyChanges(sheet, names, values, true);
	                    sheet._paintShapes();
	
	                   
	                    return true;
	                }
	                return false;
	            }
	        };
	
	        extend(UpdateShapesUndoAction.prototype, prototype);
	
	        return UpdateShapesUndoAction;
	    })(ActionBase);
	    Shapes.UpdateShapeUndoAction = UpdateShapesUndoAction;
	    var UpdateShapesPointsUndoAction = (function (_super) {
	        inherit(UpdateShapesPointsUndoAction, _super);
	
	        function UpdateShapesPointsUndoAction(sheet, command) {
	            var self = this;
	            _super.call(self);
	            self._sheet = sheet;
	            self._command = command;
	        }
	
	        var prototype = {
	            constructor: UpdateShapesPointsUndoAction,
	            canExecute : function () {
	              return true;
	            },
	            execute: function () {
	                var self = this,
	                    ret = false,
	                    command = self._command,
	                    names = command.shapes,
	                    values = command.values,
	                    sheet = self._sheet;
	                if (self.canExecute() && values) {
	                    for (var i = 0, len = names.length;i < len; i++) {
	                        var shape = sheet.shapes.get(names[i]);
	                        shape._setPoints(values[names].points);
	                    }
	                    sheet._paintShapes();
	                    ret = (names.length > 0);
	                }
	
	                return ret;
	            },
	            canUndo: function () {
	                return true;
	            },
	            undo: function () {
	                var self = this,
	                    command = self._command,
	                    names = command.shapes,
	                    values = command.values,
	                    sheet = self._sheet;
	                if (self.canUndo()) {
	                   
	
	                   
	                   
	                    for (var i = 0, len = names.length;i < len; i++) {
	                        var shape = sheet.shapes.get(names[i]);
	                        shape._setPoints(values[names].oldPoints);
	                    }
	
	                    sheet._paintShapes();
	
	                   
	                    return true;
	                }
	                return false;
	            }
	        };
	
	        extend(UpdateShapesPointsUndoAction.prototype, prototype);
	
	        return UpdateShapesPointsUndoAction;
	    })(ActionBase);
	
	    function getSelectedShapesUI(sheet) {
	        var shapes = [];
	        sheet.shapes.all().forEach(function (item) {
	            if (item.isSelected()) {
	                shapes.push(item._shapeUI);
	            }
	        });
	        return shapes;
	    }
	
	    function getSelectedShapesNames(sheet) {
	        var names = [];
	        sheet.shapes.all().forEach(function (item) {
	            if (item.isSelected()) {
	                names.push(item.name());
	            }
	        });
	        return names;
	    }
	
	    function getSelectedShapeBounds(sheet, selectedShapesNameList) {
	        var shape;
	        var shapeUIList = selectedShapesNameList.map(function (name) {
	            shape = sheet.shapes.get(name);
	            if(shape && shape._shapeUI) {
	                return shape._shapeUI;
	            }
	        });
	        return Shapes.getBoundForHoldShapes(shapeUIList, true);
	    }
	
	    function moveShapeFn(direction) {
	        return function (context, options) {
	            var sheet = Commands._getWorksheet(context, options);
	            var offsetX = 0;
	            if (direction === 0) {
	                offsetX = -1;
	            } else if (direction === 2) {
	                offsetX = 1;
	            }
	            var offsetY = 0;
	            if (direction === 1) {
	                offsetY = -1;
	            } else if (direction === 3) {
	                offsetY = 1;
	            }
	            var changes = [];
	            var shapeLayer = sheet.shapeLayers[0];
	            var shapes = getSelectedShapesUI(sheet);
	            if (shapes.length <= 0) {
	                return false;
	            }
	            for (var i = 0; i < shapes.length; i++) {
	                shapeLayer.moveShape(shapes[i], offsetX, offsetY);
	            }
	            var lines = shapeLayer.getConnectionLines(shapes[0]);
	            lines = lines.filter(function (item, pos, linesArray) {
	                return linesArray.indexOf(item) === pos;
	            });
	            changes = changes.concat(shapeLayer.getMoveShapesChanges(shapes, lines));
	
	            return sheet._commandManager().execute({
	                cmd: MOVE_SHAPES,
	                sheetName: sheet.name(),
	                changes: changes
	            });
	        };
	    }
	
	    Commands[MOVE_SHAPES_LEFT] = moveShapeFn(0);
	    Commands[MOVE_SHAPES_UP] = moveShapeFn(1);
	    Commands[MOVE_SHAPES_RIGHT] = moveShapeFn(2);
	    Commands[MOVE_SHAPES_DOWN] = moveShapeFn(3);
	    Commands[MOVE_SHAPES] = {
	        canUndo: true,
	        execute: function (context, options, isUndo) {
	            return executeCommand(context, MovingResizingShapeUndoAction, options, isUndo);
	        }
	    };
	    Commands[UN_SELECTE_ALL_SHAPES] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = Commands._getWorksheet(context, options);
	            if (hasSelectedShape(sheet)) {
	                sheet.suspendPaint();
	                setSelectStateForAllShapes(sheet, false);
	                sheet.resumePaint();
	                return true;
	            }
	            return false;
	        }
	    };
	    Commands[SELECT_ALL_SHAPES] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = Commands._getWorksheet(context, options);
	            if (hasSelectedShape(sheet)) {
	                sheet.suspendPaint();
	                setSelectStateForAllShapes(sheet, true);
	                sheet.resumePaint();
	                return true;
	            }
	            return false;
	        }
	    };
	    Commands[NAVIGATION_NEXT_SHAPE] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = Commands._getWorksheet(context, options);
	            if (hasSelectedShape(sheet)) {
	                sheet.suspendPaint();
	                var selected, first, next, i;
	                var shapes = sheet.shapes.all(), shapesLength = shapes.length;
	                if(shapesLength < 2) {
	                    sheet.resumePaint();
	                    return true;
	                }
	                for (i = 0; i < shapesLength; i++) {
	                    var item = shapes[i];
	                    if (!first) {
	                        first = item;
	                    }
	                    if (selected) {
	                        next = item;
	                        break;
	                    }
	                    if (item && item[IS_SELECTED]()) {
	                        selected = item;
	                    }
	                }
	                setSelectStateForAllShapes(sheet, false);
	                if (!next) {
	                    next = first;
	                }
	                if (next) {
	                    next.isSelected(true);
	                }
	                sheet.resumePaint();
	                return true;
	            }
	            return false;
	        }
	    };
	    Commands[NAVIGATION_PREVIOUS_SHAPE] = {
	        canUndo: false,
	        execute: function (context, options) {
	            var sheet = Commands._getWorksheet(context, options);
	            if (hasSelectedShape(sheet)) {
	                sheet.suspendPaint();
	                var first, prev, i;
	                var shapes = sheet.shapes.all(), shapesLength = shapes.length;
	                if(shapesLength < 2) {
	                    sheet.resumePaint();
	                    return true;
	                }
	                for (i = 0; i < shapesLength; i++) {
	                    var item = shapes[i];
	                    if (!first) {
	                        first = item;
	                    }
	                    if (!first[IS_SELECTED]()) {
	                        if (!item[IS_SELECTED]()) {
	                            prev = item;
	                        }
	                        if (item[IS_SELECTED]()) {
	                            break;
	                        }
	                    } else {
	                        prev = item;
	                    }
	                }
	                if (prev) {
	                    setSelectStateForAllShapes(sheet, false);
	                    prev.isSelected(true);
	                }
	                sheet.resumePaint();
	                return true;
	            }
	            return false;
	        }
	    };
	    Commands[RESIZE_SHAPES] = {
	        canUndo: true,
	        execute: function (context, options, isUndo) {
	            return executeCommand(context, MovingResizingShapeUndoAction, options, isUndo);
	        }
	    };
	    Commands[ROTATE_SHAPES] = {
	        canUndo: true,
	        execute: function (context, options, isUndo) {
	            return executeCommand(context, RotateShapeUndoAction, options, isUndo);
	        }
	    };
	    Commands[UPDATE_SHAPES] = {
	        canUndo: true,
	        execute: function (context, options, isUndo) {
	            return executeCommand(context, UpdateShapesUndoAction, options, isUndo);
	        }
	    };
	    Commands[UPDATE_SHAPES_POINTS] = {
	        canUndo: true,
	        execute: function (context, options, isUndo) {
	            return executeCommand(context, UpdateShapesPointsUndoAction, options, isUndo);
	        }
	    };
	
	    var CopyShapesUndoAction = (function (_super) {
	        inherit(CopyShapesUndoAction, _super);
	
	        function CopyShapesUndoAction(sheet, command) {
	            var self = this;
	            _super.call(self);
	            self._sheet = sheet;
	            self._command = command;
	        }
	
	        var prototype = {
	            constructor: CopyShapesUndoAction,
	            canExecute: function () {
	                return true;
	            },
	            execute: function () {
	                var self = this, sheet = self._sheet, option = self._command.copyData;
	                if (self.canExecute()) {
	                    return getClipboardShapeCopy(sheet, option, false);
	                }
	                return false;
	            },
	            canUndo: function () {
	                return false;
	            }
	        };
	        extend(CopyShapesUndoAction.prototype, prototype);
	
	        return CopyShapesUndoAction;
	    })(ActionBase);
	    Commands[COPY_SHAPES] = {
	        canUndo: false,
	        execute: function (context, options, isUndo) {
	            var sheet = Commands._getWorksheet(context, options);
	            if(sheet) {
	                var names = getSelectedShapesNames(sheet);
	                if (names.length === 0) {
	                    return false;
	                }
	                options.copyData = {
	                    names: names,
	                    bound: getSelectedShapeBounds(sheet, names)
	                };
	                return executeCommand(context, CopyShapesUndoAction, options, isUndo);
	            }
	            return false;
	
	        }
	    };
	    var CutShapesUndoAction = (function (_super) {
	        inherit(CutShapesUndoAction, _super);
	
	        function CutShapesUndoAction(sheet, command) {
	            var self = this;
	            _super.call(self);
	            self._sheet = sheet;
	            self._command = command;
	        }
	
	        var prototype = {
	            constructor: CutShapesUndoAction,
	            canExecute: function () {
	                return this._command.copyData.names.length > 0;
	            },
	            execute: function () {
	                var self = this, sheet = self._sheet, command = this._command, copyData = command.copyData;
	                if (self.canExecute()) {
	                    sheet._modelManager.startTransaction();
	                    copyData.names.forEach(function (name) {
	                        deleteShapeByName(name, sheet);
	                    });
	                    sheet._paintShapes();
	                    var changesKey = Commands._getChangesKey(sheet.name());
	                    command[changesKey] = sheet._modelManager.endTransaction();
	                    return true;
	                }
	                return false;
	            },
	            canUndo: function () {
	                return true;
	            },
	            undo: function () {
	                var self = this, sheet = self._sheet;
	                var changesKey = Commands._getChangesKey(sheet.name());
	                sheet._modelManager.undo(self._command[changesKey]);
	                sheet._paintShapes();
	                return true;
	            }
	        };
	        extend(CutShapesUndoAction.prototype, prototype);
	
	        return CutShapesUndoAction;
	    })(ActionBase);
	
	    Commands[CUT_SHAPES] = {
	        canUndo: true,
	        execute: function (context, options, isUndo) {
	            var sheet = Commands._getWorksheet(context, options);
	           
	            var copyData = options.copyData;
	            if(!copyData) {
	                var names = getSelectedShapesNames(sheet);
	                if (names.length === 0) {
	                    return false;
	                }
	                copyData = {
	                    names: names,
	                    bound: getSelectedShapeBounds(sheet, names)
	                };
	                getClipboardShapeCopy(sheet, copyData, true);
	                options.copyData = copyData;
	                options.cmd = CUT_SHAPES;
	            }
	            return executeCommand(context, CutShapesUndoAction, options, isUndo);
	        }
	    };
	
	    var PasteShapesUndoAction = (function (_super) {
	        inherit(PasteShapesUndoAction, _super);
	
	        function PasteShapesUndoAction(sheet, command) {
	            var self = this;
	            _super.call(self);
	            self._sheet = sheet;
	            self._command = command;
	        }
	
	        var prototype = {
	            constructor: PasteShapesUndoAction,
	            canExecute: function () {
	                return this._command.pasteData.shapeJsonList.length > 0;
	            },
	            execute: function () {
	                var self = this, sheet = self._sheet, command = self._command, pasteData = command.pasteData;
	
	                var names = [];
	                var start, end;
	                if(self.canExecute()) {
	                    sheet._modelManager.startTransaction();
	                    var offsetList = pasteData.offsetList, activeRowIndex = pasteData.activeRowIndex, activeColumnIndex = pasteData.activeColumnIndex;
	                    var shapes = [], lineShapes = [];
	                    pasteData.shapeJsonList.forEach(function (item, index) {
	                        var shape = createShapeForPaste(sheet, item, activeRowIndex, activeColumnIndex, offsetList[index]);
	                        if (shape._shapeType === 4 ) {
	                            start = shape.startConnector();
	                            end = shape.endConnector();
	                            if (start || end) {
	                                lineShapes.push(shape);
	                            }
	                        }
	                        if (shape._shapeType === 3 ) {
	                            lineShapes = lineShapes.concat(getLineShapeInGroup(shape));
	                        }
	                        names.push(shape.name());
	                        shapes.push(shape);
	                    });
	                   
	                    if(lineShapes.length > 0) {
	                        var allNameList = pasteData.allNameList;
	                        var nameList = getShapeNameList(shapes), nameIndex;
	                        lineShapes.forEach(function (lineShape) {
	                           
	                            start = lineShape.startConnector();
	                            end = lineShape.endConnector();
	                            if (start) {
	                                nameIndex = _inArray(start.name, allNameList);
	                                if (nameIndex > -1) {
	                                    lineShape.startConnector({
	                                        name: nameList[nameIndex],
	                                        index: start.index
	                                    });
	                                } else if(_inArray(start.name, nameList) > -1) {
	                                    lineShape.startConnector(start);
	                                } else {
	                                   
	                                    lineShape.startConnector(null);
	                                }
	                            }
	                            if (end) {
	                                nameIndex = _inArray(end.name, allNameList);
	                                if (nameIndex > -1) {
	                                    lineShape.endConnector({
	                                        name: nameList[nameIndex],
	                                        index: end.index
	                                    });
	                                } else if(_inArray(end.name, nameList) > -1) {
	                                    lineShape.endConnector(end);
	                                } else {
	                                   
	                                    lineShape.endConnector(null);
	                                }
	                            }
	                           
	                        });
	                    }
	                   
	                    var fromSheet = sheet.parent.getSheetFromName(pasteData.fromSheetName);
	                    if(fromSheet) {
	                        pasteData.oldShapeNames.forEach(function (name) {
	                            var fromShape = fromSheet.shapes.get(name);
	                           
	                            fromShape && fromShape.isSelected(false);
	                        });
	                    }
	                    var changesKey = Commands._getChangesKey(sheet.name());
	                    command[changesKey] = sheet._modelManager.endTransaction();
	                    pasteData.names = names;
	                    sheet._paintShapes();
	                    return true;
	                }
	                return false;
	            },
	            canUndo: function () {
	                return true;
	            },
	            undo: function () {
	                var self = this, sheet = self._sheet;
	                var changesKey = Commands._getChangesKey(sheet.name());
	                sheet._modelManager.undo(self._command[changesKey]);
	                sheet._paintShapes();
	                return true;
	            }
	        };
	        extend(PasteShapesUndoAction.prototype, prototype);
	
	        return PasteShapesUndoAction;
	    })(ActionBase);
	
	
	    Commands[PASTE_SHAPES] = {
	        canUndo: true,
	        execute: function (context, options, isUndo) {
	            var sheet = Commands._getWorksheet(context, options);
	            var pasteData = options.pasteData;
	            options.cmd = PASTE_SHAPES;
	           
	            if(!pasteData) {
	                var clipboardHelper = sheet._getShapeClipboardHelper();
	                var fromSheet = clipboardHelper.fromSheet;
	                var copyShapeCollection = fromSheet && fromSheet._copyShapeCollection;
	                if (!copyShapeCollection) {
	                    return false;
	                }
	
	                var activeRowIndex = sheet.getActiveRowIndex();
	                var activeColumnIndex = sheet.getActiveColumnIndex();
	
	                pasteData = {
	                    offsetList: copyShapeCollection.offsetList,
	                    activeRowIndex: activeRowIndex,
	                    activeColumnIndex : activeColumnIndex,
	                    shapeJsonList: copyShapeCollection.shapeJsonList.concat([]),
	                    allNameList : copyShapeCollection.allNameList.concat([]),
	                    oldShapeNames: copyShapeCollection.names.concat([]),
	                    fromSheetName: fromSheet.name()
	                };
	                options.pasteData = pasteData;
	            }
	
	
	            return executeCommand(context, PasteShapesUndoAction, options, isUndo);
	        }
	    };
	
	    var DeleteShapesUndoAction = (function (_super) {
	        inherit(DeleteShapesUndoAction, _super);
	
	        function DeleteShapesUndoAction(sheet, command) {
	            var self = this;
	            _super.call(self);
	            self._sheet = sheet;
	            self._command = command;
	        }
	
	        var prototype = {
	            constructor: DeleteShapesUndoAction,
	            canExecute: function () {
	                return this._command.deleteData && this._command.deleteData.names.length > 0;
	            },
	            execute: function () {
	                var self = this, sheet = self._sheet, command = this._command, deleteData = command.deleteData;
	                if(self.canExecute()) {
	                    sheet._modelManager.startTransaction();
	                    deleteData.names.forEach(function (name) {
	                        deleteShapeByName(name, sheet);
	                    });
	                    self._command._changes = sheet._modelManager.endTransaction();
	
	                    return true;
	                }
	                return false;
	            },
	            canUndo: function () {
	                return true;
	            },
	            undo: function () {
	                var self = this, sheet = self._sheet;
	                sheet._modelManager.undo(self._command._changes);
	                sheet._paintShapes();
	                return true;
	            }
	        };
	        extend(DeleteShapesUndoAction.prototype, prototype);
	
	        return DeleteShapesUndoAction;
	    })(ActionBase);
	
	    Commands[DELETE_SHAPES] = {
	        canUndo: true,
	        execute: function (context, options, isUndo) {
	            options.cmd = DELETE_SHAPES;
	            var sheet = Commands._getWorksheet(context, options);
	            var deleteData = options.deleteData;
	           
	            if(!deleteData) {
	                var names = getSelectedShapesNames(sheet);
	                if (names.length === 0) {
	                    return false;
	                }
	                deleteData = {
	                    names: names
	                };
	                options.deleteData = deleteData;
	            }
	            return executeCommand(context, DeleteShapesUndoAction, options, isUndo);
	        }
	    };
	
	    var DragCopyShapesUndoAction = (function (_super) {
	        inherit(DragCopyShapesUndoAction, _super);
	
	        function DragCopyShapesUndoAction(sheet, command) {
	            var self = this;
	            _super.call(self);
	            self._sheet = sheet;
	            self._command = command;
	        }
	
	        var prototype = {
	            constructor: DragCopyShapesUndoAction,
	            canExecute: function () {
	                return true;
	            },
	            execute: function () {
	                var self = this, changes = self._command.changes, sheet = self._sheet, shape;
	                var x, y;
	                for (var i = 0, len = changes.length; i < len; i++) {
	                    shape = sheet.shapes.get(changes[i].name);
	                   
	                    if (!shape) {
	                        shape = sheet.shapes.get(changes[i].oldShapeName)._clone();
	                        sheet.shapes._add(shape);
	                        shape.name(changes[i].name);
	                    }
	                    x = shape.x();
	                    y = shape.y();
	                    shape.resize(x + changes[i].offsetX, y + changes[i].offsetY, shape.width(), shape.height());
	                    if (shape._shapeType === 3 ) {
	                        shape.layoutChildren();
	                    }
	                    if (shape._shapeType === 4 ) {
	                        shape.startConnector(shape.startConnector(), true );
	                        shape.endConnector(shape.endConnector(), true );
	                    }
	                }
	                self._command._changes = changes.concat([]);
	                return true;
	            },
	            canUndo: function () {
	                return true;
	            },
	            undo: function () {
	                var names = this._command._changes, sheet = this._sheet, oldShape;
	                for(var i = 0, len = names.length; i < len;i++) {
	                    if(sheet) {
	                        sheet.shapes.remove(names[i].name);
	                        oldShape = sheet.shapes.get(names[i].oldShapeName);
	                        if(oldShape) {
	                            oldShape.isSelected(true);
	                        }
	                    }
	                }
	                return true;
	
	            }
	        };
	        extend(DragCopyShapesUndoAction.prototype, prototype);
	
	        return DragCopyShapesUndoAction;
	    })(ActionBase);
	
	
	    Commands[DRAG_COPY_SHAPES] = {
	        canUndo: true,
	        execute: function (context, options, isUndo) {
	            return executeCommand(context, DragCopyShapesUndoAction, options, isUndo);
	        }
	    };
	
	    Commands._initShapesDefaultCommands = function (commands) {
	        var isMac = Sheets._util._isMacOS(), ctrl = !isMac, meta = isMac;
	
	        commands.register(MOVE_SHAPES, Commands[MOVE_SHAPES]);
	        commands.register(DRAG_COPY_SHAPES, Commands[DRAG_COPY_SHAPES]);
	        commands.register(MOVE_SHAPES_UP, Commands[MOVE_SHAPES_UP], 38 , false, false, false, false);
	        commands.register(MOVE_SHAPES_DOWN, Commands[MOVE_SHAPES_DOWN], 40 , false, false, false, false);
	        commands.register(MOVE_SHAPES_LEFT, Commands[MOVE_SHAPES_LEFT], 37 , false, false, false, false);
	        commands.register(MOVE_SHAPES_RIGHT, Commands[MOVE_SHAPES_RIGHT], 39 , false, false, false, false);
	        commands.register(NAVIGATION_NEXT_SHAPE, Commands[NAVIGATION_NEXT_SHAPE], 9 , false, false, false, false);
	        commands.register(NAVIGATION_PREVIOUS_SHAPE, Commands[NAVIGATION_PREVIOUS_SHAPE], 9 , false, true, false, false);
	        commands.register(UN_SELECTE_ALL_SHAPES, Commands[UN_SELECTE_ALL_SHAPES], 27 , false, false, false, false);
	        commands.register(SELECT_ALL_SHAPES, Commands[SELECT_ALL_SHAPES], 65 , ctrl, false, false, meta);
	        commands.register(COPY_SHAPES, Commands[COPY_SHAPES], 67 , ctrl, false, false, meta);
	        commands.register(PASTE_SHAPES, Commands[PASTE_SHAPES], 86 , ctrl, false, false, meta);
	        commands.register(CUT_SHAPES, Commands[CUT_SHAPES], 88 , ctrl, false, false, meta);
	        commands.register(DELETE_SHAPES, Commands[DELETE_SHAPES], isMac ? 8  : 46 , false, false, false, false);
	        commands.register(RESIZE_SHAPES, Commands[RESIZE_SHAPES]);
	        commands.register(ROTATE_SHAPES, Commands[ROTATE_SHAPES]);
	        commands.register(UPDATE_SHAPES, Commands[UPDATE_SHAPES]);
	        commands.register(UPDATE_SHAPES_POINTS, Commands[UPDATE_SHAPES_POINTS]);
	    };
	}());

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	(function () {
	    'use strict';
	
	    var Touch = __webpack_require__(28);
	    if (Touch) {
	        (function () {
	            function preProcessManipulationStarted(argObj) {
	                var self = this;
	                var position = argObj.e._Position;
	                var target = self._touchHitTest(position.X, position.Y, true);
	                var index = target.rowViewportIndex * 3 + target.colViewportIndex;
	
	                var shapeLayer = self._sheet.shapeLayers[index];
	                if (shapeLayer) {
	                    var offset = self._sheet._getCanvasOffset(), dummyEvent = { pageX: position.X + offset.left, pageY: position.Y + offset.top };
	                    var hitInfo = shapeLayer.hitTest(dummyEvent);
	
	                    var shape = hitInfo && hitInfo.shape;
	                    if (shape && shape.isSelected) {
	                        self._activeShapeLayer = shapeLayer;
	                        self._activeShapeLayer.doMouseDown(dummyEvent);
	
	                        argObj.r = true;
	                    }
	                }
	            }
	            function preProcessManipulationDelta(argObj) {
	                var self = this;
	                var position = argObj.e._Position;
	                if (self._activeShapeLayer) {
	                    var offset = self._sheet._getCanvasOffset(), dummyEvent = { pageX: position.X + offset.left, pageY: position.Y + offset.top };
	                    self._activeShapeLayer.doMouseMove(dummyEvent);
	
	                    argObj.r = true;
	                }
	            }
	            function preProcessManipulationCompleted(argObj) {
	                var self = this;
	                var position = argObj.e._Position;
	                if (self._activeShapeLayer) {
	                    var offset = self._sheet._getCanvasOffset(), dummyEvent = { pageX: position.X + offset.left, pageY: position.Y + offset.top };
	                    self._activeShapeLayer.doMouseUp(dummyEvent);
	                    self._activeShapeLayer = null;
	
	                    argObj.r = true;
	                }
	            }
	            function preProcessTapped(argObj) {
	                var self = this;
	                var position = argObj.e._Position;
	                var target = self._touchHitTest(position.X, position.Y, true);
	                var index = target.rowViewportIndex * 3 + target.colViewportIndex;
	
	                var shapeLayer = self._sheet.shapeLayers[index];
	                if (shapeLayer) {
	                    var offset = self._sheet._getCanvasOffset(), dummyEvent = { pageX: position.X + offset.left, pageY: position.Y + offset.top };
	                    var hitInfo = shapeLayer.hitTest(dummyEvent);
	
	                    var shape = hitInfo && hitInfo.shape;
	                    if (shape) {
	                        shapeLayer.shapes.forEach(function (sp) {
	                            shapeLayer.setSelect(sp, false);
	                        });
	                        shapeLayer.setSelect(shape, true);
	                        if (shapeLayer.onShapeSelected) {
	                            shapeLayer.onShapeSelected();
	                        }
	                        argObj.r = true;
	                    }
	                }
	            }
	            Touch.TouchEventHandler._registerFeature('touch', {
	                preProcessManipulationStarted: preProcessManipulationStarted,
	                preProcessManipulationDelta: preProcessManipulationDelta,
	                preProcessManipulationCompleted: preProcessManipulationCompleted,
	                preProcessTapped: preProcessTapped
	            });
	            __webpack_require__(17).FloatingObjectTouchEventHandler._registerFeature('touch', {
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	               
	                preProcessTapped: function (argObj) {
	                    var touchEventHandler = this._floatingObjectRender._sheet._touchManager._touchEventHandler;
	                    preProcessTapped.call(touchEventHandler, argObj);
	                }
	            });
	
	
	            var Core = __webpack_require__(16);
	            var $ = Core.GC$, $_extend = $.extend;
	           
	            function ShapeTouchManager(element, shapeLayer, touchEventProvider) {
	                var self = this;
	                self._touchMouseMessageFilter = new Touch._TouchMouseMessageFilter(self);
	                self._touchTarget = new Touch._TouchTargetElement(element, 'Shape', self._touchMouseMessageFilter, 2, 200);
	                self._touchEventProvider = touchEventProvider;
	                self._touchEventHandler = new ShapeTouchEventHandler(element, shapeLayer);
	                var touchEventHandler = self._touchEventHandler;
	                var touchTarget = self._touchTarget;
	                touchTarget._canDoManipulation = function () {
	                    return true;
	                };
	                touchTarget._canDoTap = function () {
	                    return true;
	                };
	                touchTarget._manipulationStarting = function (e) {
	                    return touchEventHandler._doManipulationStarting(e);
	                };
	                touchTarget._manipulationStarted = function (e) {
	                    return touchEventHandler._doManipulationStarted(e);
	                };
	                touchTarget._manipulationDelta = function (e) {
	                    return touchEventHandler._doManipulationDelta(e);
	                };
	               
	               
	               
	                touchTarget._manipulationCompleted = function (e) {
	                    return touchEventHandler._doManipulationCompleted(e);
	                };
	                touchTarget._tapped = function (e) {
	                    return touchEventHandler._doTapped(e);
	                };
	                touchTarget._doubleTapped = function (e) {
	                   return touchEventHandler._doDoubleTapped(e);
	                };
	               
	               
	               
	            }
	            $_extend(ShapeTouchManager.prototype, {
	                _attach: function () {
	                    var self = this, touchEventProvider = self._touchEventProvider;
	                    if (touchEventProvider) {
	                        touchEventProvider._attachDettach(self._touchTarget, true);
	                    }
	                },
	                _detach: function () {
	                    var self = this, touchEventProvider = self._touchEventProvider;
	                    if (touchEventProvider) {
	                        touchEventProvider._attachDettach(self._touchTarget, false);
	                    }
	                }
	            });
	
	            function ShapeTouchEventHandler(element, shapeLayer) {
	                var self = this;
	                self._containerElement = element;
	                self._shapeLayer = shapeLayer;
	            }
	            $_extend(ShapeTouchEventHandler.prototype, {
	                _positionToPage: function(position) {
	                    var newPosition = new Touch._TouchPoint(position.X, position.Y);
	                    var t = $(this._containerElement).offset();
	                    if (t) {
	                        var body = document.body;
	                        newPosition.X += t.left + body.clientLeft || 0;
	                        newPosition.Y += t.top + body.clientTop || 0;
	                    }
	                    return newPosition;
	                },
	                _positionToHostCanvas: function (position, canvasOffset) {
	                    var newPosition = this._positionToPage(position);
	                    newPosition.X -= canvasOffset.left;
	                    newPosition.Y -= canvasOffset.top;
	                    return newPosition;
	                },
	                _doManipulationStarting: function (e) {
	                    var sheet = this._shapeLayer._sheet;
	                    if (sheet) {
	                        return sheet._touchManager._touchEventHandler._doManipulationStarting(e);
	                    }
	                },
	                _doManipulationStarted: function (e) {
	                    var sheet = this._shapeLayer._sheet;
	                    if (sheet) {
	                        var newPositionToPage = this._positionToPage(e._Position);
	                        var newPosition = this._positionToHostCanvas(e._Position, sheet._getCanvasOffset());
	                       
	                        var floatingObjectModel = sheet._floatingObjectModel,
	                            floatObjectInfo = floatingObjectModel && floatingObjectModel.hitTest(newPosition.X, newPosition.Y);
	                        if (floatObjectInfo) {
	                            this._floatObjectInfo = floatObjectInfo;
	                            e._Position = newPositionToPage;
	                            return floatObjectInfo._render._touchManager._touchEventHandler._doManipulationStarted(e, true);
	                        }
	                       
	                        e._Position = newPosition;
	                        return sheet._touchManager._touchEventHandler._doManipulationStarted(e);
	                    }
	                },
	                _doManipulationDelta: function (e) {
	                    var sheet = this._shapeLayer._sheet;
	                    if (sheet) {
	                        var newPositionToPage = this._positionToPage(e._Position);
	                        var newPosition = this._positionToHostCanvas(e._Position, sheet._getCanvasOffset());
	                       
	                        if (this._floatObjectInfo) {
	                            e._Position = newPositionToPage;
	                            return this._floatObjectInfo._render._touchManager._touchEventHandler._doManipulationDelta(e, true);
	                        }
	                       
	                        e._Position = newPosition;
	                        return sheet._touchManager._touchEventHandler._doManipulationDelta(e);
	                    }
	                },
	               
	               
	                _doManipulationCompleted: function (e) {
	                    var sheet = this._shapeLayer._sheet;
	                    if (sheet) {
	                        var newPositionToPage = this._positionToPage(e._Position);
	                        var newPosition = this._positionToHostCanvas(e._Position, sheet._getCanvasOffset());
	                       
	                        if (this._floatObjectInfo) {
	                            e._Position = newPositionToPage;
	                            var returnValue = this._floatObjectInfo._render._touchManager._touchEventHandler._doManipulationCompleted(e, true);
	                            this._floatObjectInfo = null;
	                            return returnValue;
	                        }
	                       
	                        e._Position = newPosition;
	                        return sheet._touchManager._touchEventHandler._doManipulationCompleted(e);
	                    }
	                },
	                _doTapped: function (e) {
	                    var sheet = this._shapeLayer._sheet;
	                    if (sheet) {
	                        var newPositionToPage = this._positionToPage(e._Position);
	                        var newPosition = this._positionToHostCanvas(e._Position, sheet._getCanvasOffset());
	                       
	                        var floatingObjectModel = sheet._floatingObjectModel,
	                            floatObjectInfo = floatingObjectModel && floatingObjectModel.hitTest(newPosition.X, newPosition.Y);
	                        if (floatObjectInfo) {
	                            e._Position = newPositionToPage;
	                            return floatObjectInfo._render._touchManager._touchEventHandler._doTapped(e, true);
	                        }
	                       
	                        e._Position = newPosition;
	                        return sheet._touchManager._touchEventHandler._doTapped(e);
	                    }
	                },
	                _doDoubleTapped: function (e) {
	                    var sheet = this._shapeLayer._sheet;
	                    if (sheet) {
	                        e._Position = this._positionToHostCanvas(e._Position, sheet._getCanvasOffset());
	                        return sheet._touchManager._touchEventHandler._doDoubleTapped(e);
	                    }
	                },
	               
	               
	            });
	           
	
	            var Shapes = __webpack_require__(1);
	            var browser = Core._util._browser;
	            if (browser.msie && parseFloat(browser.version) <= 10) {
	                Shapes.Canvas._registerFeature('sheetTouch', {
	                    setHost: function (host) {
	                        var self = this;
	                        var touchManager = self._touchManager = new ShapeTouchManager(host, self, self._sheet.parent._touchEventProvider);
	                        touchManager._attach();
	                    },
	                    dispose: function () {
	                        var touchManager = this._touchManager;
	                        if (touchManager) {
	                            touchManager._detach();
	                        }
	                    }
	                });
	            }
	        })();
	    }
	
	}());

/***/ }),
/* 28 */
/***/ (function(module, exports) {

	module.exports = GC.Spread.Sheets.Touch;

/***/ })
/******/ ]);
//# sourceMappingURL=gc.spread.sheets.shapes.12.0.0.js.map
}));